{"version":3,"file":"angular-ts.umd.min.js","sources":["../src/shared/constants.js","../src/shared/utils.js","../src/injection-tokens.js","../src/shared/dom.js","../src/shared/node.js","../src/core/di/di.js","../src/core/di/internal-injector.js","../src/services/storage/storage.js","../src/shared/predicates.js","../src/shared/validate.js","../src/core/di/injector.js","../src/shared/url-utils/url-utils.js","../src/services/http/http.js","../src/directive/http/http.js","../src/directive/worker/worker.js","../src/core/di/ng-module/ng-module.js","../src/shared/noderef.js","../src/core/controller/controller.js","../src/services/sce/sce.js","../src/directive/events/events.js","../src/core/compile/attributes.js","../src/directive/observe/observe.js","../src/core/compile/compile.js","../src/directive/form/form.js","../src/directive/model-options/model-options.js","../src/directive/model/model.js","../src/directive/input/input.js","../src/directive/script/script.js","../src/directive/select/select.js","../src/directive/bind/bind.js","../src/directive/class/class.js","../src/directive/cloak/cloak.js","../src/directive/controller/controller.js","../src/directive/show-hide/show-hide.js","../src/directive/if/if.js","../src/directive/include/include.js","../src/directive/init/init.js","../src/directive/non-bindable/non-bindable.js","../src/directive/ref/ref.js","../src/directive/repeat/repeat.js","../src/directive/style/style.js","../src/directive/switch/switch.js","../src/directive/options/options.js","../src/directive/transclude/transclude.js","../src/directive/attrs/attrs.js","../src/directive/validators/validators.js","../src/services/anchor-scroll/anchor-scroll.js","../src/animations/shared.js","../src/animations/animate.js","../src/services/template-cache/template-cache.js","../src/services/exception/exception.js","../src/filters/filter.js","../src/filters/json.js","../src/filters/limit-to.js","../src/filters/order-by.js","../src/core/filter/filter.js","../src/core/interpolate/interpolate.js","../src/services/location/location.js","../src/services/log/log.js","../src/core/parse/lexer/lexer.js","../src/core/parse/ast-type.js","../src/core/parse/interpreter.js","../src/core/parse/ast/ast.js","../src/core/parse/parser/parser.js","../src/core/parse/parse.js","../src/core/scope/scope.js","../src/services/template-request/template-request.js","../src/core/sanitize/sanitize-uri.js","../src/directive/messages/messages.js","../src/directive/aria/aria.js","../src/animations/runner/animate-runner.js","../src/animations/cache/animate-cache.js","../src/animations/raf/raf-scheduler.js","../src/animations/css/animate-css.js","../src/animations/queue/animate-queue.js","../src/animations/animate-js.js","../src/animations/animation.js","../src/animations/animate-css-driver.js","../src/animations/animate-js-driver.js","../src/animations/animate-swap.js","../src/animations/animate-children-directive.js","../src/shared/common.js","../src/shared/hof.js","../src/router/params/param-type.js","../src/router/params/param-types.js","../src/router/url/url-config.js","../src/router/params/state-params.js","../src/shared/queue.js","../src/router/router.js","../src/shared/strings.js","../src/router/common/trace.js","../src/router/resolve/resolvable.js","../src/router/state/target-state.js","../src/router/params/param.js","../src/router/path/path-node.js","../src/router/path/path-utils.js","../src/router/resolve/resolve-context.js","../src/router/state/views.js","../src/router/view/view.js","../src/router/transition/reject-factory.js","../src/router/transition/transition-hook.js","../src/router/glob/glob.js","../src/router/transition/hook-registry.js","../src/router/transition/hook-builder.js","../src/router/transition/transition.js","../src/router/hooks/core-resolvables.js","../src/router/hooks/on-enter-exit-retain.js","../src/router/hooks/resolve.js","../src/router/hooks/views.js","../src/router/hooks/lazy-load.js","../src/router/transition/transition-event-type.js","../src/router/hooks/ignored-transition.js","../src/router/hooks/invalid-transition.js","../src/router/transition/transition-service.js","../src/router/hooks/redirect-to.js","../src/router/state/state-service.js","../src/router/template-factory.js","../src/router/url/url-matcher.js","../src/router/state/state-object.js","../src/router/url/url-rule.js","../src/router/url/url-rules.js","../src/router/params/param-factory.js","../src/router/url/url-service.js","../src/router/state/state-matcher.js","../src/router/state/state-builder.js","../src/router/state/state-queue-manager.js","../src/router/state/state-registry.js","../src/router/directives/state-directives.js","../src/router/directives/view-directive.js","../src/directive/channel/channel.js","../src/directive/setter/setter.js","../src/services/pubsub/pubsub.js","../src/directive/inject/inject.js","../src/directive/el/el.js","../src/services/stream/stream.js","../src/services/sse/sse.js","../src/directive/viewport/viewport.js","../src/directive/wasm/wasm.js","../src/directive/scope/scope.js","../src/services/cookie/cookie.js","../src/services/rest/rfc.js","../src/services/rest/rest.js","../src/directive/listener/listener.js","../src/services/websocket/websocket.js","../src/angular.js","../src/ng.js","../src/index.js"],"sourcesContent":["export const VALID_CLASS = \"ng-valid\";\nexport const INVALID_CLASS = \"ng-invalid\";\nexport const PRISTINE_CLASS = \"ng-pristine\";\nexport const DIRTY_CLASS = \"ng-dirty\";\nexport const UNTOUCHED_CLASS = \"ng-untouched\";\nexport const TOUCHED_CLASS = \"ng-touched\";\nexport const EMPTY_CLASS = \"ng-empty\";\nexport const NOT_EMPTY_CLASS = \"ng-not-empty\";\n\n// x prefix is being kept for view-directive.spec lines 1550, 565\nexport const PREFIX_REGEXP = /^((?:x|data)[-])/i;\nexport const SPECIAL_CHARS_REGEXP = /[-]+(.)/g;\n\n/** @type {Record<string, string>} */\nexport const ALIASED_ATTR = {\n  ngMinlength: \"minlength\",\n  ngMaxlength: \"maxlength\",\n  ngMin: \"min\",\n  ngMax: \"max\",\n  ngPattern: \"pattern\",\n  ngStep: \"step\",\n};\n","import { PREFIX_REGEXP, SPECIAL_CHARS_REGEXP } from \"./constants.js\";\nimport { NodeType } from \"./node.js\";\n\nexport const isProxySymbol = Symbol(\"isProxy\");\n\n/**\n * @param {any} value\n * @returns {value is Proxy<ng.Scope> | ng.Scope}\n */\nexport function isProxy(value) {\n  return !!(value && value[isProxySymbol]);\n}\n\n/**\n * Unwraps a proxy if the value is a proxy, otherwise returns the value as-is.\n *\n * @template T\n * @param {T | (T & { $target: T })} val - A value that might be a proxy.\n * @returns {T} The unproxied value.\n */\nexport function deProxy(val) {\n  return isProxy(val) ? /** @type {ng.Scope} */ (val).$target : val;\n}\n\nconst ngMinErr = minErr(\"ng\");\n\n/**\n * @type {number}\n */\nlet uid = 0;\n\n/**\n * @returns {number} an unique alpha-numeric string\n */\nexport function nextUid() {\n  uid += 1;\n\n  return uid;\n}\n\n/**\n *\n *  Converts the specified string to lowercase.\n * @param {string} string String to be converted to lowercase.\n * @returns {string} Lowercased string.\n */\nexport function lowercase(string) {\n  return isString(string) ? string.toLowerCase() : string;\n}\n\n/**\n *\n *  Converts the specified string to uppercase.\n * @param {string} string String to be converted to uppercase.\n * @returns {string} Uppercased string.\n */\nexport function uppercase(string) {\n  return isString(string) ? string.toUpperCase() : string;\n}\n\n/**\n * @param {unknown} obj Reference to check.\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,\n *                   String ...)\n */\nexport function isArrayLike(obj) {\n  // `null`, `undefined` and `window` are not array-like\n  if (isNullOrUndefined(obj) || isWindow(obj)) return false;\n\n  // arrays, strings and jQuery/jqLite objects are array like\n  // * we have to check the existence of JQLite first as this method is called\n  //   via the forEach method when constructing the JQLite object in the first place\n  if (isArray(obj) || obj instanceof Array || isString(obj)) return true;\n\n  const len = /** @type {ArrayLike<any>} */ (obj).length;\n\n  // NodeList objects (with `item` method) and\n  // other objects with suitable length characteristics are array-like\n  return (\n    isNumber(len) &&\n    ((len >= 0 && len - 1 in /** @type {Object} */ (obj)) ||\n      typeof (/** @type {NodeList} */ (obj).item) === \"function\")\n  );\n}\n\n/**\n * Determines if a reference is undefined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is undefined.\n */\nexport function isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n\n/**\n * Determines if a reference is defined (not `undefined`).\n *\n * @template T\n * @param {T | undefined} value - Reference to check.\n * @returns {value is T} True if `value` is defined.\n */\nexport function isDefined(value) {\n  return typeof value !== \"undefined\";\n}\n\n/**\n * @template T\n * @param {any} array\n * @returns {array is T[]} true if array is an Array\n */\nexport function isArray(array) {\n  return Array.isArray(array);\n}\n\n/**\n * @template T\n * @param {any} val\n * @param {new (...args: any[]) => T} type  The constructor to test against\n * @returns {val is T}\n */\nexport function isInstanceOf(val, type) {\n  return val instanceof type;\n}\n\n/**\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\n * considered to be objects. Note that JavaScript arrays are objects.\n *\n * @template T\n * @param {T} value - Reference to check.\n * @returns {value is T & object} True if `value` is an `Object` but not `null`.\n */\nexport function isObject(value) {\n  // http://jsperf.com/isobject4\n  return value !== null && typeof value === \"object\";\n}\n\n/**\n * Determines if a value is an object with a null prototype\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Object` with a null prototype\n */\nexport function isBlankObject(value) {\n  return (\n    value !== null && typeof value === \"object\" && !Object.getPrototypeOf(value)\n  );\n}\n\n/**\n * Determines if a reference is a `string`.\n * @param {unknown} value - The value to check.\n * @returns {value is string} True if `value` is a string.\n */\nexport function isString(value) {\n  return typeof value === \"string\";\n}\n\n/**\n * Determines if a reference is a null.\n *\n * @param {unknown} value Reference to check.\n * @returns {value is null} True if `value` is a null.\n */\nexport function isNull(value) {\n  return value === null;\n}\n\n/**\n * Determines if a reference is null or undefined.\n *\n * @param {unknown} obj Reference to check.\n * @returns {obj is null | undefined} True if `value` is null or undefined.\n */\nexport function isNullOrUndefined(obj) {\n  return obj === null || typeof obj === \"undefined\";\n}\n\n/**\n * Determines if a reference is not null or undefined.\n *\n * @param {*} obj Reference to check.\n * @returns {boolean} True if `value` is null or undefined.\n */\nexport function notNullOrUndefined(obj) {\n  return !isNullOrUndefined(obj);\n}\n\n/**\n * Determines if a reference is a `Number`.\n *\n * This includes the \"special\" numbers `NaN`, `+Infinity` and `-Infinity`.\n *\n * If you wish to exclude these then you can use the native\n * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)\n * method.\n *\n * @param {unknown} value Reference to check.\n * @returns {value is number} True if `value` is a `Number`.\n */\nexport function isNumber(value) {\n  return typeof value === \"number\";\n}\n\n/**\n *\n * Determines if a value is a date.\n *\n * @param {*} value Reference to check.\n * @returns {value is Date} True if `value` is a `Date`.\n */\nexport function isDate(value) {\n  return toString.call(value) === \"[object Date]\";\n}\n\n/**\n * Determines if a reference is an `Error`.\n * Loosely based on https://www.npmjs.com/package/iserror\n *\n * @param {*} value Reference to check.\n * @returns {value is Error} True if `value` is an `Error`.\n */\nexport function isError(value) {\n  const tag = toString.call(value);\n\n  switch (tag) {\n    case \"[object Error]\":\n      return true;\n    case \"[object Exception]\":\n      return true;\n    case \"[object DOMException]\":\n      return true;\n    default:\n      return value instanceof Error;\n  }\n}\n\n/**\n * Determines if a reference is a `Function`.\n *\n * @param {*} value Reference to check.\n * @returns {value is Function} True if `value` is a `Function`.\n */\nexport function isFunction(value) {\n  return typeof value === \"function\";\n}\n\n/**\n * Determines if a value is a regular expression object.\n *\n * @param {*} value Reference to check.\n * @returns {value is RegExp} True if `value` is a `RegExp`.\n */\nexport function isRegExp(value) {\n  return toString.call(value) === \"[object RegExp]\";\n}\n\n/**\n * Checks if `obj` is a window object.\n *\n * @param {unknown} obj Object to check\n * @returns {obj is Window} True if `obj` is a window obj.\n */\nexport function isWindow(obj) {\n  return isInstanceOf(obj, Window);\n}\n\n/**\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isScope(obj) {\n  return obj && obj.$watch;\n}\n\n/**\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isFile(obj) {\n  return toString.call(obj) === \"[object File]\";\n}\n\n/**\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isFormData(obj) {\n  return toString.call(obj) === \"[object FormData]\";\n}\n\n/**\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isBlob(obj) {\n  return toString.call(obj) === \"[object Blob]\";\n}\n\n/**\n * @param {*} value\n * @returns {boolean}\n */\nexport function isBoolean(value) {\n  return typeof value === \"boolean\";\n}\n\n/**\n * @param {*} obj\n * @returns {boolean}\n */\nexport function isPromiseLike(obj) {\n  return obj && isFunction(obj.then);\n}\n\n/**\n * @param {*} value\n * @returns {string | *}\n */\nexport function trim(value) {\n  return isString(value) ? value.trim() : value;\n}\n\n/**\n * @param {string} name\n * @param {string} separator\n */\nexport function snakeCase(name, separator) {\n  const modseparator = separator || \"_\";\n\n  return name.replace(\n    /[A-Z]/g,\n    (/** @type {string} */ letter, /** @type {any} */ pos) =>\n      (pos ? modseparator : \"\") + letter.toLowerCase(),\n  );\n}\n\n/**\n * Set or clear the hashkey for an object.\n * @param {{ [x: string]: any; _hashKey?: any; }} obj object\n * @param {any} hashkey the hashkey (!truthy to delete the hashkey)\n */\nexport function setHashKey(obj, hashkey) {\n  if (hashkey) {\n    obj._hashKey = hashkey;\n  } else {\n    delete obj._hashKey;\n  }\n}\n\n/**\n * Deeply extends a destination object with one or more source objects.\n * Safely handles Dates, RegExps, DOM nodes, arrays, and nested objects.\n * Ignores the `__proto__` key to prevent prototype pollution.\n *\n * @param {Object<string, any>} dst - The destination object to extend.\n * @param {Array<Object<string, any>>} objs - Array of source objects to copy properties from.\n * @param {boolean} [deep=false] - Whether to perform a deep merge of nested objects.\n * @returns {Object<string, any>} The extended destination object.\n */\nexport function baseExtend(dst, objs, deep = false) {\n  const hasKey = dst._hashKey;\n\n  for (let i = 0, ii = objs.length; i < ii; ++i) {\n    const obj = objs[i];\n\n    if (!isObject(obj) && !isFunction(obj)) continue;\n    const keyList = keys(obj);\n\n    for (let j = 0, jj = keyList.length; j < jj; j++) {\n      const key = keyList[j];\n\n      const src = obj[key];\n\n      if (deep && isObject(src)) {\n        if (isDate(src)) {\n          dst[key] = new Date(src.valueOf());\n        } else if (isRegExp(src)) {\n          dst[key] = new RegExp(src);\n        } else if (src.nodeName) {\n          dst[key] = src.cloneNode(true);\n        } else if (key !== \"__proto__\") {\n          if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};\n          baseExtend(dst[key], [src], true);\n        }\n      } else {\n        dst[key] = src;\n      }\n    }\n  }\n\n  setHashKey(dst, hasKey);\n\n  return dst;\n}\n\n/**\n * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so\n * by passing an empty object as the target: `let object = angular.extend({}, object1, object2)`.\n *\n * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy).\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nexport function extend(dst, ...src) {\n  return baseExtend(dst, src, false);\n}\n\n/**\n * @param {any} num\n * @returns {boolean}\n */\nexport function isNumberNaN(num) {\n  return Number.isNaN(num);\n}\n\n/**\n * @param {any} parent\n * @param {any} extra\n * @returns {Object}\n */\nexport function inherit(parent, extra) {\n  return extend(Object.create(parent), extra);\n}\n\n/**\n * @param {{ toString: () => string; }} obj\n * @returns {boolean}\n */\nexport function hasCustomToString(obj) {\n  return isFunction(obj.toString) && obj.toString !== toString;\n}\n\n/**\n * Returns a string appropriate for the type of node.\n *\n * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Node/nodeName)\n *\n * @param {Element} element\n * @returns {string}\n */\nexport function getNodeName(element) {\n  return lowercase(element.nodeName);\n}\n\n/**\n * @param {any} array\n * @param {any} obj\n */\nexport function includes(array, obj) {\n  return Array.prototype.indexOf.call(array, obj) !== -1;\n}\n\n/**\n * Removes the first occurrence of a specified value from an array.\n *\n * @template T\n * @param {Array<T>} array - The array from which to remove the value.\n * @param {T} value - The value to remove.\n * @returns {number} - The index of the removed value, or -1 if the value was not found.\n */\nexport function arrayRemove(array, value) {\n  const index = array.indexOf(value);\n\n  if (index >= 0) {\n    array.splice(index, 1);\n  }\n\n  return index;\n}\n\n/**\n * @param {unknown} val1\n * @param {unknown} val2\n */\nexport function simpleCompare(val1, val2) {\n  return val1 === val2 || (Number.isNaN(val1) && Number.isNaN(val2));\n}\n\n/**\n * Determines if two objects or two values are equivalent. Supports value types, regular\n * expressions, arrays and objects.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties are equal by\n *   comparing them with `angular.equals`.\n * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)\n * * Both values represent the same regular expression (In JavaScript,\n *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual\n *   representation matches).\n *\n * During a property comparison, properties of `function` type and properties with names\n * that begin with `$` are ignored.\n *\n * Scope and DOMWindow objects are being compared only by identify (`===`).\n *\n * @param {*} o1 Object or value to compare.\n * @param {*} o2 Object or value to compare.\n * @returns {boolean} True if arguments are equal.\n *\n * @example\n   <example module=\"equalsExample\" name=\"equalsExample\">\n     <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate>\n          <h3>User 1</h3>\n          Name: <input type=\"text\" ng-model=\"user1.name\">\n          Age: <input type=\"number\" ng-model=\"user1.age\">\n\n          <h3>User 2</h3>\n          Name: <input type=\"text\" ng-model=\"user2.name\">\n          Age: <input type=\"number\" ng-model=\"user2.age\">\n\n          <div>\n            <br/>\n            <input type=\"button\" value=\"Compare\" ng-click=\"compare()\">\n          </div>\n          User 1: <pre>{{user1 | json}}</pre>\n          User 2: <pre>{{user2 | json}}</pre>\n          Equal: <pre>{{result}}</pre>\n        </form>\n      </div>\n    </file>\n    <file name=\"script.js\">\n        angular.module('equalsExample', []).controller('ExampleController', ['$scope', function($scope) {\n          $scope.user1 = {};\n          $scope.user2 = {};\n          $scope.compare = function() {\n            $scope.result = angular.equals($scope.user1, $scope.user2);\n          };\n        }]);\n    </file>\n  </example>\n */\nexport function equals(o1, o2) {\n  if (o1 === o2) return true;\n\n  if (o1 === null || o2 === null) return false;\n\n  if (Number.isNaN(o1) && Number.isNaN(o2)) return true; // NaN === NaN\n\n  const t1 = typeof o1;\n\n  const t2 = typeof o2;\n\n  if (t1 !== t2 || t1 !== \"object\") return false;\n\n  // Handle arrays\n  if (isArray(o1)) {\n    if (!isArray(o2)) return false;\n\n    const { length } = o1;\n\n    if (length !== o2.length) return false;\n\n    for (let key = 0; key < length; key++) {\n      if (!equals(o1[key], o2[key])) return false;\n    }\n\n    return true;\n  }\n\n  // Handle Dates\n  if (isDate(o1)) {\n    if (!isDate(o2)) return false;\n\n    return simpleCompare(o1.getTime(), o2.getTime());\n  }\n\n  // Handle RegExps\n  if (isRegExp(o1)) {\n    if (!isRegExp(o2)) return false;\n\n    return o1.toString() === o2.toString();\n  }\n\n  // Reject unsafe objects\n  if (\n    isScope(o1) ||\n    isScope(o2) ||\n    isWindow(o1) ||\n    isWindow(o2) ||\n    isArray(o2) ||\n    isDate(o2) ||\n    isRegExp(o2)\n  )\n    return false;\n\n  // Handle general objects\n  const keySet = nullObject();\n\n  for (const key in o1) {\n    if (key.charAt(0) === \"$\" || isFunction(o1[key])) continue;\n\n    if (!equals(o1[key], o2[key])) return false;\n    keySet[key] = true;\n  }\n\n  for (const key in o2) {\n    if (\n      !(key in keySet) &&\n      key.charAt(0) !== \"$\" &&\n      isDefined(o2[key]) &&\n      !isFunction(o2[key])\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * throw error if the name given is hasOwnProperty\n * @param  {string} name    the name to test\n * @param  {string} context the context in which the name is used, such as module or directive\n */\nexport function assertNotHasOwnProperty(name, context) {\n  if (name === \"hasOwnProperty\") {\n    throw ngMinErr(\n      \"badname\",\n      \"hasOwnProperty is not a valid {0} name\",\n      context,\n    );\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {string | unknown}\n */\nexport function stringify(value) {\n  if (isNull(value) || isUndefined(value)) {\n    return \"\";\n  }\n  switch (typeof value) {\n    case \"string\":\n      break;\n    case \"number\":\n      value = `${value}`;\n      break;\n    default:\n      if (\n        hasCustomToString(/** @type {Object} */ (value)) &&\n        !isArray(value) &&\n        !isDate(value)\n      ) {\n        value = /** @type {Object} */ (value).toString();\n      } else {\n        value = toJson(/** @type {any[]} */ (value));\n      }\n  }\n\n  return value;\n}\n\n/**\n * @param {Number} maxDepth\n * @return {boolean}\n */\nexport function isValidObjectMaxDepth(maxDepth) {\n  return isNumber(maxDepth) && maxDepth > 0;\n}\n\n/**\n * @param {any[]} array1\n * @param {IArguments | any[] | NodeListOf<ChildNode>} array2\n * @param {number | undefined} [index]\n */\nexport function concat(array1, array2, index) {\n  return array1.concat(Array.prototype.slice.call(array2, index));\n}\n\n/**\n * @param {IArguments | [string, ...any[]]} args\n * @param {number} startIndex\n */\nexport function sliceArgs(args, startIndex) {\n  return Array.prototype.slice.call(args, startIndex || 0);\n}\n\n/**\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\n * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as\n * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).\n *\n * @param {Object} context Context which `fn` should be evaluated in.\n * @param {*} fn Function to be bound.\n * @returns {Function} Function that wraps the `fn` with all the specified bindings.\n */\nexport function bind(context, fn) {\n  const curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];\n\n  if (isFunction(fn) && !(fn instanceof RegExp)) {\n    return curryArgs.length\n      ? function () {\n          return arguments.length\n            ? fn.apply(context, concat(curryArgs, arguments, 0))\n            : fn.apply(context, curryArgs);\n        }\n      : function () {\n          return arguments.length\n            ? fn.apply(context, arguments)\n            : fn.call(context);\n        };\n  }\n\n  // In IE, native methods are not functions so they cannot be bound (note: they don't need to be).\n  return fn;\n}\n\n/**\n * @param {string} key\n * @param {unknown} value\n */\nfunction toJsonReplacer(key, value) {\n  let val = value;\n\n  if (\n    typeof key === \"string\" &&\n    key.charAt(0) === \"$\" &&\n    key.charAt(1) === \"$\"\n  ) {\n    val = undefined;\n  } else if (isWindow(value)) {\n    val = \"$WINDOW\";\n  } else if (value && window.document === value) {\n    val = \"$DOCUMENT\";\n  } else if (isScope(value)) {\n    val = \"$SCOPE\";\n  }\n\n  return val;\n}\n\n/**\n * Serializes input into a JSON-formatted string. Properties with leading `$$` characters\n * will be stripped since AngularTS uses this notation internally.\n *\n * @param {Object|Array<any>|Date|string|number|boolean} obj\n *   Input to be serialized into JSON.\n * @param {boolean|number} [pretty=2]\n *   If `true`, the JSON output will contain newlines and whitespace (2 spaces).\n *   If a number, the JSON output will contain that many spaces per indentation.\n * @returns {string|undefined}\n *   JSON-ified string representing `obj`, or `undefined` if `obj` is undefined.\n */\nexport function toJson(obj, pretty) {\n  if (isUndefined(obj)) return undefined;\n\n  if (!isNumber(pretty)) {\n    pretty = pretty ? 2 : undefined;\n  }\n\n  return JSON.stringify(obj, toJsonReplacer, /** @type {number} */ (pretty));\n}\n\n/**\n * Deserializes a JSON string.\n *\n * @param {string} json JSON string to deserialize.\n * @returns {Object|Array<any>|string|number} Deserialized JSON string.\n */\nexport function fromJson(json) {\n  return isString(json) ? JSON.parse(json) : json;\n}\n\n/**\n * @param {Date} date\n * @param {number} minutes\n */\nexport function addDateMinutes(date, minutes) {\n  const newDate = new Date(date.getTime());\n\n  newDate.setMinutes(newDate.getMinutes() + minutes);\n\n  return newDate;\n}\n\n/**\n * Parses an escaped url query string into key-value pairs.\n * @param {string} value\n * @returns {Object.<string,boolean|Array<any>>}\n */\nexport function parseKeyValue(value) {\n  /** @type {Record<string, boolean | string | Array<any>>} */\n  const obj = {};\n\n  const res = value || \"\";\n\n  res.split(\"&\").forEach((keyValue) => {\n    let splitPoint;\n\n    let key;\n\n    let val;\n\n    if (keyValue) {\n      key = keyValue = keyValue.replace(/\\+/g, \"%20\");\n      splitPoint = keyValue.indexOf(\"=\");\n\n      if (splitPoint !== -1) {\n        key = keyValue.substring(0, splitPoint);\n        val = keyValue.substring(splitPoint + 1);\n      }\n      key = tryDecodeURIComponent(key);\n\n      if (isDefined(key)) {\n        val = isDefined(val) ? tryDecodeURIComponent(val) : true;\n\n        if (!hasOwn(obj, /** @type {string} */ (key))) {\n          obj[key] = /** @type {string } */ (val);\n        } else if (isArray(obj[key])) {\n          /** @type {Array<any>} */ (obj[key]).push(val);\n        } else {\n          obj[key] = [obj[key], val];\n        }\n      }\n    }\n  });\n\n  return /** @type {Object.<string,boolean|Array<any>>} */ (obj);\n}\n\n/**\n * @param {string | { [s: string]: any; } | ArrayLike<any> | null} obj\n */\nexport function toKeyValue(obj) {\n  /**\n   * @type {string[]}\n   */\n  const parts = [];\n\n  obj &&\n    entries(obj).forEach(([key, value]) => {\n      if (isArray(value)) {\n        value.forEach((arrayValue) => {\n          parts.push(\n            encodeUriQuery(key, true) +\n              (arrayValue === true\n                ? \"\"\n                : `=${encodeUriQuery(arrayValue, true)}`),\n          );\n        });\n      } else {\n        parts.push(\n          encodeUriQuery(key, true) +\n            (value === true ? \"\" : `=${encodeUriQuery(value, true)}`),\n        );\n      }\n    });\n\n  return parts.length ? parts.join(\"&\") : \"\";\n}\n\n/**\n * Tries to decode the URI component without throwing an exception.\n *\n * @param  {string} value potential URI component to check.\n * @returns {string|undefined}\n */\nexport function tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\n * segments:\n *    segment       = *pchar\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * @param {string} val\n */\nexport function encodeUriSegment(val) {\n  return encodeUriQuery(val, true)\n    .replace(/%26/gi, \"&\")\n    .replace(/%3D/gi, \"=\")\n    .replace(/%2B/gi, \"+\");\n}\n\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query         = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * @param {string | number | boolean} val\n * @param {boolean | undefined} [pctEncodeSpaces]\n */\nexport function encodeUriQuery(val, pctEncodeSpaces) {\n  return encodeURIComponent(val)\n    .replace(/%40/gi, \"@\")\n    .replace(/%3A/gi, \":\")\n    .replace(/%24/g, \"$\")\n    .replace(/%2C/gi, \",\")\n    .replace(/%3B/gi, \";\")\n    .replace(/%20/g, pctEncodeSpaces ? \"%20\" : \"+\");\n}\n\nexport const ngAttrPrefixes = [\"ng-\", \"data-ng-\"];\n\n/**\n * Creates a shallow copy of an object, an array, or returns primitives as-is.\n *\n * Assumes there are no proto properties.\n *\n * @template T\n * @param {T} src\n * @param {T extends any[] ? T : Record<string, unknown>} [dst]\n * @returns {T}\n */\nexport function shallowCopy(src, dst) {\n  if (isArray(src)) {\n    /** @type {any[]} */\n    const out = /** @type {any[]} */ (dst) || [];\n\n    out.push(...src);\n\n    return /** @type {T} */ (out);\n  }\n\n  if (isObject(src)) {\n    const out = /** @type {Record<string, unknown>} */ (dst) || {};\n\n    for (const key in src) {\n      // Copy all properties except $$-prefixed\n      if (!key.startsWith(\"$$\")) {\n        out[key] = src[key];\n      }\n    }\n\n    return /** @type {T} */ (out);\n  }\n\n  return src;\n}\n\n/**\n * Throw error if the argument is false\n * @param {boolean} argument\n * @param {string} errorMsg\n */\nexport function assert(argument, errorMsg = \"Assertion failed\") {\n  if (!argument) {\n    throw new Error(errorMsg);\n  }\n}\n\n/**\n * Throw error if the argument is falsy.\n * @param {string | boolean | Object} arg\n * @param {string} name\n * @param {string | undefined} [reason]\n */\nexport function assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr(\n      \"areq\",\n      \"Argument '{0}' is {1}\",\n      name || \"?\",\n      reason || \"required\",\n    );\n  }\n\n  return arg;\n}\n\n/**\n * @param {string | Function | any[]} arg\n * @param {string} name\n * @param {boolean | undefined} [acceptArrayAnnotation]\n */\nexport function assertArgFn(arg, name, acceptArrayAnnotation) {\n  if (acceptArrayAnnotation && isArray(arg)) {\n    arg = arg[arg.length - 1];\n  }\n\n  assertArg(\n    isFunction(arg),\n    name,\n    `not a function, got ${\n      arg && typeof arg === \"object\"\n        ? arg.constructor.name || \"Object\"\n        : typeof arg\n    }`,\n  );\n\n  return arg;\n}\n\n/** @type {ng.ErrorHandlingConfig} */\nconst minErrConfig = {\n  objectMaxDepth: 5,\n  urlErrorParamsEnabled: true,\n};\n\n/**\n * Configure several aspects of error handling if used as a setter or return the\n * current configuration if used as a getter.\n *\n * Omitted or undefined options will leave the corresponding configuration values unchanged.\n *\n * @param {ng.ErrorHandlingConfig} [config]\n * @returns {ng.ErrorHandlingConfig}\n */\nexport function errorHandlingConfig(config) {\n  if (isObject(config)) {\n    if (isDefined(config.objectMaxDepth)) {\n      minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth)\n        ? config.objectMaxDepth\n        : NaN;\n    }\n\n    if (\n      isDefined(config.urlErrorParamsEnabled) &&\n      isBoolean(config.urlErrorParamsEnabled)\n    ) {\n      minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled;\n    }\n  }\n\n  return minErrConfig;\n}\n\n/**\n * This object provides a utility for producing rich Error messages within\n * AngularTS. It can be called as follows:\n *\n * let exampleMinErr = minErr('example');\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\n *\n * The above creates an instance of minErr in the example namespace. The\n * resulting error will have a namespaced error code of example.one.  The\n * resulting error will replace {0} with the value of foo, and {1} with the\n * value of bar. The object is not restricted in the number of arguments it can\n * take.\n *\n * If fewer arguments are specified than necessary for interpolation, the extra\n * interpolation markers will be preserved in the final string.\n *\n * Since data will be parsed statically during a build step, some restrictions\n * are applied with respect to how minErr instances are created and called.\n * Instances should have names of the form namespaceMinErr for a minErr created\n * using minErr('namespace'). Error codes, namespaces and template strings\n * should all be static strings, not variables or general expressions.\n *\n * @param {string} module The namespace to use for the new minErr instance.\n * @returns {function(string, ...*): Error} minErr instance\n */\nexport function minErr(module) {\n  return function (...args) {\n    const code = args[0];\n\n    const template = args[1];\n\n    let message = `[${module ? `${module}:` : \"\"}${code}] `;\n\n    const templateArgs = sliceArgs(args, 2).map((arg) => toDebugString(arg));\n\n    message += template.replace(/\\{\\d+\\}/g, (/** @type {string} */ match) => {\n      const index = +match.slice(1, -1);\n\n      if (index < templateArgs.length) {\n        return templateArgs[index];\n      }\n\n      return match;\n    });\n\n    return new Error(message);\n  };\n}\n\n/**\n * Converts a value into a simplified debug-friendly string.\n *\n * @template T\n * @param {T|ng.Scope} obj\n * @returns {string}\n */\nexport function toDebugString(obj) {\n  if (typeof obj === \"function\") {\n    return obj.toString().replace(/ \\{[\\s\\S]*$/, \"\");\n  }\n\n  if (isUndefined(obj)) {\n    return \"undefined\";\n  }\n\n  if (typeof obj !== \"string\") {\n    /** @type {object[]} */\n    const seen = [];\n\n    const copyObj = structuredClone(\n      isProxy(obj) ? /** @type {ng.Scope} */ (obj).$target : obj,\n    );\n\n    return JSON.stringify(copyObj, (key, val) => {\n      const replace = toJsonReplacer(key, val);\n\n      if (isObject(replace)) {\n        if (seen.indexOf(replace) >= 0) return \"...\";\n\n        seen.push(replace);\n      }\n\n      return replace;\n    });\n  }\n\n  return obj;\n}\n\n/**\n * Computes a hash of an 'obj'.\n * Hash of a:\n *  string is string\n *  number is number as string\n *  object is either result of calling _hashKey function on the object or uniquely generated id,\n *         that is also assigned to the _hashKey property of the object.\n *\n * @param {*} obj\n * @returns {string} hash string such that the same input will have the same hash string.\n *         The resulting string key is in 'type:hashKey' format.\n */\nexport function hashKey(obj) {\n  const key = obj && obj._hashKey;\n\n  if (key) {\n    if (typeof key === \"function\") {\n      return obj._hashKey();\n    }\n\n    return key;\n  }\n\n  const objType = typeof obj;\n\n  if (objType === \"function\" || (objType === \"object\" && obj !== null)) {\n    obj._hashKey = `${objType}:${nextUid()}`;\n\n    return obj._hashKey;\n  }\n\n  if (objType === \"undefined\") {\n    return `${objType}:${nextUid()}`;\n  }\n\n  // account for primitives\n  return `${objType}:${obj}`;\n}\n\n/**\n * Merges two class name values into a single space-separated string.\n * Accepts strings, arrays of strings, or null/undefined values.\n *\n * @param {string | string[] | null | undefined} firstClass - The first class name(s).\n * @param {string | string[] | null | undefined} secondClass - The second class name(s).\n * @returns {string} A single string containing all class names separated by spaces.\n */\nexport function mergeClasses(firstClass, secondClass) {\n  if (!firstClass && !secondClass) return \"\";\n\n  if (!firstClass)\n    return isArray(secondClass)\n      ? secondClass.join(\" \").trim()\n      : /** @type {string} */ (secondClass);\n\n  if (!secondClass)\n    return isArray(firstClass) ? firstClass.join(\" \").trim() : firstClass;\n\n  if (isArray(firstClass)) firstClass = normalizeStringArray(firstClass);\n\n  if (isArray(secondClass)) secondClass = normalizeStringArray(secondClass);\n\n  return `${firstClass.trim()} ${secondClass.trim()}`.trim();\n}\n\n/**\n * Joins an array of strings into a single string, trimming each\n * element and ignoring empty strings, null, and undefined\n * @param {any[]} arr\n * @returns {string}\n */\nfunction normalizeStringArray(arr) {\n  const cleaned = [];\n\n  for (const item of arr) {\n    if (item) {\n      const trimmed = item.trim();\n\n      if (trimmed) cleaned.push(trimmed);\n    }\n  }\n\n  return cleaned.join(\" \");\n}\n\n/**\n * Converts all accepted directives format into proper directive name.\n * @param {string} name Name to normalize\n * @returns {string}\n */\n\nexport function directiveNormalize(name) {\n  return name\n    .replace(PREFIX_REGEXP, \"\")\n    .replace(SPECIAL_CHARS_REGEXP, (_name, letter, offset) =>\n      offset ? letter.toUpperCase() : letter,\n    );\n}\n\n/**\n * Whether element should be animated\n * @param {Node} node\n * @returns {boolean}\n */\nexport function hasAnimate(node) {\n  return hasCustomOrDataAttribute(node, \"animate\");\n}\n\n/**\n * @param {Node} node\n * @param {string} attr\n * @returns {boolean}\n */\nfunction hasCustomOrDataAttribute(node, attr) {\n  if (node.nodeType !== NodeType._ELEMENT_NODE) return false;\n  const element = /** @type {HTMLElement} */ (node);\n\n  return (\n    element.dataset[attr] === \"true\" || element.getAttribute(attr) === \"true\"\n  );\n}\n\n/**\n * @param {Object|null|undefined} obj\n * @returns {boolean}\n */\nexport function isObjectEmpty(obj) {\n  if (!obj) return true;\n\n  return !keys(obj).length;\n}\n\n/**\n * Checks whether the given object has the specified property as its own (not inherited).\n *\n * This is a safe version of `hasOwnProperty` that avoids issues with objects\n * that have it overridden or missing from their prototype chain.\n *\n * @param {object} obj - The object to check.\n * @param {string|number|symbol} key - The property key to look for.\n * @returns {boolean} True if the object has the property as its own; otherwise, false.\n *\n * @example\n * hasOwn({ foo: 123 }, 'foo'); // true\n * hasOwn({}, 'bar'); // false\n */\nexport function hasOwn(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\n/**\n * @param {Object} obj\n * @returns {string[]}\n */\nexport function keys(obj) {\n  return Object.keys(obj);\n}\n\n/**\n * @template T\n * @param {{ [s: string]: T; } | ArrayLike<T>} obj\n * @returns {[string, T][]}\n */\nexport function entries(obj) {\n  return Object.entries(obj);\n}\n\n/**\n * Wraps a function so it can only be called once.\n * Subsequent calls do nothing and return undefined.\n *\n * @template {(...args: any[]) => any} F\n * @param {F} fn - The function to wrap.\n * @returns {(this: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F> | undefined}\n */\nexport function callBackOnce(fn) {\n  let called = false;\n\n  return (...args) => {\n    if (!called) {\n      called = true;\n\n      return fn(...args);\n    }\n\n    return undefined; // satisfies consistent-return\n  };\n}\n\n/**\n * Wraps a function so it will only be called starting from the second invocation.\n * The first call does nothing and returns undefined.\n *\n * @template {(...args: any[]) => any} F\n * @param {F} fn - The function to wrap.\n * @returns {(this: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F> | undefined}\n */\nexport function callBackAfterFirst(fn) {\n  let calledOnce = false;\n\n  return (...args) => {\n    if (calledOnce) {\n      return fn(...args);\n    }\n    calledOnce = true;\n\n    return undefined;\n  };\n}\n\n/**\n * Delays execution for a specified number of milliseconds.\n *\n * @param {number} [timeout=0] - The number of milliseconds to wait. Defaults to 0.\n * @returns {Promise<void>} A promise that resolves after the delay.\n */\nexport function wait(timeout = 0) {\n  return new Promise((resolve) => setTimeout(resolve, timeout));\n}\n\n/**\n * Checks if a given string starts with a specified substring.\n *\n * This is a simple polyfill-like function that mimics the behavior of\n * `String.prototype.startsWith` without using the built-in method.\n *\n * @param {string} str - The full string to evaluate.\n * @param {string} search - The substring to test against the beginning of `str`.\n * @returns {boolean} `true` if `str` starts with `search`, otherwise `false`.\n *\n * @example\n * startsWith(\"hello world\", \"hello\");\n * // returns true\n *\n * @example\n * startsWith(\"hello world\", \"world\");\n * // returns false\n *\n * @example\n * startsWith(\"test\", \"\");\n * // returns true (empty search string always matches)\n *\n * @example\n * startsWith(\"abc\", \"abcd\");\n * // returns false\n */\nexport function startsWith(str, search) {\n  return str.slice(0, search.length) === search;\n}\n\n/**\n * Loads and instantiates a WebAssembly module.\n * Tries streaming first, then falls back.\n * @param {string} src\n * @param {WebAssembly.Imports} imports\n */\nexport async function instantiateWasm(src, imports = {}) {\n  const res = await fetch(src);\n\n  if (!res.ok) throw new Error(\"fetch failed\");\n\n  try {\n    const { instance, module } = await WebAssembly.instantiateStreaming(\n      res.clone(),\n      imports,\n    );\n\n    return { instance, exports: instance.exports, module };\n  } catch {\n    /* empty */\n  }\n\n  const bytes = await res.arrayBuffer();\n\n  const { instance, module } = await WebAssembly.instantiate(bytes, imports);\n\n  return { instance, exports: instance.exports, module };\n}\n\n/**\n * @param {*} fn\n * @returns {boolean}\n */\nexport function isArrowFunction(fn) {\n  return typeof fn === \"function\" && !fn.prototype;\n}\n\n/**\n * Creates an object with no prototype.\n *\n * This is useful for use as a dictionary or map, since the returned object\n * does not inherit from `Object.prototype` and therefore has no built-in\n * properties such as `toString` or `hasOwnProperty`.\n *\n * @template T\n * @returns {Record<string, T>} An object with a null prototype.\n */\nexport function nullObject() {\n  return Object.create(null);\n}\n","/**\n * A helper list of tokens matching the standard injectables that come predefined in the core `ng` module.\n * These string tokens are commonly injected into services, directives, or components via `$inject`.\n *\n * Example:\n * ```js\n *\n * myDirective.$inject = [\n *   angular.$t.$animate,\n *   angular.$t.$templateRequest,\n * ];\n *\n * function myDirective($animate, $templateRequest) { ... }\n *\n * ```\n * @private\n * @type Readonly<Record<string, string>>\n */\nexport const $injectTokens = {\n  _angular: \"$angular\",\n  _attrs: \"$attrs\",\n  _scope: \"$scope\",\n  _element: \"$element\",\n  _animateCssDriver: \"$$animateCssDriver\",\n  _animateJs: \"$$animateJs\",\n  _animateJsDriver: \"$$animateJsDriver\",\n  _animateQueue: \"$$animateQueue\",\n  _animation: \"$$animation\",\n  _taskTrackerFactory: \"$$taskTrackerFactory\",\n  _anchorScroll: \"$anchorScroll\",\n  _animate: \"$animate\",\n  _animateCss: \"$animateCss\",\n  _aria: \"$aria\",\n  _compile: \"$compile\",\n  _cookie: \"$cookie\",\n  _controller: \"$controller\",\n  _document: \"$document\",\n  _eventBus: \"$eventBus\",\n  _exceptionHandler: \"$exceptionHandler\",\n  _filter: \"$filter\",\n  _http: \"$http\",\n  _httpParamSerializer: \"$httpParamSerializer\",\n  _interpolate: \"$interpolate\",\n  _location: \"$location\",\n  _log: \"$log\",\n  _parse: \"$parse\",\n  _rest: \"$rest\",\n  _rootScope: \"$rootScope\",\n  _rootElement: \"$rootElement\",\n  _router: \"$router\",\n  _sce: \"$sce\",\n  _sceDelegate: \"$sceDelegate\",\n  _state: \"$state\",\n  _stateRegistry: \"$stateRegistry\",\n  _sse: \"$sse\",\n  _sanitizeUri: \"$$sanitizeUri\",\n  _sanitizeUriProvider: \"$$sanitizeUriProvider\",\n  _templateCache: \"$templateCache\",\n  _templateFactory: \"$templateFactory\",\n  _templateRequest: \"$templateRequest\",\n  _transitions: \"$transitions\",\n  _urlConfig: \"$urlConfig\",\n  _url: \"$url\",\n  _view: \"$view\",\n  _window: \"$window\",\n  _websocket: \"$websocket\",\n\n  // provide literals\n  _provide: \"$provide\",\n  _injector: \"$injector\",\n  _compileProvider: \"$compileProvider\",\n  _animateProvider: \"$animateProvider\",\n  _filterProvider: \"$filterProvider\",\n  _controllerProvider: \"$controllerProvider\",\n};\n\n/**\n * Utility for mapping to service-names to providers\n * @param {String[]} services\n */\nexport function provider(services) {\n  return services.map((x) => `${x}Provider`);\n}\n","import { hasOwn, isArray, isDefined, isObject, keys } from \"./utils.js\";\nimport { NodeType } from \"./node.js\";\nimport { $injectTokens } from \"../injection-tokens.js\";\n\n/** @type {number} */\nlet elId = 1;\n\n/**\n * Key for storing isolate scope data, attached to an element\n */\nconst ISOLATE_SCOPE_KEY = \"$isolateScope\";\n\nconst EXPANDO = \"ng\";\n\n/**\n * Expando cache for adding properties to DOM nodes with JavaScript.\n * This used to be an Object in JQLite decorator, but swapped out for a Map\n *\n * @type {Map<number, import('../interface.ts').ExpandoStore>}\n */\nexport const Cache = new Map();\n\n/**\n * Key for storing scope data, attached to an element\n */\nconst SCOPE_KEY = $injectTokens._scope;\n\nconst DASH_LOWERCASE_REGEXP = /-([a-z])/g;\n\nconst UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;\n\n// Table parts need to be wrapped with `<table>` or they're\n// stripped to their contents when put in a div.\n// XHTML parsers do not magically insert elements in the\n// same way that tag soup parsers do, so we cannot shorten\n// this by omitting <tbody> or other required elements.\n/**\n * Map of HTML elements to their required wrapper elements.\n * @type {Object.<string, string[]>}\n */\nconst wrapMap = {\n  thead: [\"table\"],\n  col: [\"colgroup\", \"table\"],\n  tr: [\"tbody\", \"table\"],\n  td: [\"tr\", \"tbody\", \"table\"],\n};\n\nwrapMap.tbody =\n  wrapMap.tfoot =\n  wrapMap.colgroup =\n  wrapMap.caption =\n    wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n/**\n * A list of boolean attributes in HTML.\n * @type {string[]}\n */\nexport const BOOLEAN_ATTR = [\n  \"multiple\",\n  \"selected\",\n  \"checked\",\n  \"disabled\",\n  \"readonly\",\n  \"required\",\n  \"open\",\n];\n\n/**\n * A list of boolean attributes in HTML\n * @type {string[]}\n */\nconst BOOLEAN_ELEMENTS = [\n  \"INPUT\",\n  \"SELECT\",\n  \"OPTION\",\n  \"TEXTAREA\",\n  \"BUTTON\",\n  \"FORM\",\n  \"DETAILS\",\n];\n\n///////////////////////////////////////////////////////////////////\n////////////        HELPER FUNCTIONS      /////////////////////////\n///////////////////////////////////////////////////////////////////\n\n/**\n *\n * @returns {number} Next unique JQInstance id\n */\nfunction elemNextId() {\n  return ++elId;\n}\n\n/**\n * @param {string} _all\n * @param {string} letter\n * @returns {string}\n */\nfunction fnCamelCaseReplace(_all, letter) {\n  return letter.toUpperCase();\n}\n\n/**\n * Converts kebab-case to camelCase.\n * @param {string} name Name to normalize\n * @returns {string}\n */\nexport function kebabToCamel(name) {\n  return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);\n}\n\n/**\n * Converts sname to camelCase.\n * @param {string} name\n * @returns {string}\n */\nexport function snakeToCamel(name) {\n  return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);\n}\n\n/**\n * @param {Element & Record<string, any>} element\n * @param {string} [name]\n */\nexport function removeElementData(element, name) {\n  const expandoId = element[EXPANDO];\n\n  const expandoStore = expandoId && Cache.get(expandoId);\n\n  if (expandoStore) {\n    if (name) {\n      delete expandoStore.data[name];\n    } else {\n      expandoStore.data = {};\n    }\n\n    removeIfEmptyData(element);\n  }\n}\n\n/**\n * Stores data associated with an element inside the expando property of the DOM element.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Expando MDN Glossary: Expando}\n *\n * @param {Element & Record<string, any> } element\n * @param {boolean} [createIfNecessary=false]\n * @returns {import(\"../interface.ts\").ExpandoStore}\n */\nexport function getExpando(element, createIfNecessary = false) {\n  let expandoId = element[EXPANDO];\n\n  let expandoStore = expandoId && Cache.get(expandoId);\n\n  if (createIfNecessary && !expandoStore) {\n    element[EXPANDO] = expandoId = elemNextId();\n    expandoStore = {\n      data: {},\n    };\n    Cache.set(expandoId, expandoStore);\n  }\n\n  return expandoStore;\n}\n\n/**\n * Checks if the string contains HTML tags or entities.\n * @param {string} html\n * @returns {boolean} True if the string is plain text, false if it contains HTML tags or entities.\n */\nexport function isTextNode(html) {\n  return !/<|&#?\\w+;/.test(html);\n}\n\n/**\n * Check if element can accept expando data\n * @param {Element|Node} node\n * @returns {boolean}\n */\nfunction elementAcceptsData(node) {\n  // The window object can accept data but has no nodeType\n  // Otherwise we are only interested in elements (1) and documents (9)\n  switch (node.nodeType) {\n    case NodeType._ELEMENT_NODE:\n    case NodeType._DOCUMENT_NODE:\n    case NodeType._COMMENT_NODE:\n    case undefined: // window.object\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * @param {Element & Record<string, any>} element\n * @param {Element & Record<string, any>} element\n * @param {boolean} [onlyDescendants]\n * @returns {void}\n */\nexport function dealoc(element, onlyDescendants) {\n  if (!element || element instanceof Comment) return;\n\n  if (isArray(element)) {\n    /* @ts-ignore */\n    element.forEach((item) => dealoc(item, onlyDescendants));\n  } else {\n    if (!onlyDescendants && elementAcceptsData(element)) {\n      cleanElementData([element]);\n    }\n\n    if (elementAcceptsData(element)) {\n      cleanElementData(element.querySelectorAll(\"*\"));\n    }\n  }\n  delete element[EXPANDO];\n  element.innerHTML = \"\";\n}\n\n/**\n * If expando store data is empty, then delete it and set its expando id.\n * to undefined.\n * @param {Element & Record<string, any>} element\n * @param {Element & Record<string, any>} element\n */\nfunction removeIfEmptyData(element) {\n  const expandoId = element[EXPANDO];\n\n  const data = expandoId ? Cache.get(expandoId)?.data : undefined;\n\n  if (!data || !keys(data).length) {\n    Cache.delete(expandoId);\n    element[EXPANDO] = undefined; // don't delete DOM expandos. Chrome don't like it\n  }\n}\n\n/**\n * Gets or sets cache data for a given element.\n *\n * @param {Element} element - The DOM element to get or set data on.\n * @param {string|Object.<string, any>} key - The key to get/set or an object for mass-setting.\n * @param {*} [value] - The value to set. If not provided, the function acts as a getter.\n * @returns {*} - The retrieved data if acting as a getter. Otherwise, undefined.\n */\nexport function getOrSetCacheData(element, key, value) {\n  if (!elementAcceptsData(element)) return undefined;\n\n  const isSimpleSetter = isDefined(value);\n\n  const isSimpleGetter = !isSimpleSetter && key && !isObject(key);\n\n  const massGetter = !key;\n\n  const expandoStore = getExpando(element, !isSimpleGetter);\n\n  const data = expandoStore && expandoStore.data;\n\n  if (!data) return undefined;\n\n  if (isSimpleSetter && typeof key === \"string\") {\n    data[kebabToCamel(key)] = value;\n  } else if (massGetter) {\n    return data;\n  } else if (isSimpleGetter && typeof key === \"string\") {\n    return data[kebabToCamel(key)];\n  } else if (key && typeof key === \"object\") {\n    // key is now narrowed to object\n    for (const prop in key) {\n      if (Object.prototype.hasOwnProperty.call(key, prop)) {\n        data[kebabToCamel(prop)] = key[prop];\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Sets cache data for a given element.\n *\n * @param {Element|Node} element - The DOM element to get or set data on.\n * @param {string} key - The key (as a string) to get/set or an object for mass-setting.\n * @param {*} [value] - The value to set. If not provided, the function acts as a getter.\n * @returns\n */\nexport function setCacheData(element, key, value) {\n  if (elementAcceptsData(element)) {\n    const expandoStore = getExpando(/** @type {Element} */ (element), true);\n\n    const data = expandoStore && expandoStore.data;\n\n    data[kebabToCamel(key)] = value;\n  } else {\n    if (element.parentElement) {\n      // TODO: check should occur perhaps prior at compilation level that this is a valid element\n      setCacheData(element.parentElement, key, value);\n    }\n  }\n}\n\n/**\n * Gets cache data for a given element.\n *\n * @param {Element} element - The DOM element to get data from.\n * @param {string} [key] - The key (as a string) to retrieve. If not provided, returns all data.\n * @returns {*} - The retrieved data for the given key or all data if no key is provided.\n */\nexport function getCacheData(element, key) {\n  if (elementAcceptsData(element)) {\n    const expandoStore = getExpando(element, false); // Don't create if it doesn't exist\n\n    const data = expandoStore && expandoStore.data;\n\n    if (!key) {\n      return undefined;\n    }\n\n    return data && data[kebabToCamel(key)];\n  }\n\n  return undefined;\n}\n\n/**\n * Deletes cache data for a given element for a particular key.\n *\n * @param {Element} element - The DOM element to delete data from.\n * @param {string} key - The key (as a string) to delete.\n * @returns void\n */\nexport function deleteCacheData(element, key) {\n  if (!key) return;\n\n  if (elementAcceptsData(element)) {\n    const expandoStore = getExpando(element, false); // Don't create if it doesn't exist\n\n    const data = expandoStore?.data;\n\n    if (data && hasOwn(data, kebabToCamel(key))) {\n      delete data[kebabToCamel(key)];\n    }\n  }\n}\n/**\n * Gets scope for a given element.\n *\n * @param {Element} element - The DOM element to get data from.\n * @returns {ng.Scope} - The retrieved data for the given key or all data if no key is provided.\n */\nexport function getScope(element) {\n  return getCacheData(element, SCOPE_KEY);\n}\n\n/**\n * Set scope for a given element.\n *\n * @param {Element|Node|ChildNode} element - The DOM element to set data on.\n * @param {ng.Scope} scope - The Scope attached to this element\n */\nexport function setScope(element, scope) {\n  return setCacheData(element, SCOPE_KEY, scope);\n}\n\n/**\n * Gets isolate scope for a given element.\n *\n * @param {Element} element - The DOM element to get data from.\n * @returns {*} - The retrieved data for the given key or all data if no key is provided.\n */\nexport function getIsolateScope(element) {\n  return getCacheData(element, ISOLATE_SCOPE_KEY);\n}\n\n/**\n * Set isolate scope for a given element.\n *\n * @param {Element} element - The DOM element to set data on.\n * @param {ng.Scope} scope - The Scope attached to this element\n */\nexport function setIsolateScope(element, scope) {\n  return setCacheData(element, ISOLATE_SCOPE_KEY, scope);\n}\n\n/**\n * Gets the controller instance for a given element, if exists. Defaults to \"ngControllerController\"\n *\n * @param {Element} element - The DOM element to get data from.\n * @param {string} [name] - Controller name.\n * @returns {ng.Scope|undefined} - The retrieved data\n */\nexport function getController(element, name) {\n  return getInheritedData(element, `$${name || \"ngController\"}Controller`);\n}\n\n/**\n * Walk up the DOM tree (including Shadow DOM) to get inherited data.\n *\n * @param {Node} element - The starting element (or document/document fragment)\n * @param {string} name - The data key to look up\n * @returns {any} - The found value, or undefined if not found\n */\nexport function getInheritedData(element, name) {\n  // if element is the document object work with the html element instead\n  if (element.nodeType === NodeType._DOCUMENT_NODE) {\n    element = /** @type {Document} */ (element).documentElement;\n  }\n\n  let value;\n\n  while (element) {\n    value = getCacheData(/** @type {Element} */ (element), name);\n\n    if (isDefined(value)) return value;\n\n    let next = element.parentNode;\n\n    if (!next && element.nodeType === NodeType._DOCUMENT_FRAGMENT_NODE) {\n      next = /** @type {ShadowRoot} */ (element).host;\n    }\n\n    // Stop the loop when next is falsy, instead of assigning null\n    if (!next) break;\n\n    element = next;\n  }\n\n  return undefined;\n}\n\n/**\n *\n * @param {Element} element\n * @param {boolean} keepData\n */\nexport function removeElement(element, keepData = false) {\n  if (!keepData) {\n    dealoc(element);\n  }\n  const parent = element.parentNode;\n\n  if (parent) parent.removeChild(element);\n}\n\nconst parser = new DOMParser();\n\n/**\n * Extracts the starting tag from an HTML string or DOM element.\n *\n * @param {string|Element|Node} elementOrStr - The HTML string or DOM element to process.\n * @returns {string} The starting tag or processed result.\n */\nexport function startingTag(elementOrStr) {\n  let clone;\n\n  if (typeof elementOrStr === \"string\") {\n    const doc = parser.parseFromString(elementOrStr, \"text/html\");\n\n    const { firstChild } = doc.body;\n\n    if (!firstChild) return \"\"; // empty string for empty input\n\n    clone = firstChild.cloneNode(true);\n  } else if (elementOrStr instanceof Element || elementOrStr instanceof Node) {\n    clone = elementOrStr.cloneNode(true);\n  } else {\n    throw new Error(\"Input must be an HTML string or a DOM element.\");\n  }\n\n  while (clone.firstChild) {\n    clone.removeChild(clone.firstChild);\n  }\n\n  const divWrapper = document.createElement(\"div\");\n\n  divWrapper.appendChild(clone);\n  const elemHtml = divWrapper.innerHTML;\n\n  try {\n    if (clone.nodeType === NodeType._TEXT_NODE) {\n      return elemHtml.toLowerCase();\n    } else if (clone.nodeType === NodeType._COMMENT_NODE) {\n      return `<!--${/** @type {Comment} **/ (clone).data.trim()}-->`;\n    } else {\n      const match = elemHtml.match(/^(<[^>]+>)/);\n\n      if (match) {\n        return match[1].replace(/^<([\\w-]+)/, (_match, nodeName) => {\n          return `<${nodeName.toLowerCase()}`;\n        });\n      }\n    }\n  } catch {\n    return elemHtml.toLowerCase();\n  }\n\n  return elemHtml.toLowerCase();\n}\n\n/**\n * Return the DOM siblings between the first and last node in the given array.\n * @param {Node[]} nodes\n * @returns {Node[]}\n */\nexport function getBlockNodes(nodes) {\n  let node = nodes[0];\n\n  const endNode = nodes[nodes.length - 1];\n\n  let blockNodes;\n\n  for (let i = 1; node !== endNode; i++) {\n    const next = node.nextSibling;\n\n    if (!next) break; // stop if no next sibling\n\n    node = next;\n\n    if (blockNodes || nodes[i] !== node) {\n      if (!blockNodes) {\n        // use element to avoid circular dependency\n        blockNodes = Array.prototype.slice.call(nodes, 0, i);\n      }\n      blockNodes.push(node);\n    }\n  }\n\n  return blockNodes || nodes;\n}\n\n/**\n * Gets the name of a boolean attribute if it exists on a given element.\n *\n * @param {Element} element - The DOM element to check.\n * @param {string} name - The name of the attribute.\n * @returns {string|false} - The attribute name if valid, otherwise false.\n */\nexport function getBooleanAttrName(element, name) {\n  const normalizedName = name.toLowerCase();\n\n  const isBooleanAttr = BOOLEAN_ATTR.includes(normalizedName);\n\n  return isBooleanAttr && BOOLEAN_ELEMENTS.includes(element.nodeName)\n    ? normalizedName\n    : false;\n}\n\n/**\n * Takes an array of elements, calls any `$destroy` event handlers, removes any data in cache, and finally removes any\n * listeners.\n * @param {NodeListOf<Element>|Element[]} nodes\n */\nexport function cleanElementData(nodes) {\n  for (let i = 0, ii = nodes.length; i < ii; i++) {\n    removeElementData(nodes[i]);\n  }\n}\n\n/**\n * Return instance of InjectorService attached to element\n * @param {Element} element\n * @returns {ng.InjectorService}\n */\nexport function getInjector(element) {\n  return getInheritedData(element, $injectTokens._injector);\n}\n\n/**\n * Parses an HTML string into a DocumentFragment.\n * @param {string} htmlString\n * @returns {DocumentFragment}\n */\nfunction parseHTML(htmlString) {\n  const template = document.createElement(\"template\");\n\n  template.innerHTML = htmlString.trim();\n\n  return template.content;\n}\n\n/**\n * Creates a DOM element from an HTML string.\n * Must have exactly one root node.\n *\n * @param {string} htmlString - A string representing the HTML to parse.\n * @returns {Element}\n */\nexport function createElementFromHTML(htmlString) {\n  const content = parseHTML(htmlString);\n\n  return /** @type {Element} */ (content.firstChild);\n}\n\n/**\n * Creates a NodeList from an HTML string.\n *\n * @param {string} htmlString - A string representing the HTML to parse.\n * @returns {NodeListOf<ChildNode>}\n */\nexport function createNodelistFromHTML(htmlString) {\n  return parseHTML(htmlString).childNodes;\n}\n\n/**\n * Remove element from the DOM and clear Cache data, associated with the node.\n * @param {Element} element\n */\nexport function emptyElement(element) {\n  dealoc(element, true);\n  switch (element.nodeType) {\n    case NodeType._ELEMENT_NODE:\n    case NodeType._DOCUMENT_NODE:\n    case NodeType._DOCUMENT_FRAGMENT_NODE:\n      element.replaceChildren();\n      break;\n  }\n}\n\n/**\n * Inserts a DOM element before or at the beginning of a parent element.\n *\n * @param {HTMLElement | Element} element\n *   The element to insert into the DOM.\n *\n * @param {HTMLElement | Element} parentElement\n *   The parent element that will receive the inserted element.\n *\n * @param {ChildNode | Element | null} [afterElement]\n *   An optional sibling element  if present and valid, `element`\n *   will be inserted after it. If omitted or invalid, `element`\n *   is prepended to `parentElement`.\n *\n * @returns {void}\n */\nexport function domInsert(element, parentElement, afterElement) {\n  // if for some reason the previous element was removed\n  // from the dom sometime before this code runs then let's\n  // just stick to using the parent element as the anchor\n  if (afterElement) {\n    const afterNode = extractElementNode(afterElement);\n\n    if (afterNode && !afterNode.parentNode && !afterNode.previousSibling) {\n      afterElement = null;\n    }\n  }\n\n  if (afterElement) {\n    afterElement.after(element);\n  } else {\n    parentElement.prepend(element);\n  }\n}\n\n/**\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @param {ChildNode | null | undefined} after\n */\nexport function animatedomInsert(element, parent, after) {\n  const originalVisibility = element.style.visibility;\n\n  const originalPosition = element.style.position;\n\n  const originalPointerEvents = element.style.pointerEvents;\n\n  Object.assign(element.style, {\n    visibility: \"hidden\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n  });\n\n  domInsert(element, parent, after);\n\n  requestAnimationFrame(() => {\n    element.style.visibility = originalVisibility;\n    element.style.position = originalPosition;\n    element.style.pointerEvents = originalPointerEvents;\n  });\n}\n\n/**\n * Returns the base href of the document.\n *\n * @returns {string} The base href.\n */\nexport function getBaseHref() {\n  const href = document.querySelector(\"base\")?.getAttribute(\"href\");\n\n  return href ? href.replace(/^(https?:)?\\/\\/[^/]*/, \"\") : \"\";\n}\n\n/**\n * @param {NodeList|Node} element\n * @returns {Node | undefined}\n */\nexport function extractElementNode(element) {\n  if (!element || !isArray(element)) return /** @type {Node} */ (element);\n\n  for (let i = 0; i < /** @type {NodeList} */ (element).length; i++) {\n    const elm = element[i];\n\n    if (elm.nodeType === NodeType._ELEMENT_NODE) {\n      return elm;\n    }\n  }\n\n  return undefined;\n}\n","/** @internal */\n/** @enum {number} */\nexport const NodeType = {\n  _ELEMENT_NODE: 1, // Node.ELEMENT_NODE,\n  _DOCUMENT_NODE: 9, // Node.DOCUMENT_NODE,\n  _TEXT_NODE: 3, // Node.TEXT_NODE,\n  _COMMENT_NODE: 8, //Node.COMMENT_NODE,\n  _DOCUMENT_FRAGMENT_NODE: 11, // Node.DOCUMENT_FRAGMENT_NODE,\n};\n","import {\n  assertArgFn,\n  isArray,\n  isFunction,\n  minErr,\n} from \"../../shared/utils.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\nconst $injectorMinErr = minErr($injectTokens._injector);\n\nconst ARROW_ARG = /^([^(]+?)=>/;\n\nconst FN_ARGS = /^[^(]*\\(\\s*([^)]*)\\)/m;\n\nconst FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\n\nconst STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/gm;\n\n/**\n * @param {Function} fn\n * @returns {string}\n */\nfunction stringifyFn(fn) {\n  return Function.prototype.toString.call(fn);\n}\n\n/**\n * @param {Function} fn\n * @returns {RegExpMatchArray | null}\n */\nfunction extractArgs(fn) {\n  const fnText = stringifyFn(fn).replace(STRIP_COMMENTS, \"\");\n\n  return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);\n}\n\n/**\n * @param {Function} func\n * @returns {boolean}\n */\nexport function isClass(func) {\n  return /^class\\b/.test(stringifyFn(func));\n}\n\n/**\n * @param {any} fn\n * @param {boolean} [strictDi]\n * @param {string} [name]\n * @returns {Array<string>}\n */\nexport function annotate(fn, strictDi, name) {\n  /**\n   * @type {any[]}\n   */\n  let inject = [];\n\n  let argDecl;\n\n  let last;\n\n  if (isFunction(fn)) {\n    inject = fn.$inject;\n\n    if (!inject) {\n      inject = [];\n\n      if (fn.length) {\n        if (strictDi) {\n          throw $injectorMinErr(\n            \"strictdi\",\n            \"{0} is not using explicit annotation and cannot be invoked in strict mode\",\n            name,\n          );\n        }\n        argDecl = extractArgs(fn);\n        argDecl &&\n          argDecl[1].split(/,/).forEach((arg) => {\n            arg.replace(FN_ARG, (_all, _underscore, injName) => {\n              inject.push(injName);\n\n              return injName;\n            });\n          });\n      }\n      fn.$inject = inject;\n    }\n  } else if (isArray(fn)) {\n    last = /** @type {ng.AnnotatedFactory<any>} */ (fn).length - 1;\n    assertArgFn(fn[last], \"fn\");\n    inject = /** @type {ng.AnnotatedFactory<any>} */ (fn).slice(0, last);\n  } else {\n    assertArgFn(fn, \"fn\", true);\n  }\n\n  return inject;\n}\n","import {\n  hasOwn,\n  isArray,\n  isArrowFunction,\n  minErr,\n} from \"../../shared/utils.js\";\nimport { annotate, isClass } from \"./di.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\nconst $injectorMinErr = minErr($injectTokens._injector);\n\nconst providerSuffix = \"Provider\";\n\nconst INSTANTIATING = true;\n\nclass AbstractInjector {\n  /**\n   * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.\n   */\n  constructor(strictDi) {\n    /**\n     * @type {Object<String, Function>}\n     */\n    this._cache = {};\n    /** @type {boolean} */\n    this.strictDi = strictDi;\n    /** @type {string[]} */\n    this._path = [];\n    /** @type {Object.<string, ng.NgModule>} */\n    this._modules = {};\n  }\n\n  /**\n   * Get a service by name.\n   *\n   * @param {string} serviceName\n   * @returns {any}\n   */\n  get(serviceName) {\n    if (hasOwn(this._cache, serviceName)) {\n      if (this._cache[serviceName] === INSTANTIATING) {\n        throw $injectorMinErr(\n          \"cdep\",\n          \"Circular dependency found: {0}\",\n          `${serviceName} <- ${this._path.join(\" <- \")}`,\n        );\n      }\n\n      return this._cache[serviceName];\n    }\n\n    this._path.unshift(serviceName);\n    this._cache[serviceName] = INSTANTIATING;\n\n    try {\n      this._cache[serviceName] = this.factory(serviceName);\n    } catch (err) {\n      // this is for the error handling being thrown by the providerCache multiple times\n      delete this._cache[serviceName];\n      throw err;\n    }\n\n    return this._cache[serviceName];\n  }\n\n  /**\n   * Get the injection arguments for a function.\n   *\n   * @param {Function|ng.AnnotatedFactory<any>} fn\n   * @param {Object & Record<string, any>} [locals]\n   * @param {string} [serviceName]\n   * @returns\n   */\n  _injectionArgs(fn, locals, serviceName) {\n    const args = [];\n\n    const $inject = annotate(fn, this.strictDi, serviceName);\n\n    for (let i = 0, { length } = $inject; i < length; i++) {\n      const key = $inject[i];\n\n      if (typeof key !== \"string\") {\n        throw $injectorMinErr(\n          \"itkn\",\n          \"Incorrect injection token! Expected service name as string, got {0}\",\n          key,\n        );\n      }\n      args.push(locals && hasOwn(locals, key) ? locals[key] : this.get(key));\n    }\n\n    return args;\n  }\n\n  /**\n   * Invoke a function with optional context and locals.\n   *\n   * @param {Function|String|ng.AnnotatedFactory<any>} fn\n   * @param {*} [self]\n   * @param {Object} [locals]\n   * @param {string} [serviceName]\n   * @returns {*}\n   */\n  invoke(fn, self, locals, serviceName) {\n    if (typeof locals === \"string\") {\n      serviceName = locals;\n      locals = undefined;\n    }\n\n    const args = this._injectionArgs(\n      /** @type {Function} */ (fn),\n      locals,\n      serviceName,\n    );\n\n    if (isArray(fn)) {\n      fn = fn[fn.length - 1];\n    }\n\n    if (isClass(/** @type {Function} */ (fn))) {\n      args.unshift(null);\n\n      return new (Function.prototype.bind.apply(\n        /** @type {Function} */ (fn),\n        /** @type {[any, ...any[]]} */ (args),\n      ))();\n    } else {\n      return /** @type {Function} */ (fn).apply(self, args);\n    }\n  }\n\n  /**\n   * Instantiate a type constructor with optional locals.\n   * @param {Function|ng.AnnotatedFactory<any>} type\n   * @param {*} [locals]\n   * @param {string} [serviceName]\n   */\n  instantiate(type, locals, serviceName) {\n    // Check if type is annotated and use just the given function at n-1 as parameter\n    // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);\n    const ctor = isArray(type) ? type[type.length - 1] : type;\n\n    const args = this._injectionArgs(type, locals, serviceName);\n\n    // Empty object at position 0 is ignored for invocation with `new`, but required.\n    args.unshift(null);\n\n    try {\n      return new (Function.prototype.bind.apply(\n        ctor,\n        /** @type {[any, ...any[]]} */ (args),\n      ))();\n    } catch (err) {\n      // try arrow function\n      if (isArrowFunction(ctor)) {\n        return ctor(args);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * @abstract\n   * @param {string} _serviceName\n   * @returns {any}\n   */\n  // eslint-disable-next-line no-unused-vars\n  factory(_serviceName) {\n    /* empty */\n  }\n}\n\n/**\n * Injector for providers\n */\nexport class ProviderInjector extends AbstractInjector {\n  /**\n   * @param {import('./interface.ts').ProviderCache} cache\n   * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.\n   */\n  constructor(cache, strictDi) {\n    super(strictDi);\n    this._cache = cache;\n  }\n\n  /**\n   * Factory method for creating services.\n   * @param {string} caller - The name of the caller requesting the service.\n   * @throws {Error} If the provider is unknown.\n   */\n  factory(caller) {\n    this._path.push(caller);\n    // prevents lookups to providers through get\n    throw $injectorMinErr(\n      \"unpr\",\n      \"Unknown provider: {0}\",\n      this._path.join(\" <- \"),\n    );\n  }\n}\n\n/**\n * Injector for factories and services\n */\nexport class InjectorService extends AbstractInjector {\n  /** @type {(mods: Array<Function | string | ng.AnnotatedFactory<any>>) => void} */\n  loadNewModules = () => {\n    /* empty */\n  };\n\n  /**\n   * @param {ProviderInjector} providerInjector\n   * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.\n   */\n  constructor(providerInjector, strictDi) {\n    super(strictDi);\n\n    /** @private @type {ProviderInjector} */\n    this._providerInjector = providerInjector;\n    /** @private @type {Object.<string, ng.NgModule>} */\n    this._modules = providerInjector._modules;\n  }\n\n  /**\n   * @param {string} serviceName\n   * @returns {*}\n   */\n  factory(serviceName) {\n    const provider = this._providerInjector.get(serviceName + providerSuffix);\n\n    return this.invoke(provider.$get, provider, undefined, serviceName);\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @returns {boolean}\n   */\n  has(name) {\n    const hasProvider = hasOwn(\n      this._providerInjector._cache,\n      name + providerSuffix,\n    );\n\n    const hasCache = hasOwn(this._cache, name);\n\n    return hasProvider || hasCache;\n  }\n}\n","/**\n * Creates a proxy that automatically persists an object's state\n * into a storage backend whenever a property is set.\n *\n * @param {Record<PropertyKey, any>} target - The object to wrap\n * @param {string} key - The storage key\n * @param {import(\"../../core/di/interface.ts\").StorageLike & import(\"../../core/di/interface\").PersistentStoreConfig} storage - Any storage-like object with getItem/setItem/removeItem\n * @param {{serialize?: function, deserialize?: function}} [options] - Optional custom (de)serialization\n * @returns {Record<PropertyKey, any>}\n */\nexport function createPersistentProxy(target, key, storage, options = {}) {\n  const serialize = options.serialize || JSON.stringify;\n\n  const deserialize = options.deserialize || JSON.parse;\n\n  // Restore saved state\n  const saved = storage.getItem(key);\n\n  if (saved) {\n    Object.assign(target, deserialize(saved));\n  }\n\n  return new Proxy(target, {\n    set(obj, prop, value) {\n      obj[prop] = value;\n      storage.setItem(key, serialize(obj));\n\n      return true;\n    },\n    deleteProperty(obj, prop) {\n      const deleted = delete obj[prop];\n\n      storage.setItem(key, serialize(obj));\n\n      return deleted;\n    },\n  });\n}\n","import { isArray, isFunction, isString } from \"./utils.js\";\n\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n * @param {*} val\n * @returns {boolean}\n */\nexport function isInjectable(val) {\n  if (isArray(val) && val.length) {\n    const head = val.slice(0, -1),\n      tail = val.slice(-1);\n\n    return !(\n      head.filter((injectable) => !isString(injectable)).length ||\n      tail.filter((injectable) => !isFunction(injectable)).length\n    );\n  }\n\n  return isFunction(val);\n}\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n * @param {any} obj\n * @returns {boolean}\n */\nexport function isPromise(obj) {\n  return (\n    obj !== null && typeof obj === \"object\" && typeof obj.then === \"function\"\n  );\n}\n","import { isInjectable } from \"./predicates.js\";\nimport {\n  isArray,\n  isDefined,\n  isNumber,\n  isString,\n  notNullOrUndefined,\n} from \"./utils.js\";\n\nexport const BADARG = \"badarg\";\nexport const BADARGKEY = \"badarg: key\";\nexport const BADARGVALUE = \"badarg: value\";\n\n/** @type {Map<ng.Validator, string>} */\nconst reasons = new Map([\n  [notNullOrUndefined, \"required\"],\n  [isArray, \"notarray\"],\n  [isInjectable, \"notinjectable\"],\n  [isDefined, \"required\"],\n  [isString, \"notstring\"],\n]);\n\n/**\n *\n * @param {ng.Validator} val\n * @returns {string}\n */\nfunction getReason(val) {\n  return reasons.get(val) ?? \"fail\";\n}\n\n/**\n * Validate a value using a predicate function.\n * Throws if the predicate returns false.\n * IMPORTANT: use this function only for developper errors and not for user/data errors\n *\n * @param {ng.Validator} fn - Predicate validator function.\n * @param {*} arg - The value to validate.\n * @param {string} name - Parameter name (included in error message).\n * @returns {*} The validated value.\n * @throws {TypeError} If the value does not satisfy the validator.\n */\nexport function validate(fn, arg, name) {\n  if (fn(arg)) return arg;\n\n  let v;\n\n  try {\n    v = JSON.stringify(arg);\n  } catch {\n    v = String(arg);\n  }\n\n  throw new TypeError(`badarg:${getReason(fn)} ${name}=${v}`);\n}\n\n/**\n * @param {*} arg - The value to validate.\n * @param {string} name - Parameter name (included in error message).\n * @returns {*} The validated value.\n * @throws {TypeError} If the value does not satisfy the validator.\n */\nexport function validateRequired(arg, name) {\n  return validate(notNullOrUndefined, arg, name);\n}\n\n/**\n * @param {*} arg - The value to validate.\n * @param {string} name - Parameter name (included in error message).\n * @returns {*} The validated value.\n * @throws {TypeError} If the value does not satisfy the validator.\n */\nexport function validateArray(arg, name) {\n  return validate(isArray, arg, name);\n}\n\n/**\n * @param {*} arg - The value to validate.\n * @param {string} name - Parameter name (included in error message).\n * @returns {*} The validated value.\n * @throws {TypeError} If the value does not satisfy the validator.\n */\nexport function validateIsString(arg, name) {\n  return validate(isString, arg, name);\n}\n\n/**\n * @param {*} arg - The value to validate.\n * @param {string} name - Parameter name (included in error message).\n * @returns {number} The validated value.\n * @throws {TypeError} If the value is not a number.\n */\nexport function validateIsNumber(arg, name) {\n  return validate(isNumber, arg, name);\n}\n\n/**\n * @template T\n * @param {unknown} arg - The value to validate.\n * @param {new (...args: any[]) => T} type - The constructor to check against.\n * @param {string} name - Parameter name (included in error message).\n * @returns {T} The validated instance.\n * @throws {TypeError} If the value is not an instance of the specified type.\n */\nexport function validateInstanceOf(arg, type, name) {\n  return validate((v) => v instanceof type, arg, name);\n}\n","import {\n  assert,\n  assertArgFn,\n  assertNotHasOwnProperty,\n  entries,\n  isArray,\n  isFunction,\n  isInstanceOf,\n  isNullOrUndefined,\n  isObject,\n  isString,\n  isUndefined,\n  minErr,\n} from \"../../shared/utils.js\";\nimport { InjectorService, ProviderInjector } from \"./internal-injector.js\";\nimport { createPersistentProxy } from \"../../services/storage/storage.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\nimport { validateArray } from \"../../shared/validate.js\";\n\nconst $injectorMinErr = minErr($injectTokens._injector);\n\nconst providerSuffix = \"Provider\";\n\n/**\n *\n * @param {Array<String|Function>} modulesToLoad\n * @param {boolean} [strictDi]\n * @returns {InjectorService}\n */\nexport function createInjector(modulesToLoad, strictDi = false) {\n  assert(isArray(modulesToLoad), \"modules required\");\n\n  /** @type {Map<String|Function, boolean>} */\n  const loadedModules = new Map(); // Keep track of loaded modules to avoid circular dependencies\n\n  /** @type {ng.ProviderCache} */\n  const providerCache = {\n    $provide: {\n      provider: supportObject(provider),\n      factory: supportObject(factory),\n      service: supportObject(service),\n      value: supportObject(value),\n      constant: supportObject(constant),\n      store,\n      decorator,\n    },\n  };\n\n  const providerInjector = (providerCache.$injector = new ProviderInjector(\n    providerCache,\n    strictDi,\n  ));\n\n  const protoInstanceInjector = new InjectorService(providerInjector, strictDi);\n\n  providerCache.$injectorProvider = {\n    // $injectionProvider return instance injector\n    $get: () => protoInstanceInjector,\n  };\n\n  let instanceInjector = protoInstanceInjector;\n\n  const runBlocks = loadModules(modulesToLoad);\n\n  instanceInjector = protoInstanceInjector.get($injectTokens._injector);\n\n  runBlocks.forEach((fn) => fn && instanceInjector.invoke(fn));\n\n  instanceInjector.loadNewModules =\n    /** @param {Array<Function | string | ng.AnnotatedFactory<any>>} mods */ (\n      mods,\n    ) => loadModules(mods).forEach((fn) => fn && instanceInjector.invoke(fn));\n\n  return instanceInjector;\n\n  ////////////////////////////////////\n  // $provide methods\n  ////////////////////////////////////\n\n  /**\n   * Registers a provider.\n   * @param {string} name\n   * @param {import('../../interface.ts').ServiceProvider | import('../../interface.ts').Injectable<any>} provider\n   * @returns {import('../../interface.ts').ServiceProvider}\n   */\n  // eslint-disable-next-line no-shadow\n  function provider(name, provider) {\n    assertNotHasOwnProperty(name, \"service\");\n    let newProvider;\n\n    if (isFunction(provider) || isArray(provider)) {\n      newProvider = providerInjector.instantiate(\n        /** @type {Function} */ (provider),\n      );\n    } else {\n      newProvider = provider;\n    }\n\n    if (!newProvider.$get) {\n      throw $injectorMinErr(\n        \"pget\",\n        \"Provider '{0}' must define $get factory method.\",\n        name,\n      );\n    }\n    providerCache[name + providerSuffix] = newProvider;\n\n    return newProvider;\n  }\n\n  /**\n   * Registers a factory.\n   * @param {string} name\n   * @param {ng.AnnotatedFactory<any>} factoryFn\n   * @returns {import('../../interface.ts').ServiceProvider}\n   */\n  function factory(name, factoryFn) {\n    return provider(name, {\n      $get() {\n        const result = instanceInjector.invoke(factoryFn, this);\n\n        if (isUndefined(result)) {\n          throw $injectorMinErr(\n            \"undef\",\n            \"Provider '{0}' must return a value from $get factory method.\",\n            name,\n          );\n        }\n\n        return result;\n      },\n    });\n  }\n\n  /**\n   * Registers a service constructor.\n   * @param {string} name\n   * @param {Function} constructor\n   * @returns {import('../../interface.ts').ServiceProvider}\n   */\n  function service(name, constructor) {\n    return factory(name, [\n      $injectTokens._injector,\n      /** @param {ng.InjectorService} $injector */ ($injector) =>\n        $injector.instantiate(constructor),\n    ]);\n  }\n\n  /**\n   * Register a fixed value as a service.\n   * @param {String} name\n   * @param {any} val\n   * @returns {ng.ServiceProvider}\n   */\n  function value(name, val) {\n    return (providerCache[name + providerSuffix] = { $get: () => val });\n  }\n\n  /**\n   * Register a constant value (available during config).\n   * @param {string} name\n   * @param {any} value\n   * @returns {void}\n   */\n  // eslint-disable-next-line no-shadow\n  function constant(name, value) {\n    assertNotHasOwnProperty(name, \"constant\");\n    providerInjector._cache[name] = value;\n    protoInstanceInjector._cache[name] = value;\n  }\n\n  /**\n   * Register a decorator function to modify or replace an existing service.\n   * @param {string} serviceName - The name of the service to decorate.\n   * @param {Function} decorFn - A function that takes `$delegate` and returns a decorated service.\n   * @returns {void}\n   */\n  function decorator(serviceName, decorFn) {\n    const origProvider = providerInjector.get(serviceName + providerSuffix);\n\n    const origGet = origProvider.$get;\n\n    origProvider.$get = function () {\n      const origInstance = instanceInjector.invoke(origGet, origProvider);\n\n      return instanceInjector.invoke(decorFn, null, {\n        $delegate: origInstance,\n      });\n    };\n  }\n\n  /**\n   * Registers a service persisted in a storage\n   *\n   * @param {string} name - Service name\n   * @param {import(\"../../interface.ts\").Constructor} ctor - Constructor for the service\n   * @param {ng.StorageType} type - Type of storage to be instantiated\n   * @param {import(\"./interface.ts\").StorageLike & import(\"./interface.ts\").PersistentStoreConfig} [backendOrConfig]\n   */\n  function store(name, ctor, type, backendOrConfig) {\n    return provider(name, {\n      $get: /** @param {ng.InjectorService} $injector */ ($injector) => {\n        switch (type) {\n          case \"session\": {\n            const instance = $injector.instantiate(ctor);\n\n            return createPersistentProxy(instance, name, sessionStorage);\n          }\n          case \"local\": {\n            const instance = $injector.instantiate(ctor);\n\n            return createPersistentProxy(instance, name, localStorage);\n          }\n          case \"cookie\": {\n            const instance = $injector.instantiate(ctor);\n\n            const $cookie = $injector.get($injectTokens._cookie);\n\n            const serialize = backendOrConfig?.serialize ?? JSON.stringify;\n\n            const deserialize = backendOrConfig?.deserialize ?? JSON.parse;\n\n            const cookieOpts = backendOrConfig?.cookie ?? {};\n\n            return createPersistentProxy(instance, name, {\n              getItem(key) {\n                const raw = $cookie.get(key);\n\n                return isNullOrUndefined(raw) ? null : raw;\n              },\n\n              setItem(k, v) {\n                $cookie.put(k, v, cookieOpts);\n              },\n\n              removeItem(k) {\n                $cookie.remove(k, cookieOpts);\n              },\n\n              serialize,\n              deserialize,\n            });\n          }\n          case \"custom\": {\n            const instance = $injector.instantiate(ctor);\n\n            let backend;\n\n            let serialize = JSON.stringify;\n\n            let deserialize = JSON.parse;\n\n            if (backendOrConfig) {\n              if (typeof backendOrConfig.getItem === \"function\") {\n                // raw Storage object\n                backend = backendOrConfig;\n              } else if (isObject(backendOrConfig)) {\n                backend = backendOrConfig.backend || localStorage;\n\n                if (backendOrConfig.serialize)\n                  // eslint-disable-next-line prefer-destructuring\n                  serialize = backendOrConfig.serialize;\n\n                if (backendOrConfig.deserialize)\n                  // eslint-disable-next-line prefer-destructuring\n                  deserialize = backendOrConfig.deserialize;\n              }\n            } else {\n              // fallback default\n              backend = localStorage;\n            }\n\n            return createPersistentProxy(\n              instance,\n              name,\n              /** @type {import(\"./interface.ts\").StorageLike} */ (backend),\n              {\n                serialize,\n                deserialize,\n              },\n            );\n          }\n        }\n\n        return undefined;\n      },\n    });\n  }\n\n  /**\n   * Loads and instantiates AngularJS modules with proper type handling.\n   *\n   * @param {Array<string | Function | ng.AnnotatedFactory<any>>} modules - Modules to load\n   * @returns {Array<any>} - Array of run block results\n   */\n  function loadModules(modules) {\n    validateArray(modules, \"modules\");\n\n    /** @type {Array<any>} */\n    let moduleRunBlocks = [];\n\n    modules.forEach((module) => {\n      // Determine a key suitable for Map: string | Function\n      /** @type {string | Function} */\n      const moduleKey = Array.isArray(module)\n        ? module[module.length - 1]\n        : module;\n\n      if (loadedModules.get(moduleKey)) return;\n      loadedModules.set(moduleKey, true);\n\n      try {\n        if (isString(module)) {\n          /** @type {ng.NgModule} */\n          const moduleFn = window.angular.module(\n            /** @type {string} */ (module),\n          );\n\n          instanceInjector._modules[module] = moduleFn;\n\n          moduleRunBlocks = moduleRunBlocks\n            .concat(loadModules(moduleFn._requires))\n            .concat(moduleFn._runBlocks);\n\n          const invokeQueue = moduleFn._invokeQueue.concat(\n            moduleFn._configBlocks,\n          );\n\n          invokeQueue.forEach((invokeArgs) => {\n            const providerInstance = providerInjector.get(invokeArgs[0]);\n\n            providerInstance[invokeArgs[1]].apply(\n              providerInstance,\n              invokeArgs[2],\n            );\n          });\n        } else if (isFunction(module)) {\n          moduleRunBlocks.push(providerInjector.invoke(module));\n        } else if (isArray(module)) {\n          moduleRunBlocks.push(\n            providerInjector.invoke(\n              /** @type {Function | ng.AnnotatedFactory<any>} */ (module),\n            ),\n          );\n        } else {\n          assertArgFn(module, \"module\");\n        }\n      } catch (err) {\n        // If module is array, fallback to last element for error message\n        const moduleName = isArray(module) ? module[module.length - 1] : module;\n\n        throw $injectorMinErr(\n          \"modulerr\",\n          \"Failed to instantiate module {0} due to:\\n{1}\",\n          moduleName,\n          isInstanceOf(err, Error) ? err.stack || err.message : String(err),\n        );\n      }\n    });\n\n    return moduleRunBlocks;\n  }\n}\n\n/**\n * Wraps a delegate function to support object-style arguments.\n *\n * @template V\n * @param {(key: string, value: V) => any} delegate - The original function accepting (key, value)\n * @returns {(key: string | Record<string, V>, value?: V) => any}\n */\nfunction supportObject(delegate) {\n  return function (key, value) {\n    if (isObject(key)) {\n      entries(/** @type {Record<string, V>} */ (key)).forEach(([k, v]) => {\n        delegate(k, v);\n      });\n\n      return undefined;\n    } else {\n      return delegate(key, /** @type {any} */ (value));\n    }\n  };\n}\n","import { isString } from \"../../shared/utils.js\";\n\nconst originUrl = urlResolve(window.location.href);\n\n/**\n * @param {import(\"./interface.ts\").ResolvableUrl} url\n * @return {import(\"./interface.ts\").ParsedUrl}\n */\nexport function urlResolve(url) {\n  if (!isString(url))\n    return /** @type {import(\"./interface.ts\").ParsedUrl} */ (url);\n\n  const urlParsingNode = new URL(\n    /** @type {string} */ (url),\n    window.location.href,\n  );\n\n  const hostname = urlParsingNode.hostname.includes(\":\")\n    ? `[${urlParsingNode.hostname}]`\n    : urlParsingNode.hostname;\n\n  return {\n    href: urlParsingNode.href,\n    protocol: urlParsingNode.protocol,\n    host: urlParsingNode.host,\n    search: urlParsingNode.search\n      ? urlParsingNode.search.replace(/^\\?/, \"\")\n      : \"\",\n    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, \"\") : \"\",\n    hostname,\n    port: urlParsingNode.port,\n    pathname:\n      urlParsingNode.pathname.charAt(0) === \"/\"\n        ? urlParsingNode.pathname\n        : `/${urlParsingNode.pathname}`,\n  };\n}\n\n/**\n * Parse a request URL and determine whether this is a same-origin request as the application\n * document.\n *\n * @param {import(\"./interface.ts\").ResolvableUrl} requestUrl The url of the request as a string that will be resolved\n * or a parsed URL object.\n * @returns {boolean} Whether the request is for the same origin as the application document.\n */\nexport function urlIsSameOrigin(requestUrl) {\n  return urlsAreSameOrigin(requestUrl, originUrl);\n}\n\n/**\n * Parse a request URL and determine whether it is same-origin as the current document base URL.\n *\n * Note: The base URL is usually the same as the document location (`location.href`) but can\n * be overriden by using the `<base>` tag.\n *\n * @param {import(\"./interface.ts\").ResolvableUrl} requestUrl The url of the request as a string that will be resolved\n * or a parsed URL object.\n * @returns {boolean} Whether the URL is same-origin as the document base URL.\n */\nexport function urlIsSameOriginAsBaseUrl(requestUrl) {\n  return urlsAreSameOrigin(requestUrl, document.baseURI);\n}\n\n/**\n * Create a function that can check a URL's origin against a list of allowed/trusted origins.\n * The current location's origin is implicitly trusted.\n *\n * @param {string[]} trustedOriginUrls - A list of URLs (strings), whose origins are trusted.\n *\n * @returns {(url: import(\"./interface.ts\").ResolvableUrl) => boolean } - A function that receives a URL (string or parsed URL object) and returns\n *     whether it is of an allowed origin.\n */\nexport function urlIsAllowedOriginFactory(trustedOriginUrls) {\n  const parsedAllowedOriginUrls = [originUrl].concat(\n    trustedOriginUrls.map(urlResolve),\n  );\n\n  /**\n   * Check whether the specified URL (string or parsed URL object) has an origin that is allowed\n   * based on a list of trusted-origin URLs. The current location's origin is implicitly\n   * trusted.\n   *\n   * @param {import(\"./interface.ts\").ResolvableUrl} requestUrl - The URL to be checked (provided as a string that will be\n   *     resolved or a parsed URL object).\n   *\n   * @returns {boolean} - Whether the specified URL is of an allowed origin.\n   */\n  return function urlIsAllowedOrigin(requestUrl) {\n    const parsedUrl = urlResolve(requestUrl);\n\n    return parsedAllowedOriginUrls.some(\n      urlsAreSameOrigin.bind(null, parsedUrl),\n    );\n  };\n}\n\n/**\n * Determine if two URLs share the same origin.\n *\n * @param {import(\"./interface.ts\").ResolvableUrl} url1 - First URL to compare as a string or a normalized URL in the form of\n *     a dictionary object returned by `urlResolve()`.\n * @param {import(\"./interface.ts\").ResolvableUrl} url2 - Second URL to compare as a string or a normalized URL in the form\n *     of a dictionary object returned by `urlResolve()`.\n *\n * @returns {boolean} - True if both URLs have the same origin, and false otherwise.\n */\nexport function urlsAreSameOrigin(url1, url2) {\n  url1 = urlResolve(url1);\n  url2 = urlResolve(url2);\n\n  return url1.protocol === url2.protocol && url1.host === url2.host;\n}\n\n/**\n * Removes a trailing hash ('#') from the given URL if it exists.\n *\n * @param {string} url\n * @returns {string}\n */\nexport function trimEmptyHash(url) {\n  return url.replace(/#$/, \"\");\n}\n","import {\n  trimEmptyHash,\n  urlIsAllowedOriginFactory,\n} from \"../../shared/url-utils/url-utils.js\";\nimport {\n  encodeUriQuery,\n  entries,\n  extend,\n  fromJson,\n  isArray,\n  isBlob,\n  isDate,\n  isDefined,\n  isFile,\n  isFormData,\n  isFunction,\n  isNullOrUndefined,\n  isObject,\n  isPromiseLike,\n  isString,\n  isUndefined,\n  keys,\n  lowercase,\n  minErr,\n  nullObject,\n  shallowCopy,\n  toJson,\n  trim,\n  uppercase,\n} from \"../../shared/utils.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n\nconst APPLICATION_JSON = \"application/json\";\n\n/**\n * @internal\n * @enum {number}\n */\nexport const Http = {\n  _OK: 200,\n  _MultipleChoices: 300,\n  _BadRequest: 400,\n  _NotFound: 404,\n  _ErrorMax: 599,\n};\n\nconst CONTENT_TYPE_APPLICATION_JSON = {\n  \"Content-Type\": `${APPLICATION_JSON};charset=utf-8`,\n};\n\nconst JSON_START = /^\\[|^\\{(?!\\{)/;\n\n/** @type {Record<string, any>} */\nconst JSON_ENDS = {\n  \"[\": /]$/,\n  \"{\": /}$/,\n};\n\nconst JSON_PROTECTION_PREFIX = /^\\)]\\}',?\\n/;\n\nconst $httpMinErr = minErr(\"$http\");\n\n/**\n * @param {string | number | boolean | Object | Date} v\n * @returns {string | number | boolean}\n */\nfunction serializeValue(v) {\n  if (isObject(v)) {\n    return isDate(v) ? v.toISOString() : /** @type {string} */ (toJson(v));\n  }\n\n  return v;\n}\n\n/**\n * Default params serializer that converts objects to strings\n * according to the following rules:\n *\n * * `{'foo': 'bar'}` results in `foo=bar`\n * * `{'foo': Date.now()}` results in `foo=2015-04-01T09%3A50%3A49.262Z` (`toISOString()` and encoded representation of a Date object)\n * * `{'foo': ['bar', 'baz']}` results in `foo=bar&foo=baz` (repeated key for each array element)\n * * `{'foo': {'bar':'baz'}}` results in `foo=%7B%22bar%22%3A%22baz%22%7D` (stringified and encoded representation of an object)\n *\n * Note that serializer will sort the request parameters alphabetically.\n */\nexport function HttpParamSerializerProvider() {\n  /**\n   * @returns {import('./interface.ts').HttpParamSerializer}\n   * A function that serializes parameters into a query string.\n   */\n  this.$get = () => {\n    return (params) => {\n      if (!params) return \"\";\n      /**\n       * @type {string[]}\n       */\n      const parts = [];\n\n      keys(params)\n        .sort()\n        .forEach((key) => {\n          const value = params[key];\n\n          if (value === null || isUndefined(value) || isFunction(value)) return;\n\n          if (isArray(value)) {\n            /** @type {any[]} */ (value).forEach((v) => {\n              if (v === null || isUndefined(v) || isFunction(v)) return;\n\n              const serializedValue = serializeValue(\n                /** @type {string | number | boolean | Object | Date} */ (v),\n              );\n\n              parts.push(\n                `${encodeUriQuery(key)}=${encodeUriQuery(serializedValue)}`,\n              );\n            });\n          } else {\n            const sanitizedValue =\n              /** @type {string | number | boolean | Object | Date} */ (value);\n\n            parts.push(\n              `${encodeUriQuery(key)}=${encodeUriQuery(serializeValue(sanitizedValue))}`,\n            );\n          }\n        });\n\n      return parts.join(\"&\");\n    };\n  };\n}\n\n/**\n * @param {unknown} data\n * @param {(arg0: string) => any} headers\n */\nexport function defaultHttpResponseTransform(data, headers) {\n  if (isString(data)) {\n    // Strip json vulnerability protection prefix and trim whitespace\n    const tempData = data.replace(JSON_PROTECTION_PREFIX, \"\").trim();\n\n    if (tempData) {\n      const contentType = headers(\"Content-Type\");\n\n      const hasJsonContentType =\n        contentType && contentType.indexOf(APPLICATION_JSON) === 0;\n\n      if (hasJsonContentType || isJsonLike(tempData)) {\n        try {\n          data = fromJson(tempData);\n        } catch (err) {\n          if (!hasJsonContentType) {\n            return data;\n          }\n          throw $httpMinErr(\n            \"baddata\",\n            'Data must be a valid JSON object. Received: \"{0}\". ' +\n              'Parse error: \"{1}\"',\n            data,\n            err,\n          );\n        }\n      }\n    }\n  }\n\n  return data;\n}\n\n/**\n * @param {string} str\n * @return {boolean}\n */\nfunction isJsonLike(str) {\n  const jsonStart = str.match(JSON_START);\n\n  return jsonStart && JSON_ENDS[jsonStart[0]].test(str);\n}\n\n/**\n * Parse headers into key value object\n *\n * @param {string | Object} headers Raw headers as a string\n * @returns {Record<string, string>} Parsed headers as key value object\n */\nfunction parseHeaders(headers) {\n  /** @type {Record<string, string>} */\n  const parsed = nullObject();\n\n  let i;\n\n  /**\n   * @param {string} key\n   * @param {any} val\n   */\n  function fillInParsed(key, val) {\n    if (key) {\n      parsed[key] = parsed[key] ? `${parsed[key]}, ${val}` : val;\n    }\n  }\n\n  if (isString(headers)) {\n    headers.split(\"\\n\").forEach(\n      /** @param {string} line */\n      (line) => {\n        i = line.indexOf(\":\");\n        fillInParsed(\n          line.substring(0, i).trim().toLowerCase(),\n          trim(line.substring(i + 1)),\n        );\n      },\n    );\n  } else if (isObject(headers)) {\n    entries(headers).forEach(([headerKey, headerVal]) => {\n      fillInParsed(headerKey.toLowerCase(), trim(headerVal));\n    });\n  }\n\n  return parsed;\n}\n\n/**\n * Returns a function that provides access to parsed headers.\n *\n * Headers are lazy parsed when first requested.\n * @see parseHeaders\n *\n * @param {(string|Object)} headers Headers to provide access to.\n * @returns {import(\"./interface.ts\").HttpHeadersGetter} Returns a getter function which if called with:\n *\n *   - if called with an argument returns a single header value (empty string if missing)\n *   - if called with no arguments returns an object containing all headers.\n */\nfunction headersGetter(headers) {\n  /**\n   * @type {Record<string, string> | undefined}\n   */\n  let headersObj;\n\n  const getter = /** @type {import(\"./interface.ts\").HttpHeadersGetter} */ (\n    function (name) {\n      if (!headersObj) headersObj = parseHeaders(headers);\n\n      if (name) {\n        const value = headersObj[name.toLowerCase()];\n\n        return value ?? \"\";\n      }\n\n      return headersObj;\n    }\n  );\n\n  return getter;\n}\n\n/**\n * Chain all given functions\n *\n * This function is used for both request and response transforming\n *\n * @param {*} data Data to transform.\n * @param {import(\"./interface.ts\").HttpHeadersGetter} headers HTTP headers getter fn.\n * @param {number=} status HTTP status code of the response.\n * @param {((...args: any[]) => any) | Array<(...args: any[]) => any>} [fns] Function or an array of functions.\n * @returns {*} Transformed data.\n */\nfunction transformData(data, headers, status, fns) {\n  if (isFunction(fns)) {\n    return fns(data, headers, status);\n  }\n\n  if (isArray(fns)) {\n    /** @type {Array<function(...any): any>} */ (fns).forEach((fn) => {\n      data = fn(data, headers, status);\n    });\n  }\n\n  return data;\n}\n\n/**\n * @param {number} status\n */\nfunction isSuccess(status) {\n  return status >= Http._OK && status < Http._MultipleChoices;\n}\n\n/**\n * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.\n */\nexport function HttpProvider() {\n  /**\n   * Object containing default values for all {@link ng.$http $http} requests.\n   *\n   * - **`defaults.cache`** - {boolean|Object} - A boolean value or object created with\n   * {@link ng.$cacheFactory `$cacheFactory`} to enable or disable caching of HTTP responses\n   * by default. See {@link $http#caching $http Caching} for more information.\n   *\n   * - **`defaults.headers`** - {Object} - Default headers for all $http requests.\n   * Refer to {@link ng.$http#setting-http-headers $http} for documentation on\n   * setting default headers.\n   *     - **`defaults.headers.common`**\n   *     - **`defaults.headers.post`**\n   *     - **`defaults.headers.put`**\n   *     - **`defaults.headers.patch`**\n   *   *\n   * - **`defaults.paramSerializer`** - `{string|function(Object<string,string>):string}` - A function\n   *  used to the prepare string representation of request parameters (specified as an object).\n   *  If specified as string, it is interpreted as a function registered with the {@link auto.$injector $injector}.\n   *  Defaults to {@link ng.$httpParamSerializer $httpParamSerializer}.\n   *\n   * - **`defaults.transformRequest`** -\n   * `{Array<function(data, headersGetter)>|function(data, headersGetter)}` -\n   * An array of functions (or a single function) which are applied to the request data.\n   * By default, this is an array with one request transformation function:\n   *\n   *   - If the `data` property of the request configuration object contains an object, serialize it\n   *     into JSON format.\n   *\n   * - **`defaults.transformResponse`** -\n   * `{Array<function(data, headersGetter, status)>|function(data, headersGetter, status)}` -\n   * An array of functions (or a single function) which are applied to the response data. By default,\n   * this is an array which applies one response transformation function that does two things:\n   *\n   *  - If XSRF prefix is detected, strip it\n   *    (see {@link ng.$http#security-considerations Security Considerations in the $http docs}).\n   *  - If the `Content-Type` is `application/json` or the response looks like JSON,\n   *    deserialize it using a JSON parser.\n   *\n   * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.\n   * Defaults value is `'XSRF-TOKEN'`.\n   *\n   * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the\n   * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.\n   * @type {import(\"./interface.ts\").HttpProviderDefaults}\n   */\n  const defaults = (this.defaults = {\n    // transform incoming response data\n    transformResponse: [defaultHttpResponseTransform],\n    // transform outgoing request data\n    transformRequest: [\n      function (data) {\n        return isObject(data) &&\n          !isFile(data) &&\n          !isBlob(data) &&\n          !isFormData(data)\n          ? toJson(data)\n          : data;\n      },\n    ],\n    // default headers\n    headers: {\n      common: {\n        Accept: \"application/json, text/plain, */*\",\n      },\n      post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),\n      put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),\n      patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),\n    },\n    xsrfCookieName: \"XSRF-TOKEN\",\n    xsrfHeaderName: \"X-XSRF-TOKEN\",\n    paramSerializer: $t._httpParamSerializer,\n  });\n\n  let useApplyAsync = false;\n\n  /**\n   * Configure $http service to combine processing of multiple http responses received at around\n   * the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in\n   * significant performance improvement for bigger applications that make many HTTP requests\n   * concurrently (common during application bootstrap).\n   *\n   * Defaults to false. If no value is specified, returns the current configured value.\n   *\n   * @param {boolean=} value If true, when requests are loaded, they will schedule a deferred\n   *    \"apply\" on the next tick, giving time for subsequent requests in a roughly ~10ms window\n   *    to load and share the same digest cycle.\n   *\n   * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.\n   *    otherwise, returns the current configured value.\n   */\n  this.useApplyAsync = function (value) {\n    if (isDefined(value)) {\n      useApplyAsync = !!value;\n\n      return this;\n    }\n\n    return useApplyAsync;\n  };\n\n  /**\n   * Array containing service factories for all synchronous or asynchronous {@link ng.$http $http}\n   * pre-processing of request or postprocessing of responses.\n   *\n   * These service factories are ordered by request, i.e. they are applied in the same order as the\n   * array, on request, but reverse order, on response.\n   *\n   * {@link ng.$http#interceptors Interceptors detailed info}\n   * @type {Array<string | ng.Injectable<import(\"./interface.ts\").HttpInterceptorFactory>>}\n   */\n  this.interceptors = [];\n\n  /**\n   * Array containing URLs whose origins are trusted to receive the XSRF token. See the\n   * {@link ng.$http#security-considerations Security Considerations} sections for more details on\n   * XSRF.\n   *\n   * **Note:** An \"origin\" consists of the [URI scheme](https://en.wikipedia.org/wiki/URI_scheme),\n   * the [hostname](https://en.wikipedia.org/wiki/Hostname) and the\n   * [port number](https://en.wikipedia.org/wiki/Port_(computer_networking). For `http:` and\n   * `https:`, the port number can be omitted if using th default ports (80 and 443 respectively).\n   * Examples: `http://example.com`, `https://api.example.com:9876`\n   *\n   * <div class=\"alert alert-warning\">\n   *   It is not possible to trust specific URLs/paths. The `path`, `query` and `fragment` parts\n   *   of a URL will be ignored. For example, `https://foo.com/path/bar?query=baz#fragment` will be\n   *   treated as `https://foo.com`, meaning that **all** requests to URLs starting with\n   *   `https://foo.com/` will include the XSRF token.\n   * </div>\n   *\n   * @example\n   *\n   * ```js\n   * // App served from `https://example.com/`.\n   * angular.\n   *   module('xsrfTrustedOriginsExample', []).\n   *   config(['$httpProvider', function($httpProvider) {\n   *     $httpProvider.xsrfTrustedOrigins.push('https://api.example.com');\n   *   }]).\n   *   run(['$http', function($http) {\n   *     // The XSRF token will be sent.\n   *     $http.get('https://api.example.com/preferences').then(...);\n   *\n   *     // The XSRF token will NOT be sent.\n   *     $http.get('https://stats.example.com/activity').then(...);\n   *   }]);\n   * ```\n   *\n   * @type {string[]}\n   */\n  this.xsrfTrustedOrigins = [];\n\n  const that = this;\n\n  this.$get = [\n    $t._injector,\n    $t._sce,\n    $t._cookie,\n    /**\n     *\n     * @param {ng.InjectorService} $injector\n     * @param {ng.SceService} $sce\n     * @param {ng.CookieService} $cookie\n     * @returns {ng.HttpService}\n     */\n    function ($injector, $sce, $cookie) {\n      /**\n       * @type {Map<string, string>}\n       */\n      const defaultCache = new Map();\n\n      /**\n       * Make sure that default param serializer is exposed as a function\n       */\n      defaults.paramSerializer = isString(defaults.paramSerializer)\n        ? $injector.get(defaults.paramSerializer)\n        : defaults.paramSerializer;\n\n      /**\n       * Interceptors stored in reverse order. Inner interceptors before outer interceptors.\n       * The reversal is needed so that we can build up the interception chain around the\n       * server request.\n       * @type {any[]}\n       */\n      const reversedInterceptors = [];\n\n      that.interceptors.forEach((interceptorFactory) => {\n        reversedInterceptors.unshift(\n          isString(interceptorFactory)\n            ? $injector.get(interceptorFactory)\n            : $injector.invoke(interceptorFactory),\n        );\n      });\n\n      /**\n       * A function to check request URLs against a list of allowed origins.\n       */\n      const urlIsAllowedOrigin = urlIsAllowedOriginFactory(\n        that.xsrfTrustedOrigins,\n      );\n\n      /**\n       * @property {Array.<Object>} requestConfig Array of config objects for currently pending\n       * requests. This is primarily meant to be used for debugging purposes.\n       * @param {ng.RequestConfig} requestConfig\n       * @returns {import(\"./interface.ts\").HttpPromise<any>}\n       */\n      const $http = /** @type {import(\"./interface.ts\").HttpService} */ (\n        function (requestConfig) {\n          if (!isObject(requestConfig)) {\n            throw minErr(\"$http\")(\n              \"badreq\",\n              \"Http request configuration must be an object.  Received: {0}\",\n              requestConfig,\n            );\n          }\n\n          if (!isString($sce.valueOf(requestConfig.url))) {\n            throw minErr(\"$http\")(\n              \"badreq\",\n              \"Http request configuration url must be a string or a $sce trusted object.  Received: {0}\",\n              requestConfig.url,\n            );\n          }\n\n          const config = /** @type {ng.RequestConfig} */ (\n            extend(\n              {\n                method: \"get\",\n                transformRequest: defaults.transformRequest,\n                transformResponse: defaults.transformResponse,\n                paramSerializer: defaults.paramSerializer,\n              },\n              requestConfig,\n            )\n          );\n\n          config.headers = mergeHeaders(requestConfig);\n          config.method = /** @type {ng.HttpMethod} */ (\n            uppercase(config.method)\n          );\n          config.paramSerializer = isString(config.paramSerializer)\n            ? $injector.get(config.paramSerializer)\n            : config.paramSerializer;\n\n          /**\n           * @type {Array<import(\"./interface.ts\").HttpInterceptor[\"request\"] | import(\"./interface.ts\").HttpInterceptor[\"requestError\"]>}\n           */\n          const requestInterceptors = [];\n\n          /**\n           * @type {Array<import(\"./interface.ts\").HttpInterceptor[\"response\"] | import(\"./interface.ts\").HttpInterceptor[\"responseError\"]>}\n           */\n          const responseInterceptors = [];\n\n          /** @type {Promise<any>} */\n          let promise = Promise.resolve(config);\n\n          // apply interceptors\n          reversedInterceptors.forEach((interceptor) => {\n            if (interceptor.request || interceptor.requestError) {\n              requestInterceptors.unshift(\n                interceptor.request,\n                interceptor.requestError,\n              );\n            }\n\n            if (interceptor.response || interceptor.responseError) {\n              responseInterceptors.push(\n                interceptor.response,\n                interceptor.responseError,\n              );\n            }\n          });\n\n          promise = chainInterceptors(promise, requestInterceptors);\n          promise = promise.then(serverRequest);\n          promise = chainInterceptors(promise, responseInterceptors);\n\n          return /** @type {import(\"./interface.ts\").HttpPromise<any>} */ (\n            promise\n          );\n\n          /**\n           * @param {Promise<any>} promiseParam\n           * @param {Array<((value: any) => any) | undefined>} interceptors\n           * @returns {Promise<any>}\n           */\n          function chainInterceptors(promiseParam, interceptors) {\n            for (let i = 0, ii = interceptors.length; i < ii; ) {\n              const thenFn = interceptors[i++];\n\n              const rejectFn = interceptors[i++];\n\n              promiseParam = promiseParam.then(thenFn, rejectFn);\n            }\n\n            interceptors.length = 0;\n\n            return promiseParam;\n          }\n\n          /**\n           * @param {import(\"./interface.ts\").HttpHeaderType} headers\n           * @param {ng.RequestConfig} configParam\n           */\n          function executeHeaderFns(headers, configParam) {\n            let headerContent;\n\n            /** @type {Record<string, string>} */\n            const processedHeaders = {};\n\n            entries(headers).forEach(([header, headerFn]) => {\n              if (isFunction(headerFn)) {\n                headerContent = headerFn(configParam);\n\n                if (!isNullOrUndefined(headerContent)) {\n                  processedHeaders[header] = headerContent;\n                }\n              } else {\n                processedHeaders[header] = headerFn;\n              }\n            });\n\n            return processedHeaders;\n          }\n\n          /**\n           * @param {ng.RequestConfig} configParam\n           */\n          function mergeHeaders(configParam) {\n            /** @type {import(\"./interface.ts\").HttpRequestConfigHeaders} */\n            let defHeaders = defaults.headers || {};\n\n            const reqHeaders =\n              /** @type {import(\"./interface.ts\").HttpHeaderType} */ (\n                extend({}, configParam.headers || {})\n              );\n\n            defHeaders = extend(\n              {},\n              defHeaders.common || {},\n              defHeaders[lowercase(configParam.method)] || {},\n            );\n\n            keys(defHeaders).forEach((defHeaderName) => {\n              const lowercaseDefHeaderName = lowercase(defHeaderName);\n\n              const hasMatchingHeader = keys(reqHeaders).some(\n                (reqHeaderName) => {\n                  return lowercase(reqHeaderName) === lowercaseDefHeaderName;\n                },\n              );\n\n              if (!hasMatchingHeader) {\n                reqHeaders[defHeaderName] = defHeaders[defHeaderName];\n              }\n            });\n\n            // execute if header value is a function for merged headers\n            return executeHeaderFns(reqHeaders, shallowCopy(configParam));\n          }\n\n          /**\n           * @param {ng.RequestConfig} configParam\n           */\n          function serverRequest(configParam) {\n            const headers = configParam.headers || {};\n\n            configParam.headers = headers;\n\n            const reqData = transformData(\n              configParam.data,\n              headersGetter(headers),\n              undefined,\n              /** @type {((...args: any[]) => any) | Array<(...args: any[]) => any>} */ (\n                configParam.transformRequest || []\n              ),\n            );\n\n            // strip content-type if data is undefined\n            if (isUndefined(reqData)) {\n              keys(headers).forEach((header) => {\n                if (lowercase(header) === \"content-type\") {\n                  delete headers[header];\n                }\n              });\n            }\n\n            if (\n              isUndefined(configParam.withCredentials) &&\n              !isUndefined(defaults.withCredentials)\n            ) {\n              configParam.withCredentials = defaults.withCredentials;\n            }\n\n            // send request\n            return sendReq(configParam, reqData).then(\n              transformResponse,\n              transformResponse,\n            );\n          }\n\n          /**\n           * @param {import(\"./interface.ts\").HttpResponse<any>} response\n           */\n          function transformResponse(response) {\n            const httpResponse =\n              /** @type {import(\"./interface.ts\").HttpResponse<any>} */ (\n                response\n              );\n\n            // make a copy since the response must be cacheable\n            const resp =\n              /** @type {import(\"./interface.ts\").HttpResponse<any>} */ (\n                extend({}, httpResponse)\n              );\n\n            resp.data = transformData(\n              httpResponse.data,\n              httpResponse.headers,\n              httpResponse.status,\n              /** @type {((...args: any[]) => any) | Array<(...args: any[]) => any>} */ (\n                config.transformResponse || []\n              ),\n            );\n\n            return isSuccess(httpResponse.status) ? resp : Promise.reject(resp);\n          }\n        }\n      );\n\n      /**\n       * @type {ng.RequestConfig[]}\n       */\n      $http.pendingRequests = [];\n\n      createShortMethods(\"get\", \"delete\", \"head\");\n      createShortMethodsWithData(\"post\", \"put\", \"patch\");\n\n      /**\n       * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of\n       * default headers, withCredentials as well as request and response transformations.\n       *\n       * See \"Setting HTTP Headers\" and \"Transforming Requests and Responses\" sections above.\n       */\n      $http.defaults = defaults;\n\n      return $http;\n\n      /**\n       * @param {...(\"get\" | \"delete\" | \"head\")} names\n       */\n      function createShortMethods(...names) {\n        names.forEach((name) => {\n          /**\n           * @param {string} url\n           * @param {import(\"./interface.ts\").RequestShortcutConfig} [config]\n           */\n          $http[name] = function (url, config) {\n            return $http(\n              /** @type {ng.RequestConfig} */ (\n                extend({}, config || {}, {\n                  method: name,\n                  url,\n                })\n              ),\n            );\n          };\n        });\n      }\n\n      /**\n       * @param {...(\"post\" | \"put\" | \"patch\")} names\n       */\n      function createShortMethodsWithData(...names) {\n        names.forEach((name) => {\n          /**\n           * @param {string} url\n           * @param {string|Object} data\n           * @param {import(\"./interface.ts\").RequestShortcutConfig} [config]\n           */\n          $http[name] = function (url, data, config) {\n            return $http(\n              /** @type {ng.RequestConfig} */ (\n                extend({}, config || {}, {\n                  method: name,\n                  url,\n                  data,\n                })\n              ),\n            );\n          };\n        });\n      }\n\n      /**\n       * @param {ng.RequestConfig} config\n       * @param {any} reqData\n       */\n      function sendReq(config, reqData) {\n        const { promise, resolve, reject } = Promise.withResolvers();\n\n        /** @type {any} */\n        let cache;\n\n        let cachedResp;\n\n        const reqHeaders = config.headers || {};\n\n        config.headers = reqHeaders;\n\n        let { url } = config;\n\n        if (!isString(url)) {\n          // If it is not a string then the URL must be a $sce trusted object\n          url = $sce.valueOf(url);\n        }\n\n        url = buildUrl(\n          url,\n          /** @type {(obj: any) => string} */ (config.paramSerializer)(\n            config.params,\n          ),\n        );\n\n        $http.pendingRequests.push(config);\n        promise.then(removePendingReq, removePendingReq);\n\n        if (\n          (config.cache || defaults.cache) &&\n          config.cache !== false &&\n          config.method === \"GET\"\n        ) {\n          cache = isObject(config.cache)\n            ? config.cache\n            : isObject(/** @type {?} */ (defaults).cache)\n              ? /** @type {?} */ (defaults).cache\n              : defaultCache;\n        }\n\n        if (cache) {\n          cachedResp = cache.get(url);\n\n          if (isDefined(cachedResp)) {\n            if (isPromiseLike(cachedResp)) {\n              // cached request has already been sent, but there is no response yet\n              cachedResp.then(\n                resolvePromiseWithResult,\n                resolvePromiseWithResult,\n              );\n            } else {\n              // serving from cache\n              if (isArray(cachedResp)) {\n                resolvePromise(\n                  cachedResp[1],\n                  cachedResp[0],\n                  shallowCopy(cachedResp[2]),\n                  cachedResp[3],\n                  cachedResp[4],\n                );\n              } else {\n                resolvePromise(cachedResp, Http._OK, {}, \"OK\", \"complete\");\n              }\n            }\n          } else {\n            // put the promise for the non-transformed response into cache as a placeholder\n            cache.set(url, promise);\n          }\n        }\n\n        // if we won't have the response in cache, set the xsrf headers and\n        // send the request to the backend\n        if (isUndefined(cachedResp)) {\n          const xsrfCookieName =\n            config.xsrfCookieName || defaults.xsrfCookieName;\n\n          const xsrfValue =\n            xsrfCookieName && urlIsAllowedOrigin(config.url)\n              ? $cookie.getAll()[xsrfCookieName]\n              : undefined;\n\n          if (xsrfValue) {\n            const xsrfHeaderName =\n              config.xsrfHeaderName || defaults.xsrfHeaderName;\n\n            if (xsrfHeaderName) {\n              reqHeaders[xsrfHeaderName] = xsrfValue;\n            }\n          }\n\n          http(\n            config.method,\n            url,\n            reqData,\n            done,\n            reqHeaders,\n            config.timeout,\n            config.withCredentials,\n            /** @type {XMLHttpRequestResponseType | undefined} */ (\n              config.responseType\n            ),\n            createApplyHandlers(config.eventHandlers),\n            createApplyHandlers(config.uploadEventHandlers),\n          );\n        }\n\n        return promise;\n\n        /**\n         * @param eventHandlers\n         * @return {Record<string, EventListener>}\n         */\n        /**\n         * @param {ng.RequestConfig[\"eventHandlers\"] | ng.RequestConfig[\"uploadEventHandlers\"]} eventHandlers\n         */\n        function createApplyHandlers(eventHandlers) {\n          if (eventHandlers) {\n            /** @type {Record<string, EventListener>} */\n            const applyHandlers = {};\n\n            entries(eventHandlers).forEach(([key, eventHandler]) => {\n              applyHandlers[key] = function (event) {\n                if (useApplyAsync) {\n                  setTimeout(() => callEventHandler());\n                } else {\n                  callEventHandler();\n                }\n\n                function callEventHandler() {\n                  if (typeof eventHandler === \"function\") {\n                    eventHandler(event);\n                  } else if (\n                    eventHandler &&\n                    typeof eventHandler === \"object\" &&\n                    \"handleEvent\" in eventHandler\n                  ) {\n                    eventHandler.handleEvent(event);\n                  }\n                }\n              };\n            });\n\n            return /** @type {Record<string, EventListener>} */ (applyHandlers);\n          } else {\n            return {};\n          }\n        }\n\n        /**\n         * Callback registered to http():\n         *  - caches the response if desired\n         *  - resolves the raw $http promise\n         *  - calls $apply\n         */\n        /**\n         * @param {number} status\n         * @param {any} response\n         * @param {string | null} headersString\n         * @param {string} statusText\n         * @param {import(\"./interface.ts\").HttpResponseStatus} xhrStatus\n         */\n        function done(status, response, headersString, statusText, xhrStatus) {\n          if (cache) {\n            if (isSuccess(status)) {\n              cache.set(url, [\n                status,\n                response,\n                parseHeaders(headersString || \"\"),\n                statusText,\n                xhrStatus,\n              ]);\n            } else {\n              // remove promise from the cache\n              cache.delete(url);\n            }\n          }\n\n          function resolveHttpPromise() {\n            resolvePromise(\n              response,\n              status,\n              headersString,\n              statusText,\n              xhrStatus,\n            );\n          }\n\n          if (useApplyAsync) {\n            setTimeout(resolveHttpPromise);\n          } else {\n            resolveHttpPromise();\n          }\n        }\n\n        /**\n         * Resolves the raw $http promise.\n         * @param {any} response\n         * @param {number} status\n         * @param {string | Record<string, string> | null} headers\n         * @param {string} statusText\n         * @param {import(\"./interface.ts\").HttpResponseStatus} xhrStatus\n         */\n        function resolvePromise(\n          response,\n          status,\n          headers,\n          statusText,\n          xhrStatus,\n        ) {\n          // status: HTTP response status code, 0, -1 (aborted by timeout / promise)\n          status = status >= -1 ? status : 0;\n\n          (isSuccess(status) ? resolve : reject)({\n            data: response,\n            status,\n            headers: headersGetter(headers ?? \"\"),\n            config,\n            statusText,\n            xhrStatus,\n          });\n        }\n\n        /**\n         * @param {import(\"./interface.ts\").HttpResponse<any>} result\n         */\n        function resolvePromiseWithResult(result) {\n          resolvePromise(\n            result.data,\n            result.status,\n            shallowCopy(result.headers()),\n            result.statusText,\n            result.xhrStatus,\n          );\n        }\n\n        function removePendingReq() {\n          const idx = $http.pendingRequests.indexOf(config);\n\n          if (idx !== -1) $http.pendingRequests.splice(idx, 1);\n        }\n      }\n\n      /**\n       * @param {string} url\n       * @param {string} serializedParams\n       */\n      function buildUrl(url, serializedParams) {\n        if (serializedParams.length > 0) {\n          url += (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + serializedParams;\n        }\n\n        return url;\n      }\n    },\n  ];\n}\n\n/**\n * Makes an HTTP request using XMLHttpRequest with flexible options.\n *\n * @param {string} method - The HTTP method (e.g., \"GET\", \"POST\").\n * @param {string} [url] - The URL to send the request to. Defaults to the current page URL.\n * @param {*} [post] - The body to send with the request, if any.\n * @param {(status: number, response: any, headersString: string|null, statusText: string, xhrStatus: import(\"./interface.ts\").HttpResponseStatus) => void} [callback] - Callback invoked when the request completes.\n * @param {Object<string, string|undefined>} [headers] - Headers to set on the request.\n * @param {number|Promise<any>} [timeout] - Timeout in ms or a cancellable promise.\n * @param {boolean} [withCredentials] - Whether to send credentials with the request.\n * @param {XMLHttpRequestResponseType} [responseType] - The type of data expected in the response.\n * @param {ng.RequestConfig[\"eventHandlers\"]} [eventHandlers] - Event listeners for the XMLHttpRequest object.\n * @param {ng.RequestConfig[\"uploadEventHandlers\"]} [uploadEventHandlers] - Event listeners for the XMLHttpRequest.upload object.\n * @returns {void}\n */\nexport function http(\n  method,\n  url,\n  post,\n  callback,\n  headers,\n  timeout,\n  withCredentials,\n  responseType,\n  eventHandlers,\n  uploadEventHandlers,\n) {\n  url = url || trimEmptyHash(window.location.href);\n\n  const xhr = new XMLHttpRequest();\n\n  let abortedByTimeout = false;\n\n  /**\n   * @type {number | undefined}\n   */\n  let timeoutId;\n\n  xhr.open(method, url, true);\n\n  if (headers) {\n    for (const [key, value] of entries(headers)) {\n      if (isDefined(value)) {\n        xhr.setRequestHeader(key, value);\n      }\n    }\n  }\n\n  xhr.onload = () => {\n    let status = xhr.status || 0;\n\n    const statusText = xhr.statusText || \"\";\n\n    if (status === 0) {\n      status = xhr.response\n        ? Http._OK\n        : new URL(url).protocol === \"file:\"\n          ? Http._NotFound\n          : 0;\n    }\n\n    completeRequest(\n      status,\n      xhr.response,\n      xhr.getAllResponseHeaders(),\n      statusText,\n      \"complete\",\n    );\n  };\n\n  xhr.onerror = () => completeRequest(-1, null, null, \"\", \"error\");\n  xhr.ontimeout = () => completeRequest(-1, null, null, \"\", \"timeout\");\n\n  xhr.onabort = () => {\n    completeRequest(-1, null, null, \"\", abortedByTimeout ? \"timeout\" : \"abort\");\n  };\n\n  if (eventHandlers) {\n    for (const [key, handler] of entries(eventHandlers)) {\n      xhr.addEventListener(key, handler);\n    }\n  }\n\n  if (uploadEventHandlers) {\n    for (const [key, handler] of entries(uploadEventHandlers)) {\n      xhr.upload.addEventListener(key, handler);\n    }\n  }\n\n  if (withCredentials) {\n    xhr.withCredentials = true;\n  }\n\n  if (responseType) {\n    try {\n      xhr.responseType = responseType;\n    } catch (err) {\n      if (responseType !== \"json\") throw err;\n    }\n  }\n\n  xhr.send(isUndefined(post) ? null : post);\n\n  if (typeof timeout === \"number\" && timeout > 0) {\n    timeoutId = setTimeout(() => timeoutRequest(\"timeout\"), timeout);\n  } else if (isPromiseLike(timeout)) {\n    /** @type {Promise<any>} */ (timeout).then(() => {\n      timeoutRequest(\"abort\");\n    });\n  }\n\n  /**\n   * @param {\"timeout\"|\"abort\"} reason\n   */\n  function timeoutRequest(reason) {\n    abortedByTimeout = reason === \"timeout\";\n\n    if (xhr) xhr.abort();\n  }\n\n  /**\n   * @param {number} status - HTTP status code or -1 for network errors.\n   * @param {*} response - The parsed or raw response from the server.\n   * @param {string|null} headersString - The raw response headers as a string.\n   * @param {string} statusText - The status text returned by the server.\n   * @param {ng.HttpResponseStatus} xhrStatus - Final status of the request.\n   */\n  function completeRequest(\n    status,\n    response,\n    headersString,\n    statusText,\n    xhrStatus,\n  ) {\n    if (isDefined(timeoutId)) {\n      clearTimeout(timeoutId);\n    }\n\n    if (callback) {\n      callback(status, response, headersString, statusText, xhrStatus);\n    }\n  }\n}\n","import { $injectTokens as $t } from \"../../injection-tokens.js\";\nimport { Http } from \"../../services/http/http.js\";\nimport { NodeType } from \"../../shared/node.js\";\nimport {\n  callBackAfterFirst,\n  isDefined,\n  isInstanceOf,\n  isObject,\n  isString,\n  toKeyValue,\n  wait,\n} from \"../../shared/utils.js\";\n\n/**\n * @param {\"get\" | \"delete\" | \"post\" | \"put\"} method - HTTP method applied to request\n * @param {string} [attrOverride] - Custom name to use for the attribute\n * @returns {ng.DirectiveFactory}\n */\nfunction defineDirective(method, attrOverride) {\n  const attrName =\n    attrOverride || `ng${method.charAt(0).toUpperCase()}${method.slice(1)}`;\n\n  const directive = /** @type {ng.DirectiveFactory & Function} */ (\n    createHttpDirective(method, attrName)\n  );\n\n  directive.$inject = [\n    $t._http,\n    $t._compile,\n    $t._log,\n    $t._parse,\n    $t._state,\n    $t._sse,\n    $t._animate,\n  ];\n\n  return directive;\n}\n\n/** @type {ng.DirectiveFactory} */\nexport const ngGetDirective = defineDirective(\"get\");\n\n/** @type {ng.DirectiveFactory} */\nexport const ngDeleteDirective = defineDirective(\"delete\");\n\n/** @type {ng.DirectiveFactory} */\nexport const ngPostDirective = defineDirective(\"post\");\n\n/** @type {ng.DirectiveFactory} */\nexport const ngPutDirective = defineDirective(\"put\");\n\n/** @type {ng.DirectiveFactory} */\nexport const ngSseDirective = defineDirective(\"get\", \"ngSse\");\n\n/**\n * Selects DOM event to listen for based on the element type.\n *\n * @param {Element} element - The DOM element to inspect.\n * @returns {\"click\" | \"change\" | \"submit\"} The name of the event to listen for.\n */\nexport function getEventNameForElement(element) {\n  const tag = element.tagName.toLowerCase();\n\n  if ([\"input\", \"textarea\", \"select\"].includes(tag)) {\n    return \"change\";\n  } else if (tag === \"form\") {\n    return \"submit\";\n  }\n\n  return \"click\";\n}\n\n/**\n * Creates an HTTP directive factory that supports GET, DELETE, POST, PUT.\n *\n * @param {\"get\" | \"delete\" | \"post\" | \"put\"} method - HTTP method to use.\n * @param {string} attrName - Attribute name containing the URL.\n * @returns {ng.DirectiveFactory}\n */\nexport function createHttpDirective(method, attrName) {\n  /**\n   * @param {ng.HttpService} $http\n   * @param {ng.CompileService} $compile\n   * @param {ng.LogService} $log\n   * @param {ng.ParseService} $parse\n   * @param {ng.StateService} $state\n   * @param {ng.SseService} $sse\n   * @param {ng.AnimateService} $animate\n   * @returns {ng.Directive}\n   */\n  return function ($http, $compile, $log, $parse, $state, $sse, $animate) {\n    /**\n     * Collects form data from the element or its associated form.\n     *\n     * @param {HTMLElement} element\n     * @returns {Object<string, any>}\n     */\n    function collectFormData(element) {\n      /** @type {HTMLFormElement | null} */\n      let form = null;\n\n      const tag = element.tagName.toLowerCase();\n\n      if (tag === \"form\") {\n        form = /** @type {HTMLFormElement} */ (element);\n      } else if (\"form\" in element && element.form) {\n        // eslint-disable-next-line prefer-destructuring\n        form = /** @type {HTMLFormElement} */ (element.form);\n      } else if (element.hasAttribute(\"form\")) {\n        const formId = element.getAttribute(\"form\");\n\n        if (formId) {\n          const maybeForm = document.getElementById(formId);\n\n          if (maybeForm && maybeForm.tagName.toLowerCase() === \"form\") {\n            form = /** @type {HTMLFormElement} */ (maybeForm);\n          }\n        }\n      }\n\n      if (!form) {\n        if (\n          \"name\" in element &&\n          typeof element.name === \"string\" &&\n          element.name.length > 0\n        ) {\n          if (\n            isInstanceOf(element, HTMLInputElement) ||\n            isInstanceOf(element, HTMLTextAreaElement) ||\n            isInstanceOf(element, HTMLSelectElement)\n          ) {\n            const key = element.name;\n\n            const { value } = element;\n\n            return { [key]: value };\n          }\n        }\n\n        return {};\n      }\n\n      const formData = new FormData(form);\n\n      /** @type {import(\"../../shared/interface.ts\").Dict<any>} */\n      const data = {};\n\n      formData.forEach((value, key) => {\n        data[key] = value;\n      });\n\n      return data;\n    }\n\n    return /** @type {ng.Directive} */ ({\n      restrict: \"A\",\n      link(scope, element, attrs) {\n        const eventName = attrs.trigger || getEventNameForElement(element);\n\n        const tag = element.tagName.toLowerCase();\n\n        /**\n         * @type {Element | ChildNode[] | undefined}\n         */\n        let content = undefined;\n\n        if (isDefined(attrs.latch)) {\n          attrs.$observe(\n            \"latch\",\n            callBackAfterFirst(() =>\n              element.dispatchEvent(new Event(eventName)),\n            ),\n          );\n        }\n\n        let throttled = false;\n\n        let intervalId;\n\n        if (isDefined(attrs.interval)) {\n          element.dispatchEvent(new Event(eventName));\n          intervalId = setInterval(\n            () => element.dispatchEvent(new Event(eventName)),\n            parseInt(attrs.interval) || 1000,\n          );\n        }\n\n        /**\n         * Handles DOM manipulation based on a swap strategy and server-rendered HTML.\n         *\n         * @param {string | Object} html - The HTML string or JSON object returned from the server.\n         * @param {import(\"./interface.ts\").SwapModeType} swap\n         * @param {ng.Scope} scopeParam\n         * @param {ng.Attributes} attrsParam\n         * @param {Element} elementParam\n         */\n        function handleSwapResponse(\n          html,\n          swap,\n          scopeParam,\n          attrsParam,\n          elementParam,\n        ) {\n          let animationEnabled = false;\n\n          if (attrsParam.animate) {\n            animationEnabled = true;\n          }\n          /**\n           * @type {ChildNode[]|*[]}\n           */\n          let nodes = [];\n\n          if (![\"textcontent\", \"delete\", \"none\"].includes(swap)) {\n            if (!html) return;\n            const compiled = $compile(/** @type {string} */ (html))(scopeParam);\n\n            nodes =\n              compiled instanceof DocumentFragment\n                ? Array.from(compiled.childNodes)\n                : [compiled];\n          }\n\n          const targetSelector = attrsParam.target;\n\n          const target = targetSelector\n            ? document.querySelector(targetSelector)\n            : elementParam;\n\n          if (!target) {\n            $log.warn(`${attrName}: target \"${targetSelector}\" not found`);\n\n            return;\n          }\n\n          switch (swap) {\n            case \"outerHTML\": {\n              const parent = target.parentNode;\n\n              if (!parent) return;\n\n              // Build fragment for static replacement OR a list for animation\n              const frag = document.createDocumentFragment();\n\n              nodes.forEach((x) => frag.appendChild(x));\n\n              if (!animationEnabled) {\n                parent.replaceChild(frag, target);\n                break;\n              }\n\n              const placeholder = document.createElement(\"span\");\n\n              placeholder.style.display = \"none\";\n              parent.insertBefore(placeholder, target.nextSibling);\n\n              $animate.leave(target).done(() => {\n                const insertedNodes = Array.from(frag.childNodes);\n\n                // Insert each node in order\n                for (const x of insertedNodes) {\n                  if (x.nodeType === NodeType._ELEMENT_NODE) {\n                    // Animate elements\n                    $animate.enter(\n                      /** @type {Element} */ (x),\n                      /** @type {Element} */ (parent),\n                      placeholder,\n                    );\n                  } else {\n                    // Insert text nodes statically\n                    parent.insertBefore(x, placeholder);\n                  }\n                }\n\n                content = insertedNodes;\n                scopeParam.$flushQueue(); // flush once after all insertions\n              });\n\n              scopeParam.$flushQueue(); // flush leave animation\n              break;\n            }\n\n            case \"textContent\":\n              if (animationEnabled) {\n                $animate.leave(target).done(() => {\n                  target.textContent = /** @type {string} */ (html);\n                  $animate.enter(\n                    target,\n                    /** @type {Element} */ (target.parentNode),\n                  );\n                  scopeParam.$flushQueue();\n                });\n\n                scopeParam.$flushQueue();\n              } else {\n                target.textContent = /** @type {string} */ (html);\n              }\n              break;\n\n            case \"beforebegin\": {\n              const parent = target.parentNode;\n\n              if (!parent) break;\n\n              nodes.forEach((node) => {\n                if (\n                  animationEnabled &&\n                  node.nodeType === NodeType._ELEMENT_NODE\n                ) {\n                  $animate.enter(node, /** @type {Element} */ (parent), target); // insert before target\n                } else {\n                  parent.insertBefore(node, target);\n                }\n              });\n\n              if (animationEnabled) scopeParam.$flushQueue();\n              break;\n            }\n\n            case \"afterbegin\": {\n              const { firstChild } = target;\n\n              [...nodes].reverse().forEach((node) => {\n                if (\n                  animationEnabled &&\n                  node.nodeType === NodeType._ELEMENT_NODE\n                ) {\n                  $animate.enter(\n                    node,\n                    target,\n                    /** @type {Element} */ (firstChild),\n                  ); // insert before first child\n                } else {\n                  target.insertBefore(node, firstChild);\n                }\n              });\n\n              if (animationEnabled) scopeParam.$flushQueue();\n              break;\n            }\n\n            case \"beforeend\": {\n              nodes.forEach((node) => {\n                if (\n                  animationEnabled &&\n                  node.nodeType === NodeType._ELEMENT_NODE\n                ) {\n                  $animate.enter(node, target); // append at end\n                } else {\n                  target.appendChild(node);\n                }\n              });\n\n              if (animationEnabled) scopeParam.$flushQueue();\n              break;\n            }\n\n            case \"afterend\": {\n              const parent = target.parentNode;\n\n              if (!parent) break;\n              const { nextSibling } = target;\n\n              [...nodes].reverse().forEach((node) => {\n                if (\n                  animationEnabled &&\n                  node.nodeType === NodeType._ELEMENT_NODE\n                ) {\n                  $animate.enter(\n                    node,\n                    /** @type {Element} */ (parent),\n                    /** @type {Element} */ (nextSibling),\n                  ); // insert after target\n                } else {\n                  parent.insertBefore(node, nextSibling);\n                }\n              });\n\n              if (animationEnabled) scopeParam.$flushQueue();\n              break;\n            }\n\n            case \"delete\":\n              if (animationEnabled) {\n                $animate.leave(target).done(() => {\n                  target.remove(); // safety: actually remove in case $animate.leave didn't\n                  scopeParam.$flushQueue();\n                });\n                scopeParam.$flushQueue();\n              } else {\n                target.remove();\n              }\n              break;\n\n            case \"none\":\n              break;\n\n            case \"innerHTML\":\n            default:\n              if (animationEnabled) {\n                if (\n                  content &&\n                  /** @type {HTMLElement} */ (content).nodeType !==\n                    NodeType._TEXT_NODE\n                ) {\n                  $animate\n                    .leave(/** @type {HTMLElement} */ (content))\n                    .done(() => {\n                      content = nodes[0];\n                      $animate.enter(nodes[0], target);\n                      scopeParam.$flushQueue();\n                    });\n                  scopeParam.$flushQueue();\n                } else {\n                  content = nodes[0];\n\n                  if (\n                    /** @type {HTMLElement} */ (content).nodeType ===\n                    NodeType._TEXT_NODE\n                  ) {\n                    target.replaceChildren(...nodes);\n                  } else {\n                    $animate.enter(nodes[0], target);\n                    scopeParam.$flushQueue();\n                  }\n                }\n              } else {\n                target.replaceChildren(...nodes);\n              }\n              break;\n          }\n        }\n\n        element.addEventListener(eventName, async (event) => {\n          if (/** @type {HTMLButtonElement} */ (element).disabled) return;\n\n          if (tag === \"form\") event.preventDefault();\n          const swap =\n            /** @type {import(\"./interface.ts\").SwapModeType} */ (attrs.swap) ||\n            \"innerHTML\";\n\n          const url = attrs[attrName];\n\n          if (!url) {\n            $log.warn(`${attrName}: no URL specified`);\n\n            return;\n          }\n\n          const handler = /** @param {ng.HttpResponse<string|Object>} res */ (\n            res,\n          ) => {\n            if (isDefined(attrs.loading)) {\n              attrs.$set(\"loading\", false);\n            }\n\n            if (isDefined(attrs.loadingClass)) {\n              attrs.$removeClass(attrs.loadingClass);\n            }\n\n            const html = res.data;\n\n            if (\n              Http._OK <= res.status &&\n              res.status <= Http._MultipleChoices - 1\n            ) {\n              if (isDefined(attrs.success)) {\n                $parse(attrs.success)(scope, { $res: html });\n              }\n\n              if (isDefined(attrs.stateSuccess)) {\n                $state.go(attrs.stateSuccess);\n              }\n            } else if (\n              Http._BadRequest <= res.status &&\n              res.status <= Http._ErrorMax\n            ) {\n              if (isDefined(attrs.error)) {\n                $parse(attrs.error)(scope, { $res: html });\n              }\n\n              if (isDefined(attrs.stateError)) {\n                $state.go(attrs.stateError);\n              }\n            }\n\n            if (isObject(html)) {\n              if (attrs.target) {\n                scope.$eval(`${attrs.target} = ${JSON.stringify(html)}`);\n              } else {\n                scope.$merge(html);\n              }\n            } else if (isString(html)) {\n              handleSwapResponse(html, swap, scope, attrs, element);\n            }\n          };\n\n          if (isDefined(attrs.delay)) {\n            await wait(parseInt(attrs.delay) | 0);\n          }\n\n          if (throttled) return;\n\n          if (isDefined(attrs.throttle)) {\n            throttled = true;\n            attrs.$set(\"throttled\", true);\n            setTimeout(() => {\n              attrs.$set(\"throttled\", false);\n              throttled = false;\n            }, parseInt(attrs.throttle));\n          }\n\n          if (isDefined(attrs.loading)) {\n            attrs.$set(\"loading\", true);\n          }\n\n          if (isDefined(attrs.loadingClass)) {\n            attrs.$addClass(attrs.loadingClass);\n          }\n\n          if (method === \"post\" || method === \"put\") {\n            let data;\n\n            /** @type {ng.RequestShortcutConfig} */\n            const config = {};\n\n            if (attrs.enctype) {\n              config.headers = {\n                \"Content-Type\": attrs.enctype,\n              };\n              data = toKeyValue(collectFormData(element));\n            } else {\n              data = collectFormData(element);\n            }\n            $http[method](url, data, config).then(handler).catch(handler);\n          } else {\n            if (method === \"get\" && attrs.ngSse) {\n              const sseUrl = url;\n\n              /** @type {ng.SseConfig} */\n              const config = {\n                withCredentials: attrs.withCredentials === \"true\",\n                transformMessage: (data) => {\n                  try {\n                    return JSON.parse(data);\n                  } catch {\n                    return data;\n                  }\n                },\n                onOpen: () => {\n                  $log.info(`${attrName}: SSE connection opened to ${sseUrl}`);\n\n                  if (isDefined(attrs.loading)) attrs.$set(\"loading\", false);\n\n                  if (isDefined(attrs.loadingClass))\n                    attrs.$removeClass(attrs.loadingClass);\n                },\n                onMessage: (data) => {\n                  const res = { status: 200, data };\n\n                  handler(/** @type {ng.HttpResponse<Object>} */ (res));\n                },\n                onError: (err) => {\n                  $log.error(`${attrName}: SSE error`, err);\n                  const res = { status: 500, data: err };\n\n                  handler(/** @type {ng.HttpResponse<Object>} */ (res));\n                },\n                onReconnect: (count) => {\n                  $log.info(`ngSse: reconnected ${count} time(s)`);\n\n                  if (attrs.onReconnect)\n                    $parse(attrs.onReconnect)(scope, { $count: count });\n                },\n              };\n\n              const source = $sse(sseUrl, config);\n\n              scope.$on(\"$destroy\", () => {\n                $log.info(`${attrName}: closing SSE connection`);\n                source.close();\n              });\n            } else {\n              $http[method](url).then(handler).catch(handler);\n            }\n          }\n        });\n\n        if (intervalId) {\n          scope.$on(\"$destroy\", () => clearInterval(intervalId));\n        }\n\n        if (eventName === \"load\") {\n          element.dispatchEvent(new Event(\"load\"));\n        }\n      },\n    });\n  };\n}\n","import { $injectTokens as $t } from \"../../injection-tokens.js\";\nimport { callBackAfterFirst, isDefined, wait } from \"../../shared/utils.js\";\nimport { getEventNameForElement } from \"../http/http.js\";\n\nngWorkerDirective.$inject = [$t._parse, $t._log, $t._exceptionHandler];\n/**\n * Usage: <div ng-worker=\"workerName\" data-params=\"{{ expression }}\" data-on-result=\"callback($result)\"></div>\n *\n * @param {ng.ParseService} $parse\n * @param {ng.LogService} $log\n * @param {ng.ExceptionHandlerService} $exceptionHandler\n * @returns {ng.Directive}\n */\nexport function ngWorkerDirective($parse, $log, $exceptionHandler) {\n  return {\n    restrict: \"A\",\n    link(scope, element, attrs) {\n      const workerName = attrs.ngWorker;\n\n      if (!workerName) {\n        $log.warn(\"ngWorker: missing worker name\");\n\n        return;\n      }\n\n      /** @type {string} */\n      const eventName = attrs.trigger || getEventNameForElement(element);\n\n      let throttled = false;\n\n      let intervalId;\n\n      if (isDefined(attrs.latch)) {\n        attrs.$observe(\n          \"latch\",\n          callBackAfterFirst(() => element.dispatchEvent(new Event(eventName))),\n        );\n      }\n\n      if (isDefined(attrs.interval)) {\n        element.dispatchEvent(new Event(eventName));\n        intervalId = setInterval(\n          () => element.dispatchEvent(new Event(eventName)),\n          parseInt(attrs.interval) || 1000,\n        );\n      }\n\n      const worker = createWorkerConnection(workerName, {\n        logger: $log,\n        err: $exceptionHandler,\n        onMessage: (result) => {\n          if (isDefined(attrs.dataOnResult)) {\n            $parse(attrs.dataOnResult)(scope, { $result: result });\n          } else {\n            const swap = attrs.swap || \"innerHTML\";\n\n            handleSwap(result, swap, element);\n          }\n        },\n        onError: (err) => {\n          $log.error(`[ng-worker:${workerName}]`, err);\n\n          if (isDefined(attrs.dataOnError)) {\n            $parse(attrs.dataOnError)(scope, { $error: err });\n          } else {\n            element.textContent = \"Error\";\n          }\n        },\n      });\n\n      element.addEventListener(eventName, async () => {\n        if (element.hasAttribute(\"disabled\")) return;\n\n        if (isDefined(attrs.delay)) {\n          await wait(parseInt(attrs.delay) || 0);\n        }\n\n        if (throttled) return;\n\n        if (isDefined(attrs.throttle)) {\n          throttled = true;\n          attrs.$set(\"throttled\", true);\n          setTimeout(() => {\n            attrs.$set(\"throttled\", false);\n            throttled = false;\n          }, parseInt(attrs.throttle));\n        }\n\n        let params;\n\n        try {\n          params = attrs.params ? scope.$eval(attrs.params) : undefined;\n        } catch (err) {\n          $log.error(\"ngWorker: failed to evaluate data-params\", err);\n          params = undefined;\n        }\n\n        worker.post(params);\n      });\n\n      if (intervalId) {\n        scope.$on(\"$destroy\", () => clearInterval(intervalId));\n      }\n\n      if (eventName === \"load\") {\n        element.dispatchEvent(new Event(\"load\"));\n      }\n    },\n  };\n}\n\n/**\n * Swap result into DOM based on strategy\n * @param {string} result\n * @param {string} swap\n * @param {HTMLElement} element\n */\nfunction handleSwap(result, swap, element) {\n  switch (swap) {\n    case \"outerHTML\": {\n      const parent = element.parentNode;\n\n      if (!parent) return;\n      const temp = document.createElement(\"div\");\n\n      temp.innerHTML = result;\n      parent.replaceChild(/** @type {ChildNode} */ (temp.firstChild), element);\n      break;\n    }\n    case \"textContent\":\n      element.textContent = result;\n      break;\n    case \"beforebegin\":\n      element.insertAdjacentHTML(\"beforebegin\", result);\n      break;\n    case \"afterbegin\":\n      element.insertAdjacentHTML(\"afterbegin\", result);\n      break;\n    case \"beforeend\":\n      element.insertAdjacentHTML(\"beforeend\", result);\n      break;\n    case \"afterend\":\n      element.insertAdjacentHTML(\"afterend\", result);\n      break;\n    case \"innerHTML\":\n    default:\n      element.innerHTML = result;\n      break;\n  }\n}\n\n/**\n * Creates a managed Web Worker connection.\n *\n * @param {string | URL} scriptPath\n * @param {ng.WorkerConfig} [config]\n * @returns {ng.WorkerConnection}\n */\nexport function createWorkerConnection(scriptPath, config) {\n  if (!scriptPath) throw new Error(\"Worker script path required\");\n\n  const defaults = {\n    autoRestart: false,\n    autoTerminate: false,\n    onMessage() {\n      /* empty */\n    },\n    onError() {\n      /* empty */\n    },\n    /**\n     * @param {string} data\n     */\n    transformMessage(data) {\n      try {\n        return JSON.parse(data);\n      } catch {\n        return data;\n      }\n    },\n  };\n\n  const cfg = /** @type {import(\"./interface.ts\").DefultWorkerConfig} */ (\n    Object.assign({}, defaults, config)\n  );\n\n  let worker = new Worker(scriptPath, { type: \"module\" });\n\n  let terminated = false;\n\n  const reconnect = function () {\n    if (terminated) return;\n    cfg.logger.info(\"Worker: restarting...\");\n    worker.terminate();\n    worker = new Worker(scriptPath, { type: \"module\" });\n    wire(worker);\n  };\n\n  const wire = (/** @type {Worker} */ workerParam) => {\n    workerParam.onmessage = function (event) {\n      let { data } = event;\n\n      try {\n        data = cfg.transformMessage(data);\n      } catch {\n        /* no-op */\n      }\n      cfg.onMessage(data, event); // always provide both args\n    };\n\n    workerParam.onerror = function (err) {\n      cfg.onError(err);\n\n      if (cfg.autoRestart) reconnect();\n    };\n  };\n\n  wire(worker);\n\n  return {\n    post(data) {\n      if (terminated) {\n        cfg.logger.warn(\"Worker already terminated\");\n      }\n\n      try {\n        worker.postMessage(data);\n      } catch (err) {\n        cfg.logger.log(\"Worker post failed\", err);\n      }\n    },\n\n    terminate() {\n      terminated = true;\n      worker.terminate();\n    },\n\n    restart() {\n      if (terminated) cfg.logger.warn(\"Worker cannot restart after terminate\");\n      reconnect();\n    },\n\n    config: cfg,\n  };\n}\n","import { $injectTokens as $t } from \"../../../injection-tokens.js\";\nimport { createWorkerConnection } from \"../../../directive/worker/worker.js\";\nimport {\n  instantiateWasm,\n  isFunction,\n  isString,\n  isDefined,\n  isObject,\n  isArray,\n} from \"../../../shared/utils.js\";\nimport { isInjectable } from \"../../../shared/predicates.js\";\nimport { validate, validateRequired } from \"../../../shared/validate.js\";\n\n/**\n * Modules are collections of application configuration information for components:\n * controllers, directives, filters, etc. They provide recipes for the injector\n * to do the actual instantiation. A module itself has no behaviour but only state.\n * A such, it acts as a data structure between the Angular instance and the injector service.\n */\nexport class NgModule {\n  /**\n   * @param {string} name - Name of the module\n   * @param {Array<string>} requires - List of modules which the injector will load before the current module\n   * @param {ng.Injectable<any>} [configFn]\n   */\n  constructor(name, requires, configFn) {\n    validate(isString, name, \"name\");\n    validate(isArray, requires, \"requires\");\n    /**\n     * @public\n     * Name of the current module.\n     * @type {string}\n     */\n    this.name = name;\n\n    /**\n     * Array of module names that this module depends on.\n     * @ignore\n     * @type {string[]}\n     */\n    this._requires = requires;\n\n    /**\n     * Holds a collection of tasks, required to instantiate an angular component\n     * @ignore\n     * @type {!Array<Array<*>>}\n     */\n    this._invokeQueue = [];\n\n    /**\n     * @ignore\n     * @type {!Array<Array<*>>}\n     */\n    this._configBlocks = [];\n\n    /** @ignore @type {!Array.<ng.Injectable<any>>} */\n    this._runBlocks = [];\n\n    if (configFn) {\n      this.config(configFn);\n    }\n\n    /** @ignore @type {!Array.<ng.Injectable<any>>} */\n    this._services = [];\n\n    /** @ignore @type {!Array.<ng.RestDefinition<any>>} */\n    this._restDefinitions = [];\n  }\n\n  /**\n   * @param {string} name\n   * @param {any} object - Allows undefined\n   * @returns {NgModule}\n   */\n  value(name, object) {\n    validate(isString, name, \"name\");\n\n    this._invokeQueue.push([$t._provide, \"value\", [name, object]]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {Object|string|number} object\n   * @returns {NgModule}\n   */\n  constant(name, object) {\n    validate(isString, name, \"name\");\n    validate(isDefined, object, \"object\");\n\n    this._invokeQueue.unshift([$t._provide, \"constant\", [name, object]]);\n\n    return this;\n  }\n\n  /**\n   *\n   * @param {ng.Injectable<any>} configFn\n   * @returns {NgModule}\n   */\n  config(configFn) {\n    validate(isInjectable, configFn, \"configFn\");\n\n    this._configBlocks.push([$t._injector, \"invoke\", [configFn]]);\n\n    return this;\n  }\n\n  /**\n   * @param {ng.Injectable<any>} block\n   * @returns {NgModule}\n   */\n  run(block) {\n    validate(isInjectable, block, \"block\");\n\n    this._runBlocks.push(block);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.Component} options\n   * @returns {NgModule}\n   */\n  component(name, options) {\n    validate(isString, name, \"name\");\n    validate(isDefined, options, \"object\");\n\n    this._invokeQueue.push([$t._compileProvider, \"component\", [name, options]]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.Injectable<any>} providerFunction\n   * @returns {NgModule}\n   */\n  factory(name, providerFunction) {\n    validate(isString, name, \"name\");\n    validateRequired(providerFunction, \"providerFunction\");\n    this._invokeQueue.push([$t._provide, \"factory\", [name, providerFunction]]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.Injectable<any>} serviceFunction\n   * @returns {NgModule}\n   */\n  service(name, serviceFunction) {\n    validate(isString, name, \"name\");\n    validateRequired(serviceFunction, \"serviceFunction\");\n    this._services.push(name);\n    this._invokeQueue.push([$t._provide, \"service\", [name, serviceFunction]]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.Injectable<any>} providerType\n   * @returns {NgModule}\n   */\n  provider(name, providerType) {\n    validate(isString, name, \"name\");\n    validateRequired(providerType, \"providerType\");\n    this._invokeQueue.push([$t._provide, \"provider\", [name, providerType]]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.Injectable<any>} decorFn\n   * @returns {NgModule}\n   */\n  decorator(name, decorFn) {\n    validate(isString, name, \"name\");\n    validateRequired(decorFn, \"decorFn\");\n    this._configBlocks.push([$t._provide, \"decorator\", [name, decorFn]]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.Injectable<any>} directiveFactory\n   * @returns {NgModule}\n   */\n  directive(name, directiveFactory) {\n    validate(isString, name, \"name\");\n    validateRequired(directiveFactory, \"directiveFactory\");\n    this._invokeQueue.push([\n      $t._compileProvider,\n      \"directive\",\n      [name, directiveFactory],\n    ]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.Injectable<any>} animationFactory\n   * @returns {NgModule}\n   */\n  animation(name, animationFactory) {\n    validate(isString, name, \"name\");\n    validateRequired(animationFactory, \"animationFactory\");\n    this._invokeQueue.push([\n      $t._animateProvider,\n      \"register\",\n      [name, animationFactory],\n    ]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {ng.FilterFactory} filterFn\n   * @return {NgModule}\n   */\n  filter(name, filterFn) {\n    validate(isString, name, \"name\");\n    validate(isFunction, filterFn, `filterFn`);\n    this._invokeQueue.push([$t._filterProvider, \"register\", [name, filterFn]]);\n\n    return this;\n  }\n\n  /**\n   * The $controller service is used by Angular to create new controllers.\n   * This provider allows controller registration via the register method.\n   *\n   * @param {string} name Controller name\n   * @param {ng.Injectable<ng.ControllerConstructor>} ctlFn Controller constructor fn (optionally decorated with DI annotations in the array notation)\n   * @returns {NgModule}\n   */\n  controller(name, ctlFn) {\n    validate(isString, name, \"name\");\n    validateRequired(ctlFn, `fictlFnlterFn`);\n    this._invokeQueue.push([$t._controllerProvider, \"register\", [name, ctlFn]]);\n\n    return this;\n  }\n\n  /**\n   * Register a named WebAssembly module that will be instantiated via $provide.\n   *\n   * @param {string} name - The injectable name used to access the instantiated WebAssembly module.\n   *\n   * @param {string} src - URL of the `.wasm` file to fetch and instantiate.\n   *\n   * @param {Object<string, any>} [imports] WebAssembly import object, passed to `WebAssembly.instantiate` or  `WebAssembly.instantiateStreaming`.\n   *\n   * @param {Object<string, any>} [opts] - Configuration object.\n   *\n   *   Supported keys:\n   *   - **raw**: `boolean`\n   *       - `false` (default): the injectable resolves to `instance.exports`\n   *         (ideal for plain WASM modules).\n   *       - `true`: the injectable resolves to the full instantiation result:\n   *         `{ instance, exports, module }`\n   *         (required for runtimes such as Go, Emscripten, wasm-bindgen, etc).\n   *\n   * @returns {NgModule}\n   */\n  wasm(name, src, imports = {}, opts = {}) {\n    validate(isString, name, \"name\");\n    validate(isString, src, \"src\");\n    const raw = !!opts.raw;\n\n    this._invokeQueue.push([\n      $t._provide,\n      \"provider\",\n      [\n        name,\n        class {\n          $get() {\n            return instantiateWasm(src, imports).then((result) =>\n              raw ? result : result.exports,\n            );\n          }\n        },\n      ],\n    ]);\n\n    return this;\n  }\n\n  /**\n   * Register a named worker that will be instantiated via $provide.\n   *\n   * @param {string} name\n   * @param {string | URL} scriptPath\n   * @param {ng.WorkerConfig} [config]\n   * @returns {NgModule}\n   */\n  worker(name, scriptPath, config) {\n    validate(isString, name, \"name\");\n    validate(isString, scriptPath, \"scriptPath\");\n    this._invokeQueue.push([\n      $t._provide,\n      \"provider\",\n      [\n        name,\n        class {\n          $get = () => createWorkerConnection(scriptPath, config);\n        },\n      ],\n    ]);\n\n    return this;\n  }\n\n  /**\n   * @param {string} name\n   * @param {Function|Object} ctor - A regular function, an arrow function or an object\n   * @param {ng.StorageType} type\n   * @param {ng.StorageBackend} [backendOrConfig]\n   * @returns {NgModule}\n   */\n  store(name, ctor, type, backendOrConfig) {\n    validate(isString, name, \"name\");\n    validateRequired(ctor, \"ctor\");\n    this._invokeQueue.push([\n      $t._provide,\n      \"store\",\n      [name, isObject(ctor) ? () => ctor : ctor, type, backendOrConfig],\n    ]);\n\n    return this;\n  }\n\n  /**\n   * @template T, ID\n   * Register a REST resource during module configuration.\n   * @param {string} name - Service name\n   * @param {string} url - Base URL or URI template\n   * @param {ng.EntityClass<T>} entityClass - Optional constructor for mapping JSON\n   * @param {Object=} options - Optional RestService options (interceptors, etc)\n   * @returns {NgModule}\n   */\n  rest(name, url, entityClass, options = {}) {\n    validate(isString, name, \"name\");\n    validate(isString, url, \"url\");\n    validate(isFunction, entityClass, \"entityClass\");\n    /** @type {ng.RestDefinition<T>} */\n    const def = { name, url, entityClass, options };\n\n    this._restDefinitions.push(def);\n\n    // push provider/factory to invokeQueue\n    this._invokeQueue.push([\n      $t._provide,\n      \"factory\",\n      [\n        name,\n        [\n          $t._rest,\n          /** @param {(baseUrl:string, entityClass?:Function, options?:object) => ng.RestService<T, ID>} $rest */ (\n            $rest,\n          ) => $rest(url, entityClass, options),\n        ],\n      ],\n    ]);\n\n    return this;\n  }\n\n  /**\n   * Register a pre-configured SSE connection during module configuration.\n   *\n   * @param {string} name - Injectable name\n   * @param {string} url - SSE endpoint\n   * @param {ng.SseConfig} [options] - Optional SSE config\n   * @returns {NgModule}\n   */\n  sse(name, url, options = {}) {\n    validate(isString, name, \"name\");\n    validate(isString, url, \"url\");\n\n    this._invokeQueue.push([\n      $t._provide,\n      \"factory\",\n      [\n        name,\n        [\n          $t._sse,\n          /** @param {ng.SseService} $sse */ ($sse) => $sse(url, options),\n        ],\n      ],\n    ]);\n\n    return this;\n  }\n\n  /**\n   * Register a pre-configured WebSocket connection during module configuration.\n   *\n   * @param {string} name - Injectable name\n   * @param {string} url - WebSocket endpoint\n   * @param {string[]} [protocols] - Optional subprotocols\n   * @param {ng.WebSocketConfig} [options] - Optional WebSocket configuration\n   * @returns {NgModule}\n   */\n  websocket(name, url, protocols = [], options = {}) {\n    validate(isString, name, \"name\");\n    validate(isString, url, \"url\");\n\n    this._invokeQueue.push([\n      $t._provide,\n      \"factory\",\n      [\n        name,\n        [\n          $t._websocket,\n          /** @param {ng.WebSocketService} $ws */ ($ws) =>\n            $ws(url, protocols, options),\n        ],\n      ],\n    ]);\n\n    return this;\n  }\n}\n","import { isArray, isString } from \"./utils.js\";\nimport { createElementFromHTML } from \"./dom.js\";\nimport { NodeType } from \"./node.js\";\n\n/**\n * A type-safe wrapper around a DOM Node, HTMLElement, HTML string, NodeList, or an array of Nodes.\n * Provides guarantees around presence and access.\n */\nexport class NodeRef {\n  static $nonscope = true;\n  /**\n   * @param {Node | Element | string | NodeList | Node[]} element - The DOM node(s) or HTML string to wrap.\n   * @throws {Error} If the argument is invalid or cannot be wrapped properly.\n   */\n  constructor(element) {\n    /** @private @type {Node | ChildNode | undefined} */\n    this._node = undefined;\n\n    /** @type {Element | undefined} */\n    this._element = undefined;\n\n    /** @private @type {Array<Node>} a stable list on nodes */\n    this._nodes = [];\n\n    /** @type {boolean} */\n    this._isList = false;\n\n    // Handle HTML string\n    if (isString(element)) {\n      const res = createElementFromHTML(/** @type {string} */ (element));\n\n      switch (true) {\n        case res instanceof Element:\n          this.element = res;\n          break;\n        case res instanceof Node:\n          this.node = res;\n          break;\n      }\n    }\n\n    // Handle NodeList\n    else if (element instanceof NodeList) {\n      if (element.length === 1) {\n        this.node = element[0];\n      } else {\n        this._nodes = Array.from(element);\n        this._isList = true;\n      }\n    }\n\n    // Handle single Element\n    else if (element instanceof Element) {\n      this.element = /** @type {Element} */ element;\n    }\n\n    // Handle single Node\n    else if (element instanceof Node) {\n      this._node = element;\n    }\n\n    // Handle array of elements\n    else if (isArray(element)) {\n      if (element.length === 1) {\n        this.node = /** @type {Node} */ (element[0]);\n      } else {\n        this.nodes = /** @type {Node[]} */ (element);\n      }\n    } else {\n      throw new Error(\"Invalid element passed to NodeRef\");\n    }\n  }\n\n  /** @returns {Element} */\n  get element() {\n    return /** @type {Element} */ (this._element);\n  }\n\n  /** @param {Element} el */\n  set element(el) {\n    this._element = el;\n    this._isList = false;\n  }\n\n  /** @returns {Node | ChildNode} */\n  get node() {\n    return /** @type {Node | ChildNode} */ (this._node || this._element);\n  }\n\n  /** @param {Node | ChildNode} node */\n  set node(node) {\n    this._node = node;\n\n    if (node.nodeType === NodeType._ELEMENT_NODE) {\n      this._element = /** @type {Element} */ (node);\n    } else {\n      this._element = undefined;\n    }\n  }\n\n  /** @param {Array<Node>} nodes */\n  set nodes(nodes) {\n    this._nodes = nodes;\n    this._isList = true;\n  }\n\n  /** @returns {Array<Node>} */\n  get nodes() {\n    return this._nodes;\n  }\n\n  /** @returns {NodeList|Node[]} */\n  get nodelist() {\n    if (this._nodes.length === 0) return [];\n\n    if (this._nodes[0].parentElement)\n      return this._nodes[0].parentElement.childNodes;\n    const fragment = document.createDocumentFragment();\n\n    this._nodes.forEach((el) => fragment.appendChild(el));\n\n    return fragment.childNodes;\n  }\n\n  /** @returns {Element | Node | ChildNode | NodeList | Node[]} */\n  get dom() {\n    if (this._isList) return this.nodelist;\n    else return this.node;\n  }\n\n  /** @returns {number} */\n  get size() {\n    return this._isList ? this._nodes.length : 1;\n  }\n\n  /** @returns {Element | Node | ChildNode} */\n  _getAny() {\n    if (this._isList) {\n      return this._nodes[0];\n    } else {\n      return /** @type {Element | Node | ChildNode} */ (\n        this._element || this._node\n      );\n    }\n  }\n\n  /** @returns {Element | Array<Node> | Node | ChildNode} */\n  _getAll() {\n    if (this._isList) {\n      return this._nodes;\n    } else {\n      return /** @type {Element | Node | ChildNode} */ (\n        this._element || this._node\n      );\n    }\n  }\n\n  /** @returns {Array<Element> | Array<Node>} */\n  _collection() {\n    if (this._isList) {\n      return Array.from(this._nodes);\n    } else {\n      return [\n        /** @type {Element | Node | ChildNode} */ (this._element || this._node),\n      ];\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {Element | Node | ChildNode}\n   */\n  _getIndex(index) {\n    if (this._isList) {\n      return this._nodes[index];\n    } else {\n      return this.node;\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @param {Element | Node | ChildNode} node\n   */\n  _setIndex(index, node) {\n    if (this._isList) {\n      this._nodes[index] = node;\n    } else {\n      this.node = node;\n    }\n  }\n\n  /**\n   * @returns {NodeRef}\n   */\n  _clone() {\n    const cloned = this._isList\n      ? this.nodes.map((el) => el.cloneNode(true))\n      : this.node.cloneNode(true);\n\n    return new NodeRef(cloned);\n  }\n\n  _isElement() {\n    return this._element !== undefined;\n  }\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport {\n  assertArgFn,\n  assertNotHasOwnProperty,\n  entries,\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  minErr,\n} from \"../../shared/utils.js\";\n\n/**\n * @typedef {import(\"../../interface.ts\").ControllerConstructor} ControllerConstructor\n * @typedef {import(\"../../interface.ts\").Injectable<ControllerConstructor>} InjectableController\n * @typedef {import(\"./interface.ts\").ControllerService} ControllerService\n * @typedef {import(\"./interface.ts\").ControllerLocals} ControllerLocals\n * @typedef {import(\"./interface.ts\").ControllerExpression} ControllerExpression\n */\n\nconst $controllerMinErr = minErr(\"$controller\");\n\nconst CNTRL_REG = /^(\\S+)(\\s+as\\s+([\\w$]+))?$/;\n\n/**\n * @param {string | InjectableController | undefined} controller\n * @param {string} [ident]\n * @returns {string|undefined}\n */\nexport function identifierForController(controller, ident) {\n  if (ident && isString(ident)) return ident;\n\n  if (isString(controller)) {\n    const match = CNTRL_REG.exec(controller);\n\n    if (match) return match[3];\n  }\n\n  return undefined;\n}\n\n/**\n * @param {unknown} def\n * @param {string} name\n * @returns {InjectableController}\n */\nfunction normalizeControllerDef(def, name) {\n  if (isArray(def)) return /** @type {any} */ (def);\n\n  if (isFunction(def)) return /** @type {any} */ (def);\n\n  throw $controllerMinErr(\n    \"ctrlreg\",\n    \"Controller '{0}' must be a function or an array-annotated injectable.\",\n    name,\n  );\n}\n\n/**\n * Extracts the underlying controller function from an injectable and provides\n * safe access to `name` and `prototype`.\n *\n * @param {InjectableController} injectable\n * @param {string} [argNameForErrors]\n * @returns {{ func: Function, name: string, prototype: any }}\n */\nfunction unwrapController(injectable, argNameForErrors) {\n  const candidate = isArray(injectable)\n    ? injectable[injectable.length - 1]\n    : injectable;\n\n  // Defensive: should always hold if normalized, but keeps TS happy too.\n  assertArgFn(candidate, argNameForErrors || \"controller\", true);\n\n  /** @type {Function} */\n  const func = /** @type {any} */ (candidate);\n\n  return {\n    func,\n    name: func.name || \"\",\n    prototype: func.prototype || null,\n  };\n}\n\nexport class ControllerProvider {\n  constructor() {\n    /** @type {Map<string, InjectableController>} @private */\n    this.controllers = new Map();\n  }\n\n  /** @param {string} name @returns {boolean} */\n  has(name) {\n    return this.controllers.has(name);\n  }\n\n  /**\n   * @param {string | Record<string, unknown>} name\n   * @param {unknown} [constructor]\n   */\n  register(name, constructor) {\n    if (isString(name)) {\n      assertNotHasOwnProperty(name, \"controller\");\n      this.controllers.set(name, normalizeControllerDef(constructor, name));\n\n      return;\n    }\n\n    if (isObject(name)) {\n      entries(name).forEach(([key, value]) => {\n        this.controllers.set(key, normalizeControllerDef(value, key));\n      });\n    }\n  }\n\n  /**\n   * @type {import(\"../../interface.ts\").Injectable<($injector: ng.InjectorService) => ControllerService>}\n   */\n  $get = [\n    $injectTokens._injector,\n\n    /** @param {ng.InjectorService} $injector @returns {ControllerService} */\n    ($injector) => {\n      /** @type {ControllerProvider} */\n      const provider = this;\n\n      return (expression, locals, later, ident) => {\n        /** @type {any} */\n        let instance;\n\n        /** @type {string | undefined} */\n        let constructorName;\n\n        /** @type {string | null} */\n        let identifier = ident && isString(ident) ? ident : null;\n\n        later = later === true;\n\n        if (isString(expression)) {\n          const match = /** @type {string} */ (expression).match(CNTRL_REG);\n\n          if (!match) {\n            throw $controllerMinErr(\n              \"ctrlfmt\",\n              \"Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.\",\n              expression,\n            );\n          }\n\n          constructorName = match[1];\n          identifier = identifier || match[3] || null;\n\n          const lookedUp = provider.controllers.get(constructorName);\n\n          if (!lookedUp) {\n            throw $controllerMinErr(\n              \"ctrlreg\",\n              \"The controller with the name '{0}' is not registered.\",\n              constructorName,\n            );\n          }\n\n          expression = lookedUp;\n          assertArgFn(expression, constructorName, true);\n        }\n\n        /** @type {InjectableController} */\n        const injectable = /** @type {any} */ (expression);\n\n        const meta = unwrapController(injectable, constructorName);\n\n        if (later) {\n          instance = Object.create(meta.prototype || null);\n\n          const exportName = constructorName || meta.name;\n\n          if (identifier) {\n            instance.$controllerIdentifier = identifier;\n            provider.addIdentifier(locals, identifier, instance, exportName);\n          }\n\n          if (instance?.constructor?.$scopename && locals?.$scope) {\n            locals.$scope.$scopename = instance.constructor.$scopename;\n          }\n\n          return () => {\n            const result = $injector.invoke(\n              injectable,\n              instance,\n              locals,\n              constructorName,\n            );\n\n            if (\n              result !== instance &&\n              (isObject(result) || isFunction(result))\n            ) {\n              instance = result;\n\n              if (identifier) {\n                instance.$controllerIdentifier = identifier;\n                provider.addIdentifier(\n                  locals,\n                  identifier,\n                  instance,\n                  exportName,\n                );\n              }\n            }\n\n            return instance;\n          };\n        }\n\n        instance = $injector.instantiate(\n          /** @type {any} */ (injectable),\n          locals,\n          constructorName,\n        );\n\n        if (identifier) {\n          provider.addIdentifier(\n            locals,\n            identifier,\n            instance,\n            constructorName || meta.name,\n          );\n        }\n\n        return instance;\n      };\n    },\n  ];\n\n  /**\n   * @param {ControllerLocals | undefined} locals\n   * @param {string} identifier\n   * @param {object} instance\n   * @param {string} name\n   */\n  addIdentifier(locals, identifier, instance, name) {\n    if (!(locals && isObject(locals.$scope))) {\n      throw minErr(\"$controller\")(\n        \"noscp\",\n        \"Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.\",\n        name,\n        identifier,\n      );\n    }\n    locals.$scope[identifier] = instance;\n    locals.$scope.$controllerIdentifier = identifier;\n  }\n}\n","import {\n  urlIsSameOrigin,\n  urlIsSameOriginAsBaseUrl,\n  urlResolve,\n} from \"../../shared/url-utils/url-utils.js\";\nimport {\n  entries,\n  hasOwn,\n  isDefined,\n  isFunction,\n  isRegExp,\n  isString,\n  isUndefined,\n  minErr,\n  shallowCopy,\n} from \"../../shared/utils.js\";\n\nimport { snakeToCamel } from \"../../shared/dom.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n\nconst $sceMinErr = minErr(\"$sce\");\n\nexport const SCE_CONTEXTS = {\n  // HTML is used when there's HTML rendered (e.g. ng-bind-html, iframe srcdoc binding).\n  HTML: \"html\",\n\n  // Style statements or stylesheets. Currently unused in AngularTS.\n  CSS: \"css\",\n\n  // An URL used in a context where it refers to the source of media, which are not expected to be run\n  // as scripts, such as an image, audio, video, etc.\n  MEDIA_URL: \"mediaUrl\",\n\n  // An URL used in a context where it does not refer to a resource that loads code.\n  // A value that can be trusted as a URL can also trusted as a MEDIA_URL.\n  URL: \"url\",\n\n  // RESOURCE_URL is a subtype of URL used where the referred-to resource could be interpreted as\n  // code. (e.g. ng-include, script src binding, templateUrl)\n  // A value that can be trusted as a RESOURCE_URL, can also trusted as a URL and a MEDIA_URL.\n  RESOURCE_URL: \"resourceUrl\",\n};\n\n// Copied from:\n// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021\n// Prereq: s is a string.\n/**\n * @param {string} str\n */\nexport function escapeForRegexp(str) {\n  return str.replace(/([-()[\\]{}+?*.$^|,:#<!\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Adjusts a matcher string or RegExp into a proper RegExp.\n *\n * @param {string | RegExp | \"self\"} matcher\n * @returns {RegExp | \"self\"}\n */\nexport function adjustMatcher(matcher) {\n  if (matcher === \"self\") {\n    return matcher;\n  }\n\n  if (isString(matcher)) {\n    // Strings match exactly except for 2 wildcards - '*' and '**'.\n    // '*' matches any character except those from the set ':/.?&'.\n    // '**' matches any character (like .* in a RegExp).\n    // More than 2 *'s raises an error as it's ill defined.\n    if (matcher.indexOf(\"***\") > -1) {\n      throw $sceMinErr(\n        \"iwcard\",\n        \"Illegal sequence *** in string matcher.  String: {0}\",\n        matcher,\n      );\n    }\n    matcher = escapeForRegexp(matcher)\n      .replace(/\\\\\\*\\\\\\*/g, \".*\")\n      .replace(/\\\\\\*/g, \"[^:/.?&;]*\");\n\n    return new RegExp(`^${matcher}$`);\n  }\n\n  if (isRegExp(matcher)) {\n    // The only other type of matcher allowed is a Regexp.\n    // Match entire URL / disallow partial matches.\n    // Flags are reset (i.e. no global, ignoreCase or multiline)\n    return new RegExp(`^${matcher.source}$`);\n  }\n  throw $sceMinErr(\n    \"imatcher\",\n    'Matchers may only be \"self\", string patterns or RegExp objects',\n  );\n}\n\n/**\n * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict\n * Contextual Escaping (SCE)} services to AngularTS.\n *\n * For an overview of this service and the functionality it provides in AngularTS, see the main\n * page for {@link ng.$sce SCE}. The current page is targeted for developers who need to alter how\n * SCE works in their application, which shouldn't be needed in most cases.\n *\n * <div class=\"alert alert-danger\">\n * AngularTS strongly relies on contextual escaping for the security of bindings: disabling or\n * modifying this might cause cross site scripting (XSS) vulnerabilities. For libraries owners,\n * changes to this service will also influence users, so be extra careful and document your changes.\n * </div>\n *\n * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of\n * the `$sce` service to customize the way Strict Contextual Escaping works in AngularTS.  This is\n * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to\n * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things\n * work because `$sce` delegates to `$sceDelegate` for these operations.\n *\n * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.\n *\n * The default instance of `$sceDelegate` should work out of the box with little pain.  While you\n * can override it completely to change the behavior of `$sce`, the common case would\n * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting\n * your own trusted and banned resource lists for trusting URLs used for loading AngularTS resources\n * such as templates.  Refer {@link ng.$sceDelegateProvider#trustedResourceUrlList\n * $sceDelegateProvider.trustedResourceUrlList} and {@link\n * ng.$sceDelegateProvider#bannedResourceUrlList $sceDelegateProvider.bannedResourceUrlList}\n */\n\n/**\n *\n * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate\n * $sceDelegate service}, used as a delegate for {@link ng.$sce Strict Contextual Escaping (SCE)}.\n *\n * The `$sceDelegateProvider` allows one to get/set the `trustedResourceUrlList` and\n * `bannedResourceUrlList` used to ensure that the URLs used for sourcing AngularTS templates and\n * other script-running URLs are safe (all places that use the `$sce.RESOURCE_URL` context). See\n * {@link ng.$sceDelegateProvider#trustedResourceUrlList\n * $sceDelegateProvider.trustedResourceUrlList} and\n * {@link ng.$sceDelegateProvider#bannedResourceUrlList $sceDelegateProvider.bannedResourceUrlList},\n *\n * For the general details about this service in AngularTS, read the main page for {@link ng.$sce\n * Strict Contextual Escaping (SCE)}.\n *\n * **Example**:  Consider the following case. <a name=\"example\"></a>\n *\n * - your app is hosted at url `http://myapp.example.com/`\n * - but some of your templates are hosted on other domains you control such as\n *   `http://srv01.assets.example.com/`, `http://srv02.assets.example.com/`, etc.\n * - and you have an open redirect at `http://myapp.example.com/clickThru?...`.\n *\n * Here is what a secure configuration for this scenario might look like:\n *\n * ```\n *  angular.module('myApp', []).config(function($sceDelegateProvider) {\n *    $sceDelegateProvider.trustedResourceUrlList([\n *      // Allow same origin resource loads.\n *      'self',\n *      // Allow loading from our assets domain.  Notice the difference between * and **.\n *      'http://srv*.assets.example.com/**'\n *    ]);\n *\n *    // The banned resource URL list overrides the trusted resource URL list so the open redirect\n *    // here is blocked.\n *    $sceDelegateProvider.bannedResourceUrlList([\n *      'http://myapp.example.com/clickThru**'\n *    ]);\n *  });\n * ```\n * Note that an empty trusted resource URL list will block every resource URL from being loaded, and will require\n * you to manually mark each one as trusted with `$sce.trustAsResourceUrl`. However, templates\n * requested by {@link ng.$templateRequest $templateRequest} that are present in\n * {@link ng.$templateCache $templateCache} will not go through this check. If you have a mechanism\n * to populate your templates in that cache at config time, then it is a good idea to remove 'self'\n * from the trusted resource URL lsit. This helps to mitigate the security impact of certain types\n * of issues, like for instance attacker-controlled `ng-includes`.\n */\nexport class SceDelegateProvider {\n  constructor() {\n    // Resource URLs can also be trusted by policy.\n    /** @type {Array<RegExp | \"self\">} */\n    let trustedResourceUrlList = [\"self\"];\n\n    /** @type {Array<RegExp | \"self\">} */\n    let bannedResourceUrlList = [];\n\n    /**\n     *\n     * @param {(Array<RegExp | \"self\"> | null)=} value When provided, replaces the trustedResourceUrlList with\n     *     the value provided.  This must be an array or null.  A snapshot of this array is used so\n     *     further changes to the array are ignored.\n     *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items\n     *     allowed in this array.\n     *\n     * @return {Array<RegExp | \"self\">} The currently set trusted resource URL array.\n     *\n     *\n     * Sets/Gets the list trusted of resource URLs.\n     *\n     * The **default value** when no `trustedResourceUrlList` has been explicitly set is `['self']`\n     * allowing only same origin resource requests.\n     *\n     * <div class=\"alert alert-warning\">\n     * **Note:** the default `trustedResourceUrlList` of 'self' is not recommended if your app shares\n     * its origin with other apps! It is a good idea to limit it to only your application's directory.\n     * </div>\n     */\n    this.trustedResourceUrlList = function (value) {\n      if (arguments.length) {\n        const list = value || [];\n\n        trustedResourceUrlList = list.map(adjustMatcher);\n      }\n\n      return trustedResourceUrlList;\n    };\n\n    /**\n     *\n     * @param {(Array<RegExp | \"self\"> | null)=} value When provided, replaces the `bannedResourceUrlList` with\n     *     the value provided. This must be an array or null. A snapshot of this array is used so\n     *     further changes to the array are ignored.</p><p>\n     *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items\n     *     allowed in this array.</p><p>\n     *     The typical usage for the `bannedResourceUrlList` is to **block\n     *     [open redirects](http://cwe.mitre.org/data/definitions/601.html)** served by your domain as\n     *     these would otherwise be trusted but actually return content from the redirected domain.\n     *     </p><p>\n     *     Finally, **the banned resource URL list overrides the trusted resource URL list** and has\n     *     the final say.\n     *\n     * @return {Array<RegExp | \"self\">} The currently set `bannedResourceUrlList` array.\n     *\n     *\n     * Sets/Gets the `bannedResourceUrlList` of trusted resource URLs.\n     *\n     * The **default value** when no trusted resource URL list has been explicitly set is the empty\n     * array (i.e. there is no `bannedResourceUrlList`.)\n     */\n    this.bannedResourceUrlList = function (value) {\n      if (arguments.length) {\n        const list = value || [];\n\n        bannedResourceUrlList = list.map(adjustMatcher);\n      }\n\n      return bannedResourceUrlList;\n    };\n\n    this.$get = [\n      $t._injector,\n      $t._sanitizeUri,\n      $t._exceptionHandler,\n      /**\n       *\n       * @param {ng.InjectorService} $injector\n       * @param {import(\"../../core/sanitize/interface.ts\").SanitizerFn} $$sanitizeUri\n       * @param {ng.ExceptionHandlerService} $exceptionHandler\n       * @returns\n       */\n      function ($injector, $$sanitizeUri, $exceptionHandler) {\n        let htmlSanitizer = function () {\n          $exceptionHandler(\n            $sceMinErr(\n              \"unsafe\",\n              \"Attempting to use an unsafe value in a safe context.\",\n            ),\n          );\n        };\n\n        if ($injector.has(\"$sanitize\")) {\n          htmlSanitizer = $injector.get(\"$sanitize\");\n        }\n\n        /**\n         * @param {string|RegExp} matcher\n         * @param {import(\"../../shared/url-utils/interface.ts\").ParsedUrl} parsedUrl\n         * @return {boolean}\n         */\n        function matchUrl(matcher, parsedUrl) {\n          if (matcher === \"self\") {\n            return (\n              urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl)\n            );\n          }\n\n          // definitely a regex.  See adjustMatchers()\n          return !!(/** @type {RegExp} */ (matcher).exec(parsedUrl.href));\n        }\n\n        /**\n         * @param {string | Object} url\n         * @returns {boolean}\n         */\n        function isResourceUrlAllowedByPolicy(url) {\n          const parsedUrl = urlResolve(url.toString());\n\n          let i,\n            j,\n            allowed = false;\n\n          // Ensure that at least one item from the trusted resource URL list allows this url.\n          for (i = 0, j = trustedResourceUrlList.length; i < j; i++) {\n            if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {\n              allowed = true;\n              break;\n            }\n          }\n\n          if (allowed) {\n            // Ensure that no item from the banned resource URL list has blocked this url.\n            for (i = 0, j = bannedResourceUrlList.length; i < j; i++) {\n              if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {\n                allowed = false;\n                break;\n              }\n            }\n          }\n\n          return allowed;\n        }\n\n        /**\n         * @param {new (...args: any[]) => any=} Base\n         * @return {new (trustedValue: string) => { _unwrapTrustedValue(): string }}\n         */\n        function generateHolderType(Base) {\n          /** @param {string} trustedValue */\n          const holderType = function TrustedValueHolderType(trustedValue) {\n            this._unwrapTrustedValue = function () {\n              return trustedValue;\n            };\n          };\n\n          if (Base) {\n            holderType.prototype = new Base();\n          }\n          holderType.prototype.valueOf = function sceValueOf() {\n            return this._unwrapTrustedValue();\n          };\n          holderType.prototype.toString = function sceToString() {\n            return this._unwrapTrustedValue().toString();\n          };\n\n          return holderType;\n        }\n\n        const trustedValueHolderBase = generateHolderType();\n\n        /** @type {Record<string, new (trustedValue: string) => { _unwrapTrustedValue(): string }>} */\n        const byType = {};\n\n        byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);\n        byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);\n        byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(\n          trustedValueHolderBase,\n        );\n        byType[SCE_CONTEXTS.URL] = generateHolderType(\n          byType[SCE_CONTEXTS.MEDIA_URL],\n        );\n        byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(\n          byType[SCE_CONTEXTS.URL],\n        );\n\n        /**\n         * Returns a trusted representation of the parameter for the specified context. This trusted\n         * object will later on be used as-is, without any security check, by bindings or directives\n         * that require this security context.\n         * For instance, marking a string as trusted for the `$sce.HTML` context will entirely bypass\n         * the potential `$sanitize` call in corresponding `$sce.HTML` bindings or directives, such as\n         * `ng-bind-html`. Note that in most cases you won't need to call this function: if you have the\n         * sanitizer loaded, passing the value itself will render all the HTML that does not pose a\n         * security risk.\n         *\n         * See {@link ng.$sceDelegate#getTrusted getTrusted} for the function that will consume those\n         * trusted values, and {@link ng.$sce $sce} for general documentation about strict contextual\n         * escaping.\n         *\n         * @param {string} type The context in which this value is safe for use, e.g. `$sce.URL`,\n         *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.\n         *\n         * @param {*} trustedValue The value that should be considered trusted.\n         * @return {*} A trusted representation of value, that can be used in the given context.\n         */\n        function trustAs(type, trustedValue) {\n          const Constructor =\n            isDefined(type) && hasOwn(byType, type) ? byType[type] : null;\n\n          if (!Constructor) {\n            $exceptionHandler(\n              $sceMinErr(\n                \"icontext\",\n                \"Attempted to trust a value in invalid context. Context: {0}; Value: {1}\",\n                type,\n                trustedValue,\n              ),\n            );\n\n            return undefined;\n          }\n\n          if (\n            trustedValue === null ||\n            isUndefined(trustedValue) ||\n            trustedValue === \"\"\n          ) {\n            return trustedValue;\n          }\n\n          // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting\n          // mutable objects, we ensure here that the value passed in is actually a string.\n          if (typeof trustedValue !== \"string\") {\n            $exceptionHandler(\n              $sceMinErr(\n                \"itype\",\n                \"Attempted to trust a non-string value in a content requiring a string: Context: {0}\",\n                type,\n              ),\n            );\n\n            return undefined;\n          }\n\n          const tst = new Constructor(trustedValue);\n\n          return tst;\n        }\n\n        /**\n         * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs\n         * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link\n         * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.\n         *\n         * If the passed parameter is not a value that had been returned by {@link\n         * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, it must be returned as-is.\n         *\n         * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}\n         *     call or anything else.\n         * @return {*} The `value` that was originally provided to {@link ng.$sceDelegate#trustAs\n         *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns\n         *     `value` unchanged.\n         */\n        function valueOf(maybeTrusted) {\n          if (maybeTrusted instanceof trustedValueHolderBase) {\n            return maybeTrusted._unwrapTrustedValue();\n          }\n\n          return maybeTrusted;\n        }\n\n        /**\n         *\n         * Given an object and a security context in which to assign it, returns a value that's safe to\n         * use in this context, which was represented by the parameter. To do so, this function either\n         * unwraps the safe type it has been given (for instance, a {@link ng.$sceDelegate#trustAs\n         * `$sceDelegate.trustAs`} result), or it might try to sanitize the value given, depending on\n         * the context and sanitizer availablility.\n         *\n         * The contexts that can be sanitized are $sce.MEDIA_URL, $sce.URL and $sce.HTML. The first two are available\n         * by default, and the third one relies on the `$sanitize` service (which may be loaded through\n         * the `ngSanitize` module). Furthermore, for $sce.RESOURCE_URL context, a plain string may be\n         * accepted if the resource url policy defined by {@link ng.$sceDelegateProvider#trustedResourceUrlList\n         * `$sceDelegateProvider.trustedResourceUrlList`} and {@link ng.$sceDelegateProvider#bannedResourceUrlList\n         * `$sceDelegateProvider.bannedResourceUrlList`} accepts that resource.\n         *\n         * This function will throw if the safe type isn't appropriate for this context, or if the\n         * value given cannot be accepted in the context (which might be caused by sanitization not\n         * being available, or the value not being recognized as safe).\n         *\n         * <div class=\"alert alert-danger\">\n         * Disabling auto-escaping is extremely dangerous, it usually creates a Cross Site Scripting\n         * (XSS) vulnerability in your application.\n         * </div>\n         *\n         * @param {string} type The context in which this value is to be used (such as `$sce.HTML`).\n         * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs\n         *     `$sceDelegate.trustAs`} call, or anything else (which will not be considered trusted.)\n         * @return {*} A version of the value that's safe to use in the given context, or throws an\n         *     exception if this is impossible.\n         */\n        function getTrusted(type, maybeTrusted) {\n          if (\n            maybeTrusted === null ||\n            isUndefined(maybeTrusted) ||\n            maybeTrusted === \"\"\n          ) {\n            return maybeTrusted;\n          }\n          const constructor = hasOwn(byType, type) ? byType[type] : null;\n\n          // If maybeTrusted is a trusted class instance or subclass instance, then unwrap and return\n          // as-is.\n          if (constructor && maybeTrusted instanceof constructor) {\n            return maybeTrusted._unwrapTrustedValue();\n          }\n\n          // If maybeTrusted is a trusted class instance but not of the correct trusted type\n          // then unwrap it and allow it to pass through to the rest of the checks\n          if (isFunction(maybeTrusted._unwrapTrustedValue)) {\n            maybeTrusted = maybeTrusted._unwrapTrustedValue();\n          }\n\n          // If we get here, then we will either sanitize the value or throw an exception.\n          if (type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) {\n            // we attempt to sanitize non-resource URLs\n            return $$sanitizeUri(\n              maybeTrusted.toString(),\n              type === SCE_CONTEXTS.MEDIA_URL,\n            );\n          }\n\n          if (type === SCE_CONTEXTS.RESOURCE_URL) {\n            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {\n              return maybeTrusted;\n            }\n            $exceptionHandler(\n              $sceMinErr(\n                \"insecurl\",\n                \"Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}\",\n                maybeTrusted.toString(),\n              ),\n            );\n\n            return undefined;\n          } else if (type === SCE_CONTEXTS.HTML) {\n            // htmlSanitizer throws its own error when no sanitizer is available.\n            return htmlSanitizer();\n          }\n\n          // Default error when the $sce service has no way to make the input safe.\n          return $exceptionHandler(\n            $sceMinErr(\n              \"unsafe\",\n              \"Attempting to use an unsafe value in a safe context.\",\n            ),\n          );\n        }\n\n        return { trustAs, getTrusted, valueOf };\n      },\n    ];\n  }\n}\n\nexport function SceProvider() {\n  let enabled = true;\n\n  /**\n   * @param {boolean=} value If provided, then enables/disables SCE application-wide.\n   * @return {boolean} True if SCE is enabled, false otherwise.\n   *\n   *\n   * Enables/disables SCE and returns the current value.\n   */\n  this.enabled = function (value) {\n    if (arguments.length) {\n      enabled = !!value;\n    }\n\n    return enabled;\n  };\n\n  this.$get = [\n    $t._parse,\n    $t._sceDelegate,\n    /**\n     *\n     * @param {ng.ParseService} $parse\n     * @param {ng.SceDelegateService} $sceDelegate\n     * @return {ng.SceService}\n     */\n    ($parse, $sceDelegate) => {\n      const sce = /** @type {ng.SceService & Record<string, any>} */ (\n        shallowCopy(SCE_CONTEXTS)\n      );\n\n      /**\n       * @return {Boolean} True if SCE is enabled, false otherwise.  If you want to set the value, you\n       *     have to do it at module config time on {@link ng.$sceProvider $sceProvider}.\n       *\n       *\n       * Returns a boolean indicating if SCE is enabled.\n       */\n      sce.isEnabled = function () {\n        return enabled;\n      };\n      sce.trustAs = $sceDelegate.trustAs;\n      sce.getTrusted = $sceDelegate.getTrusted;\n      sce.valueOf = $sceDelegate.valueOf;\n\n      if (!enabled) {\n        /**\n         * @param {string} type\n         * @param {*} value\n         */\n        sce.trustAs = sce.getTrusted = function (type, value) {\n          return value;\n        };\n        /** @param {*} v */\n        sce.valueOf = (v) => v;\n      }\n\n      /**\n       * Converts AngularTS {@link guide/expression expression} into a function.  This is like {@link\n       * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it\n       * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,\n       * *result*)}\n       *\n       * @param {string} type The SCE context in which this result will be used.\n       * @param {string} expr String expression to compile.\n       * @return {import(\"../../core/parse/interface.ts\").CompiledExpression} A function which represents the compiled expression:\n       *\n       *    * `context`  `{object}`  an object against which any expressions embedded in the\n       *      strings are evaluated against (typically a scope object).\n       *    * `locals`  `{object=}`  local variables context object, useful for overriding values\n       *      in `context`.\n       */\n      sce.parseAs = (type, expr) => {\n        const parsed = $parse(expr);\n\n        if (parsed._literal && parsed.constant) {\n          return parsed;\n        }\n\n        return $parse(expr, (value) => sce.getTrusted(type, value));\n      };\n\n      /**\n       * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}. As such, returns a\n       * wrapped object that represents your value, and the trust you have in its safety for the given\n       * context. AngularTS can then use that value as-is in bindings of the specified secure context.\n       * This is used in bindings for `ng-bind-html`, `ng-include`, and most `src` attribute\n       * interpolations. See {@link ng.$sce $sce} for strict contextual escaping.\n       *\n       * @param {string} type The context in which this value is safe for use, e.g. `$sce.URL`,\n       *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.\n       *\n       * @param {*} value The value that that should be considered trusted.\n       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`\n       *     in the context you specified.\n       */\n\n      /**\n       * Shorthand method.  `$sce.trustAsHtml(value)` \n       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}\n       *\n       * @param {*} value The value to mark as trusted for `$sce.HTML` context.\n       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`\n       *     in `$sce.HTML` context (like `ng-bind-html`).\n       */\n\n      /**\n       * Shorthand method.  `$sce.trustAsCss(value)` \n       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.CSS, value)`}\n       *\n       * @param {*} value The value to mark as trusted for `$sce.CSS` context.\n       * @return {*} A wrapped version of value that can be used as a trusted variant\n       *     of your `value` in `$sce.CSS` context. This context is currently unused, so there are\n       *     almost no reasons to use this function so far.\n       */\n\n      /**\n       * Shorthand method.  `$sce.trustAsUrl(value)` \n       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}\n       *\n       * @param {*} value The value to mark as trusted for `$sce.URL` context.\n       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`\n       *     in `$sce.URL` context. That context is currently unused, so there are almost no reasons\n       *     to use this function so far.\n       */\n\n      /**\n       * Shorthand method.  `$sce.trustAsResourceUrl(value)` \n       *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}\n       *\n       * @param {*} value The value to mark as trusted for `$sce.RESOURCE_URL` context.\n       * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`\n       *     in `$sce.RESOURCE_URL` context (template URLs in `ng-include`, most `src` attribute\n       *     bindings, ...)\n       */\n\n      /**\n       * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,\n       * takes any input, and either returns a value that's safe to use in the specified context,\n       * or throws an exception. This function is aware of trusted values created by the `trustAs`\n       * function and its shorthands, and when contexts are appropriate, returns the unwrapped value\n       * as-is. Finally, this function can also throw when there is no way to turn `maybeTrusted` in a\n       * safe value (e.g., no sanitization is available or possible.)\n       *\n       * @param {string} type The context in which this value is to be used.\n       * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs\n       *     `$sce.trustAs`} call, or anything else (which will not be considered trusted.)\n       * @return {*} A version of the value that's safe to use in the given context, or throws an\n       *     exception if this is impossible.\n       */\n\n      /**\n       * Shorthand method.  `$sce.getTrustedHtml(value)` \n       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}\n       *\n       * @param {*} value The value to pass to `$sce.getTrusted`.\n       * @return {*} The return value of `$sce.getTrusted($sce.HTML, value)`\n       */\n\n      /**\n       * Shorthand method.  `$sce.getTrustedCss(value)` \n       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}\n       *\n       * @param {*} value The value to pass to `$sce.getTrusted`.\n       * @return {*} The return value of `$sce.getTrusted($sce.CSS, value)`\n       */\n\n      /**\n       * Shorthand method.  `$sce.getTrustedUrl(value)` \n       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}\n       *\n       * @param {*} value The value to pass to `$sce.getTrusted`.\n       * @return {*} The return value of `$sce.getTrusted($sce.URL, value)`\n       */\n\n      /**\n       * Shorthand method.  `$sce.getTrustedResourceUrl(value)` \n       *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}\n       *\n       * @param {*} value The value to pass to `$sceDelegate.getTrusted`.\n       * @return {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`\n       */\n\n      /**\n       * Shorthand method.  `$sce.parseAsHtml(expression string)` \n       *     {@link ng.$sceparseAs `$sce.parseAs($sce.HTML, value)`}\n       *\n       * @param {string} expression String expression to compile.\n       * @return {function(context, locals)} A function which represents the compiled expression:\n       *\n       *    * `context`  `{object}`  an object against which any expressions embedded in the\n       *      strings are evaluated against (typically a scope object).\n       *    * `locals`  `{object=}`  local variables context object, useful for overriding values\n       *      in `context`.\n       */\n\n      /**\n       * Shorthand method.  `$sce.parseAsCss(value)` \n       *     {@link ng.$sceparseAs `$sce.parseAs($sce.CSS, value)`}\n       *\n       * @param {string} expression String expression to compile.\n       * @return {function(context, locals)} A function which represents the compiled expression:\n       *\n       *    * `context`  `{object}`  an object against which any expressions embedded in the\n       *      strings are evaluated against (typically a scope object).\n       *    * `locals`  `{object=}`  local variables context object, useful for overriding values\n       *      in `context`.\n       */\n\n      /**\n       * Shorthand method.  `$sce.parseAsUrl(value)` \n       *     {@link ng.$sceparseAs `$sce.parseAs($sce.URL, value)`}\n       *\n       * @param {string} expression String expression to compile.\n       * @return {function(context, locals)} A function which represents the compiled expression:\n       *\n       *    * `context`  `{object}`  an object against which any expressions embedded in the\n       *      strings are evaluated against (typically a scope object).\n       *    * `locals`  `{object=}`  local variables context object, useful for overriding values\n       *      in `context`.\n       */\n\n      /**\n       * Shorthand method.  `$sce.parseAsResourceUrl(value)` \n       *     {@link ng.$sceparseAs `$sce.parseAs($sce.RESOURCE_URL, value)`}\n       *\n       * @param {string} expression String expression to compile.\n       * @return {function(context, locals)} A function which represents the compiled expression:\n       *\n       *    * `context`  `{object}`  an object against which any expressions embedded in the\n       *      strings are evaluated against (typically a scope object).\n       *    * `locals`  `{object=}`  local variables context object, useful for overriding values\n       *      in `context`.\n       */\n\n      /**\n       * Shorthand method.  `$sce.parseAsJs(value)` \n       *     {@link ng.$sceparseAs `$sce.parseAs($sce.JS, value)`}\n       *\n       * @param {string} expression String expression to compile.\n       * @return {function(context, locals)} A function which represents the compiled expression:\n       *\n       *    * `context`  `{object}`  an object against which any expressions embedded in the\n       *      strings are evaluated against (typically a scope object).\n       *    * `locals`  `{object=}`  local variables context object, useful for overriding values\n       *      in `context`.\n       */\n\n      // Shorthand delegations.\n      const parse = sce.parseAs;\n\n      const { getTrusted } = sce;\n\n      const { trustAs } = sce;\n\n      entries(SCE_CONTEXTS).forEach(([name, enumValue]) => {\n        const lName = name.toLowerCase();\n\n        /** @param {string} expr */\n        sce[snakeToCamel(`parse_as_${lName}`)] = function (expr) {\n          return parse(enumValue, expr);\n        };\n        /** @param {*} value */\n        sce[snakeToCamel(`get_trusted_${lName}`)] = function (value) {\n          return getTrusted(enumValue, value);\n        };\n        /** @param {*} value */\n        sce[snakeToCamel(`trust_as_${lName}`)] = function (value) {\n          return trustAs(enumValue, value);\n        };\n      });\n\n      return /** @type {ng.SceService} */ (sce);\n    },\n  ];\n}\n","import { directiveNormalize } from \"../../shared/utils.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n/*\n * A collection of directives that allows creation of custom event handlers that are defined as\n * AngularTS expressions and are compiled and executed within the current scope.\n */\n\n/**\n * @type {Record<string, ng.Injectable<any>>}\n */\nexport const ngEventDirectives = {};\n\n\"click copy cut dblclick focus blur keydown keyup load mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup paste submit touchstart touchend touchmove\"\n  .split(\" \")\n  .forEach((eventName) => {\n    const directiveName = directiveNormalize(`ng-${eventName}`);\n\n    ngEventDirectives[directiveName] = [\n      $t._parse,\n      $t._exceptionHandler,\n\n      /**\n       * @param {ng.ParseService} $parse\n       * @param {ng.ExceptionHandlerService} $exceptionHandler\n       * @returns\n       */\n      ($parse, $exceptionHandler) => {\n        return createEventDirective(\n          $parse,\n          $exceptionHandler,\n          directiveName,\n          eventName,\n        );\n      },\n    ];\n  });\n\n/**\n *\n * @param {ng.ParseService} $parse\n * @param {ng.ExceptionHandlerService} $exceptionHandler\n * @param {string} directiveName\n * @param {string} eventName\n * @returns {ng.Directive}\n */\nexport function createEventDirective(\n  $parse,\n  $exceptionHandler,\n  directiveName,\n  eventName,\n) {\n  return {\n    restrict: \"A\",\n    compile(_element, attr) {\n      const fn = $parse(attr[directiveName]);\n\n      return (scope, element) => {\n        /**\n         * @param {Event} event\n         */\n        const handler = (event) => {\n          try {\n            fn(scope, { $event: event });\n          } catch (error) {\n            $exceptionHandler(error);\n          }\n        };\n\n        element.addEventListener(eventName, handler);\n\n        scope.$on(\"$destroy\", () =>\n          element.removeEventListener(eventName, handler),\n        );\n      };\n    },\n  };\n}\n\n/**\n *\n * @param {ng.ParseService} $parse\n * @param {ng.ExceptionHandlerService} $exceptionHandler\n * @param {ng.WindowService} $window\n * @param {string} directiveName\n * @param {string} eventName\n * @returns {ng.Directive}\n */\nexport function createWindowEventDirective(\n  $parse,\n  $exceptionHandler,\n  $window,\n  directiveName,\n  eventName,\n) {\n  return {\n    restrict: \"A\",\n    compile(_element, attr) {\n      const fn = $parse(attr[directiveName]);\n\n      return (scope) => {\n        /**\n         * @param {Event} event\n         */\n        const handler = (event) => {\n          try {\n            fn(scope, { $event: event });\n          } catch (error) {\n            $exceptionHandler(error);\n          }\n        };\n\n        $window.addEventListener(eventName, handler);\n\n        scope.$on(\"$destroy\", () =>\n          $window.removeEventListener(eventName, handler),\n        );\n      };\n    },\n  };\n}\n","import { getBooleanAttrName } from \"../../shared/dom.js\";\nimport {\n  arrayRemove,\n  directiveNormalize,\n  hasAnimate,\n  hasOwn,\n  isNullOrUndefined,\n  isString,\n  isUndefined,\n  minErr,\n  nullObject,\n  snakeCase,\n  trim,\n} from \"../../shared/utils.js\";\nimport { ALIASED_ATTR } from \"../../shared/constants.js\";\n\nconst $compileMinErr = minErr(\"$compile\");\n\nconst SIMPLE_ATTR_NAME = /^\\w/;\n\nconst specialAttrHolder = document.createElement(\"div\");\n\nexport class Attributes {\n  static $nonscope = true;\n\n  /**\n   * Creates an Attributes instance.\n   *\n   * There are two construction modes:\n   *\n   * 1. **Fresh instance** (no `attributesToCopy`):\n   *    - Used when compiling a DOM element for the first time.\n   *    - Initializes a new `$attr` map to track normalized  DOM attribute names.\n   *\n   * 2. **Clone instance** (`attributesToCopy` provided):\n   *    - Used when cloning attributes for directive linking / child scopes.\n   *    - Performs a shallow copy of all properties from the source Attributes object,\n   *      including `$attr`, normalized attribute values, and internal fields\n   *      (e.g. `_observers`).\n   *    - `$attr` is intentionally **not reinitialized** in this case, because the\n   *      source object already contains the correct normalized  DOM attribute mapping.\n   *\n   * @param {ng.AnimateService} $animate\n   * @param {ng.ExceptionHandlerService} $exceptionHandler\n   * @param {ng.SceService} $sce\n   * @param {import(\"../../shared/noderef.js\").NodeRef} [nodeRef]\n   * @param {Object & Record<string, any>} [attributesToCopy]\n   */\n  constructor($animate, $exceptionHandler, $sce, nodeRef, attributesToCopy) {\n    /** @type {ng.AnimateService} */\n    this._animate = $animate;\n\n    /** @type {ng.ExceptionHandlerService} */\n    this._exceptionHandler = $exceptionHandler;\n\n    /** @type {ng.SceService} */\n    this._sce = $sce;\n    /**\n     * A map of DOM element attribute names to the normalized name. This is needed\n     * to do reverse lookup from normalized name back to actual name.\n     * @type {Record<string, string>}\n     */\n    this.$attr = {};\n\n    if (attributesToCopy) {\n      const keys = Object.keys(attributesToCopy);\n\n      /** @type {Record<string, any>} */\n      const that = this;\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n\n        that[key] = attributesToCopy[key];\n      }\n    }\n\n    /** @type {import(\"../../shared/noderef.js\").NodeRef | undefined} */\n    this._nodeRef = nodeRef;\n  }\n\n  /** @ignore @returns {Node|Element} */\n  _element() {\n    return /** @type {Node|Element} */ (this._nodeRef?._getAny());\n  }\n\n  /**\n   * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or\n   * `data-`) to its normalized, camelCase form.\n   *\n   * Also there is special case for Moz prefix starting with upper case letter.\n   *\n   * For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}\n   *\n   * @param {string} name Name to normalize\n   */\n  $normalize = directiveNormalize;\n\n  /**\n   * Adds the CSS class value specified by the classVal parameter to the element. If animations\n   * are enabled then an animation will be triggered for the class addition.\n   *\n   * @param {string} classVal The className value that will be added to the element\n   */\n  $addClass(classVal) {\n    if (classVal && classVal.length > 0) {\n      if (hasAnimate(this._element())) {\n        this._animate.addClass(\n          /** @type {Element} */ (this._element()),\n          classVal,\n        );\n      } else {\n        this._nodeRef?.element.classList.add(classVal);\n      }\n    }\n  }\n\n  /**\n   * Removes the CSS class value specified by the classVal parameter from the element. If\n   * animations are enabled then an animation will be triggered for the class removal.\n   *\n   * @param {string} classVal The className value that will be removed from the element\n   */\n  $removeClass(classVal) {\n    if (classVal && classVal.length > 0) {\n      if (hasAnimate(this._element())) {\n        this._animate.removeClass(\n          /** @type {Element} */ (this._element()),\n          classVal,\n        );\n      } else {\n        this._nodeRef?.element.classList.remove(classVal);\n      }\n    }\n  }\n\n  /**\n   * Adds and removes the appropriate CSS class values to the element based on the difference\n   * between the new and old CSS class values (specified as newClasses and oldClasses).\n   *\n   * @param {string} newClasses The current CSS className value\n   * @param {string} oldClasses The former CSS className value\n   */\n  $updateClass(newClasses, oldClasses) {\n    const toAdd = tokenDifference(newClasses, oldClasses);\n\n    if (toAdd && toAdd.length) {\n      if (hasAnimate(this._element())) {\n        this._animate.addClass(/** @type {Element }*/ (this._element()), toAdd);\n      } else {\n        this._nodeRef?.element.classList.add(...toAdd.trim().split(/\\s+/));\n      }\n    }\n    const toRemove = tokenDifference(oldClasses, newClasses);\n\n    if (toRemove && toRemove.length) {\n      if (hasAnimate(this._element())) {\n        this._animate.removeClass(\n          /** @type {Element} */ (this._element()),\n          toRemove,\n        );\n      } else {\n        this._nodeRef?.element.classList.remove(\n          ...toRemove.trim().split(/\\s+/),\n        );\n      }\n    }\n  }\n\n  /**\n   * Set a normalized attribute on the element in a way such that all directives\n   * can share the attribute. This function properly handles boolean attributes.\n   * @param {string} key Normalized key. (ie ngAttribute)\n   * @param {string|boolean|null} value The value to set. If `null` attribute will be deleted.\n   * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.\n   *     Defaults to true.\n   * @param {string=} attrName Optional none normalized name. Defaults to key.\n   */\n  $set(key, value, writeAttr, attrName) {\n    const node = this._element();\n\n    const booleanKey = getBooleanAttrName(/** @type {Element}   */ (node), key);\n\n    const aliasedKey = ALIASED_ATTR[key];\n\n    let observer = key;\n\n    if (booleanKey) {\n      /** @type {Record<string, any>} */ (this._element())[key] = value;\n      attrName = booleanKey;\n    } else if (aliasedKey) {\n      /** @type {Record<string, any>} */ (this)[aliasedKey] = value;\n      observer = aliasedKey;\n    }\n\n    /** @type {Record<string, any>} */ (this)[key] = value;\n\n    // translate normalized key to actual key\n    if (attrName) {\n      this.$attr[key] = attrName;\n    } else {\n      attrName = this.$attr[key];\n\n      if (!attrName) {\n        this.$attr[key] = attrName = snakeCase(key, \"-\");\n      }\n    }\n\n    const nodeName = this._nodeRef?.node.nodeName.toLowerCase();\n\n    let maybeSanitizedValue;\n\n    // Sanitize img[srcset] values.\n    if (nodeName === \"img\" && key === \"srcset\") {\n      this[key] = maybeSanitizedValue = this.sanitizeSrcset(\n        value,\n        \"$set('srcset', value)\",\n      );\n    } else {\n      maybeSanitizedValue = value;\n    }\n\n    if (writeAttr !== false) {\n      const elem = /** @type {Element} */ (this._element());\n\n      if (isNullOrUndefined(maybeSanitizedValue)) {\n        elem.removeAttribute(attrName);\n        //\n      } else if (SIMPLE_ATTR_NAME.test(attrName)) {\n        // jQuery skips special boolean attrs treatment in XML nodes for\n        // historical reasons and hence AngularTS cannot freely call\n        // `.getAttribute(attrName, false) with such attributes. To avoid issues\n        // in XHTML, call `removeAttr` in such cases instead.\n        // See https://github.com/jquery/jquery/issues/4249\n        if (booleanKey && maybeSanitizedValue === false) {\n          elem.removeAttribute(attrName);\n        } else {\n          if (booleanKey) {\n            elem.toggleAttribute(\n              attrName,\n              /** @type {boolean} */ (maybeSanitizedValue),\n            );\n          } else {\n            elem.setAttribute(\n              attrName,\n              /** @type {string} */ (maybeSanitizedValue),\n            );\n          }\n        }\n      } else {\n        this.setSpecialAttr(\n          /** @type {Element} */ (this._element()),\n          attrName,\n          /** @type {string} */ (maybeSanitizedValue),\n        );\n      }\n    }\n\n    // fire observers\n    const { _observers } = this;\n\n    if (_observers && _observers[observer]) {\n      _observers[observer].forEach(\n        (/** @type {(arg0: unknown) => void} */ fn) => {\n          try {\n            fn(maybeSanitizedValue);\n          } catch (err) {\n            this._exceptionHandler(err);\n          }\n        },\n      );\n    }\n  }\n\n  /**\n   * @template T\n   * Observes an interpolated attribute.\n   * \n   * The observer function will be invoked once during the next `$digest` following\n   * compilation. The observer is then invoked whenever the interpolated value\n   * changes.\n   *\n   * @param {string} key Normalized key. (ie ngAttribute) .\n   * @param {(value?: T) => any} fn Function that will be called whenever\n            the interpolated value of the attribute changes.\n  *        See the {@link guide/interpolation#how-text-and-attribute-bindings-work Interpolation\n  *        guide} for more info.\n  * @returns {Function} Returns a deregistration function for this observer.\n  */\n  $observe(key, fn) {\n    const _observers = this._observers || (this._observers = nullObject());\n\n    const listeners = _observers[key] || (_observers[key] = []);\n\n    listeners.push(fn);\n\n    if (\n      !listeners._inter &&\n      hasOwn(this, key) &&\n      !isUndefined(/** @type {Record<string, any>} */ (this)[key])\n    ) {\n      // no one registered attribute interpolation function, so lets call it manually\n      fn(/** @type {Record<string, any>} */ (this)[key]);\n    }\n\n    return function () {\n      arrayRemove(listeners, fn);\n    };\n  }\n\n  /**\n   * Sets a special (non-standard) attribute on an element.\n   *\n   * Used for attribute names that cannot be set via `setAttribute`\n   * (e.g. names not starting with a letter like `(click)`).\n   *\n   * @param {Element} element\n   * @param {string} attrName\n   * @param {string | null} value\n   * @returns {void}\n   */\n  setSpecialAttr(element, attrName, value) {\n    // Attributes names that do not start with letters (such as `(click)`) cannot be set using `setAttribute`\n    // so we have to jump through some hoops to get such an attribute\n    // https://github.com/angular/angular.js/pull/13318\n    specialAttrHolder.innerHTML = `<span ${attrName}>`;\n    const { attributes } = /** @type {Element} */ (\n      specialAttrHolder.firstChild\n    );\n\n    const attribute = attributes[0];\n\n    // We have to remove the attribute from its container element before we can add it to the destination element\n    attributes.removeNamedItem(attribute.name);\n    attribute.value = value ?? \"\";\n    element.attributes.setNamedItem(attribute);\n  }\n\n  /**\n   *\n   * @param {unknown} value\n   * @param {string} invokeType\n   * @returns {unknown}\n   */\n  sanitizeSrcset(value, invokeType) {\n    let i;\n\n    if (!value) {\n      return value;\n    }\n\n    if (!isString(value)) {\n      throw $compileMinErr(\n        \"srcset\",\n        'Can\\'t pass trusted values to `{0}`: \"{1}\"',\n        invokeType,\n        /** @type {Object} */ (value).toString(),\n      );\n    }\n\n    // Such values are a bit too complex to handle automatically inside $sce.\n    // Instead, we sanitize each of the URIs individually, which works, even dynamically.\n\n    // It's not possible to work around this using `$sce.trustAsMediaUrl`.\n    // If you want to programmatically set explicitly trusted unsafe URLs, you should use\n    // `$sce.trustAsHtml` on the whole `img` tag and inject it into the DOM using the\n    // `ng-bind-html` directive.\n\n    let result = \"\";\n\n    // first check if there are spaces because it's not the same pattern\n    const trimmedSrcset = trim(value);\n\n    //                (   999x   ,|   999w   ,|   ,|,   )\n    const srcPattern = /(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/;\n\n    const pattern = /\\s/.test(trimmedSrcset) ? srcPattern : /(,)/;\n\n    // split srcset into tuple of uri and descriptor except for the last item\n    const rawUris = trimmedSrcset.split(pattern);\n\n    // for each tuples\n    const nbrUrisWith2parts = Math.floor(rawUris.length / 2);\n\n    for (i = 0; i < nbrUrisWith2parts; i++) {\n      const innerIdx = i * 2;\n\n      // sanitize the uri\n      result += this._sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));\n      // add the descriptor\n      result += ` ${trim(rawUris[innerIdx + 1])}`;\n    }\n\n    // split the last item into uri and descriptor\n    const lastTuple = trim(rawUris[i * 2]).split(/\\s/);\n\n    // sanitize the last uri\n    result += this._sce.getTrustedMediaUrl(trim(lastTuple[0]));\n\n    // and add the last descriptor if any\n    if (lastTuple.length === 2) {\n      result += ` ${trim(lastTuple[1])}`;\n    }\n\n    return result.replace(/unsafe:unsafe/g, \"unsafe\");\n  }\n}\n\n/**\n * Computes the difference between two space-separated token strings.\n *\n * @param {string} str1 - The first string containing space-separated tokens.\n * @param {string} str2 - The second string containing space-separated tokens.\n * @returns {string} A string containing tokens that are in str1 but not in str2, separated by spaces.\n *\n */\nfunction tokenDifference(str1, str2) {\n  const tokens1 = new Set(str1.split(/\\s+/));\n\n  const tokens2 = new Set(str2.split(/\\s+/));\n\n  const difference = Array.from(tokens1).filter((token) => !tokens2.has(token));\n\n  return difference.join(\" \");\n}\n","import { kebabToCamel } from \"../../shared/dom.js\";\n\n/**\n * @param {string} source - the name of the attribute to be observed\n * @param {string} prop - the scope property to be updated with attribute value\n * @returns {ng.Directive}\n */\nexport function ngObserveDirective(source, prop) {\n  return {\n    restrict: \"A\",\n    compile: () => (scope, element) => {\n      if (prop === \"\") {\n        prop = source;\n      }\n      const normalized = kebabToCamel(prop);\n\n      if (!scope[normalized]) {\n        scope[normalized] = element.getAttribute(source);\n      }\n\n      const observer = new MutationObserver((mutations) => {\n        const mutation = mutations[0];\n\n        const newValue = /** @type {HTMLElement} */ (\n          mutation.target\n        ).getAttribute(source);\n\n        if (scope[normalized] !== newValue) {\n          scope[normalized] = newValue;\n        }\n      });\n\n      observer.observe(element, {\n        attributes: true,\n        attributeFilter: [source],\n      });\n\n      scope.$on(\"$destroy\", () => {\n        observer.disconnect();\n      });\n    },\n  };\n}\n","import {\n  createElementFromHTML,\n  createNodelistFromHTML,\n  emptyElement,\n  getBooleanAttrName,\n  getCacheData,\n  getInheritedData,\n  isTextNode,\n  setCacheData,\n  setIsolateScope,\n  setScope,\n  startingTag,\n} from \"../../shared/dom.js\";\nimport { NodeType } from \"../../shared/node.js\";\nimport { NodeRef } from \"../../shared/noderef.js\";\nimport { identifierForController } from \"../controller/controller.js\";\nimport {\n  assertArg,\n  assertNotHasOwnProperty,\n  bind,\n  deProxy,\n  directiveNormalize,\n  entries,\n  equals,\n  extend,\n  getNodeName,\n  hasOwn,\n  inherit,\n  isArray,\n  isBoolean,\n  isDefined,\n  isError,\n  isFunction,\n  isObject,\n  isScope,\n  isString,\n  isUndefined,\n  minErr,\n  nullObject,\n  simpleCompare,\n  trim,\n} from \"../../shared/utils.js\";\nimport { SCE_CONTEXTS } from \"../../services/sce/sce.js\";\nimport { PREFIX_REGEXP } from \"../../shared/constants.js\";\nimport {\n  createEventDirective,\n  createWindowEventDirective,\n} from \"../../directive/events/events.js\";\nimport { Attributes } from \"./attributes.js\";\nimport { ngObserveDirective } from \"../../directive/observe/observe.js\";\nimport { $injectTokens, $injectTokens as $t } from \"../../injection-tokens.js\";\n\n/** @typedef {import(\"./interface.ts\").BoundTranscludeFn} BoundTranscludeFn */\n/** @typedef {import(\"./interface.ts\").ChildTranscludeOrLinkFn} ChildTranscludeOrLinkFn */\n/** @typedef {import(\"./interface.ts\").CloneAttachFn} CloneAttachFn */\n/** @typedef {import(\"./interface.ts\").CompileNodesFn} CompileNodesFn */\n/** @typedef {import(\"./interface.ts\").CompositeLinkFn} CompositeLinkFn */\n/** @typedef {import(\"./interface.ts\").NodeLinkFn} NodeLinkFn */\n/** @typedef {import(\"./interface.ts\").NodeLinkFnCtx } NodeLinkFnCtx */\n/** @typedef {import(\"./interface.ts\").PreviousCompileContext} PreviousCompileContext */\n/** @typedef {import(\"./interface.ts\").PublicLinkFn} PublicLinkFn */\n/** @typedef {import(\"./interface.ts\").TranscludedNodes} TranscludedNodes */\n/** @typedef {import(\"./interface.ts\").InternalDirective} InternalDirective */\n\nconst $compileMinErr = minErr(\"$compile\");\n\nconst EXCLUDED_DIRECTIVES = [\"ngIf\", \"ngRepeat\"];\n\nconst ALL_OR_NOTHING_ATTRS = [\"ngSrc\", \"ngSrcset\", \"src\", \"srcset\"];\n\nconst REQUIRE_PREFIX_REGEXP = /^(?:(\\^\\^?)?(\\?)?(\\^\\^?)?)?/;\n\nconst NG_PREFIX_BINDING = /^ng(Attr|Prop|On|Observe|Window)([A-Z].*)$/;\n\n// Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes\n// The assumption is that future DOM event attribute names will begin with\n// 'on' and be composed of only English letters.\nconst EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;\n\nconst valueFn = (/** @type {any} */ value) => () => value;\n\nexport const DirectiveSuffix = \"Directive\";\n\nexport class CompileProvider {\n  /* @ignore */ static $inject = [$t._provide, $t._sanitizeUriProvider];\n\n  /**\n   * @param {ng.ProvideService} $provide\n   * @param {import('../sanitize/sanitize-uri.js').SanitizeUriProvider} $sanitizeUriProvider\n   */\n  constructor($provide, $sanitizeUriProvider) {\n    /**\n     * @type {Record<string, any>}\n     */\n    const hasDirectives = {};\n\n    const bindingCache = nullObject();\n\n    /**\n     * @param {Object} scope\n     * @param {string} directiveName\n     * @param {boolean} isController\n     * @returns {Object} a configuration object for attribute bindings\n     */\n    function parseIsolateBindings(scope, directiveName, isController) {\n      const LOCAL_REGEXP = /^([@&]|[=<]())(\\??)\\s*([\\w$]*)$/;\n\n      const bindings = nullObject();\n\n      entries(scope).forEach(([scopeName, definition]) => {\n        definition = definition.trim();\n\n        if (definition in bindingCache) {\n          bindings[scopeName] = bindingCache[definition];\n\n          return;\n        }\n        const match = definition.match(LOCAL_REGEXP);\n\n        if (!match) {\n          throw $compileMinErr(\n            \"iscp\",\n            \"Invalid {3} for directive '{0}'.\" +\n              \" Definition: {... {1}: '{2}' ...}\",\n            directiveName,\n            scopeName,\n            definition,\n            isController\n              ? \"controller bindings definition\"\n              : \"isolate scope definition\",\n          );\n        }\n\n        bindings[scopeName] = {\n          mode: match[1][0],\n          collection: match[2] === \"*\",\n          optional: match[3] === \"?\",\n          attrName: match[4] || scopeName,\n        };\n\n        if (match[4]) {\n          bindingCache[definition] = bindings[scopeName];\n        }\n      });\n\n      return bindings;\n    }\n\n    /**\n     * @param {ng.Directive} directive\n     * @param {string} directiveName\n     */\n    function parseDirectiveBindings(directive, directiveName) {\n      /** @type {{ isolateScope: Object|null, bindToController: Object|null }} */\n      const bindings = {\n        isolateScope: null,\n        bindToController: null,\n      };\n\n      if (isObject(directive.scope)) {\n        if (directive.bindToController === true) {\n          bindings.bindToController = parseIsolateBindings(\n            directive.scope,\n            directiveName,\n            true,\n          );\n          bindings.isolateScope = {};\n        } else {\n          bindings.isolateScope = parseIsolateBindings(\n            directive.scope,\n            directiveName,\n            false,\n          );\n        }\n      }\n\n      if (isObject(directive.bindToController)) {\n        bindings.bindToController = parseIsolateBindings(\n          directive.bindToController,\n          directiveName,\n          true,\n        );\n      }\n\n      if (bindings.bindToController && !directive.controller) {\n        // There is no controller\n        throw $compileMinErr(\n          \"noctrl\",\n          \"Cannot bind to controller without directive '{0}'s controller.\",\n          directiveName,\n        );\n      }\n\n      return bindings;\n    }\n\n    /**\n     * @param {ng.Directive} directive\n     */\n    function getDirectiveRequire(directive) {\n      const require =\n        directive.require || (directive.controller && directive.name);\n\n      if (!isArray(require) && isObject(require)) {\n        const entryList = entries(require);\n\n        for (let i = 0, len = entryList.length; i < len; i++) {\n          const [key, value] = entryList[i];\n\n          const match = value.match(REQUIRE_PREFIX_REGEXP);\n\n          if (!match) continue; // safety check if match fails\n\n          const name = value.substring(match[0].length);\n\n          if (!name) {\n            require[key] = match[0] + key;\n          }\n        }\n      }\n\n      return require;\n    }\n\n    /**\n     * @param {unknown} restrict\n     * @param {string} name\n     */\n    function getDirectiveRestrict(restrict, name) {\n      if (restrict && !(isString(restrict) && /[EA]/.test(restrict))) {\n        throw $compileMinErr(\n          \"badrestrict\",\n          \"Restrict property '{0}' of directive '{1}' is invalid\",\n          restrict,\n          name,\n        );\n      }\n\n      // Default is element or attribute\n      return restrict || \"EA\";\n    }\n\n    /**\n     * Register a new directive with the compiler.\n     *\n     * @param {string|Object} name Name of the directive in camel-case (i.e. `ngBind` which will match\n     *    as `ng-bind`), or an object map of directives where the keys are the names and the values\n     *    are the factories.\n     * @param {Function|Array<Function>} directiveFactory An injectable directive factory function. See the\n     *    {@link guide/directive directive guide} and the {@link $compile compile API} for more info.\n     * @returns {CompileProvider} Self for chaining.\n     */\n    this.directive = function registerDirective(name, directiveFactory) {\n      assertArg(name, \"name\");\n\n      if (isString(name)) {\n        assertNotHasOwnProperty(name, \"directive\");\n        assertValidDirectiveName(name);\n        assertArg(directiveFactory, \"directiveFactory\");\n\n        if (!hasOwn(hasDirectives, name)) {\n          hasDirectives[name] = [];\n          $provide.factory(name + DirectiveSuffix, [\n            $injectTokens._injector,\n            $injectTokens._exceptionHandler,\n            /**\n             * @param {ng.InjectorService} $injector\n             * @param {ng.ExceptionHandlerService} $exceptionHandler\n             */\n            function ($injector, $exceptionHandler) {\n              const directives = [];\n\n              for (let i = 0, l = hasDirectives[name].length; i < l; i++) {\n                const directiveFactoryInstance = hasDirectives[name][i];\n\n                try {\n                  let directive = $injector.invoke(directiveFactoryInstance);\n\n                  if (isFunction(directive)) {\n                    directive = { compile: valueFn(directive) };\n                  } else if (!directive.compile && directive.link) {\n                    directive.compile = valueFn(directive.link);\n                  }\n\n                  directive.priority = directive.priority || 0;\n                  directive.index = i;\n                  directive.name = directive.name || name;\n                  directive.require = getDirectiveRequire(directive);\n                  directive.restrict = getDirectiveRestrict(\n                    directive.restrict,\n                    name,\n                  );\n\n                  directives.push(directive);\n                } catch (err) {\n                  $exceptionHandler(err);\n                }\n              }\n\n              return directives;\n            },\n          ]);\n        }\n        hasDirectives[name].push(directiveFactory);\n      } else {\n        entries(name).forEach(([k, v]) => registerDirective(k, v));\n      }\n\n      return this;\n    };\n\n    /**\n     * @param {string|Object} name Name of the component in camelCase (i.e. `myComp` which will match `<my-comp>`),\n     *    or an object map of components where the keys are the names and the values are the component definition objects.\n     * @param {import(\"../../interface.ts\").Component} options Component definition object (a simplified\n     *    {directive definition object}),\n     *    with the following properties (all optional):\n     *\n     *    - `controller`  `{(string|function()=}`  controller constructor function that should be\n     *      associated with newly created scope or the name of a {controller} if passed as a string. An empty `noop` function by default.\n     *    - `controllerAs`  `{string=}`  identifier name for to reference the controller in the component's scope.\n     *      If present, the controller will be published to scope under the `controllerAs` name.\n     *      If not present, this will default to be `$ctrl`.\n     *    - `template`  `{string=|function()=}`  html template as a string or a function that\n     *      returns an html template as a string which should be used as the contents of this component.\n     *      Empty string by default.\n     *\n     *      If `template` is a function, then it is {injected} with\n     *      the following locals:\n     *\n     *      - `$element` - Current element\n     *      - `$attrs` - Current attributes object for the element\n     *\n     *    - `templateUrl`  `{string=|function()=}`  path or function that returns a path to an html\n     *      template that should be used  as the contents of this component.\n     *\n     *      If `templateUrl` is a function, then it is {injected} with\n     *      the following locals:\n     *\n     *      - `$element` - Current element\n     *      - `$attrs` - Current attributes object for the element\n     *\n     *    - `bindings`  `{object=}`  defines bindings between DOM attributes and component properties.\n     *      Component properties are always bound to the component controller and not to the scope.\n     *      See {`bindToController`}.\n     *    - `transclude`  `{boolean=}`  whether {content transclusion} is enabled.\n     *      Disabled by default.\n     *    - `require` - `{Object<string, string>=}` - requires the controllers of other directives and binds them to\n     *      this component's controller. The object keys specify the property names under which the required\n     *      controllers (object values) will be bound. See {`require`}.\n     *    - `$...`  additional properties to attach to the directive factory function and the controller\n     *      constructor function. (This is used by the component router to annotate)\n     *\n     * @returns {CompileProvider} the compile provider itself, for chaining of function calls.\n     */\n    this.component = function (name, options) {\n      if (!isString(name)) {\n        entries(name).forEach(([key, val]) => this.component(key, val));\n\n        return this;\n      }\n\n      const controller =\n        options.controller ||\n        function () {\n          /* empty */\n        };\n\n      /**\n       * @param {ng.InjectorService} $injector\n       */\n      function factory($injector) {\n        /**\n         * @param {string | Function | ng.AnnotatedFactory<any> | undefined} fn\n         */\n        const makeInjectable = (fn) => {\n          if (isFunction(fn) || isArray(fn)) {\n            return (\n              /** @type {HTMLElement} */ tElement,\n              /** @type {ng.Attributes} */ tAttrs,\n            ) => {\n              return $injector.invoke(fn, null, {\n                $element: tElement,\n                $attrs: tAttrs,\n              });\n            };\n          }\n\n          return fn;\n        };\n\n        const template =\n          !options.template && !options.templateUrl ? \"\" : options.template;\n\n        /** @type {Record<string, any>} */\n        const ddo = {\n          controller,\n          controllerAs:\n            identifierForController(options.controller) ||\n            options.controllerAs ||\n            \"$ctrl\",\n          template: makeInjectable(template),\n          templateUrl: makeInjectable(options.templateUrl),\n          transclude: options.transclude,\n          scope: {},\n          bindToController: options.bindings || {},\n          restrict: \"E\",\n          require: options.require,\n        };\n\n        // Copy annotations (starting with $) over to the DDO\n        entries(options).forEach(([key, val]) => {\n          if (key.charAt(0) === \"$\") {\n            ddo[key] = val;\n          }\n        });\n\n        return ddo;\n      }\n\n      // Copy any annotation properties (starting with $) over to the factory and controller constructor functions\n      // These could be used by libraries such as the new component router\n      entries(options).forEach(([key, val]) => {\n        if (key.charAt(0) === \"$\") {\n          /** @type {Record<string, any>} */ (factory)[key] = val;\n\n          // Don't try to copy over annotations to named controller\n          if (isFunction(controller)) {\n            /** @type {Record<string, any>} */ (controller)[key] = val;\n          }\n        }\n      });\n\n      factory.$inject = [$injectTokens._injector];\n\n      return this.directive(name, factory);\n    };\n\n    /**\n     * Retrieves or overrides the default regular expression that is used for determining trusted safe\n     * urls during a[href] sanitization.\n     *\n     * The sanitization is a security measure aimed at preventing XSS attacks via html links.\n     *\n     * Any url about to be assigned to a[href] via data-binding is first normalized and turned into\n     * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationTrustedUrlList`\n     * regular expression. If a match is found, the original url is written into the dom. Otherwise,\n     * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.\n     *\n     * @param {RegExp=} regexp New regexp to trust urls with.\n     * @returns {RegExp|import('../sanitize/sanitize-uri.js').SanitizeUriProvider} Current RegExp if called without value or self for\n     *    chaining otherwise.\n     */\n    this.aHrefSanitizationTrustedUrlList = function (regexp) {\n      if (isDefined(regexp)) {\n        $sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp);\n      }\n\n      return $sanitizeUriProvider.aHrefSanitizationTrustedUrlList();\n    };\n\n    /**\n     * Retrieves or overrides the default regular expression that is used for determining trusted safe\n     * urls during img[src] sanitization.\n     *\n     * The sanitization is a security measure aimed at prevent XSS attacks via html links.\n     *\n     * Any url about to be assigned to img[src] via data-binding is first normalized and turned into\n     * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationTrustedUrlList`\n     * regular expression. If a match is found, the original url is written into the dom. Otherwise,\n     * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.\n     *\n     * @param {RegExp=} regexp New regexp to trust urls with.\n     * @returns {RegExp|import('../sanitize/sanitize-uri.js').SanitizeUriProvider | undefined} Current RegExp if called without value or self for\n     *    chaining otherwise.\n     */\n    this.imgSrcSanitizationTrustedUrlList = function (regexp) {\n      if (isDefined(regexp)) {\n        $sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp);\n\n        return undefined;\n      }\n\n      return $sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();\n    };\n\n    /**\n     * @param {boolean=} enabled update the strictComponentBindingsEnabled state if provided,\n     * otherwise return the current strictComponentBindingsEnabled state.\n     * @returns {*} current value if used as getter or itself (chaining) if used as setter\n     *\n     * Call this method to enable / disable the strict component bindings check. If enabled, the\n     * compiler will enforce that all scope / controller bindings of a\n     * {@link $compileProvider#directive} / {@link $compileProvider#component}\n     * that are not set as optional with `?`, must be provided when the directive is instantiated.\n     * If not provided, the compiler will throw the\n     * {@link error/$compile/missingattr $compile:missingattr error}.\n     *\n     * The default value is false.\n     */\n    let strictComponentBindingsEnabled = false;\n\n    this.strictComponentBindingsEnabled =\n      /** @param {boolean} enabled */ function (enabled) {\n        if (isDefined(enabled)) {\n          strictComponentBindingsEnabled = enabled;\n\n          return this;\n        }\n\n        return strictComponentBindingsEnabled;\n      };\n\n    /**\n     * The security context of DOM Properties.\n     */\n    const PROP_CONTEXTS = nullObject();\n\n    /**\n     * Defines the security context for DOM properties bound by ng-prop-*.\n     *\n     * @param {string} elementName The element name or '*' to match any element.\n     * @param {string} propertyName The DOM property name.\n     * @param {string} ctx The {@link _sce} security context in which this value is safe for use, e.g. `$sce.URL`\n     * @returns {object} `this` for chaining\n     */\n    this.addPropertySecurityContext = function (\n      elementName,\n      propertyName,\n      ctx,\n    ) {\n      const key = `${elementName.toLowerCase()}|${propertyName.toLowerCase()}`;\n\n      if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) {\n        throw $compileMinErr(\n          \"ctxoverride\",\n          \"Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.\",\n          elementName,\n          propertyName,\n          PROP_CONTEXTS[key],\n          ctx,\n        );\n      }\n\n      PROP_CONTEXTS[key] = ctx;\n\n      return this;\n    };\n\n    /* Default property contexts.\n     *\n     * Copy of https://github.com/angular/angular/blob/6.0.6/packages/compiler/src/schema/dom_security_schema.ts#L31-L58\n     * Changing:\n     * - SecurityContext.* => SCE_CONTEXTS/$sce.*\n     * - STYLE => CSS\n     * - various URL => MEDIA_URL\n     * - *|formAction, form|action URL => RESOURCE_URL (like the attribute)\n     */\n    (function registerNativePropertyContexts() {\n      /**\n       * @param {string} ctx\n       * @param {any[]} values\n       */\n      function registerContext(ctx, values) {\n        values.forEach((v) => {\n          PROP_CONTEXTS[v.toLowerCase()] = ctx;\n        });\n      }\n\n      registerContext(SCE_CONTEXTS.HTML, [\n        \"iframe|srcdoc\",\n        \"*|innerHTML\",\n        \"*|outerHTML\",\n      ]);\n      registerContext(SCE_CONTEXTS.CSS, [\"*|style\"]);\n      registerContext(SCE_CONTEXTS.URL, [\n        \"area|href\",\n        \"area|ping\",\n        \"a|href\",\n        \"a|ping\",\n        \"blockquote|cite\",\n        \"body|background\",\n        \"del|cite\",\n        \"input|src\",\n        \"ins|cite\",\n        \"q|cite\",\n      ]);\n      registerContext(SCE_CONTEXTS.MEDIA_URL, [\n        \"audio|src\",\n        \"img|src\",\n        \"img|srcset\",\n        \"source|src\",\n        \"source|srcset\",\n        \"track|src\",\n        \"video|src\",\n        \"video|poster\",\n      ]);\n      registerContext(SCE_CONTEXTS.RESOURCE_URL, [\n        \"*|formAction\",\n        \"applet|code\",\n        \"applet|codebase\",\n        \"base|href\",\n        \"embed|src\",\n        \"frame|src\",\n        \"form|action\",\n        \"head|profile\",\n        \"html|manifest\",\n        \"iframe|src\",\n        \"link|href\",\n        \"media|src\",\n        \"object|codebase\",\n        \"object|data\",\n        \"script|src\",\n      ]);\n    })();\n\n    this.$get = [\n      $t._injector,\n      $t._interpolate,\n      $t._exceptionHandler,\n      $t._templateRequest,\n      $t._parse,\n      $t._controller,\n      $t._sce,\n      $t._animate,\n      /**\n       * @param {ng.InjectorService} $injector\n       * @param {ng.InterpolateService} $interpolate\n       * @param {ng.ExceptionHandlerService} $exceptionHandler\n       * @param {ng.TemplateRequestService} $templateRequest\n       * @param {ng.ParseService} $parse\n       * @param {ng.ControllerService} $controller\n       * @param {ng.SceService} $sce\n       * @param {ng.AnimateService} $animate\n       * @returns {ng.CompileService}\n       */\n      (\n        $injector,\n        $interpolate,\n        $exceptionHandler,\n        $templateRequest,\n        $parse,\n        $controller,\n        $sce,\n        $animate,\n      ) => {\n        // The onChanges hooks should all be run together in a single digest\n        // When changes occur, the call to trigger their hooks will be added to this queue\n        /**\n         * @type {(() => void)[]}\n         */\n        const onChangesQueue = [];\n\n        // This function is called in a $postUpdate to trigger all the onChanges hooks in a single digest\n        function flushOnChangesQueue() {\n          for (let i = 0, ii = onChangesQueue.length; i < ii; ++i) {\n            try {\n              onChangesQueue[i]();\n            } catch (err) {\n              $exceptionHandler(err);\n            }\n          }\n          // Reset the queue to trigger a new schedule next time there is a change\n          onChangesQueue.length = 0;\n        }\n\n        const startSymbol = $interpolate.startSymbol();\n\n        const endSymbol = $interpolate.endSymbol();\n\n        /** @type {(x: string) => string} */\n        const denormalizeTemplate =\n          startSymbol === \"{{\" && endSymbol === \"}}\"\n            ? (x) => x\n            : (x) => x.replace(/\\{\\{/g, startSymbol).replace(/}}/g, endSymbol);\n\n        return compile;\n\n        /**\n         * @type {ng.CompileService}\n         */\n        function compile(\n          element,\n          transcludeFn,\n          maxPriority,\n          ignoreDirective,\n          previousCompileContext,\n        ) {\n          /** @type {NodeRef | null} */\n          let nodeRef = element ? new NodeRef(element) : null;\n\n          /**\n           * The composite link function is a composite of individual node linking functions.\n           * It will be invoke by the public link function below.\n           * @type {ng.CompositeLinkFn | null}\n           */\n          let compositeLinkFn = compileNodes(\n            nodeRef,\n            /** @type {ChildTranscludeOrLinkFn} */ (transcludeFn),\n            maxPriority,\n            ignoreDirective,\n            previousCompileContext,\n          );\n\n          /**\n           * @type {string | null}\n           */\n          let namespace = null;\n\n          /** @type {ng.PublicLinkFn} */\n          const publicLinkFn = function (scope, cloneConnectFn, options) {\n            if (!nodeRef) {\n              throw $compileMinErr(\n                \"multilink\",\n                \"This element has already been linked.\",\n              );\n            }\n\n            assertArg(scope, \"scope\");\n\n            // could be empty nodelist\n            if (nodeRef._element) {\n              setScope(nodeRef._element, scope);\n            }\n\n            if (\n              previousCompileContext &&\n              previousCompileContext.needsNewScope\n            ) {\n              // A parent directive did a replace and a directive on this element asked\n              // for transclusion, which caused us to lose a layer of element on which\n              // we could hold the new transclusion scope, so we will create it manually\n              // here.\n              scope = scope.$parent?.$new() || scope.$new();\n            }\n\n            options = options || {};\n            let { _parentBoundTranscludeFn } = options;\n\n            const { transcludeControllers, _futureParentElement } = options;\n\n            // When `_parentBoundTranscludeFn` is passed, it is a\n            // `controllersBoundTransclude` function (it was previously passed\n            // as `transclude` to directive.link) so we must unwrap it to get\n            // its `boundTranscludeFn`\n            if (\n              _parentBoundTranscludeFn &&\n              _parentBoundTranscludeFn._boundTransclude\n            ) {\n              _parentBoundTranscludeFn =\n                _parentBoundTranscludeFn._boundTransclude;\n            }\n\n            if (!namespace) {\n              namespace = detectNamespaceForChildElements(_futureParentElement);\n            }\n            /** @type {NodeRef} */\n            let $linkNode;\n\n            if (namespace !== \"html\") {\n              // When using a directive with replace:true and templateUrl the jqCompileNodes\n              // (or a child element inside of them)\n              // might change, so we need to recreate the namespace adapted compileNodes\n              // for call to the link function.\n              // Note: This will already clone the nodes...\n              const fragment = createElementFromHTML(\"<div></div>\");\n\n              fragment.append(nodeRef.node);\n              const wrappedTemplate = wrapTemplate(\n                namespace,\n                fragment.innerHTML,\n              );\n\n              $linkNode = new NodeRef(wrappedTemplate[0]);\n            } else if (cloneConnectFn) {\n              $linkNode = nodeRef._clone();\n            } else {\n              $linkNode = nodeRef;\n            }\n\n            if (transcludeControllers) {\n              const controllers =\n                /** @type {Record<string, { instance: any }>} */ (\n                  transcludeControllers\n                );\n\n              for (const controllerName in controllers) {\n                assertArg($linkNode.element, \"element\");\n                setCacheData(\n                  $linkNode.element,\n                  `$${controllerName}Controller`,\n                  controllers[controllerName].instance,\n                );\n              }\n            }\n\n            if (cloneConnectFn) {\n              cloneConnectFn($linkNode.dom, scope);\n            }\n\n            if (compositeLinkFn) {\n              compositeLinkFn(scope, $linkNode, _parentBoundTranscludeFn);\n            }\n\n            if (!cloneConnectFn) {\n              nodeRef = compositeLinkFn = null;\n            }\n\n            return $linkNode._getAll();\n          };\n\n          return publicLinkFn;\n        }\n\n        /**\n         * @param {Element | Node | null | undefined} parentElement\n         */\n        function detectNamespaceForChildElements(parentElement) {\n          // TODO: Make this detect MathML as well...\n          const node = parentElement;\n\n          if (!node) {\n            return \"html\";\n          }\n\n          return getNodeName(/** @type {Element} */ (node)) !==\n            \"foreignobject\" && toString.call(node).match(/SVG/)\n            ? \"svg\"\n            : \"html\";\n        }\n\n        /**\n         * Compiles a `NodeRef` (single node or node-list) into a composite linking function.\n         *\n         * Walks each node in `nodeRefList`, collects and applies directives (including template/templateUrl\n         * and transclusion handling), then recursively compiles child nodes when appropriate. The result is\n         * a `CompositeLinkFn` that, when invoked, links all compiled nodes in a stable order and wires up\n         * any required bound transclusion functions.\n         *\n         * Notes:\n         * - If no directives (or child link fns) are found anywhere in the list, this returns `null`.\n         * - `previousCompileContext` is only applied to the first node in a virtual group and is cleared\n         *   for subsequent nodes.\n         *\n         * @param {NodeRef | null} nodeRefList\n         *   The compilation root: either a single node wrapper or a wrapper around a NodeList/array.\n         * @param {ChildTranscludeOrLinkFn | null | undefined} transcludeFn\n         *   Parent transclusion/link function propagated down during compilation. When compiling child nodes,\n         *   this may be replaced with a node-specific transclusion function (e.g. for element transclusion or\n         *   template compilation).\n         * @param {number | undefined} [maxPriority]\n         *   If provided, directives with priority >= `maxPriority` are ignored on the first node in the list.\n         *   (Used to stop further directive application when compiling a subset.)\n         * @param {string | undefined} [ignoreDirective]\n         *   Normalized directive name to ignore while collecting directives (used to prevent recursion when\n         *   compiling transcluded content).\n         * @param {PreviousCompileContext | null | undefined} [previousCompileContext]\n         *   Internal bookkeeping passed through compilation passes to coordinate replace/transclusion/templateUrl\n         *   and virtual-group indexing.\n         *\n         * @returns {CompositeLinkFn | null}\n         *   A composite linking function for the compiled node list, or `null` if nothing requires linking.\n         */\n        function compileNodes(\n          nodeRefList,\n          transcludeFn,\n          maxPriority,\n          ignoreDirective,\n          previousCompileContext,\n        ) {\n          if (!nodeRefList) return null;\n          /**\n           * Aggregates for the composite linking function, where a node in a node list is mapped\n           * to a corresponding link function. For single elements, the node should be mapped to\n           * a single node link function.\n           * @type {ng.LinkFnMapping[]}\n           */\n          const linkFnsList = []; // An array to hold node indices and their linkFns\n\n          /**\n           * @type {NodeLinkFn | undefined}\n           */\n          let nodeLinkFnFound;\n\n          let linkFnFound = false;\n\n          for (let i = 0; i < nodeRefList.size; i++) {\n            const attrs = new Attributes($animate, $exceptionHandler, $sce);\n\n            const directives = collectDirectives(\n              /** @type Element */ (nodeRefList._getIndex(i)),\n              attrs,\n              i === 0 ? maxPriority : undefined,\n              ignoreDirective,\n            );\n\n            /** @type {ng.NodeLinkFnCtx | undefined} */\n            let nodeLinkFnCtx;\n\n            if (directives.length) {\n              nodeLinkFnCtx = applyDirectivesToNode(\n                directives,\n                nodeRefList?._getIndex(i),\n                attrs,\n                /** @type {ChildTranscludeOrLinkFn} */ (transcludeFn),\n                null,\n                [],\n                [],\n                Object.assign({}, previousCompileContext, {\n                  index: i,\n                  parentNodeRef: nodeRefList,\n                  ctxNodeRef: nodeRefList,\n                }),\n              );\n            }\n\n            let childLinkFn;\n\n            const nodeLinkFn = nodeLinkFnCtx?.nodeLinkFn;\n\n            const { childNodes } = nodeRefList._getIndex(i);\n\n            if (\n              (nodeLinkFn && nodeLinkFnCtx?.terminal) ||\n              !childNodes ||\n              !childNodes.length\n            ) {\n              childLinkFn = null;\n            } else {\n              const transcluded = nodeLinkFn\n                ? nodeLinkFnCtx?.transcludeOnThisElement ||\n                  !nodeLinkFnCtx?.templateOnThisElement\n                  ? nodeLinkFnCtx?.transclude\n                  : undefined\n                : transcludeFn;\n\n              // recursive call\n              const childNodeRef = new NodeRef(childNodes);\n\n              childLinkFn = compileNodes(childNodeRef, transcluded);\n            }\n\n            if (nodeLinkFn || childLinkFn) {\n              linkFnsList.push({\n                index: i,\n                nodeLinkFnCtx,\n                childLinkFn,\n              });\n              linkFnFound = true;\n              nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;\n            }\n\n            // use the previous context only for the first element in the virtual group\n            previousCompileContext = null;\n          }\n\n          // return a composite linking function if we have found anything, null otherwise\n          return linkFnFound ? compositeLinkFn : null;\n\n          /**\n           * The composite link function links all the individual nodes\n           *\n           * @param {ng.Scope} scope\n           * @param {NodeRef} nodeRef\n           * @param {*} [_parentBoundTranscludeFn]\n           */\n          function compositeLinkFn(scope, nodeRef, _parentBoundTranscludeFn) {\n            assertArg(nodeRef, \"nodeRef\");\n            let stableNodeList = [];\n\n            if (nodeLinkFnFound) {\n              // create a stable copy of the nodeList, only copying elements with linkFns\n              const stableLength = nodeRef._isList ? nodeRef.nodes.length : 1;\n\n              stableNodeList = new Array(stableLength);\n              // create a sparse array by only copying the elements which have a linkFn\n              linkFnsList.forEach((val) => {\n                const idx = val.index;\n\n                if (idx === 0) {\n                  stableNodeList[idx] = nodeRef._isList\n                    ? nodeRef.nodes[idx]\n                    : nodeRef.node;\n                } else {\n                  if (nodeRefList?._getIndex(idx)) {\n                    stableNodeList[idx] = nodeRef.nodes[idx];\n                  }\n                }\n              });\n            } else {\n              if (nodeRef._isList) {\n                nodeRef.nodes.forEach((elem) => stableNodeList.push(elem));\n              } else {\n                stableNodeList.push(nodeRef.node);\n              }\n            }\n\n            linkFnsList.forEach(({ index, nodeLinkFnCtx, childLinkFn }) => {\n              const node = stableNodeList[index];\n\n              node.stable = true;\n              let childScope;\n\n              let childBoundTranscludeFn;\n\n              if (nodeLinkFnCtx?.nodeLinkFn) {\n                childScope = nodeLinkFnCtx.newScope ? scope.$new() : scope;\n\n                if (nodeLinkFnCtx.transcludeOnThisElement) {\n                  // bind proper scope for the translusion function\n                  childBoundTranscludeFn = createBoundTranscludeFn(\n                    scope,\n                    /** @type {ng.TranscludeFn} */ (nodeLinkFnCtx?.transclude),\n                    _parentBoundTranscludeFn,\n                  );\n                } else if (\n                  !nodeLinkFnCtx.templateOnThisElement &&\n                  _parentBoundTranscludeFn\n                ) {\n                  childBoundTranscludeFn = _parentBoundTranscludeFn;\n                } else if (!_parentBoundTranscludeFn && transcludeFn) {\n                  childBoundTranscludeFn = createBoundTranscludeFn(\n                    scope,\n                    /** @type {ng.TranscludeFn} */ (transcludeFn),\n                  );\n                } else {\n                  childBoundTranscludeFn = null;\n                }\n\n                // attach new scope to element\n                if (nodeLinkFnCtx?.newScope) {\n                  setScope(node, childScope);\n                }\n\n                nodeLinkFnCtx.nodeLinkFn(\n                  childLinkFn,\n                  childScope,\n                  node,\n                  childBoundTranscludeFn,\n                );\n              } else if (childLinkFn) {\n                childLinkFn(\n                  scope,\n                  new NodeRef(node.childNodes),\n                  _parentBoundTranscludeFn,\n                );\n              }\n            });\n          }\n        }\n\n        /**\n         * Prebinds a transclusion function to a parent scope and threads parent-bound transclusion context.\n         *\n         * @param {ng.Scope} scope\n         *   The parent scope used to derive transcluded scopes when one is not explicitly provided.\n         * @param {ng.TranscludeFn} transcludeFn\n         *   The underlying transclusion function to wrap (must expose `_slots` if slot transclusion is used).\n         * @param {BoundTranscludeFn | null | undefined} [previousBoundTranscludeFn]\n         *   Parent bound transclusion function (used to support nested transclusion).\n         * @returns {BoundTranscludeFn}\n         */\n        function createBoundTranscludeFn(\n          scope,\n          transcludeFn,\n          previousBoundTranscludeFn,\n        ) {\n          /**\n           * Scope-bound wrapper that ensures a transcluded scope exists and forwards to `transcludeFn`.\n           *\n           * @param {ng.Scope | null | undefined} transcludedScope\n           *   The scope to use for transcluded content; if omitted/falsey, a new one is created via\n           *   `scope.$transcluded(containingScope)`.\n           * @param {CloneAttachFn | undefined} cloneFn\n           *   Optional clone-attach callback for the transcluded DOM.\n           * @param {unknown} controllers\n           *   Controllers to expose to the transclusion (used for element transclusion cases).\n           * @param {Node | Element | null | undefined} _futureParentElement\n           *   The element that will ultimately contain the transcluded nodes.\n           * @param {ng.Scope | undefined} containingScope\n           *   The anchor scope at the transclusion point, used to derive the transcluded scope.\n           * @returns {TranscludedNodes | void}\n           */\n          function boundTranscludeFn(\n            transcludedScope,\n            cloneFn,\n            controllers,\n            _futureParentElement,\n            containingScope,\n          ) {\n            if (!transcludedScope) {\n              transcludedScope = scope.$transcluded(\n                /** @type {ng.Scope} */ (containingScope),\n              );\n            }\n\n            const transcludeRes = transcludeFn(transcludedScope, cloneFn, {\n              _parentBoundTranscludeFn: previousBoundTranscludeFn,\n              transcludeControllers: controllers,\n              _futureParentElement,\n            });\n\n            return transcludeRes;\n          }\n\n          // We need  to attach the transclusion slots onto the `boundTranscludeFn`\n          // so that they are available inside the `controllersBoundTransclude` function\n          const boundSlots = (boundTranscludeFn._slots = nullObject());\n\n          for (const slotName in transcludeFn._slots) {\n            if (transcludeFn._slots[slotName]) {\n              boundSlots[slotName] = createBoundTranscludeFn(\n                scope,\n                transcludeFn._slots[slotName],\n                previousBoundTranscludeFn,\n              );\n            } else {\n              boundSlots[slotName] = null;\n            }\n          }\n\n          return boundTranscludeFn;\n        }\n\n        /**\n         * Looks for directives on the given node and adds them to the directive collection which is\n         * sorted.\n         *\n         * @param {Element} node Node to search.\n         * @param {Attributes|any} attrs The shared attrs object which is used to populate the normalized attributes.\n         * @param {number=} maxPriority Max directive priority.\n         * @param {string} [ignoreDirective]\n         * @return {InternalDirective[]} An array to which the directives are added to. This array is sorted before the function returns.\n         */\n        function collectDirectives(node, attrs, maxPriority, ignoreDirective) {\n          /**\n           * @type {InternalDirective[]}\n           */\n          const directives = [];\n\n          const { nodeType } = node;\n\n          const attrsMap = attrs.$attr;\n\n          let nodeName;\n\n          switch (nodeType) {\n            case NodeType._ELEMENT_NODE /* Element */:\n              nodeName = node.nodeName.toLowerCase();\n\n              if (ignoreDirective !== directiveNormalize(nodeName)) {\n                // use the node name: <directive>\n                addDirective(\n                  directives,\n                  directiveNormalize(nodeName),\n                  \"E\",\n                  maxPriority,\n                );\n              }\n\n              // iterate over the attributes\n              for (let j = 0; j < node.attributes?.length; j++) {\n                let isNgAttr = false;\n\n                let isNgProp = false;\n\n                let isNgEvent = false;\n\n                let isNgObserve = false;\n\n                let isWindow = false;\n\n                const attr = node.attributes[j];\n\n                let { name } = attr;\n\n                const { value } = attr;\n\n                let nName = directiveNormalize(name.toLowerCase());\n\n                // Support ng-attr-*, ng-prop-* and ng-on-*\n                const ngPrefixMatch = nName.match(NG_PREFIX_BINDING);\n\n                if (ngPrefixMatch) {\n                  isNgAttr = ngPrefixMatch[1] === \"Attr\";\n                  isNgProp = ngPrefixMatch[1] === \"Prop\";\n                  isNgEvent = ngPrefixMatch[1] === \"On\";\n                  isNgObserve = ngPrefixMatch[1] === \"Observe\";\n                  isWindow = ngPrefixMatch[1] === \"Window\";\n\n                  // Normalize the non-prefixed name\n                  name = name\n                    .replace(PREFIX_REGEXP, \"\")\n                    .toLowerCase()\n                    .substring(4 + ngPrefixMatch[1].length)\n                    .replace(/_(.)/g, (match, letter) => letter.toUpperCase());\n                }\n\n                if (isNgProp || isNgEvent || isWindow) {\n                  attrs[nName] = value;\n                  attrsMap[nName] = attr.name;\n\n                  if (isNgProp) {\n                    addPropertyDirective(node, directives, nName, name);\n                  } else if (isNgEvent) {\n                    directives.push(\n                      /** @type {InternalDirective} */ (\n                        createEventDirective(\n                          $parse,\n                          $exceptionHandler,\n                          nName,\n                          name,\n                        )\n                      ),\n                    );\n                  } else {\n                    // isWindow\n                    directives.push(\n                      /** @type {InternalDirective} */ (\n                        createWindowEventDirective(\n                          $parse,\n                          $exceptionHandler,\n                          window,\n                          nName,\n                          name,\n                        )\n                      ),\n                    );\n                  }\n                } else if (isNgObserve) {\n                  directives.push(\n                    /** @type {InternalDirective} */ (\n                      ngObserveDirective(name, value)\n                    ),\n                  );\n                } else {\n                  // Update nName for cases where a prefix was removed\n                  // NOTE: the .toLowerCase() is unnecessary and causes https://github.com/angular/angular.js/issues/16624 for ng-attr-*\n                  nName = directiveNormalize(name.toLowerCase());\n                  attrsMap[nName] = name;\n\n                  if (isNgAttr || !hasOwn(attrs, nName)) {\n                    attrs[nName] = value;\n\n                    if (getBooleanAttrName(node, nName)) {\n                      attrs[nName] = true; // presence means true\n                    }\n                  }\n\n                  addAttrInterpolateDirective(\n                    node,\n                    directives,\n                    value,\n                    nName,\n                    isNgAttr,\n                  );\n\n                  if (nName !== ignoreDirective) {\n                    addDirective(directives, nName, \"A\", maxPriority);\n                  }\n                }\n              }\n\n              if (\n                nodeName === \"input\" &&\n                node.getAttribute(\"type\") === \"hidden\"\n              ) {\n                // Hidden input elements can have strange behaviour when navigating back to the page\n                // This tells the browser not to try to cache and reinstate previous values\n                node.setAttribute(\"autocomplete\", \"off\");\n              }\n\n              break;\n            case NodeType._TEXT_NODE:\n              addTextInterpolateDirective(\n                directives,\n                /** @type {string} */ (node.nodeValue),\n              );\n              break;\n            default:\n              break;\n          }\n\n          directives.sort(byPriority);\n\n          return directives;\n        }\n\n        /**\n         * A function generator that is used to support both eager and lazy compilation\n         * linking function.\n         * @param {boolean} eager\n         * @param {NodeList | Node | null} nodes\n         * @param {ChildTranscludeOrLinkFn | null | undefined} transcludeFn\n         * @param {number | undefined} maxPriority\n         * @param {string | undefined} ignoreDirective\n         * @param {{ _nonTlbTranscludeDirective?: any; needsNewScope?: any; } | null | undefined} previousCompileContext\n         * @returns {ng.PublicLinkFn | ng.TranscludeFn}\n         */\n        function compilationGenerator(\n          eager,\n          nodes,\n          transcludeFn,\n          maxPriority,\n          ignoreDirective,\n          previousCompileContext,\n        ) {\n          /** @type { ng.PublicLinkFn | undefined } */\n          let compiled;\n\n          if (eager) {\n            return /** @type {ng.PublicLinkFn} */ (\n              compile(\n                nodes,\n                transcludeFn,\n                maxPriority,\n                ignoreDirective,\n                previousCompileContext,\n              )\n            );\n          }\n\n          /**\n           * @param {Parameters<PublicLinkFn>} args\n           * @returns {ReturnType<PublicLinkFn>}\n           */\n          function lazyCompilation(...args) {\n            if (!compiled) {\n              compiled = compile(\n                nodes,\n                transcludeFn,\n                maxPriority,\n                ignoreDirective,\n                previousCompileContext,\n              );\n\n              nodes = transcludeFn = previousCompileContext = null;\n            }\n\n            return compiled(...args);\n          }\n\n          return /** @type {ng.PublicLinkFn} */ (lazyCompilation);\n        }\n\n        /**\n         * Applies a sorted set of directives to a single node and produces the node-level link context.\n         *\n         * Responsibilities:\n         * - Run directive `compile()` functions (and collect pre/post link fns).\n         * - Inline templates / handle `replace`, `templateUrl`, and transclusion.\n         * - Track terminal directives and scope requirements for later linking.\n         *\n         * @param {InternalDirective[]} directives\n         *   Collected directives for this node (must be pre-sorted by priority).\n         * @param {Node | Element} compileNode\n         *   The DOM node to apply directive compilation against (may be replaced during compilation).\n         * @param {Attributes} templateAttrs\n         *   Shared, normalized attributes for the node at compile-time.\n         * @param {ChildTranscludeOrLinkFn} transcludeFn\n         *   Parent transclusion/link function passed down during compilation.\n         * @param {InternalDirective | null | undefined} originalReplaceDirective\n         *   The original directive that triggered a `replace` (ignored when compiling transclusion/template).\n         * @param {Array<NodeLinkFn>} [preLinkFns]\n         *   Accumulator for pre-link functions (executed in registration order).\n         * @param {Array<ng.NodeLinkFn>} [postLinkFns]\n         *   Accumulator for post-link functions (executed in reverse order).\n         * @param {PreviousCompileContext} [previousCompileContext]\n         *   Internal bookkeeping for replace/transclusion/templateUrl compilation passes.\n         *\n         * @returns {NodeLinkFnCtx}\n         *   The node link context (nodeLinkFn + flags + transclusion/template metadata).\n         */\n        function applyDirectivesToNode(\n          directives,\n          compileNode,\n          templateAttrs,\n          transcludeFn,\n          originalReplaceDirective,\n          preLinkFns,\n          postLinkFns,\n          previousCompileContext,\n        ) {\n          previousCompileContext = previousCompileContext || {};\n          preLinkFns = /** @type {any[]} */ (preLinkFns || []);\n          postLinkFns = /** @type {any[]} */ (postLinkFns || []);\n\n          let terminalPriority = -Number.MAX_VALUE;\n\n          let terminal = false;\n\n          let {\n            _newScopeDirective,\n            _controllerDirectives,\n            _newIsolateScopeDirective,\n            _templateDirective,\n            _nonTlbTranscludeDirective,\n            hasElementTranscludeDirective,\n          } = previousCompileContext;\n\n          const { ctxNodeRef, parentNodeRef } = previousCompileContext;\n\n          let hasTranscludeDirective = false;\n\n          let hasTemplate = false;\n\n          let compileNodeRef = new NodeRef(compileNode);\n\n          const { index } = previousCompileContext;\n\n          templateAttrs._nodeRef = compileNodeRef;\n          /** @type {InternalDirective} */\n          let directive;\n\n          /** @type {string} */\n          let directiveName;\n\n          let $template;\n\n          let replaceDirective = originalReplaceDirective;\n\n          /** @type {import(\"./interface.ts\").ChildTranscludeOrLinkFn} */\n          let childTranscludeFn = transcludeFn;\n\n          let didScanForMultipleTransclusion = false;\n\n          let mightHaveMultipleTransclusionError = false;\n\n          let directiveValue;\n\n          /**\n           * Links all the directives of a single node.\n           * @type {ng.NodeLinkFn}\n           */\n\n          let nodeLinkFn = function (\n            childLinkFn,\n            scope,\n            linkNode,\n            boundTranscludeFn,\n          ) {\n            let i;\n\n            let ii;\n\n            let isolateScope;\n\n            let controllerScope;\n\n            /** @type {{ [s: string]: any; }} */\n            let elementControllers = nullObject();\n\n            let scopeToChild = scope;\n\n            /** @type {NodeRef} */\n            let $element;\n\n            /** @type {Attributes} */\n            let attrs;\n\n            let scopeBindingInfo;\n\n            if (compileNode === linkNode) {\n              attrs = templateAttrs;\n              $element = /** @type {NodeRef} */ (templateAttrs._nodeRef);\n            } else {\n              $element = new NodeRef(linkNode);\n              attrs = new Attributes(\n                $animate,\n                $exceptionHandler,\n                $sce,\n                $element,\n                templateAttrs,\n              );\n            }\n\n            controllerScope = scope;\n\n            if (_newIsolateScopeDirective) {\n              isolateScope = scope.$newIsolate();\n            } else if (_newScopeDirective) {\n              controllerScope = scope.$parent;\n            }\n            controllerScope = /** @type {ng.Scope} */ (\n              controllerScope || scope\n            );\n\n            if (boundTranscludeFn) {\n              // track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`\n              // is later passed as `_parentBoundTranscludeFn` to `publicLinkFn`\n              /** @type {any} */\n              const newTrancludeFn = /** @type {any} */ (\n                controllersBoundTransclude\n              );\n\n              newTrancludeFn._boundTransclude = boundTranscludeFn;\n              // expose the slots on the `$transclude` function\n              newTrancludeFn.isSlotFilled = function (\n                /** @type {string | number} */ slotName,\n              ) {\n                return !!boundTranscludeFn._slots[slotName];\n              };\n              transcludeFn = newTrancludeFn;\n            }\n\n            const controllerDirectives = _controllerDirectives || nullObject();\n\n            if (_controllerDirectives) {\n              elementControllers = setupControllers(\n                $element,\n                attrs,\n                /** @type {ng.TranscludeFn} */ (transcludeFn),\n                _controllerDirectives,\n                /** @type {ng.Scope} */ (isolateScope || scope),\n                scope,\n                _newIsolateScopeDirective,\n              );\n            }\n\n            if (_newIsolateScopeDirective && isolateScope) {\n              isolateScope.$target._isolateBindings = /** @type {any} */ (\n                _newIsolateScopeDirective\n              )._isolateBindings;\n              scopeBindingInfo = initializeDirectiveBindings(\n                scope,\n                attrs,\n                isolateScope,\n                isolateScope._isolateBindings,\n                _newIsolateScopeDirective,\n              );\n\n              if (scopeBindingInfo.removeWatches) {\n                isolateScope.$on(\"$destroy\", scopeBindingInfo.removeWatches);\n              }\n            }\n\n            // Initialize bindToController bindings\n            for (const name in elementControllers) {\n              const controllerDirective = controllerDirectives[name];\n\n              const controller = elementControllers[name];\n\n              const bindings = /** @type {any} */ (controllerDirective)\n                ._bindings.bindToController;\n\n              // Controller instance is bound to the scope\n              const controllerInstance = controller();\n\n              controller.instance = controllerScope.$new(controllerInstance);\n              setCacheData(\n                $element.node,\n                `$${controllerDirective.name}Controller`,\n                controller.instance,\n              );\n              controller.bindingInfo = initializeDirectiveBindings(\n                /** @type {ng.Scope} */ (controllerScope),\n                attrs,\n                controller.instance,\n                bindings,\n                controllerDirective,\n              );\n            }\n\n            // Bind the required controllers to the controller, if `require` is an object and `bindToController` is truthy\n            if (_controllerDirectives) {\n              entries(controllerDirectives).forEach(\n                ([name, controllerDirective]) => {\n                  const { require } = controllerDirective;\n\n                  if (\n                    controllerDirective.bindToController &&\n                    !isArray(require) &&\n                    isObject(require)\n                  ) {\n                    extend(\n                      elementControllers[name].instance,\n                      getControllers(\n                        name,\n                        require,\n                        $element.element,\n                        elementControllers,\n                      ),\n                    );\n                  }\n                },\n              );\n            }\n\n            // Handle the init and destroy lifecycle hooks on all controllers that have them\n            if (elementControllers) {\n              Object.values(elementControllers).forEach((controller) => {\n                const controllerInstance = controller.instance;\n\n                if (isFunction(controllerInstance.$onChanges)) {\n                  try {\n                    controllerInstance.$onChanges(\n                      controller.bindingInfo.initialChanges,\n                    );\n                  } catch (err) {\n                    $exceptionHandler(err);\n                  }\n                }\n\n                if (isFunction(controllerInstance.$onInit)) {\n                  try {\n                    controllerInstance.$target.$onInit();\n                  } catch (err) {\n                    $exceptionHandler(err);\n                  }\n                }\n\n                if (isFunction(controllerInstance.$onDestroy)) {\n                  /** @type {ng.Scope} */ (controllerScope).$on(\n                    \"$destroy\",\n                    () => {\n                      controllerInstance.$onDestroy();\n                    },\n                  );\n                }\n              });\n            }\n\n            // PRELINKING\n            for (i = 0, ii = preLinkFns.length; i < ii; i++) {\n              const preLinkFn = /** @type {any} */ (preLinkFns[i]);\n\n              const controllers =\n                preLinkFn.require &&\n                getControllers(\n                  preLinkFn.directiveName,\n                  preLinkFn.require,\n                  $element.element,\n                  elementControllers,\n                );\n\n              // invoke link function\n              try {\n                preLinkFn(\n                  preLinkFn.isolateScope ? isolateScope : scope,\n                  $element.node, // Prelink functions accept a Node\n                  attrs,\n                  controllers,\n                  transcludeFn,\n                );\n              } catch (err) {\n                $exceptionHandler(err);\n              }\n            }\n\n            // RECURSION\n            // We only pass the isolate scope, if the isolate directive has a template,\n            // otherwise the child elements do not belong to the isolate directive.\n\n            if (\n              _newIsolateScopeDirective &&\n              (_newIsolateScopeDirective.template ||\n                _newIsolateScopeDirective.templateUrl === null)\n            ) {\n              scopeToChild = isolateScope || scope;\n            }\n\n            if (\n              childLinkFn &&\n              linkNode &&\n              linkNode.childNodes &&\n              linkNode.childNodes.length\n            ) {\n              childLinkFn(\n                scopeToChild,\n                new NodeRef(linkNode.childNodes),\n                boundTranscludeFn,\n              );\n            }\n\n            // POSTLINKING\n            for (i = postLinkFns.length - 1; i >= 0; i--) {\n              const postLinkFn = /** @type {any} */ (postLinkFns[i]);\n\n              const controllers =\n                postLinkFn.require &&\n                getControllers(\n                  postLinkFn.directiveName,\n                  postLinkFn.require,\n                  /** @type {Element} */ ($element.node),\n                  elementControllers,\n                );\n\n              // invoke link function\n              try {\n                if (postLinkFn.isolateScope && isolateScope) {\n                  setIsolateScope($element.element, isolateScope);\n                }\n\n                postLinkFn(\n                  postLinkFn.isolateScope ? isolateScope : scope,\n                  $element.node,\n                  attrs,\n                  controllers,\n                  transcludeFn,\n                );\n              } catch (err) {\n                $exceptionHandler(err);\n              }\n            }\n\n            if (elementControllers) {\n              // Trigger $postLink lifecycle hooks\n              Object.values(elementControllers).forEach((controller) => {\n                const controllerInstance = controller.instance;\n\n                if (isFunction(controllerInstance.$postLink)) {\n                  controllerInstance.$postLink();\n                }\n              });\n            }\n\n            // This is the function that is injected as `$transclude` or\n            // the fifth parameter to the link function.\n            // Example: function link (scope, element, attrs, ctrl, transclude) {}\n            // Note: all arguments are optional!\n            /**\n             * @param {import(\"../scope/scope.js\").Scope | import(\"./interface.ts\").CloneAttachFn | undefined} scopeParam\n             * @param {import(\"./interface.ts\").CloneAttachFn | Node | null | undefined} cloneAttachFn\n             * @param {Node | null | undefined} _futureParentElement\n             * @param {string | number | undefined} slotName\n             */\n            function controllersBoundTransclude(\n              scopeParam,\n              cloneAttachFn,\n              _futureParentElement,\n              slotName,\n            ) {\n              let transcludeControllers;\n\n              // No scope passed in:\n              if (!isScope(scopeParam)) {\n                slotName = /** @type {string | number | undefined} */ (\n                  _futureParentElement\n                );\n                _futureParentElement = /** @type {Node | null | undefined} */ (\n                  cloneAttachFn\n                );\n                cloneAttachFn =\n                  /** @type {import(\"./interface.ts\").CloneAttachFn | undefined} */ (\n                    scopeParam\n                  );\n                scopeParam = undefined;\n              }\n\n              if (hasElementTranscludeDirective) {\n                transcludeControllers = elementControllers;\n              }\n\n              if (!_futureParentElement) {\n                _futureParentElement = hasElementTranscludeDirective\n                  ? $element.node.parentElement\n                  : $element.node;\n              }\n\n              if (!boundTranscludeFn) {\n                return undefined;\n              }\n\n              if (slotName) {\n                // slotTranscludeFn can be one of three things:\n                //  * a transclude function - a filled slot\n                //  * `null` - an optional slot that was not filled\n                //  * `undefined` - a slot that was not declared (i.e. invalid)\n                const slotTranscludeFn = boundTranscludeFn._slots[slotName];\n\n                if (slotTranscludeFn) {\n                  return slotTranscludeFn(\n                    /** @type {ng.Scope | null | undefined} */ (scopeParam),\n                    /** @type {CloneAttachFn | undefined} */ (cloneAttachFn),\n                    transcludeControllers,\n                    _futureParentElement,\n                    scopeToChild,\n                  );\n                }\n\n                if (isUndefined(slotTranscludeFn)) {\n                  throw $compileMinErr(\n                    \"noslot\",\n                    'No parent directive that requires a transclusion with slot name \"{0}\". ' +\n                      \"Element: {1}\",\n                    slotName,\n                    startingTag($element.element),\n                  );\n                }\n\n                return undefined;\n              } else {\n                return boundTranscludeFn(\n                  /** @type {ng.Scope | null | undefined} */ (scopeParam),\n                  /** @type {CloneAttachFn | undefined} */ (cloneAttachFn),\n                  transcludeControllers,\n                  _futureParentElement,\n                  scopeToChild,\n                );\n              }\n            }\n          };\n\n          // executes all directives on the current element\n          for (let i = 0, ii = directives.length; i < ii; i++) {\n            directive = directives[i];\n            const directivePriority = directive.priority || 0;\n\n            if (terminalPriority > directivePriority) {\n              break; // prevent further processing of directives\n            }\n\n            directiveValue = directive.scope;\n\n            if (directiveValue) {\n              // skip the check for directives with async templates, we'll check the derived sync\n              // directive when the template arrives\n              if (!directive.templateUrl) {\n                if (isObject(directiveValue)) {\n                  // This directive is trying to add an isolated scope.\n                  // Check that there is no scope of any kind already\n                  assertNoDuplicate(\n                    \"new/isolated scope\",\n                    /** @type {any} */ (\n                      _newIsolateScopeDirective || _newScopeDirective\n                    ),\n                    directive,\n                    compileNodeRef,\n                  );\n                  _newIsolateScopeDirective = directive;\n                } else {\n                  // This directive is trying to add a child scope.\n                  // Check that there is no isolated scope already\n                  assertNoDuplicate(\n                    \"new/isolated scope\",\n                    /** @type {any} */ (_newIsolateScopeDirective),\n                    directive,\n                    compileNodeRef,\n                  );\n                }\n              }\n\n              _newScopeDirective = _newScopeDirective || directive;\n            }\n\n            directiveName = directive.name || \"\";\n\n            // If we encounter a condition that can result in transclusion on the directive,\n            // then scan ahead in the remaining directives for others that may cause a multiple\n            // transclusion error to be thrown during the compilation process.  If a matching directive\n            // is found, then we know that when we encounter a transcluded directive, we need to eagerly\n            // compile the `transclude` function rather than doing it lazily in order to throw\n            // exceptions at the correct time\n            const hasReplacedTemplate =\n              directive.replace &&\n              (directive.templateUrl || directive.template);\n\n            const shouldTransclude =\n              directive.transclude &&\n              !EXCLUDED_DIRECTIVES.includes(directiveName);\n\n            if (\n              !didScanForMultipleTransclusion &&\n              (hasReplacedTemplate || shouldTransclude)\n            ) {\n              let candidateDirective;\n\n              for (\n                let scanningIndex = i + 1;\n                (candidateDirective = directives[scanningIndex++]);\n              ) {\n                if (\n                  (candidateDirective.transclude &&\n                    !EXCLUDED_DIRECTIVES.includes(\n                      candidateDirective.name || \"\",\n                    )) ||\n                  (candidateDirective.replace &&\n                    (candidateDirective.templateUrl ||\n                      candidateDirective.template))\n                ) {\n                  mightHaveMultipleTransclusionError = true;\n                  break;\n                }\n              }\n\n              didScanForMultipleTransclusion = true;\n            }\n\n            if (!directive.templateUrl && directive.controller) {\n              _controllerDirectives = _controllerDirectives || nullObject();\n              assertNoDuplicate(\n                `'${directiveName}' controller`,\n                /** @type {any} */ (_controllerDirectives[directiveName]),\n                directive,\n                compileNodeRef,\n              );\n              _controllerDirectives[directiveName] = directive;\n            }\n\n            directiveValue = directive.transclude;\n\n            if (directiveValue) {\n              hasTranscludeDirective = true;\n\n              // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.\n              // This option should only be used by directives that know how to safely handle element transclusion,\n              // where the transcluded nodes are added or replaced after linking.\n              if (!EXCLUDED_DIRECTIVES.includes(directiveName)) {\n                assertNoDuplicate(\n                  \"transclusion\",\n                  /** @type {any} */ (_nonTlbTranscludeDirective),\n                  directive,\n                  compileNodeRef,\n                );\n                _nonTlbTranscludeDirective = directive;\n              }\n\n              if (directiveValue === \"element\") {\n                hasElementTranscludeDirective = true;\n                terminalPriority = directivePriority;\n                $template = compileNodeRef;\n                compileNodeRef = new NodeRef(document.createComment(\"\"));\n                templateAttrs._nodeRef = compileNodeRef;\n                compileNode = compileNodeRef.node;\n\n                if (ctxNodeRef) {\n                  ctxNodeRef.node = compileNode;\n                }\n                replaceWith(\n                  new NodeRef(/** @type {Element} */ ($template._element)),\n                  compileNode,\n                  index,\n                );\n\n                childTranscludeFn = compilationGenerator(\n                  mightHaveMultipleTransclusionError,\n                  /** @type {Element} */ ($template._element),\n                  transcludeFn,\n                  terminalPriority,\n                  replaceDirective ? replaceDirective.name : undefined,\n                  {\n                    // Don't pass in:\n                    // - _controllerDirectives - otherwise we'll create duplicates controllers\n                    // - _newIsolateScopeDirective or _templateDirective - combining templates with\n                    //   element transclusion doesn't make sense.\n                    //\n                    // We need only _nonTlbTranscludeDirective so that we prevent putting transclusion\n                    // on the same element more than once.\n                    _nonTlbTranscludeDirective,\n                  },\n                );\n              } else {\n                const slots = nullObject();\n\n                /** @type {NodeList | DocumentFragment} */\n                let nodes;\n\n                if (!isObject(directiveValue)) {\n                  //\n                  // Clone childnodes before clearing contents on transcluded directives\n                  nodes = compileNode.cloneNode(true).childNodes;\n                } else {\n                  // We have transclusion slots,\n                  // collect them up, compile them and store their transclusion functions\n                  nodes = document.createDocumentFragment();\n\n                  const slotMap = nullObject();\n\n                  const filledSlots = nullObject();\n\n                  // Parse the element selectors\n                  entries(directiveValue).forEach(\n                    ([slotName, elementSelector]) => {\n                      // If an element selector starts with a ? then it is optional\n                      const optional = elementSelector.charAt(0) === \"?\";\n\n                      elementSelector = optional\n                        ? elementSelector.substring(1)\n                        : elementSelector;\n\n                      slotMap[elementSelector] = slotName;\n\n                      // We explicitly assign `null` since this implies that a slot was defined but not filled.\n                      // Later when calling boundTransclusion functions with a slot name we only error if the\n                      // slot is `undefined`\n                      slots[slotName] = null;\n\n                      // filledSlots contains `true` for all slots that are either optional or have been\n                      // filled. This is used to check that we have not missed any required slots\n                      filledSlots[slotName] = optional;\n                    },\n                  );\n\n                  // Add the matching elements into their slot\n                  compileNodeRef.element.childNodes.forEach((node) => {\n                    const slotName =\n                      slotMap[\n                        directiveNormalize(\n                          getNodeName(/** @type {Element} */ (node)),\n                        )\n                      ];\n\n                    if (slotName) {\n                      filledSlots[slotName] = true;\n                      slots[slotName] =\n                        slots[slotName] || document.createDocumentFragment();\n                      slots[slotName].appendChild(node);\n                    } else {\n                      /** @type {DocumentFragment} */ (nodes).appendChild(node);\n                    }\n                  });\n\n                  // Check for required slots that were not filled\n                  entries(filledSlots).forEach(([slotName, filled]) => {\n                    if (!filled) {\n                      throw $compileMinErr(\n                        \"reqslot\",\n                        \"Required transclusion slot `{0}` was not filled.\",\n                        slotName,\n                      );\n                    }\n                  });\n\n                  for (const slotName in slots) {\n                    if (slots[slotName]) {\n                      // Only define a transclusion function if the slot was filled\n                      const slotCompileNodes = slots[slotName].childNodes;\n\n                      slots[slotName] = compilationGenerator(\n                        mightHaveMultipleTransclusionError,\n                        slotCompileNodes,\n                        transcludeFn,\n                        undefined,\n                        undefined,\n                        previousCompileContext,\n                      );\n                    }\n                  }\n\n                  nodes = nodes.childNodes;\n                }\n\n                emptyElement(/** @type {Element} */ (compileNode)); // clear contents on transcluded directives\n\n                // lazily compile transcluded template and generate a transcluded link function\n\n                childTranscludeFn = compilationGenerator(\n                  mightHaveMultipleTransclusionError,\n                  nodes,\n                  transcludeFn,\n                  undefined,\n                  undefined,\n                  {\n                    needsNewScope:\n                      /** @type {any} */ (directive)._isolateScope ||\n                      /** @type {any} */ (directive)._newScope,\n                  },\n                );\n                /** @type {import(\"./interface.ts\").TranscludeFn} */ (\n                  childTranscludeFn\n                )._slots = slots;\n              }\n            }\n\n            if (directive.template) {\n              hasTemplate = true;\n              assertNoDuplicate(\n                \"template\",\n                /** @type {any} */ (_templateDirective),\n                directive,\n                compileNodeRef,\n              );\n              _templateDirective = directive;\n\n              directiveValue = isFunction(directive.template)\n                ? directive.template(\n                    /** @type {HTMLElement} */ (compileNodeRef.node),\n                    templateAttrs,\n                  )\n                : directive.template;\n\n              directiveValue = denormalizeTemplate(directiveValue);\n\n              if (directive.replace) {\n                replaceDirective = directive;\n\n                if (isTextNode(directiveValue)) {\n                  $template = [];\n                } else {\n                  $template = wrapTemplate(\n                    directive.templateNamespace,\n                    trim(directiveValue),\n                  );\n                }\n\n                if (isString($template)) {\n                  $template = Array.from(\n                    createNodelistFromHTML($template),\n                  ).filter((x) => x.nodeType === NodeType._ELEMENT_NODE);\n                }\n                compileNode = $template[0];\n\n                if (\n                  $template.length !== 1 ||\n                  compileNode.nodeType !== NodeType._ELEMENT_NODE\n                ) {\n                  throw $compileMinErr(\n                    \"tplrt\",\n                    \"Template for directive '{0}' must have exactly one root element. {1}\",\n                    directiveName,\n                    \"\",\n                  );\n                }\n\n                replaceWith(compileNodeRef, compileNode);\n\n                if (parentNodeRef && index !== undefined) {\n                  /** @type {NodeRef} */ (parentNodeRef)._setIndex(\n                    index,\n                    compileNode,\n                  );\n                }\n\n                /** @type {Attributes} */\n                const newTemplateAttrs = /** @type {any} */ ({ $attr: {} });\n\n                // combine directives from the original node and from the template:\n                // - take the array of directives for this element\n                // - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)\n                // - collect directives from the template and sort them by priority\n                // - combine directives as: processed + template + unprocessed\n                const _templateDirectives = collectDirectives(\n                  /** @type {Element} */ (compileNode),\n                  newTemplateAttrs,\n                );\n\n                const unprocessedDirectives = directives.splice(\n                  i + 1,\n                  directives.length - (i + 1),\n                );\n\n                if (_newIsolateScopeDirective || _newScopeDirective) {\n                  // The original directive caused the current element to be replaced but this element\n                  // also needs to have a new scope, so we need to tell the template directives\n                  // that they would need to get their scope from further up, if they require transclusion\n                  markDirectiveScope(\n                    _templateDirectives,\n                    _newIsolateScopeDirective,\n                    _newScopeDirective,\n                  );\n                }\n                directives = directives\n                  .concat(_templateDirectives)\n                  .concat(unprocessedDirectives);\n\n                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);\n\n                ii = directives.length;\n              } else {\n                if (compileNodeRef._isElement()) {\n                  compileNodeRef.element.innerHTML = directiveValue;\n                }\n              }\n            }\n\n            if (directive.templateUrl) {\n              hasTemplate = true;\n              assertNoDuplicate(\n                \"template\",\n                /** @type {any} */ (_templateDirective),\n                directive,\n                compileNodeRef,\n              );\n              _templateDirective = directive;\n\n              if (directive.replace) {\n                replaceDirective = directive;\n              }\n\n              nodeLinkFn = /** @type {ng.NodeLinkFn} */ (\n                compileTemplateUrl(\n                  directives.splice(i, directives.length - i),\n                  compileNodeRef,\n                  templateAttrs,\n                  /** @type {Element} */ (compileNode),\n                  hasTranscludeDirective && childTranscludeFn,\n                  preLinkFns,\n                  postLinkFns,\n                  {\n                    index,\n                    _controllerDirectives,\n                    _newScopeDirective:\n                      _newScopeDirective !== directive && _newScopeDirective,\n                    _newIsolateScopeDirective,\n                    _templateDirective,\n                    _nonTlbTranscludeDirective,\n                    _futureParentElement:\n                      previousCompileContext._futureParentElement,\n                  },\n                )\n              );\n              ii = directives.length;\n            } else if (directive.compile) {\n              try {\n                /** @type {any} */\n                const linkFn = directive.compile(\n                  /** @type {HTMLElement} */ (compileNodeRef._getAny()),\n                  templateAttrs,\n                  childTranscludeFn,\n                );\n\n                const context = directive._originalDirective || directive;\n\n                if (isFunction(linkFn)) {\n                  addLinkFns(null, bind(context, linkFn));\n                } else if (linkFn) {\n                  addLinkFns(\n                    bind(context, /** @type {ng.PublicLinkFn} */ (linkFn).pre),\n                    bind(context, /** @type {ng.PublicLinkFn} */ (linkFn).post),\n                  );\n                }\n              } catch (err) {\n                $exceptionHandler(err);\n              }\n            }\n\n            if (directive.terminal) {\n              terminal = true;\n              terminalPriority = Math.max(terminalPriority, directivePriority);\n            }\n          }\n\n          previousCompileContext.hasElementTranscludeDirective =\n            hasElementTranscludeDirective;\n\n          // might be normal or delayed nodeLinkFn depending on if templateUrl is present\n          return {\n            nodeLinkFn,\n            terminal,\n            transclude: childTranscludeFn,\n            transcludeOnThisElement: hasTranscludeDirective,\n            templateOnThisElement: hasTemplate,\n            newScope: !!(\n              _newScopeDirective && _newScopeDirective.scope === true\n            ),\n          };\n\n          /// /////////////////\n          /**\n           * @param {any | null} pre\n           * @param {any | null} post\n           */\n          function addLinkFns(pre, post) {\n            if (pre) {\n              pre.require = directive.require;\n              pre.directiveName = directiveName;\n\n              if (\n                _newIsolateScopeDirective === directive ||\n                directive._isolateScope\n              ) {\n                pre = cloneAndAnnotateFn(pre, { isolateScope: true });\n              }\n              /** @type {any[]} */ (preLinkFns).push(/** @type {any} */ (pre));\n            }\n\n            if (post) {\n              post.require = directive.require;\n              post.directiveName = directiveName;\n\n              if (\n                _newIsolateScopeDirective === directive ||\n                directive._isolateScope\n              ) {\n                post = cloneAndAnnotateFn(post, { isolateScope: true });\n              }\n              /** @type {any[]} */ (postLinkFns).push(\n                /** @type {any} */ (post),\n              );\n            }\n          }\n        }\n\n        /**\n         *\n         * @param {string} directiveName\n         * @param {string | Array<any> | Record<string, any>} require\n         * @param {Element | undefined} $element\n         * @param {*} elementControllers\n         * @returns {any}\n         */\n        function getControllers(\n          directiveName,\n          require,\n          $element,\n          elementControllers,\n        ) {\n          /** @type {any} */\n          let value;\n\n          if (isString(require)) {\n            const match = /** @type {RegExpMatchArray} */ (\n              require.match(REQUIRE_PREFIX_REGEXP)\n            );\n\n            const name = require.substring(match[0].length);\n\n            const inheritType = match[1] || match[3];\n\n            const optional = match[2] === \"?\";\n\n            // If only parents then start at the parent element\n            if (inheritType === \"^^\") {\n              if ($element && $element.parentElement) {\n                $element = $element.parentElement;\n              } else {\n                $element = undefined;\n              }\n              // Otherwise attempt getting the controller from elementControllers in case\n              // the element is transcluded (and has no data) and to avoid .data if possible\n            } else {\n              value = elementControllers && elementControllers[name];\n              value = value && value.instance;\n            }\n\n            if (!value) {\n              const dataName = `$${name}Controller`;\n\n              if (\n                inheritType === \"^^\" &&\n                $element &&\n                $element.nodeType === NodeType._DOCUMENT_NODE\n              ) {\n                // inheritedData() uses the documentElement when it finds the document, so we would\n                // require from the element itself.\n                value = null;\n              } else {\n                value = $element\n                  ? inheritType\n                    ? getInheritedData($element, dataName)\n                    : getCacheData($element, dataName)\n                  : undefined;\n              }\n            }\n\n            if (!value && !optional) {\n              throw $compileMinErr(\n                \"ctreq\",\n                \"Controller '{0}', required by directive '{1}', can't be found!\",\n                name,\n                directiveName,\n              );\n            }\n          } else if (isArray(require)) {\n            value = [];\n\n            for (let i = 0, ii = require.length; i < ii; i++) {\n              value[i] = getControllers(\n                directiveName,\n                require[i],\n                $element,\n                elementControllers,\n              );\n            }\n          } else if (isObject(require)) {\n            value = {};\n            entries(require).forEach(([property, controller]) => {\n              value[property] = getControllers(\n                directiveName,\n                controller,\n                $element,\n                elementControllers,\n              );\n            });\n          }\n\n          return value || null;\n        }\n\n        /**\n         * @param {NodeRef} $element\n         * @param {Attributes} attrs\n         * @param {ng.TranscludeFn} transcludeFn\n         * @param {{ [x: string]: any; }} _controllerDirectives\n         * @param {ng.Scope} isolateScope\n         * @param {ng.Scope} scope\n         * @param {any} _newIsolateScopeDirective\n         * @returns {any}\n         */\n        function setupControllers(\n          $element,\n          attrs,\n          transcludeFn,\n          _controllerDirectives,\n          isolateScope,\n          scope,\n          _newIsolateScopeDirective,\n        ) {\n          const elementControllers = nullObject();\n\n          for (const controllerKey in _controllerDirectives) {\n            const directive = _controllerDirectives[controllerKey];\n\n            const locals = {\n              $scope:\n                directive === _newIsolateScopeDirective ||\n                directive._isolateScope\n                  ? isolateScope\n                  : scope,\n              $element: /** @type {any} */ ($element.node),\n              $attrs: attrs,\n              $transclude: transcludeFn,\n            };\n\n            let { controller } = directive;\n\n            if (controller === \"@\") {\n              controller = /** @type {any} */ (attrs)[directive.name];\n            }\n\n            const controllerInstance = $controller(\n              controller,\n              locals,\n              true,\n              directive.controllerAs,\n            );\n\n            // For directives with element transclusion the element is a comment.\n            // In this case .data will not attach any data.\n            // Instead, we save the controllers for the element in a local hash and attach to .data\n            // later, once we have the actual element.\n            elementControllers[directive.name] = controllerInstance;\n\n            if ($element._isElement()) {\n              setCacheData(\n                $element.element,\n                `$${directive.name}Controller`,\n                controllerInstance.instance,\n              );\n            }\n          }\n\n          return elementControllers;\n        }\n\n        // Depending upon the context in which a directive finds itself it might need to have a new isolated\n        // or child scope created. For instance:\n        // * if the directive has been pulled into a template because another directive with a higher priority\n        // asked for element transclusion\n        // * if the directive itself asks for transclusion but it is at the root of a template and the original\n        // element was replaced. See https://github.com/angular/angular.js/issues/12936\n        /**\n         * @param {any[]} directives\n         * @param {any} isolateScope\n         * @param {any} [newScope]\n         */\n        function markDirectiveScope(directives, isolateScope, newScope) {\n          for (let j = 0, jj = directives.length; j < jj; j++) {\n            directives[j] = inherit(directives[j], {\n              _isolateScope: isolateScope,\n              _newScope: newScope,\n            });\n          }\n        }\n\n        /**\n         * looks up the directive and decorates it with exception handling and proper parameters. We\n         * call this the boundDirective.\n         * @param {string} name name of the directive to look up.\n         * @param {string} location The directive must be found in specific format.\n        String containing any of these characters:\n        \n        * `E`: element name\n        * `A': attribute\n         * @returns {InternalDirective | false} true if directive was added.\n         * @param {InternalDirective[]} tDirectives\n         * @param {number | undefined} maxPriority\n         */\n        function addDirective(tDirectives, name, location, maxPriority) {\n          /** @type {InternalDirective | false} */\n          let match = false;\n\n          const maxPriorityValue = isUndefined(maxPriority)\n            ? Number.MAX_VALUE\n            : /** @type {number} */ (maxPriority);\n\n          if (hasOwn(hasDirectives, name)) {\n            for (\n              let directive,\n                directives = $injector.get(name + DirectiveSuffix),\n                i = 0,\n                ii = directives.length;\n              i < ii;\n              i++\n            ) {\n              directive = directives[i];\n\n              if (\n                maxPriorityValue > (directive.priority || 0) &&\n                directive.restrict.indexOf(location) !== -1\n              ) {\n                if (!directive._bindings) {\n                  const bindings = (directive._bindings =\n                    parseDirectiveBindings(directive, directive.name));\n\n                  if (isObject(bindings.isolateScope)) {\n                    directive._isolateBindings = bindings.isolateScope;\n                  }\n                }\n                tDirectives.push(directive);\n                match = directive;\n              }\n            }\n          }\n\n          return match;\n        }\n\n        /**\n         * When the element is replaced with HTML template then the new attributes\n         * on the template need to be merged with the existing attributes in the DOM.\n         * The desired effect is to have both of the attributes present.\n         *\n         * @param {Attributes} dst destination attributes (original DOM)\n         * @param {Attributes} src source attributes (from the directive template)\n         */\n        function mergeTemplateAttributes(dst, src) {\n          const dstAny = /** @type {any} */ (dst);\n\n          const srcAny = /** @type {any} */ (src);\n\n          const srcAttr = src.$attr;\n\n          const dstAttr = dst.$attr;\n\n          // reapply the old attributes to the new element\n          entries(dstAny).forEach(([key, value]) => {\n            if (key[0] !== \"$\" && key[0] !== \"_\") {\n              if (srcAny[key] && srcAny[key] !== value) {\n                if (value.length) {\n                  value += (key === \"style\" ? \";\" : \" \") + srcAny[key];\n                } else {\n                  value = srcAny[key];\n                }\n              }\n              dst.$set(key, value, true, srcAttr[key]);\n            }\n          });\n\n          // copy the new attributes on the old attrs object\n          entries(srcAny).forEach(([key, value]) => {\n            // Check if we already set this attribute in the loop above.\n            // `dst` will never contain hasOwnProperty as DOM parser won't let it.\n            // You will get an \"InvalidCharacterError: DOM Exception 5\" error if you\n            // have an attribute like \"has-own-property\" or \"data-has-own-property\", etc.\n            if (!hasOwn(dst, key) && key.charAt(0) !== \"$\") {\n              dstAny[key] = value;\n\n              if (key !== \"class\" && key !== \"style\") {\n                dstAttr[key] = srcAttr[key];\n              }\n            }\n          });\n        }\n\n        /**\n         *\n         * @param {InternalDirective[]} directives\n         * @param {NodeRef} $compileNode\n         * @param {Attributes} tAttrs\n         * @param {any} $rootElement\n         * @param {*} childTranscludeFn\n         * @param {Array<any>} preLinkFns\n         * @param {Array<any>} postLinkFns\n         * @param {*} previousCompileContext\n         * @returns\n         */\n        function compileTemplateUrl(\n          directives,\n          $compileNode,\n          tAttrs,\n          $rootElement,\n          childTranscludeFn,\n          preLinkFns,\n          postLinkFns,\n          previousCompileContext,\n        ) {\n          /**\n           * @type {any[] | null}\n           */\n          let linkQueue = [];\n\n          /** @type {any} */\n          let afterTemplateNodeLinkFn;\n\n          /**\n           * @type {CompositeLinkFn | null}\n           */\n          let afterTemplateChildLinkFn = null;\n\n          let afterTemplateNodeLinkFnCtx;\n\n          const beforeTemplateCompileNode = $compileNode._getAny();\n\n          const origAsyncDirective = /** @type {InternalDirective} */ (\n            directives.shift()\n          );\n\n          const derivedSyncDirective = /** @type {InternalDirective} */ (\n            inherit(origAsyncDirective, {\n              templateUrl: null,\n              transclude: null,\n              replace: null,\n              _originalDirective: origAsyncDirective,\n            })\n          );\n\n          /** @type {string} */\n          let templateUrl;\n\n          if (isFunction(origAsyncDirective.templateUrl)) {\n            templateUrl =\n              /** @type { ((element: Element, tAttrs: Attributes) => string) } */ (\n                origAsyncDirective.templateUrl\n              )($compileNode.element, tAttrs);\n          } else {\n            // eslint-disable-next-line prefer-destructuring\n            templateUrl = /** @type {string} */ (\n              origAsyncDirective.templateUrl\n            );\n          }\n          const { templateNamespace } = origAsyncDirective;\n\n          emptyElement($compileNode.element);\n\n          $templateRequest(templateUrl)\n            .then((content) => {\n              /** @type {Element} */\n              let compileNode;\n\n              let tempTemplateAttrs;\n\n              let $template;\n\n              let childBoundTranscludeFn;\n\n              content = denormalizeTemplate(content);\n\n              if (origAsyncDirective.replace) {\n                if (isTextNode(content)) {\n                  $template = [];\n                } else if (isString(content)) {\n                  $template = Array.from(\n                    createNodelistFromHTML(content),\n                  ).filter(\n                    (node) =>\n                      node.nodeType !== NodeType._COMMENT_NODE &&\n                      node.nodeType !== NodeType._TEXT_NODE,\n                  );\n                } else {\n                  $template = wrapTemplate(templateNamespace, trim(content));\n                }\n                compileNode = $template[0];\n\n                if (\n                  $template.length !== 1 ||\n                  compileNode.nodeType !== NodeType._ELEMENT_NODE\n                ) {\n                  throw $compileMinErr(\n                    \"tplrt\",\n                    \"Template for directive '{0}' must have exactly one root element. {1}\",\n                    origAsyncDirective.name,\n                    templateUrl,\n                  );\n                }\n\n                /** @type {Attributes} */\n                tempTemplateAttrs = /** @type {any} */ ({ $attr: {} });\n\n                replaceWith(\n                  $compileNode,\n                  compileNode,\n                  previousCompileContext.index,\n                );\n\n                const _templateDirectives = collectDirectives(\n                  compileNode,\n                  tempTemplateAttrs,\n                );\n\n                if (isObject(origAsyncDirective.scope)) {\n                  // the original directive that caused the template to be loaded async required\n                  // an isolate scope\n                  markDirectiveScope(_templateDirectives, true);\n                }\n                directives = _templateDirectives.concat(directives);\n\n                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);\n              } else {\n                compileNode = /** @type {Element} */ (\n                  beforeTemplateCompileNode\n                );\n                $compileNode.element.innerHTML = content;\n              }\n\n              directives.unshift(derivedSyncDirective);\n              afterTemplateNodeLinkFnCtx = applyDirectivesToNode(\n                directives,\n                compileNode,\n                tAttrs,\n                childTranscludeFn,\n                origAsyncDirective,\n                preLinkFns,\n                postLinkFns,\n                { ...previousCompileContext, ctxNodeRef: $compileNode },\n              );\n\n              afterTemplateNodeLinkFn = afterTemplateNodeLinkFnCtx?.nodeLinkFn;\n\n              if ($rootElement) {\n                entries($rootElement).forEach(([i, node]) => {\n                  if (node === compileNode) {\n                    $rootElement[i] = $compileNode;\n                  }\n                });\n              }\n              afterTemplateChildLinkFn = compileNodes(\n                new NodeRef($compileNode._getAny().childNodes),\n                childTranscludeFn,\n              );\n\n              while (linkQueue && linkQueue.length) {\n                const scope = /** @type {ng.Scope | undefined} */ (\n                  linkQueue.shift()\n                );\n\n                const beforeTemplateLinkNode = /** @type {any} */ (\n                  linkQueue.shift()\n                );\n\n                const boundTranscludeFn =\n                  /** @type {BoundTranscludeFn | null | undefined} */ (\n                    linkQueue.shift()\n                  );\n\n                if (!scope) {\n                  continue;\n                }\n\n                let linkNode = $compileNode._getAny();\n\n                if (scope._destroyed) {\n                  continue;\n                }\n\n                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {\n                  const oldClasses = beforeTemplateLinkNode.className;\n\n                  if (\n                    !(\n                      previousCompileContext.hasElementTranscludeDirective &&\n                      origAsyncDirective.replace\n                    )\n                  ) {\n                    // it was cloned therefore we have to clone as well.\n                    linkNode = compileNode.cloneNode(true);\n                    beforeTemplateLinkNode.appendChild(linkNode);\n                  }\n\n                  // Copy in CSS classes from original node\n                  try {\n                    if (oldClasses !== \"\") {\n                      $compileNode.element.classList.forEach((cls) =>\n                        beforeTemplateLinkNode.classList.add(cls),\n                      );\n                    }\n                  } catch {\n                    // ignore, since it means that we are trying to set class on\n                    // SVG element, where class name is read-only.\n                  }\n                }\n\n                if (afterTemplateNodeLinkFnCtx.transcludeOnThisElement) {\n                  childBoundTranscludeFn = createBoundTranscludeFn(\n                    scope,\n                    /** @type {ng.TranscludeFn} */ (\n                      afterTemplateNodeLinkFnCtx.transclude\n                    ),\n                    boundTranscludeFn,\n                  );\n                } else {\n                  childBoundTranscludeFn = boundTranscludeFn;\n                }\n\n                afterTemplateNodeLinkFn(\n                  /** @type {CompositeLinkFn | null} */ (\n                    afterTemplateChildLinkFn\n                  ),\n                  scope,\n                  linkNode,\n                  childBoundTranscludeFn,\n                );\n              }\n              linkQueue = null;\n            })\n            .catch((error) => {\n              if (isError(error)) {\n                $exceptionHandler(error);\n              } else {\n                $exceptionHandler(new Error(error));\n              }\n            });\n\n          return function delayedNodeLinkFn(\n            /** @type {any} */ _ignoreChildLinkFn,\n            /** @type {ng.Scope} */ scope,\n            /** @type {any} */ node,\n            /** @type {any} */ rootElement,\n            /** @type {any} */ boundTranscludeFn,\n          ) {\n            let childBoundTranscludeFn = boundTranscludeFn;\n\n            if (scope._destroyed) {\n              return;\n            }\n\n            if (linkQueue) {\n              linkQueue.push(scope, node, rootElement);\n            } else {\n              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {\n                childBoundTranscludeFn = createBoundTranscludeFn(\n                  scope,\n                  afterTemplateNodeLinkFn.transclude,\n                  boundTranscludeFn,\n                );\n              }\n              afterTemplateNodeLinkFn(\n                /** @type {CompositeLinkFn | null} */ (\n                  afterTemplateChildLinkFn\n                ),\n                scope,\n                node,\n                rootElement,\n                childBoundTranscludeFn,\n              );\n            }\n          };\n        }\n\n        /**\n         * Sorting function for bound directives.\n         * @param {InternalDirective} a\n         * @param {InternalDirective} b\n         */\n        function byPriority(a, b) {\n          const diff =\n            /** @type {number} */ (b.priority) -\n            /** @type {number} */ (a.priority);\n\n          if (diff !== 0) {\n            return diff;\n          }\n\n          if (a.name !== b.name) {\n            return a.name < b.name ? -1 : 1;\n          }\n\n          return (\n            /** @type {number} */ (a.index) - /** @type {number} */ (b.index)\n          );\n        }\n\n        /**\n         * @param {string} what\n         * @param {{ name: any; }} previousDirective\n         * @param {{ name: any; }} directive\n         * @param {NodeRef} element\n         */\n        function assertNoDuplicate(\n          what,\n          previousDirective,\n          directive,\n          element,\n        ) {\n          if (previousDirective) {\n            throw $compileMinErr(\n              \"multidir\",\n              \"Multiple directives [{0}, {1}] asking for {3} on: {4}\",\n              previousDirective.name,\n              directive.name,\n              what,\n              startingTag(/** @tupe {NodeRef} */ element._getAny()),\n            );\n          }\n        }\n\n        /**\n         * @param {ng.Directive[]} directives\n         * @param {string} text\n         */\n        function addTextInterpolateDirective(directives, text) {\n          const interpolateFn = $interpolate(text, true);\n\n          if (interpolateFn) {\n            directives.push({\n              priority: 0,\n              compile: () => (scope, node) => {\n                interpolateFn.expressions.forEach((x) => {\n                  scope.$watch(x, () => {\n                    const res = interpolateFn(deProxy(scope));\n\n                    switch (node.nodeType) {\n                      case 1:\n                        node.innerHTML = res;\n                        break;\n                      default:\n                        node.nodeValue = res;\n                    }\n                  });\n                });\n              },\n            });\n          }\n        }\n\n        /**\n         * @param {string | undefined} type\n         * @param {string} template\n         * @returns\n         */\n        function wrapTemplate(type, template) {\n          type = (type || \"html\").toLowerCase();\n          switch (type) {\n            case \"svg\":\n            case \"math\": {\n              const wrapper =\n                /** @type {HTMLDivElement} */ document.createElement(\"div\");\n\n              wrapper.innerHTML = `<${type}>${template}</${type}>`;\n\n              return wrapper.childNodes[0].childNodes;\n            }\n            default:\n              return template;\n          }\n        }\n\n        /**\n         * @param {string} nodeName\n         * @param {string} attrNormalizedName\n         * @returns {string|undefined}\n         */\n        function getTrustedAttrContext(nodeName, attrNormalizedName) {\n          if (attrNormalizedName === \"srcdoc\") {\n            return $sce.HTML;\n          }\n\n          // All nodes with src attributes require a RESOURCE_URL value, except for\n          // img and various html5 media nodes, which require the MEDIA_URL context.\n          if (attrNormalizedName === \"src\" || attrNormalizedName === \"ngSrc\") {\n            if (\n              [\"img\", \"video\", \"audio\", \"source\", \"track\"].indexOf(nodeName) ===\n              -1\n            ) {\n              return $sce.RESOURCE_URL;\n            }\n\n            return $sce.MEDIA_URL;\n          }\n\n          if (attrNormalizedName === \"xlinkHref\") {\n            // Some xlink:href are okay, most aren't\n            if (nodeName === \"image\") {\n              return $sce.MEDIA_URL;\n            }\n\n            if (nodeName === \"a\") {\n              return $sce.URL;\n            }\n\n            return $sce.RESOURCE_URL;\n          }\n\n          if (\n            // Formaction\n            (nodeName === \"form\" && attrNormalizedName === \"action\") ||\n            // If relative URLs can go where they are not expected to, then\n            // all sorts of trust issues can arise.\n            (nodeName === \"base\" && attrNormalizedName === \"href\") ||\n            // links can be stylesheets or imports, which can run script in the current origin\n            (nodeName === \"link\" && attrNormalizedName === \"href\")\n          ) {\n            return $sce.RESOURCE_URL;\n          }\n\n          if (\n            nodeName === \"a\" &&\n            (attrNormalizedName === \"href\" || attrNormalizedName === \"ngHref\")\n          ) {\n            return $sce.URL;\n          }\n\n          return undefined;\n        }\n\n        /**\n         * @param {string} nodeName\n         * @param {string} propNormalizedName\n         */\n        function getTrustedPropContext(nodeName, propNormalizedName) {\n          const prop = propNormalizedName.toLowerCase();\n\n          return (\n            PROP_CONTEXTS[`${nodeName}|${prop}`] || PROP_CONTEXTS[`*|${prop}`]\n          );\n        }\n\n        /**\n         * @param {unknown} value\n         * @param {string} invokeType\n         */\n        function sanitizeSrcset(value, invokeType) {\n          if (!value) {\n            return value;\n          }\n\n          if (!isString(value)) {\n            throw $compileMinErr(\n              \"srcset\",\n              'Can\\'t pass trusted values to `{0}`: \"{1}\"',\n              invokeType,\n              /** @type {Object} */ (value).toString(),\n            );\n          }\n\n          // Such values are a bit too complex to handle automatically inside $sce.\n          // Instead, we sanitize each of the URIs individually, which works, even dynamically.\n          // It's not possible to work around this using `$sce.trustAsMediaUrl`.\n          // If you want to programmatically set explicitly trusted unsafe URLs, you should use\n          // `$sce.trustAsHtml` on the whole `img` tag and inject it into the DOM using the\n          // `ng-bind-html` directive.\n          let result = \"\";\n\n          // first check if there are spaces because it's not the same pattern\n          const trimmedSrcset = trim(value);\n\n          //                (   999x   ,|   999w   ,|   ,|,   )\n          const srcPattern = /(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/;\n\n          const pattern = /\\s/.test(trimmedSrcset) ? srcPattern : /(,)/;\n\n          // split srcset into tuple of uri and descriptor except for the last item\n          const rawUris = trimmedSrcset.split(pattern);\n\n          // for each tuples\n          const nbrUrisWith2parts = Math.floor(rawUris.length / 2);\n\n          let i;\n\n          for (i = 0; i < nbrUrisWith2parts; i++) {\n            const innerIdx = i * 2;\n\n            // sanitize the uri\n            result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));\n            // add the descriptor\n            result += ` ${trim(rawUris[innerIdx + 1])}`;\n          }\n\n          // split the last item into uri and descriptor\n          const lastTuple = trim(rawUris[i * 2]).split(/\\s/);\n\n          // sanitize the last uri\n          result += $sce.getTrustedMediaUrl(trim(lastTuple[0]));\n\n          // and add the last descriptor if any\n          if (lastTuple.length === 2) {\n            result += ` ${trim(lastTuple[1])}`;\n          }\n\n          return result;\n        }\n\n        /**\n         * @param {Element} node\n         * @param {ng.Directive<any>[] | { priority: number; compile: (_: any, attr: any) => { pre: (scope: any, $element: any) => void; }; }[]} directives\n         * @param {string} attrName\n         * @param {string} propName\n         */\n        function addPropertyDirective(node, directives, attrName, propName) {\n          if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) {\n            throw $compileMinErr(\n              \"nodomevents\",\n              \"Property bindings for HTML DOM event properties are disallowed\",\n            );\n          }\n\n          const nodeName = getNodeName(node);\n\n          const trustedContext = getTrustedPropContext(nodeName, propName);\n\n          let sanitizer = (/** @type {any} */ x) => x;\n\n          // Sanitize img[srcset] + source[srcset] values.\n          if (\n            propName === \"srcset\" &&\n            (nodeName === \"img\" || nodeName === \"source\")\n          ) {\n            sanitizer = (value) =>\n              sanitizeSrcset($sce.valueOf(value), \"ng-prop-srcset\");\n          } else if (trustedContext) {\n            sanitizer = $sce.getTrusted.bind($sce, trustedContext);\n          }\n\n          directives.push({\n            priority: 100,\n            compile: function ngPropCompileFn(_, attr) {\n              const ngPropGetter = $parse(attr[attrName]);\n\n              return {\n                pre: function ngPropPreLinkFn(\n                  /** @type {import(\"../scope/scope.js\").Scope} */ scope,\n                  /** @type {{ [x: string]: any; }} */ $element,\n                ) {\n                  function applyPropValue() {\n                    const propValue = ngPropGetter(scope);\n\n                    $element[propName] = sanitizer(propValue);\n                  }\n\n                  applyPropValue();\n                  scope.$watch(propName, applyPropValue);\n                  scope.$watch(attr[attrName], (val) => {\n                    $sce.valueOf(val);\n                    applyPropValue();\n                  });\n                },\n              };\n            },\n          });\n        }\n\n        /**\n         * @param {Element} node\n         * @param {ng.Directive<any>[]} directives\n         * @param {string} value\n         * @param {string} name\n         * @param {boolean} isNgAttr\n         */\n        function addAttrInterpolateDirective(\n          node,\n          directives,\n          value,\n          name,\n          isNgAttr,\n        ) {\n          const nodeName = getNodeName(node);\n\n          const trustedContext = getTrustedAttrContext(nodeName, name);\n\n          const mustHaveExpression = !isNgAttr;\n\n          const allOrNothing = ALL_OR_NOTHING_ATTRS.includes(name) || isNgAttr;\n\n          /** @type {import(\"../interpolate/interface.ts\").InterpolationFunction | undefined} */\n          let interpolateFn = /** @type {any} */ (\n            $interpolate(\n              value,\n              mustHaveExpression,\n              trustedContext,\n              allOrNothing,\n            )\n          );\n\n          // no interpolation found -> ignore\n          if (!interpolateFn) {\n            return;\n          }\n\n          if (name === \"multiple\" && nodeName === \"select\") {\n            throw $compileMinErr(\n              \"selmulti\",\n              \"Binding to the 'multiple' attribute is not supported. Element: {0}\",\n              startingTag(node.outerHTML),\n            );\n          }\n\n          if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {\n            throw $compileMinErr(\n              \"nodomevents\",\n              \"Interpolations for HTML DOM event attributes are disallowed\",\n            );\n          }\n\n          directives.push({\n            priority: 100,\n            compile() {\n              return {\n                pre: function attrInterpolatePreLinkFn(scope, element, attr) {\n                  const _observers =\n                    attr._observers || (attr._observers = nullObject());\n\n                  // If the attribute has changed since last $interpolate()ed\n                  const newValue = attr[name];\n\n                  if (newValue !== value) {\n                    // we need to interpolate again since the attribute value has been updated\n                    // (e.g. by another directive's compile function)\n                    // ensure unset/empty values make interpolateFn falsy\n                    interpolateFn =\n                      /** @type {import(\"../interpolate/interface.ts\").InterpolationFunction | undefined} */ (\n                        newValue &&\n                          $interpolate(\n                            newValue,\n                            true,\n                            trustedContext,\n                            allOrNothing,\n                          )\n                      );\n                    value = newValue;\n                  }\n\n                  // if attribute was updated so that there is no interpolation going on we don't want to\n                  // register any observers\n                  if (!interpolateFn) {\n                    return;\n                  }\n\n                  // initialize attr object so that it's ready in case we need the value for isolate\n                  // scope initialization, otherwise the value would not be available from isolate\n                  // directive's linking fn during linking phase\n                  attr[name] = interpolateFn(scope);\n\n                  (_observers[name] || (_observers[name] = []))._inter = true;\n                  interpolateFn.expressions.forEach((x) => {\n                    const targetScope =\n                      (attr._observers && attr._observers[name]._scope) ||\n                      scope;\n\n                    targetScope.$watch(x, () => {\n                      const newInterpolatedValue =\n                        /** @type {import(\"../interpolate/interface.ts\").InterpolationFunction} */ (\n                          interpolateFn\n                        )(scope);\n\n                      // special case for class attribute addition + removal\n                      // so that class changes can tap into the animation\n                      // hooks provided by the $animate service. Be sure to\n                      // skip animations when the first digest occurs (when\n                      // both the new and the old values are the same) since\n                      // the CSS classes are the non-interpolated values\n                      if (name === \"class\") {\n                        attr.$updateClass(\n                          newInterpolatedValue,\n                          /** @type {Element} */ (attr._element()).classList\n                            .value,\n                        );\n                      } else {\n                        attr.$set(\n                          name,\n                          name === \"srcset\"\n                            ? $sce.getTrustedMediaUrl(newInterpolatedValue)\n                            : newInterpolatedValue,\n                        );\n                      }\n                    });\n                  });\n\n                  if (interpolateFn.expressions.length === 0) {\n                    attr.$set(\n                      name,\n                      name === \"srcset\"\n                        ? $sce.getTrustedMediaUrl(newValue)\n                        : newValue,\n                    );\n                  }\n                },\n              };\n            },\n          });\n        }\n\n        /**\n         *\n         * @param {NodeRef} elementsToRemove The JQLite element which we are going to replace. We keep\n         *                                  the shell, but replace its DOM node reference.\n         * @param {Node} newNode The new DOM node.\n         * @param {number} [index] Parent node index.\n         */\n        function replaceWith(elementsToRemove, newNode, index) {\n          const firstElementToRemove = elementsToRemove._getAny();\n\n          // const removeCount = elementsToRemove.length;\n          const parent = firstElementToRemove.parentNode;\n\n          if (parent) {\n            if (isDefined(index)) {\n              const oldChild = parent.childNodes[index];\n\n              if (oldChild) {\n                parent.replaceChild(newNode, oldChild);\n              }\n            } else {\n              parent.insertBefore(newNode, parent.firstChild);\n              //parent.append(newNode);\n            }\n          }\n\n          // Append all the `elementsToRemove` to a fragment. This will...\n          // - remove them from the DOM\n          // - allow them to still be traversed with .nextSibling\n          // - allow a single fragment.qSA to fetch all elements being removed\n          const fragment = document.createDocumentFragment();\n\n          elementsToRemove._collection().forEach((element) => {\n            fragment.appendChild(element);\n          });\n\n          elementsToRemove.node = newNode;\n        }\n\n        /**\n         * @param {Function} fn\n         * @param {Object} annotation\n         */\n        function cloneAndAnnotateFn(fn, annotation) {\n          return extend(\n            function () {\n              return fn.apply(null, arguments);\n            },\n            fn,\n            annotation,\n          );\n        }\n\n        /**\n         * @param {string} attrName\n         * @param {string} directiveName\n         */\n        function strictBindingsCheck(attrName, directiveName) {\n          if (strictComponentBindingsEnabled) {\n            throw $compileMinErr(\n              \"missingattr\",\n              \"Attribute '{0}' of '{1}' is non-optional and must be set!\",\n              attrName,\n              directiveName,\n            );\n          }\n        }\n\n        // Set up $watches for isolate scope and controller bindings.\n        /**\n         *\n         * @param {ng.Scope} scope\n         * @param {*} attrs\n         * @param {ng.Scope}  destination - child scope or isolate scope\n         * @param {*} bindings\n         * @param {*} directive\n         * @returns\n         */\n        function initializeDirectiveBindings(\n          scope,\n          attrs,\n          destination,\n          bindings,\n          directive,\n        ) {\n          /**\n           * @type {((() => void) | undefined)[]}\n           */\n          const removeWatchCollection = [];\n\n          /** @type {Record<string, import(\"./interface.ts\").SimpleChange>} */\n          const initialChanges = {};\n\n          /** @type {Record<string, import(\"./interface.ts\").SimpleChange> | undefined} */\n          let changes;\n\n          const attrsAny = /** @type {any} */ (attrs);\n\n          const destAny = /** @type {any} */ (destination);\n\n          if (bindings) {\n            entries(bindings).forEach(([scopeName, definition]) => {\n              const {\n                attrName,\n                optional,\n                mode, // @, =, <, or &\n              } = definition;\n\n              /** @type {any} */\n              let lastValue;\n\n              /** @type {import(\"../parse/interface\").CompiledExpression | undefined} */\n              let parentGet;\n\n              /** @type {(scope: any, value: any) => any} */\n              let parentSet;\n\n              /** @type {(a: any, b: any) => boolean} */\n              let compare;\n\n              let removeWatch;\n\n              let firstCall = true;\n\n              let firstChange = true;\n\n              switch (mode) {\n                case \"@\":\n                  if (!optional && !hasOwn(attrs, attrName)) {\n                    strictBindingsCheck(attrName, directive.name);\n                    destAny[scopeName] = attrsAny[attrName] = undefined;\n                  }\n\n                  removeWatch = attrs.$observe(\n                    attrName,\n                    /** @param {any} value */ (value) => {\n                      if (isString(value) || isBoolean(value)) {\n                        recordChanges(scopeName, value, firstChange);\n\n                        destAny[scopeName] = value;\n\n                        if (firstCall) {\n                          firstCall = false;\n                        } else {\n                          triggerOnChangesHook();\n                          firstChange = false;\n                        }\n                      }\n                    },\n                  );\n                  attrs._observers[attrName]._scope = scope;\n                  lastValue = attrsAny[attrName];\n\n                  if (isString(lastValue)) {\n                    // If the attribute has been provided then we trigger an interpolation to ensure\n                    // the value is there for use in the link fn\n                    destAny[scopeName] =\n                      /** @type {import(\"../interpolate/interface.ts\").InterpolationFunction} */ (\n                        $interpolate(lastValue)\n                      )(scope);\n                  } else if (isBoolean(lastValue)) {\n                    // If the attributes is one of the BOOLEAN_ATTR then AngularTS will have converted\n                    // the value to boolean rather than a string, so we special case this situation\n                    destAny[scopeName] = lastValue;\n                  }\n\n                  /**\n                   * @type {import(\"./interface.ts\").SimpleChange}\n                   */\n                  initialChanges[scopeName] = {\n                    currentValue: destAny[scopeName],\n                    firstChange: true,\n                  };\n                  removeWatchCollection.push(removeWatch);\n                  break;\n\n                case \"=\": {\n                  if (!hasOwn(attrs, attrName)) {\n                    if (optional) {\n                      break;\n                    }\n                    strictBindingsCheck(attrName, directive.name);\n                    attrsAny[attrName] = undefined;\n                  }\n\n                  if (optional && !attrsAny[attrName]) {\n                    break;\n                  }\n\n                  const attr = attrsAny[attrName];\n\n                  parentGet = attr && $parse(attr);\n\n                  if (parentGet && parentGet._literal) {\n                    compare = equals;\n                  } else {\n                    compare = simpleCompare;\n                  }\n\n                  parentSet =\n                    (parentGet && parentGet._assign) ||\n                    function () {\n                      // reset the change, or we will throw this exception on every $digest\n\n                      throw $compileMinErr(\n                        \"nonassign\",\n                        \"Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!\",\n                        attrsAny[attrName],\n                        attrName,\n                        directive.name,\n                      );\n                    };\n                  // store the value that the parent scope had after the last check:\n                  lastValue = destAny.$target[scopeName] =\n                    parentGet && parentGet(scope.$target);\n\n                  const parentValueWatch = function parentValueWatch(\n                    /** @type {any} */ parentValue,\n                  ) {\n                    if (!compare(parentValue, destAny[scopeName])) {\n                      // we are out of sync and need to copy\n                      if (!compare(parentValue, lastValue)) {\n                        // parent changed and it has precedence\n                        destAny[scopeName] = parentValue;\n                      } else {\n                        // if the parent can be assigned then do so\n                        parentSet(scope, (parentValue = destAny[scopeName]));\n                      }\n                    }\n                    lastValue = parentValue;\n\n                    return lastValue;\n                  };\n\n                  if (attrsAny[attrName]) {\n                    const expr = attrsAny[attrName];\n\n                    // make it lazy as we dont want to trigger the two way data binding at this point\n                    scope.$watch(\n                      expr,\n                      (val) => {\n                        const res = $parse(\n                          attrsAny[attrName],\n                          parentValueWatch,\n                        );\n\n                        if (val) {\n                          if (parentGet && parentGet._literal) {\n                            scope.$target[attrName] = val;\n                          } else {\n                            scope[attrName] = val;\n                          }\n                          res(scope);\n                        } else {\n                          scope[attrName] = scope[attrsAny[attrName]];\n                        }\n                      },\n                      true,\n                    );\n                  }\n\n                  removeWatch = destination.$watch(\n                    attrName,\n                    (val) => {\n                      if (\n                        val === lastValue &&\n                        !isUndefined(attrsAny[attrName])\n                      ) {\n                        return;\n                      }\n\n                      if (\n                        (parentGet &&\n                          !!parentGet._inputs &&\n                          !parentGet._literal) ||\n                        (isUndefined(attrsAny[attrName]) && isDefined(val))\n                      ) {\n                        destination.$target[attrName] = lastValue;\n                        throw $compileMinErr(\n                          \"nonassign\",\n                          \"Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!\",\n                          attrsAny[attrName],\n                          attrName,\n                          directive.name,\n                        );\n                      } else {\n                        // manually set the handler to avoid watch cycles\n                        if (isObject(val)) {\n                          entries(val).forEach(([key, value]) => {\n                            scope.$target[key] = value;\n                          });\n                        } else {\n                          parentSet(scope.$target, (lastValue = val));\n                          scope.$handler._watchers\n                            .get(attrsAny[attrName])\n                            ?.forEach((watchFn) => {\n                              watchFn.listenerFn(val, scope.$target);\n                            });\n                        }\n                      }\n                    },\n                    true,\n                  );\n                  removeWatchCollection.push(removeWatch);\n                  break;\n                }\n\n                case \"<\":\n                  if (!hasOwn(attrs, attrName)) {\n                    if (optional) {\n                      break;\n                    }\n                    strictBindingsCheck(attrName, directive.name);\n                    attrsAny[attrName] = undefined;\n                  }\n\n                  if (optional && !attrsAny[attrName]) {\n                    break;\n                  }\n\n                  parentGet = attrsAny[attrName] && $parse(attrsAny[attrName]);\n\n                  destAny.$target[scopeName] =\n                    parentGet && parentGet(scope.$target);\n                  /** @type {import(\"./interface.ts\").SimpleChange} */\n                  initialChanges[scopeName] = {\n                    currentValue: destAny.$target[scopeName],\n                    firstChange,\n                  };\n                  scope.$target.attrs = attrs;\n\n                  if (attrsAny[attrName]) {\n                    removeWatch = scope.$watch(\n                      attrsAny[attrName],\n                      (val) => {\n                        destAny.$target[scopeName] = val;\n                        recordChanges(scopeName, val, firstChange);\n\n                        if (firstChange) {\n                          firstChange = false;\n                        }\n                      },\n                      true,\n                    );\n                    removeWatchCollection.push(removeWatch);\n                  }\n                  break;\n\n                case \"&\":\n                  if (!optional && !hasOwn(attrs, attrName)) {\n                    strictBindingsCheck(attrName, directive.name);\n                  }\n                  // Don't assign Object.prototype method to scope\n                  parentGet = hasOwn(attrs, attrName)\n                    ? $parse(attrsAny[attrName])\n                    : undefined;\n\n                  // Don't assign noop to destination if expression is not valid\n                  if (!parentGet && optional) {\n                    break;\n                  }\n\n                  destAny.$target[scopeName] = function (\n                    /** @type {any} */ locals,\n                  ) {\n                    return parentGet && parentGet(scope.$target, locals);\n                  };\n\n                  break;\n              }\n            });\n          }\n\n          /**\n           * @param {string} key\n           * @param {any} currentValue\n           * @param {boolean} initial\n           */\n          function recordChanges(key, currentValue, initial) {\n            if (isFunction(destination.$onChanges)) {\n              // If we have not already scheduled the top level onChangesQueue handler then do so now\n              if (!onChangesQueue.length) {\n                scope.$postUpdate(flushOnChangesQueue);\n                onChangesQueue.length = 0;\n              }\n\n              // If we have not already queued a trigger of onChanges for this controller then do so now\n              if (!changes) {\n                changes = {};\n                onChangesQueue.push(triggerOnChangesHook);\n              }\n              // Store this change\n              changes[key] = {\n                currentValue,\n                firstChange: initial,\n              };\n            }\n          }\n\n          function triggerOnChangesHook() {\n            destination.$onChanges &&\n              changes &&\n              destination.$onChanges(changes);\n            // Now clear the changes so that we schedule onChanges when more changes arrive\n            changes = undefined;\n          }\n\n          return {\n            initialChanges,\n            removeWatches:\n              removeWatchCollection.length &&\n              function removeWatches() {\n                for (\n                  let i = 0, ii = removeWatchCollection.length;\n                  i < ii;\n                  ++i\n                ) {\n                  /** @type {Function} */ (removeWatchCollection[i])();\n                }\n              },\n          };\n        }\n      },\n    ];\n  }\n}\n\n/**\n * @param {String} name\n * @returns {void}\n */\nfunction assertValidDirectiveName(name) {\n  const letter = name.charAt(0);\n\n  if (!letter || letter !== letter.toLowerCase()) {\n    throw $compileMinErr(\n      \"baddir\",\n      \"Directive/Component name '{0}' is invalid. The first character must be a lowercase letter\",\n      name,\n    );\n  }\n\n  if (name !== name.trim()) {\n    throw $compileMinErr(\n      \"baddir\",\n      \"Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces\",\n      name,\n    );\n  }\n}\n","import {\n  arrayRemove,\n  assertNotHasOwnProperty,\n  deProxy,\n  extend,\n  hasAnimate,\n  isBoolean,\n  isObjectEmpty,\n  isUndefined,\n  shallowCopy,\n  snakeCase,\n} from \"../../shared/utils.js\";\nimport {\n  DIRTY_CLASS,\n  INVALID_CLASS,\n  PRISTINE_CLASS,\n  VALID_CLASS,\n} from \"../../shared/constants.js\";\nimport { $injectTokens, $injectTokens as $t } from \"../../injection-tokens.js\";\n\n/**\n * @type {{\n *   $nonscope: boolean,\n *   $addControl: Function,\n *   $getControls: () => any[],\n *   _renameControl: Function,\n *   $removeControl: Function,\n *   $setValidity: Function | ((key: any, isValid: boolean | undefined | null, control: any) => any),\n *   $setDirty: Function,\n *   $setPristine: Function,\n *   $setSubmitted: Function,\n *   _setSubmitted: Function\n * }}\n */\nexport const nullFormCtrl = {\n  $nonscope: true,\n  $addControl: () => {\n    /* empty */\n  },\n  $getControls: () => [],\n  _renameControl: (\n    /** @type {{ $name: any; }} */ control,\n    /** @type {any} */ name,\n  ) => {\n    control.$name = name;\n  },\n  $removeControl: () => {\n    /* empty */\n  },\n  $setValidity: () => {\n    /* empty */\n  },\n  $setDirty: () => {\n    /* empty */\n  },\n  $setPristine: () => {\n    /* empty */\n  },\n  $setSubmitted: () => {\n    /* empty */\n  },\n  _setSubmitted: () => {\n    /* empty */\n  },\n};\n\nexport const PENDING_CLASS = \"ng-pending\";\nconst SUBMITTED_CLASS = \"ng-submitted\";\n\n/**\n * @property {boolean} $dirty True if user has already interacted with the form.\n * @property {boolean} $valid True if all of the containing forms and controls are valid.\n * @property {boolean} $invalid True if at least one containing control or form is invalid.\n * @property {boolean} $submitted True if user has submitted the form even if its invalid.\n *\n * @property {Object} $pending An object hash, containing references to controls or forms with\n *  pending validators, where:\n *\n *  - keys are validations tokens (error names).\n *  - values are arrays of controls or forms that have a pending validator for the given error name.\n *\n * See {@link form.FormController#$error $error} for a list of built-in validation tokens.\n *\n * @property {Object} $error An object hash, containing references to controls or forms with failing\n *  validators, where:\n *\n *  - keys are validation tokens (error names),\n *  - values are arrays of controls or forms that have a failing validator for the given error name.\n *\n *  Built-in validation tokens:\n *  - `email`\n *  - `max`\n *  - `maxlength`\n *  - `min`\n *  - `minlength`\n *  - `number`\n *  - `pattern`\n *  - `required`\n *  - `url`\n *  - `date`\n *  - `datetimelocal`\n *  - `time`\n *  - `week`\n *  - `month`\n *\n *\n * `FormController` keeps track of all its controls and nested forms as well as the state of them,\n * such as being valid/invalid or dirty/pristine.\n *\n * Each {@link ng.directive:form form} directive creates an instance\n * of `FormController`.\n *\n */\n// asks for $scope to fool the BC controller module\nexport class FormController {\n  static $nonscope = true;\n  /* @ignore */ static $inject = [\n    $t._element,\n    $t._attrs,\n    $t._scope,\n    $t._animate,\n    $t._interpolate,\n  ];\n\n  /**\n   * @param {HTMLFormElement} $element\n   * @param {ng.Attributes} $attrs\n   * @param {ng.Scope} $scope\n   * @param {ng.AnimateService} $animate\n   * @param {ng.InterpolateService} $interpolate\n   */\n  constructor($element, $attrs, $scope, $animate, $interpolate) {\n    /** @type {boolean} */\n    this._isAnimated = hasAnimate($element);\n\n    /**\n     * @type {FormController[]}\n     */\n    this._controls = [];\n\n    this.$name = /** @type {ng.InterpolationFunction} */ (\n      $interpolate($attrs.name || $attrs.ngForm || \"\")\n    )($scope);\n\n    /**\n     * @property {boolean} $dirty True if user has already interacted with the form.\n     */\n    this.$dirty = false;\n\n    /**\n     * @propertys {boolean} $pristine - True if user has not interacted with the form yet.s\n     */\n    this.$pristine = true;\n    /** @type {boolean | undefined} */\n    this.$valid = true;\n    /** @type {boolean | undefined} */\n    this.$invalid = false;\n    this.$submitted = false;\n    /** @type {FormController|Object} */\n    this._parentForm = nullFormCtrl;\n\n    this._element = $element;\n    this._animate = $animate;\n    /** @type {Record<string, any>} */\n    this.$error = {};\n\n    /** @type {Record<string, any>} */\n    this._success = {};\n    /**\n     * @type {Record<string, any>| undefined}\n     */\n    this.$pending = undefined;\n    /** @type {Record<string, any>} */\n    this._classCache = {};\n    const isValid = this._element.classList.contains(VALID_CLASS);\n\n    this._classCache[VALID_CLASS] = isValid;\n    this._classCache[INVALID_CLASS] = !isValid;\n\n    /** @type {Record<string, any>} */\n    this.$target = {};\n  }\n\n  /**\n   * Rollback all form controls pending updates to the `$modelValue`.\n   *\n   * Updates may be pending by a debounced event or because the input is waiting for a some future\n   * event defined in `ng-model-options`. This method is typically needed by the reset button of\n   * a form that uses `ng-model-options` to pend updates.\n   */\n  $rollbackViewValue() {\n    this._controls.forEach((control) => {\n      control.$rollbackViewValue();\n    });\n  }\n\n  /**\n   * Commit all form controls pending updates to the `$modelValue`.\n   *\n   * Updates may be pending by a debounced event or because the input is waiting for a some future\n   * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`\n   * usually handles calling this in response to input events.\n   */\n  $commitViewValue() {\n    this._controls.forEach((control) => {\n      control.$commitViewValue();\n    });\n  }\n\n  /**\n   * Register a control with the form. Input elements using ngModelController do this automatically\n   * when they are linked.\n   *\n   * Note that the current state of the control will not be reflected on the new parent form. This\n   * is not an issue with normal use, as freshly compiled and linked controls are in a `$pristine`\n   * state.\n   *\n   * However, if the method is used programmatically, for example by adding dynamically created controls,\n   * or controls that have been previously removed without destroying their corresponding DOM element,\n   * it's the developers responsibility to make sure the current state propagates to the parent form.\n   *\n   * For example, if an input control is added that is already `$dirty` and has `$error` properties,\n   * calling `$setDirty()` and `$validate()` afterwards will propagate the state to the parent form.\n   * @param {FormController} control\n   */\n  $addControl(control) {\n    // Breaking change - before, inputs whose name was \"hasOwnProperty\" were quietly ignored\n    // and not added to the scope.  Now we throw an error.\n    assertNotHasOwnProperty(control.$name, \"input\");\n    this._controls.push(control);\n\n    if (control.$name) {\n      /** @type {Record<string, any>} */ (this)[control.$name] = control;\n    }\n    control.$target._parentForm = this;\n  }\n\n  /**\n   * This method returns a **shallow copy** of the controls that are currently part of this form.\n   * The controls can be instances of {@link form.FormController `FormController`}\n   * ({@link ngForm \"child-forms\"}) and of {@link ngModel.NgModelController `NgModelController`}.\n   * If you need access to the controls of child-forms, you have to call `$getControls()`\n   * recursively on them.\n   * This can be used for example to iterate over all controls to validate them.\n   *\n   * The controls can be accessed normally, but adding to, or removing controls from the array has\n   * no effect on the form. Instead, use {@link form.FormController#$addControl `$addControl()`} and\n   * {@link form.FormController#$removeControl `$removeControl()`} for this use-case.\n   * Likewise, adding a control to, or removing a control from the form is not reflected\n   * in the shallow copy. That means you should get a fresh copy from `$getControls()` every time\n   * you need access to the controls.\n   * @returns {ReadonlyArray<FormController>}\n   */\n  $getControls() {\n    return /** @type {ReadonlyArray<FormController>} */ (\n      shallowCopy(this._controls)\n    );\n  }\n\n  // Private API: rename a form control\n  /**\n   * @param {FormController} control\n   * @param {string | number} newName\n   */\n  _renameControl(control, newName) {\n    const oldName = control.$name;\n\n    if (/** @type {Record<string, any>} */ (this)[oldName] === control) {\n      delete (/** @type {Record<string, any>} */ (this)[oldName]);\n    }\n    /** @type {Record<string, any>} */ (this)[newName] = control;\n    control.$name = newName;\n  }\n\n  /**\n   * Deregister a control from the form.\n   *\n   * Input elements using ngModelController do this automatically when they are destroyed.\n   *\n   * Note that only the removed control's validation state (`$errors`etc.) will be removed from the\n   * form. `$dirty`, `$submitted` states will not be changed, because the expected behavior can be\n   * different from case to case. For example, removing the only `$dirty` control from a form may or\n   * may not mean that the form is still `$dirty`.\n   * @param {FormController } control\n   */\n  $removeControl(control) {\n    if (\n      control.$name &&\n      /** @type {Record<string, any>} */ (this)[control.$name] === control\n    ) {\n      delete (/** @type {Record<string, any>} */ (this)[control.$name]);\n    }\n    this.$pending &&\n      Object.keys(this.$pending).forEach((name) => {\n        this.$setValidity(name, null, control);\n      });\n    this.$error &&\n      Object.keys(this.$error).forEach((name) => {\n        this.$setValidity(name, null, control);\n      });\n    this._success &&\n      Object.keys(this._success).forEach((name) => {\n        this.$setValidity(name, null, control);\n      });\n\n    arrayRemove(this._controls, control);\n\n    control.$target._parentForm = nullFormCtrl;\n  }\n\n  /**\n   * Sets the form to a dirty state.\n   *\n   * This method can be called to add the 'ng-dirty' class and set the form to a dirty\n   * state (ng-dirty class). This method will also propagate to parent forms.\n   */\n  $setDirty() {\n    if (hasAnimate(this._element)) {\n      this._animate.removeClass(this._element, PRISTINE_CLASS);\n      this._animate.addClass(this._element, DIRTY_CLASS);\n    } else {\n      // Fallback for non-animated environments\n      this._element.classList.remove(PRISTINE_CLASS);\n      this._element.classList.add(DIRTY_CLASS);\n    }\n    this.$dirty = true;\n    this.$pristine = false;\n    /** @type {FormController} */ (this._parentForm).$setDirty();\n  }\n\n  /**\n   * Sets the form to its pristine state.\n   *\n   * This method sets the form's `$pristine` state to true, the `$dirty` state to false, removes\n   * the `ng-dirty` class and adds the `ng-pristine` class. Additionally, it sets the `$submitted`\n   * state to false.\n   *\n   * This method will also propagate to all the controls contained in this form.\n   *\n   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after\n   * saving or resetting it.\n   */\n  $setPristine() {\n    if (hasAnimate(this._element)) {\n      this._animate.setClass(\n        this._element,\n        PRISTINE_CLASS,\n        `${DIRTY_CLASS} ${SUBMITTED_CLASS}`,\n      );\n    } else {\n      // Fallback for non-animated environments\n      this._element.classList.remove(DIRTY_CLASS, SUBMITTED_CLASS);\n      this._element.classList.add(PRISTINE_CLASS);\n    }\n\n    this.$dirty = false;\n    this.$pristine = true;\n    this.$submitted = false;\n    this._controls.forEach((control) => {\n      control.$setPristine();\n    });\n  }\n\n  /**\n   * Sets the form to its untouched state.\n   *\n   * This method can be called to remove the 'ng-touched' class and set the form controls to their\n   * untouched state (ng-untouched class).\n   *\n   * Setting a form controls back to their untouched state is often useful when setting the form\n   * back to its pristine state.\n   */\n  $setUntouched() {\n    this._controls.forEach((control) => {\n      control.$setUntouched();\n    });\n  }\n\n  /**\n   * Sets the form to its `$submitted` state. This will also set `$submitted` on all child and\n   * parent forms of the form.\n   */\n  $setSubmitted() {\n    /** @type {FormController} */\n    let rootForm = this;\n\n    while (rootForm._parentForm && rootForm._parentForm !== nullFormCtrl) {\n      rootForm = /** @type {FormController} */ (rootForm._parentForm);\n    }\n    rootForm._setSubmitted();\n  }\n\n  _setSubmitted() {\n    if (hasAnimate(this._element)) {\n      this._animate.addClass(this._element, SUBMITTED_CLASS);\n    } else {\n      this._element.classList.add(SUBMITTED_CLASS);\n    }\n    this.$submitted = true;\n    this._controls.forEach((control) => {\n      if (control._setSubmitted) {\n        control._setSubmitted();\n      }\n    });\n  }\n\n  /**\n   * @param {Record<string, any>} object\n   * @param {string} property\n   * @param {FormController | import(\"../model/model.js\").NgModelController} controller\n   */\n  set(object, property, controller) {\n    const list = object[property];\n\n    if (!list) {\n      object = deProxy(object);\n      object[property] = [controller];\n    } else {\n      const index = list.indexOf(controller);\n\n      if (index === -1) {\n        list.push(controller);\n      }\n    }\n  }\n\n  /**\n   * @param {Record<string, any>} object\n   * @param {string} property\n   * @param {FormController | import(\"../model/model.js\").NgModelController} controller\n   */\n  unset(object, property, controller) {\n    const list = object[property];\n\n    if (!list) {\n      return;\n    }\n    const index = arrayRemove(list, controller);\n\n    if (index === -1) {\n      arrayRemove(list, /** @type {FormController} */ (controller).$target);\n    }\n\n    if (list.length === 0) {\n      delete object[property];\n    }\n  }\n\n  /**\n   * Change the validity state of the form, and notify the parent form (if any).\n   *\n   * Application developers will rarely need to call this method directly. It is used internally, by\n   * {@link ngModel.NgModelController#$setValidity NgModelController.$setValidity()}, to propagate a\n   * control's validity state to the parent `FormController`.\n   *\n   * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be\n   *        assigned to either `$error[validationErrorKey]` or `$pending[validationErrorKey]` (for\n   *        unfulfilled `$asyncValidators`), so that it is available for data-binding. The\n   *        `validationErrorKey` should be in camelCase and will get converted into dash-case for\n   *        class name. Example: `myError` will result in `ng-valid-my-error` and\n   *        `ng-invalid-my-error` classes and can be bound to as `{{ someForm.$error.myError }}`.\n   * @param {boolean | null | undefined} state Whether the current state is valid (true), invalid (false), pending\n   *        (undefined),  or skipped (null). Pending is used for unfulfilled `$asyncValidators`.\n   *        Skipped is used by AngularTS when validators do not run because of parse errors and when\n   *        `$asyncValidators` do not run because any of the `$validators` failed.\n   * @param {import(\"../model/model.js\").NgModelController | FormController} controller - The controller whose validity state is\n   *        triggering the change.\n   */\n  $setValidity(validationErrorKey, state, controller) {\n    const that = this;\n\n    if (isUndefined(state)) {\n      createAndSet(this, \"$pending\", validationErrorKey, controller);\n    } else {\n      unsetAndCleanup(this, \"$pending\", validationErrorKey, controller);\n    }\n\n    if (!isBoolean(state)) {\n      this.unset(this.$error, validationErrorKey, controller);\n      this.unset(this._success, validationErrorKey, controller);\n    } else if (state) {\n      this.unset(this.$error, validationErrorKey, controller);\n      this.set(this._success, validationErrorKey, controller);\n    } else {\n      this.set(this.$error, validationErrorKey, controller);\n      this.unset(this._success, validationErrorKey, controller);\n    }\n\n    if (this.$pending) {\n      cachedToggleClass(this, PENDING_CLASS, true);\n      this.$valid = this.$invalid = undefined;\n      toggleValidationCss(this, \"\", null);\n    } else {\n      cachedToggleClass(this, PENDING_CLASS, false);\n      this.$valid = isObjectEmpty(this.$error);\n      this.$invalid = !this.$valid;\n      toggleValidationCss(this, \"\", this.$valid);\n    }\n\n    // re-read the state as the set/unset methods could have\n    // combined state in this.$error[validationError] (used for forms),\n    // where setting/unsetting only increments/decrements the value,\n    // and does not replace it.\n    let combinedState;\n\n    if (this.$pending && this.$pending[validationErrorKey]) {\n      combinedState = undefined;\n    } else if (this.$error[validationErrorKey]) {\n      combinedState = false;\n    } else if (this._success[validationErrorKey]) {\n      combinedState = true;\n    } else {\n      combinedState = null;\n    }\n\n    toggleValidationCss(this, validationErrorKey, combinedState);\n    /** @type {FormController} */ (this._parentForm).$setValidity(\n      validationErrorKey,\n      combinedState,\n      this,\n    );\n\n    /**\n     * @param {FormController & Record<string, any>} ctrl\n     * @param {string} name\n     * @param {string} value\n     * @param {FormController | import(\"../model/model.js\").NgModelController} controllerParam\n     */\n    function createAndSet(ctrl, name, value, controllerParam) {\n      if (!ctrl[name]) {\n        ctrl[name] = {};\n      }\n      that.set(ctrl[name], value, controllerParam);\n    }\n\n    /**\n     * @param {FormController & Record<string, any>} ctrl\n     * @param {string} name\n     * @param {string} value\n     * @param {FormController | import(\"../model/model.js\").NgModelController} controllerParam\n     */\n    function unsetAndCleanup(ctrl, name, value, controllerParam) {\n      if (ctrl[name]) {\n        that.unset(ctrl[name], value, controllerParam);\n      }\n\n      if (isObjectEmpty(ctrl[name])) {\n        ctrl[name] = undefined;\n      }\n    }\n\n    /**\n     * @param {FormController | import(\"../model/model.js\").NgModelController} ctrl\n     * @param {string} validationErrorKeyParam\n     * @param {boolean | null | undefined} isValid\n     */\n    function toggleValidationCss(ctrl, validationErrorKeyParam, isValid) {\n      validationErrorKeyParam = validationErrorKeyParam\n        ? `-${snakeCase(validationErrorKeyParam, \"-\")}`\n        : \"\";\n\n      cachedToggleClass(\n        ctrl,\n        VALID_CLASS + validationErrorKeyParam,\n        isValid === true,\n      );\n      cachedToggleClass(\n        ctrl,\n        INVALID_CLASS + validationErrorKeyParam,\n        isValid === false,\n      );\n    }\n  }\n}\n\n/**\n * Helper directive that makes it possible to create control groups inside a\n * {@link ng.directive:form `form`} directive.\n * These \"child forms\" can be used, for example, to determine the validity of a sub-group of\n * controls.\n *\n * <div class=\"alert alert-danger\">\n * **Note**: `ngForm` cannot be used as a replacement for `<form>`, because it lacks its\n * [built-in HTML functionality](https://html.spec.whatwg.org/#the-form-element).\n * Specifically, you cannot submit `ngForm` like a `<form>` tag. That means,\n * you cannot send data to the server with `ngForm`, or integrate it with\n * {@link ng.directive:ngSubmit `ngSubmit`}.\n * </div>\n *\n * @param {string=} ngForm|name Name of the form. If specified, the form controller will\n *                              be published into the related scope, under this name.\n *\n */\n\n/**\n * Directive that instantiates\n * {@link form.FormController FormController}.\n *\n * If the `name` attribute is specified, the form controller is published onto the current scope under\n * this name.\n *\n * ## Alias: {@link ng.directive:ngForm `ngForm`}\n *\n * In AngularTS, forms can be nested. This means that the outer form is valid when all of the child\n * forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so\n * AngularTS provides the {@link ng.directive:ngForm `ngForm`} directive, which behaves identically to\n * `form` but can be nested. Nested forms can be useful, for example, if the validity of a sub-group\n * of controls needs to be determined.\n *\n * ## CSS classes\n *  - `ng-valid` is set if the form is valid.\n *  - `ng-invalid` is set if the form is invalid.\n *  - `ng-pending` is set if the form is pending.\n *  - `ng-pristine` is set if the form is pristine.\n *  - `ng-dirty` is set if the form is dirty.\n *  - `ng-submitted` is set if the form was submitted.\n *\n * Keep in mind that ngAnimate can detect each of these classes when added and removed.\n *\n *\n * ## Submitting a form and preventing the default action\n *\n * Since the role of forms in client-side AngularTS applications is different than in classical\n * roundtrip apps, it is desirable for the browser not to translate the form submission into a full\n * page reload that sends the data to the server. Instead some javascript logic should be triggered\n * to handle the form submission in an application-specific way.\n *\n * For this reason, AngularTS prevents the default action (form submission to the server) unless the\n * `<form>` element has an `action` attribute specified.\n *\n * You can use one of the following two ways to specify what javascript method should be called when\n * a form is submitted:\n *\n * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element\n * - {@link ng.directive:ngClick ngClick} directive on the first\n *  button or input field of type submit (input[type=submit])\n *\n * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}\n * or {@link ng.directive:ngClick ngClick} directives.\n * This is because of the following form submission rules in the HTML specification:\n *\n * - If a form has only one input field then hitting enter in this field triggers form submit\n * (`ngSubmit`)\n * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter\n * doesn't trigger submit\n * - if a form has one or more input fields and one or more buttons or input[type=submit] then\n * hitting enter in any of the input fields will trigger the click handler on the *first* button or\n * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)\n *\n * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is\n * submitted. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`\n * to have access to the updated model.\n *\n * @animations\n * Animations in ngForm are triggered when any of the associated CSS classes are added and removed.\n * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and `.ng-valid` as well as any\n * other validations that are performed within the form. Animations in ngForm are similar to how\n * they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well\n * as JS animations.\n *\n * @param {string=} isNgForm Name of the form. If specified, the form controller will be published into\n *                       related scope, under this name.\n */\nconst formDirectiveFactory = function (isNgForm) {\n  return [\n    $injectTokens._parse,\n    /**\n     * @param {ng.ParseService} $parse\n     * @returns {ng.Directive}\n     */\n    function ($parse) {\n      return {\n        name: \"form\",\n        restrict: isNgForm ? \"EA\" : \"E\",\n        require: [\"form\", \"^^?form\"], // first is the form's own ctrl, second is an optional parent form\n        controller: FormController,\n        compile: function ngFormCompile(formElement, attr) {\n          // Setup initial state of the control\n          formElement.classList.add(PRISTINE_CLASS, VALID_CLASS);\n\n          const nameAttr = attr.name\n            ? \"name\"\n            : isNgForm && attr.ngForm\n              ? \"ngForm\"\n              : false;\n\n          return {\n            pre: function ngFormPreLink(\n              scope,\n              formElementParam,\n              attrParam,\n              ctrls,\n            ) {\n              const controller = ctrls[0];\n\n              // if `action` attr is not present on the form, prevent the default action (submission)\n              if (!(\"action\" in attrParam)) {\n                const handleFormSubmission = function (\n                  /** @type {Event} */ event,\n                ) {\n                  controller.$commitViewValue();\n                  controller.$setSubmitted();\n                  event.preventDefault();\n                };\n\n                formElementParam.addEventListener(\n                  \"submit\",\n                  handleFormSubmission,\n                );\n                formElementParam.addEventListener(\"$destroy\", () => {\n                  formElementParam.removeEventListener(\n                    \"submit\",\n                    handleFormSubmission,\n                  );\n                });\n              }\n\n              const parentFormCtrl = ctrls[1] || controller._parentForm;\n\n              parentFormCtrl.$addControl(controller);\n\n              const setter = /** @type {Function} */ (\n                nameAttr\n                  ? getSetter(controller.$name)\n                  : () => {\n                      /* empty */\n                    }\n              );\n\n              if (nameAttr) {\n                setter(scope, controller);\n                attrParam.$observe(nameAttr, (newValue) => {\n                  if (controller.$name === newValue) return;\n                  scope.$target[controller.$name] = undefined;\n                  controller._parentForm._renameControl(controller, newValue);\n\n                  if (\n                    scope.$target !== controller._parentForm &&\n                    controller._parentForm !== nullFormCtrl\n                  ) {\n                    // form moved\n                  } else {\n                    scope.$target[newValue] = controller;\n                  }\n                });\n              }\n              formElementParam.addEventListener(\"$destroy\", () => {\n                controller.$target._parentForm.$removeControl(controller);\n                setter(scope, undefined);\n                extend(controller, nullFormCtrl); // stop propagating child destruction handlers upwards\n              });\n            },\n          };\n        },\n      };\n\n      /**\n       * @param {string} expression\n       */\n      function getSetter(expression) {\n        if (expression === \"\") {\n          // create an assignable expression, so forms with an empty name can be renamed later\n          return $parse('this[\"\"]')._assign;\n        }\n\n        return $parse(expression)._assign;\n      }\n    },\n  ];\n};\n\nexport const formDirective = formDirectiveFactory();\nexport const ngFormDirective = formDirectiveFactory(\"ngForm\");\n\n/**\n * @param {FormController|ng.NgModelController} ctrl\n * @param {string} className\n * @param {boolean} switchValue\n */\nexport function cachedToggleClass(ctrl, className, switchValue) {\n  if (switchValue && !ctrl._classCache[className]) {\n    if (ctrl._isAnimated) {\n      ctrl._animate.addClass(ctrl._element, className);\n    } else {\n      ctrl._element.classList.add(className);\n    }\n    ctrl._classCache[className] = true;\n  } else if (!switchValue && ctrl._classCache[className]) {\n    if (ctrl._isAnimated) {\n      ctrl._animate.removeClass(ctrl._element, className);\n    } else {\n      ctrl._element.classList.remove(className);\n    }\n    ctrl._classCache[className] = false;\n  }\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { entries, isDefined, keys, trim } from \"../../shared/utils.js\";\n\nconst DEFAULT_REGEXP = /(\\s+|^)default(\\s+|$)/;\n\n/**\n * @typedef {Object & Record<string, any>} ModelOptionsConfig\n * @property {string} [updateOn] - A string specifying which events the input should be bound to. Multiple events can be set using a space-delimited list. The special event 'default' matches the default events belonging to the control.\n * @property {number|Object.<string, number>} [debounce] - An integer specifying the debounce time in milliseconds. A value of 0 triggers an immediate update. If an object is supplied, custom debounce values can be set for each event.\n * @property {boolean} [allowInvalid] - Indicates whether the model can be set with values that did not validate correctly. Defaults to false, which sets the model to undefined on validation failure.\n * @property {boolean} [getterSetter] - Determines whether to treat functions bound to `ngModel` as getters/setters. Defaults to false.\n * @property {boolean} [updateOnDefault]\n */\n\nclass NgModelOptionsController {\n  /* @ignore */ static $nonscope = true;\n  /* @ignore */ static $inject = [$injectTokens._attrs, $injectTokens._scope];\n\n  /**\n   * @param {ng.Attributes} $attrs\n   * @param {ng.Scope} $scope\n   */\n  constructor($attrs, $scope) {\n    this._attrs = $attrs;\n    this._scope = $scope;\n    /** @type {NgModelOptionsController | null} */\n    this.parentCtrl = null;\n\n    /** @type {ModelOptions} */\n    this.$options = defaultModelOptions;\n  }\n\n  $onInit() {\n    const parentOptions = this.parentCtrl\n      ? this.parentCtrl.$options\n      : defaultModelOptions;\n\n    const modelOptionsDefinition = this._scope.$eval(\n      this._attrs.ngModelOptions,\n    );\n\n    this.$options = parentOptions.createChild(modelOptionsDefinition);\n  }\n}\n\n/**\n * A container for the options set by the {@link ngModelOptions} directive\n */\nclass ModelOptions {\n  static $nonscope = true;\n\n  /**\n   * @param {ModelOptionsConfig} options\n   */\n  constructor(options) {\n    /** @type {ModelOptionsConfig} */\n    this._options = options;\n  }\n\n  /**\n   * Returns the value of the given option\n   * @param {string} name the name of the option to retrieve\n   * @returns {string|boolean|number|Object.<string, number>} the value of the option   *\n   */\n  getOption(name) {\n    return this._options[name];\n  }\n\n  /**\n   * @param {ModelOptionsConfig} options a hash of options for the new child that will override the parent's options\n   * @return {ModelOptions} a new `ModelOptions` object initialized with the given options.\n   */\n  createChild(options) {\n    let inheritAll = false;\n\n    // make a shallow copy\n    options = Object.assign({}, options);\n\n    // Inherit options from the parent if specified by the value `\"$inherit\"`\n    entries(options).forEach(([key, option]) => {\n      if (option === \"$inherit\") {\n        if (key === \"*\") {\n          inheritAll = true;\n        } else {\n          options[key] = this._options[key];\n\n          // `updateOn` is special so we must also inherit the `updateOnDefault` option\n          if (key === \"updateOn\") {\n            options.updateOnDefault = this._options.updateOnDefault;\n          }\n        }\n      } else if (key === \"updateOn\") {\n        // If the `updateOn` property contains the `default` event then we have to remove\n        // it from the event list and set the `updateOnDefault` flag.\n        options.updateOnDefault = false;\n        options[key] = trim(\n          /** @type {string} */ (option).replace(DEFAULT_REGEXP, () => {\n            options.updateOnDefault = true;\n\n            return \" \";\n          }),\n        );\n      }\n    }, this);\n\n    if (inheritAll) {\n      // We have a property of the form: `\"*\": \"$inherit\"`\n      delete options[\"*\"];\n      defaults(options, this._options);\n    }\n\n    // Finally add in any missing defaults\n    defaults(options, defaultModelOptions._options);\n\n    return new ModelOptions(options);\n  }\n}\n\nexport const defaultModelOptions = new ModelOptions({\n  updateOn: \"\",\n  updateOnDefault: true,\n  debounce: 0,\n  getterSetter: false,\n  allowInvalid: false,\n});\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngModelOptionsDirective() {\n  return {\n    restrict: \"A\",\n    // ngModelOptions needs to run before ngModel and input directives\n    priority: 10,\n    require: { parentCtrl: \"?^^ngModelOptions\" },\n    bindToController: true,\n    controller: NgModelOptionsController,\n  };\n}\n\n// shallow copy over values from `src` that are not already specified on `dst`\n/**\n * @param {ModelOptionsConfig} dst\n * @param {Object & Record<string, any>} src\n */\nfunction defaults(dst, src) {\n  keys(src).forEach((key) => {\n    if (!isDefined(dst[key])) {\n      dst[key] = src[key];\n    }\n  });\n}\n","import {\n  DIRTY_CLASS,\n  EMPTY_CLASS,\n  INVALID_CLASS,\n  NOT_EMPTY_CLASS,\n  PRISTINE_CLASS,\n  TOUCHED_CLASS,\n  UNTOUCHED_CLASS,\n  VALID_CLASS,\n} from \"../../shared/constants.js\";\nimport {\n  deProxy,\n  entries,\n  hasAnimate,\n  isBoolean,\n  isFunction,\n  isNull,\n  isNumber,\n  isNumberNaN,\n  isObjectEmpty,\n  isPromiseLike,\n  isUndefined,\n  keys,\n  minErr,\n  snakeCase,\n} from \"../../shared/utils.js\";\nimport {\n  PENDING_CLASS,\n  cachedToggleClass,\n  nullFormCtrl,\n} from \"../form/form.js\";\nimport { defaultModelOptions } from \"../model-options/model-options.js\";\nimport { startingTag } from \"../../shared/dom.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n\nexport const ngModelMinErr = minErr(\"ngModel\");\n\n/**\n * \n * @property {*} $viewValue The actual value from the control's view.\n *\n * @property {*} $modelValue The value in the model that the control is bound to.\n * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever\n *  the control updates the ngModelController with a new `$viewValue` from the DOM, usually via user input.\n *\n * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever\n    the bound ngModel expression changes programmatically. The `$formatters` are not called when the\n    value of the control is changed by user interaction.\n *\n * @property {Object.<string, (string, string) => boolean>} $validators A collection of validators that are applied whenever the model value changes. \n * The key value within the object refers to the name of the validator while the function refers to the validation operation. \n * The validation operation is provided with the model value as an argument and must return a true or false value depending on the response of that validation.\n *\n * @property {Object.<string, function(string, string) => Promise>} $asyncValidators A collection of validations that are expected to perform an asynchronous validation (e.g. a HTTP request).\n *  The validation function that is provided is expected to return a promise when it is run during the model validation process\n *\n * @property {Array.<Function>} $viewChangeListeners Array of functions to execute whenever\n *     a change to {@link ngModel.NgModelController#$viewValue `$viewValue`} has caused a change\n *     to {@link ngModel.NgModelController#$modelValue `$modelValue`}.\n *     It is called with no arguments, and its return value is ignored.\n *     This can be used in place of additional $watches against the model value.\n *\n * @property {Object} $error An object hash with all failing validator ids as keys.\n * @property {Object} $pending An object hash with all pending validator ids as keys.\n *\n * @property {boolean} $untouched True if control has not lost focus yet.\n * @property {boolean} $touched True if control has lost focus.\n * @property {boolean} $pristine True if user has not interacted with the control yet.\n * @property {boolean} $dirty True if user has already interacted with the control.\n * @property {boolean} $valid True if there is no error.\n * @property {boolean} $invalid True if at least one error on the control.\n * @property {string} $name The name attribute of the control.\n */\n\nexport class NgModelController {\n  /* @ignore */ static $nonscope = true;\n  /* @ignore */ static $inject = [\n    $t._scope,\n    $t._exceptionHandler,\n    $t._attrs,\n    $t._element,\n    $t._parse,\n    $t._animate,\n    $t._interpolate,\n  ];\n\n  /**\n   * @param {ng.Scope} $scope\n   * @param {ng.ExceptionHandlerService} $exceptionHandler\n   * @param {ng.Attributes} $attr\n   * @param {HTMLElement} $element\n   * @param {ng.ParseService} $parse\n   * @param {ng.AnimateService} $animate\n   * @param {ng.InterpolateService} $interpolate\n   */\n  constructor(\n    $scope,\n    $exceptionHandler,\n    $attr,\n    $element,\n    $parse,\n    $animate,\n    $interpolate,\n  ) {\n    /** @type {boolean} */\n    this._isAnimated = hasAnimate($element);\n    /** @type {any} The actual value from the control's view  */\n    this.$viewValue = Number.NaN;\n\n    /** @type {any} The value in the model that the control is bound to. */\n    this.$modelValue = Number.NaN;\n    /** @type {any} */\n    this._rawModelValue = undefined; // stores the parsed modelValue / model set from scope regardless of validity.\n\n    /** @type {import(\"./interface.ts\").ModelValidators} */\n    this.$validators = {};\n\n    /** @type {import(\"./interface.ts\").AsyncModelValidators} */\n    this.$asyncValidators = {};\n\n    /** @type {Array<import(\"./interface.ts\").ModelParser>} */\n    this.$parsers = [];\n\n    /** @type {Array<import(\"./interface.ts\").ModelFormatter>} */\n    this.$formatters = [];\n\n    /** @type {Array<import(\"./interface.ts\").ModelViewChangeListener>} */\n    this.$viewChangeListeners = [];\n\n    /** @type {boolean} */\n    this.$untouched = true;\n\n    /** @type {boolean} */\n    this.$touched = false;\n\n    /** @type {boolean} */\n    this.$pristine = true;\n\n    /** @type {boolean} */\n    this.$dirty = false;\n\n    /** @type {boolean | undefined} */\n    this.$valid = true;\n\n    /** @type {boolean | undefined} */\n    this.$invalid = false;\n\n    /** @type {Record<string, boolean>} */\n    this.$error = {}; // keep invalid keys here\n\n    /** @type {Record<string, boolean>} */\n    this._success = {}; // keep valid keys here\n    /**\n     * @type {import(\"../../shared/interface.ts\").Dict<any> | undefined}\n     */\n    this.$pending = undefined; // keep pending keys here\n    this.$name = /** @type {ng.InterpolationFunction} */ (\n      $interpolate($attr.name || \"\", false)\n    )($scope);\n    this._parentForm = nullFormCtrl;\n    this.$options = defaultModelOptions;\n    this._updateEvents = \"\";\n    // Attach the correct context to the event handler function for updateOn\n    this._updateEventHandler = this._updateEventHandler.bind(this);\n\n    this._parsedNgModel = $parse($attr.ngModel);\n    this._parsedNgModelAssign =\n      /** @type {(context: any, value: any) => any} */ (\n        this._parsedNgModel._assign\n      );\n\n    /**\n     * @type {import(\"../../core/parse/interface.ts\").CompiledExpression |\n     *        (function(ng.Scope): any)}\n     */\n    this._ngModelGet = this._parsedNgModel;\n    this._ngModelSet = this._parsedNgModelAssign;\n    this._pendingDebounce = undefined;\n    this._parserValid = undefined;\n\n    /** @type {string} */\n    this._parserName = \"parse\";\n\n    /** @type {number} */\n    this._currentValidationRunId = 0;\n\n    /** @type {ng.Scope} */\n    this._scope = $scope; // attempt to bind to nearest controller if present\n    this._attr = $attr;\n    this._element = $element;\n    this._animate = $animate;\n    this._parse = $parse;\n    this._exceptionHandler = $exceptionHandler;\n\n    this._hasNativeValidators = false;\n\n    /** @type {Record<string, boolean>} */\n    this._classCache = {};\n    const isValid = this._element.classList.contains(VALID_CLASS);\n\n    this._classCache[VALID_CLASS] = isValid;\n    this._classCache[INVALID_CLASS] = !isValid;\n\n    this._eventRemovers = new Set();\n\n    setupModelWatcher(this);\n  }\n\n  /**\n   * @param {{ [x: string]: boolean; }} object\n   * @param {string | number} property\n   */\n  set(object, property) {\n    object[property] = true;\n  }\n\n  /**\n   * @param {{ [x: string]: any; }} object\n   * @param {string | number} property\n   */\n  unset(object, property) {\n    delete object[property];\n  }\n\n  /**\n   * @param {string} validationErrorKey\n   * @param {boolean | undefined | null} state\n   */\n  $setValidity(validationErrorKey, state) {\n    const that = this;\n\n    /**\n     * @param {NgModelController & Record<string, any>} ctrl\n     * @param {string} name\n     * @param {string} value\n     */\n    function createAndSet(ctrl, name, value) {\n      if (!ctrl[name]) {\n        ctrl[name] = {};\n      }\n      that.set(ctrl[name], value);\n    }\n\n    /**\n     * @param {NgModelController & Record<string, any>} ctrl\n     * @param {string} name\n     * @param {string} value\n     */\n    function unsetAndCleanup(ctrl, name, value) {\n      if (ctrl[name]) {\n        that.unset(ctrl[name], value);\n      }\n\n      if (isObjectEmpty(ctrl[name])) {\n        ctrl[name] = undefined;\n      }\n    }\n\n    /**\n     * @param {NgModelController | import(\"../form/form.js\").FormController} ctrl\n     * @param {string} validationErrorKeyParam\n     * @param {boolean | null | undefined} isValid\n     */\n    function toggleValidationCss(ctrl, validationErrorKeyParam, isValid) {\n      validationErrorKeyParam = validationErrorKeyParam\n        ? `-${snakeCase(validationErrorKeyParam, \"-\")}`\n        : \"\";\n\n      cachedToggleClass(\n        ctrl,\n        VALID_CLASS + validationErrorKeyParam,\n        isValid === true,\n      );\n      cachedToggleClass(\n        ctrl,\n        INVALID_CLASS + validationErrorKeyParam,\n        isValid === false,\n      );\n    }\n\n    if (isUndefined(state)) {\n      createAndSet(this, \"$pending\", validationErrorKey);\n    } else {\n      unsetAndCleanup(this, \"$pending\", validationErrorKey);\n    }\n\n    if (!isBoolean(state)) {\n      delete this.$error[validationErrorKey];\n      delete this._success[validationErrorKey];\n    } else if (state) {\n      delete this.$error[validationErrorKey];\n      this.set(this._success, validationErrorKey);\n    } else {\n      this.set(this.$error, validationErrorKey);\n      delete this._success[validationErrorKey];\n    }\n\n    if (this.$pending) {\n      cachedToggleClass(this, PENDING_CLASS, true);\n      this.$valid = this.$invalid = undefined;\n      toggleValidationCss(this, \"\", null);\n    } else {\n      cachedToggleClass(this, PENDING_CLASS, false);\n      this.$valid = isObjectEmpty(this.$error);\n      this.$invalid = !this.$valid;\n      toggleValidationCss(this, \"\", this.$valid);\n    }\n\n    // re-read the state as the set/unset methods could have\n    // combined state in this.$error[validationError] (used for forms),\n    // where setting/unsetting only increments/decrements the value,\n    // and does not replace it.\n    let combinedState = undefined;\n\n    if (this.$pending && this.$pending[validationErrorKey]) {\n      combinedState = undefined;\n    } else if (this.$error[validationErrorKey]) {\n      combinedState = false;\n    } else if (this._success[validationErrorKey]) {\n      combinedState = true;\n    } else {\n      combinedState = null;\n    }\n\n    toggleValidationCss(this, validationErrorKey, combinedState);\n    this._parentForm.$setValidity(validationErrorKey, combinedState, this);\n  }\n\n  _initGetterSetters() {\n    if (this.$options.getOption(\"getterSetter\")) {\n      const invokeModelGetter = this._parse(`${this._attr.ngModel}()`);\n\n      const invokeModelSetter = this._parse(`${this._attr.ngModel}(_$p)`);\n\n      this._ngModelGet = (/** @type {ng.Scope | undefined} */ $scope) => {\n        let modelValue = this._parsedNgModel($scope);\n\n        if (isFunction(modelValue)) {\n          modelValue = invokeModelGetter($scope);\n        }\n\n        return modelValue;\n      };\n      this._ngModelSet = (\n        /** @type {ng.Scope} */ $scope,\n        /** @type {any} */ newValue,\n      ) => {\n        if (isFunction(this._parsedNgModel($scope))) {\n          invokeModelSetter($scope, { _$p: newValue });\n        } else {\n          this._parsedNgModelAssign($scope, newValue);\n        }\n      };\n    } else if (!this._parsedNgModel._assign) {\n      throw ngModelMinErr(\n        \"nonassign\",\n        \"Expression '{0}' is non-assignable. Element: {1}\",\n        this._attr.ngModel,\n        startingTag(this._element),\n      );\n    }\n  }\n\n  /**\n   * Called when the view needs to be updated. It is expected that the user of the ng-model\n   * directive will implement this method.\n   *\n   * The `$render()` method is invoked in the following situations:\n   *\n   * * `$rollbackViewValue()` is called.  If we are rolling back the view value to the last\n   *   committed value then `$render()` is called to update the input control.\n   * * The value referenced by `ng-model` is changed programmatically and both the `$modelValue` and\n   *   the `$viewValue` are different from last time.\n   *\n   * Since `ng-model` does not do a deep watch, `$render()` is only invoked if the values of\n   * `$modelValue` and `$viewValue` are actually different from their previous values. If `$modelValue`\n   * or `$viewValue` are objects (rather than a string or number) then `$render()` will not be\n   * invoked if you only change a property on the objects.\n   */\n  $render() {\n    /* empty */\n  }\n\n  /**\n   * This is called when we need to determine if the value of an input is empty.\n   *\n   * For instance, the required directive does this to work out if the input has data or not.\n   *\n   * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.\n   *\n   * You can override this for input directives whose concept of being empty is different from the\n   * default. The `checkboxInputType` directive does this because in its case a value of `false`\n   * implies empty.\n   *\n   * @param {*} value The value of the input to check for emptiness.\n   * @returns {boolean} True if `value` is \"empty\".\n   */\n  $isEmpty(value) {\n    return (\n      isUndefined(value) ||\n      value === \"\" ||\n      value === null ||\n      Number.isNaN(value)\n    );\n  }\n\n  /**\n   * @param {any} value\n   */\n  _updateEmptyClasses(value) {\n    if (this.$isEmpty(value)) {\n      if (hasAnimate(this._element)) {\n        this._animate.removeClass(this._element, NOT_EMPTY_CLASS);\n        this._animate.addClass(this._element, EMPTY_CLASS);\n      } else {\n        this._element.classList.remove(NOT_EMPTY_CLASS);\n        this._element.classList.add(EMPTY_CLASS);\n      }\n    } else {\n      if (hasAnimate(this._element)) {\n        this._animate.removeClass(this._element, EMPTY_CLASS);\n        this._animate.addClass(this._element, NOT_EMPTY_CLASS);\n      } else {\n        this._element.classList.remove(EMPTY_CLASS);\n        this._element.classList.add(NOT_EMPTY_CLASS);\n      }\n    }\n  }\n\n  /**\n   * Sets the control to its pristine state.\n   *\n   * This method can be called to remove the `ng-dirty` class and set the control to its pristine\n   * state (`ng-pristine` class). A model is considered to be pristine when the control\n   * has not been changed from when first compiled.\n   */\n  $setPristine() {\n    this.$dirty = false;\n    this.$pristine = true;\n\n    if (!this._element) return;\n\n    if (hasAnimate(this._element)) {\n      this._animate.removeClass(this._element, EMPTY_CLASS);\n      this._animate.addClass(this._element, PRISTINE_CLASS);\n    } else {\n      this._element.classList.remove(EMPTY_CLASS);\n      this._element.classList.add(PRISTINE_CLASS);\n    }\n  }\n\n  /**\n   * Sets the control to its dirty state.\n   *\n   * This method can be called to remove the `ng-pristine` class and set the control to its dirty\n   * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed\n   * from when first compiled.\n   */\n  $setDirty() {\n    this.$dirty = true;\n    this.$pristine = false;\n\n    if (hasAnimate(this._element)) {\n      this._animate.removeClass(this._element, PRISTINE_CLASS);\n      this._animate.addClass(this._element, DIRTY_CLASS);\n    } else {\n      this._element.classList.remove(PRISTINE_CLASS);\n      this._element.classList.add(DIRTY_CLASS);\n    }\n    this._parentForm.$setDirty();\n  }\n\n  /**\n   * Sets the control to its untouched state.\n   *\n   * This method can be called to remove the `ng-touched` class and set the control to its\n   * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched\n   * by default, however this function can be used to restore that state if the model has\n   * already been touched by the user.\n   */\n  $setUntouched() {\n    this.$touched = false;\n    this.$untouched = true;\n\n    if (hasAnimate(this._element)) {\n      this._animate.setClass(this._element, UNTOUCHED_CLASS, TOUCHED_CLASS);\n    } else {\n      this._element.classList.remove(TOUCHED_CLASS);\n      this._element.classList.add(UNTOUCHED_CLASS);\n    }\n  }\n\n  /**\n   * Sets the control to its touched state.\n   *\n   * This method can be called to remove the `ng-untouched` class and set the control to its\n   * touched state (`ng-touched` class). A model is considered to be touched when the user has\n   * first focused the control element and then shifted focus away from the control (blur event).\n   */\n  $setTouched() {\n    this.$touched = true;\n    this.$untouched = false;\n\n    if (hasAnimate(this._element)) {\n      this._animate.setClass(this._element, TOUCHED_CLASS, UNTOUCHED_CLASS);\n    } else {\n      this._element.classList.remove(UNTOUCHED_CLASS);\n      this._element.classList.add(TOUCHED_CLASS);\n    }\n  }\n\n  /**\n   * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,\n   * which may be caused by a pending debounced event or because the input is waiting for some\n   * future event.\n   *\n   * If you have an input that uses `ng-model-options` to set up debounced updates or updates that\n   * depend on special events such as `blur`, there can be a period when the `$viewValue` is out of\n   * sync with the ngModel's `$modelValue`.\n   *\n   * In this case, you can use `$rollbackViewValue()` to manually cancel the debounced / future update\n   * and reset the input to the last committed view value.\n   *\n   * It is also possible that you run into difficulties if you try to update the ngModel's `$modelValue`\n   * programmatically before these debounced/future events have resolved/occurred, because AngularTS's\n   * dirty checking mechanism is not able to tell whether the model has actually changed or not.\n   *\n   * The `$rollbackViewValue()` method should be called before programmatically changing the model of an\n   * input which may have such events pending. This is important in order to make sure that the\n   * input field will be updated with the new model value and any pending operations are cancelled.\n   *\n   * @example\n   * <example name=\"ng-model-cancel-update\" module=\"cancel-update-example\">\n   *   <file name=\"app.js\">\n   *     angular.module('cancel-update-example', [])\n   *\n   *     .controller('CancelUpdateController', ['$scope', function($scope) {\n   *       $scope.model = {value1: '', value2: ''};\n   *\n   *       $scope.setEmpty = function(e, value, rollback) {\n   *         if (e.keyCode === 27) {\n   *           e.preventDefault();\n   *           if (rollback) {\n   *             $scope.myForm[value].$rollbackViewValue();\n   *           }\n   *           $scope.model[value] = '';\n   *         }\n   *       };\n   *     }]);\n   *   </file>\n   *   <file name=\"index.html\">\n   *     <div ng-controller=\"CancelUpdateController\">\n   *       <p>Both of these inputs are only updated if they are blurred. Hitting escape should\n   *       empty them. Follow these steps and observe the difference:</p>\n   *       <ol>\n   *         <li>Type something in the input. You will see that the model is not yet updated</li>\n   *         <li>Press the Escape key.\n   *           <ol>\n   *             <li> In the first example, nothing happens, because the model is already '', and no\n   *             update is detected. If you blur the input, the model will be set to the current view.\n   *             </li>\n   *             <li> In the second example, the pending update is cancelled, and the input is set back\n   *             to the last committed view value (''). Blurring the input does nothing.\n   *             </li>\n   *           </ol>\n   *         </li>\n   *       </ol>\n   *\n   *       <form name=\"myForm\" ng-model-options=\"{ updateOn: 'blur' }\">\n   *         <div>\n   *           <p id=\"inputDescription1\">Without $rollbackViewValue():</p>\n   *           <input name=\"value1\" aria-describedby=\"inputDescription1\" ng-model=\"model.value1\"\n   *                  ng-keydown=\"setEmpty($event, 'value1')\">\n   *           value1: \"{{ model.value1 }}\"\n   *         </div>\n   *\n   *         <div>\n   *           <p id=\"inputDescription2\">With $rollbackViewValue():</p>\n   *           <input name=\"value2\" aria-describedby=\"inputDescription2\" ng-model=\"model.value2\"\n   *                  ng-keydown=\"setEmpty($event, 'value2', true)\">\n   *           value2: \"{{ model.value2 }}\"\n   *         </div>\n   *       </form>\n   *     </div>\n   *   </file>\n       <file name=\"style.css\">\n          div {\n            display: table-cell;\n          }\n          div:nth-child(1) {\n            padding-right: 30px;\n          }\n\n        </file>\n   * </example>\n   */\n  $rollbackViewValue() {\n    this._pendingDebounce && clearTimeout(this._pendingDebounce);\n    this.$viewValue = this._lastCommittedViewValue;\n    this.$render();\n  }\n\n  /**\n   * Runs each of the registered validators (first synchronous validators and then\n   * asynchronous validators).\n   * If the validity changes to invalid, the model will be set to `undefined`,\n   * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.\n   * If the validity changes to valid, it will set the model to the last available valid\n   * `$modelValue`, i.e. either the last parsed value or the last value set from the scope.\n   */\n  $validate() {\n    // ignore $validate before model is initialized\n    if (isNumberNaN(this.$modelValue)) {\n      return;\n    }\n\n    const viewValue = this._lastCommittedViewValue;\n\n    // Note: we use the _rawModelValue as $modelValue might have been\n    // set to undefined during a view -> model update that found validation\n    // errors. We can't parse the view here, since that could change\n    // the model although neither viewValue nor the model on the scope changed\n    const modelValue = this._rawModelValue;\n\n    const prevValid = this.$valid;\n\n    const prevModelValue = this.$modelValue;\n\n    const allowInvalid = this.$options.getOption(\"allowInvalid\");\n\n    const that = this;\n\n    this._runValidators(\n      modelValue,\n      viewValue,\n      (/** @type {boolean | undefined} */ allValid) => {\n        // If there was no change in validity, don't update the model\n        // This prevents changing an invalid modelValue to undefined\n        if (!allowInvalid && prevValid !== allValid) {\n          // Note: Don't check this.$valid here, as we could have\n          // external validators (e.g. calculated on the server),\n          // that just call $setValidity and need the model value\n          // to calculate their validity.\n          that.$modelValue = allValid ? modelValue : undefined;\n\n          if (that.$modelValue !== prevModelValue) {\n            that._writeModelToScope();\n          }\n        }\n      },\n    );\n  }\n\n  /**\n   * @param {any} modelValue\n   * @param {any} viewValue\n   * @param {Function} doneCallback\n   */\n  _runValidators(modelValue, viewValue, doneCallback) {\n    this._currentValidationRunId++;\n    const localValidationRunId = this._currentValidationRunId;\n\n    const that = this;\n\n    // check parser error\n    if (!processParseErrors()) {\n      validationDone(false);\n\n      return;\n    }\n\n    if (!processSyncValidators()) {\n      validationDone(false);\n\n      return;\n    }\n    processAsyncValidators();\n\n    function processParseErrors() {\n      const errorKey = that._parserName;\n\n      if (isUndefined(that._parserValid)) {\n        setValidity(errorKey, null);\n      } else {\n        if (!that._parserValid) {\n          keys(that.$validators).forEach((name) => {\n            setValidity(name, null);\n          });\n          keys(that.$asyncValidators).forEach((name) => {\n            setValidity(name, null);\n          });\n        }\n\n        // Set the parse error last, to prevent unsetting it, should a $validators key == parserName\n        setValidity(errorKey, that._parserValid);\n\n        return that._parserValid;\n      }\n\n      return true;\n    }\n\n    function processSyncValidators() {\n      let syncValidatorsValid = true;\n\n      entries(that.$validators).forEach(([name, validator]) => {\n        const result = Boolean(validator(modelValue, viewValue));\n\n        syncValidatorsValid = syncValidatorsValid && result;\n        setValidity(name, result);\n      });\n\n      if (!syncValidatorsValid) {\n        keys(that.$asyncValidators).forEach((name) => {\n          setValidity(name, null);\n        });\n\n        return false;\n      }\n\n      return true;\n    }\n\n    function processAsyncValidators() {\n      /**\n       * @type {any[]}\n       */\n      const validatorPromises = [];\n\n      let allValid = true;\n\n      entries(that.$asyncValidators).forEach(([name, validator]) => {\n        const promise = validator(modelValue, viewValue);\n\n        if (!isPromiseLike(promise)) {\n          throw ngModelMinErr(\n            \"nopromise\",\n            \"Expected asynchronous validator to return a promise but got '{0}' instead.\",\n            promise,\n          );\n        }\n        setValidity(name, undefined);\n        validatorPromises.push(\n          promise.then(\n            () => {\n              setValidity(name, true);\n            },\n            () => {\n              allValid = false;\n              setValidity(name, false);\n            },\n          ),\n        );\n      });\n\n      if (!validatorPromises.length) {\n        validationDone(true);\n      } else {\n        Promise.all(validatorPromises).then(\n          () => {\n            validationDone(allValid);\n          },\n          () => {\n            /* empty */\n          },\n        );\n      }\n    }\n\n    /**\n     * @param {string} name\n     * @param {boolean | undefined | null} isValid\n     */\n    function setValidity(name, isValid) {\n      if (localValidationRunId === that._currentValidationRunId) {\n        that.$setValidity(name, isValid);\n      }\n    }\n\n    /**\n     * @param {boolean} allValid\n     */\n    function validationDone(allValid) {\n      if (localValidationRunId === that._currentValidationRunId) {\n        doneCallback(allValid);\n      }\n    }\n  }\n\n  /**\n   * Commit a pending update to the `$modelValue`.\n   *\n   * Updates may be pending by a debounced event or because the input is waiting for a some future\n   * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`\n   * usually handles calling this in response to input events.\n   */\n  $commitViewValue() {\n    clearTimeout(this._pendingDebounce);\n\n    // If the view value has not changed then we should just exit, except in the case where there is\n    // a native validator on the element. In this case the validation state may have changed even though\n    // the viewValue has stayed empty.\n    if (\n      this._lastCommittedViewValue === this.$viewValue &&\n      (this.$viewValue !== \"\" || !this._hasNativeValidators)\n    ) {\n      return;\n    }\n\n    if (\n      this._lastCommittedViewValue === undefined &&\n      Number.isNaN(this.$viewValue)\n    ) {\n      return;\n    }\n\n    this._updateEmptyClasses(this.$viewValue);\n    this._lastCommittedViewValue = this.$viewValue;\n\n    // change to dirty\n    if (this.$pristine) {\n      this.$setDirty();\n    }\n    this._parseAndValidate();\n  }\n\n  _parseAndValidate() {\n    let modelValue = this._lastCommittedViewValue;\n\n    const that = this;\n\n    this._parserValid = isUndefined(modelValue) ? undefined : true;\n\n    // Reset any previous parse error\n    this.$setValidity(this._parserName, null);\n    this._parserName = \"parse\";\n\n    if (this._parserValid) {\n      for (let i = 0; i < this.$parsers.length; i++) {\n        modelValue = this.$parsers[i](modelValue);\n\n        if (isUndefined(modelValue)) {\n          this._parserValid = false;\n          break;\n        }\n      }\n    }\n\n    if (isNumberNaN(this.$modelValue)) {\n      // this.$modelValue has not been touched yet...\n\n      this.$modelValue = this._ngModelGet(this._scope);\n    }\n    const prevModelValue = this.$modelValue;\n\n    const allowInvalid = this.$options.getOption(\"allowInvalid\");\n\n    this._rawModelValue = modelValue;\n\n    if (allowInvalid) {\n      this.$modelValue = modelValue;\n      writeToModelIfNeeded();\n    }\n\n    // Pass the _lastCommittedViewValue here, because the cached viewValue might be out of date.\n    // This can happen if e.g. $setViewValue is called from inside a parser\n    this._runValidators(\n      modelValue,\n      this._lastCommittedViewValue,\n      (/** @type {any} */ allValid) => {\n        if (!allowInvalid) {\n          // Note: Don't check this.$valid here, as we could have\n          // external validators (e.g. calculated on the server),\n          // that just call $setValidity and need the model value\n          // to calculate their validity.\n          // if (that.$modelValue ?? that.$modelValue[isProxySymbol]) {\n          //   delete that.$modelValue;\n          // }\n          that.$modelValue = allValid ? modelValue : undefined;\n          writeToModelIfNeeded();\n        }\n      },\n    );\n\n    function writeToModelIfNeeded() {\n      // intentional loose equality\n      // eslint-disable-next-line eqeqeq\n      if (that.$modelValue != prevModelValue) {\n        if (isNull(that.$modelValue) && prevModelValue === \"\") return;\n\n        that._writeModelToScope();\n      }\n    }\n  }\n\n  _writeModelToScope() {\n    this._ngModelSet(this._scope, this.$modelValue);\n    Object.values(this.$viewChangeListeners).forEach((listener) => {\n      try {\n        listener();\n      } catch (err) {\n        this._exceptionHandler(err);\n      }\n    }, this);\n  }\n\n  /**\n   * Update the view value.\n   *\n   * This method should be called when a control wants to change the view value; typically,\n   * this is done from within a DOM event handler. For example, the {@link ng.directive:input input}\n   * directive calls it when the value of the input changes and {@link ng.directive:select select}\n   * calls it when an option is selected.\n   *\n   * When `$setViewValue` is called, the new `value` will be staged for committing through the `$parsers`\n   * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged\n   * value is sent directly for processing through the `$parsers` pipeline. After this, the `$validators` and\n   * `$asyncValidators` are called and the value is applied to `$modelValue`.\n   * Finally, the value is set to the **expression** specified in the `ng-model` attribute and\n   * all the registered change listeners, in the `$viewChangeListeners` list are called.\n   *\n   * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`\n   * and the `default` trigger is not listed, all those actions will remain pending until one of the\n   * `updateOn` events is triggered on the DOM element.\n   * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}\n   * directive is used with a custom debounce for this particular event.\n   * Note that a `$digest` is only triggered once the `updateOn` events are fired, or if `debounce`\n   * is specified, once the timer runs out.\n   *\n   * When used with standard inputs, the view value will always be a string (which is in some cases\n   * parsed into another type, such as a `Date` object for `input[date]`.)\n   * However, custom controls might also pass objects to this method. In this case, we should make\n   * a copy of the object before passing it to `$setViewValue`. This is because `ngModel` does not\n   * perform a deep watch of objects, it only looks for a change of identity. If you only change\n   * the property of the object then ngModel will not realize that the object has changed and\n   * will not invoke the `$parsers` and `$validators` pipelines. For this reason, you should\n   * not change properties of the copy once it has been passed to `$setViewValue`.\n   * Otherwise you may cause the model value on the scope to change incorrectly.\n   *\n   * <div class=\"alert alert-info\">\n   * In any case, the value passed to the method should always reflect the current value\n   * of the control. For example, if you are calling `$setViewValue` for an input element,\n   * you should pass the input DOM value. Otherwise, the control and the scope model become\n   * out of sync. It's also important to note that `$setViewValue` does not call `$render` or change\n   * the control's DOM value in any way. If we want to change the control's DOM value\n   * programmatically, we should update the `ngModel` scope expression. Its new value will be\n   * picked up by the model controller, which will run it through the `$formatters`, `$render` it\n   * to update the DOM, and finally call `$validate` on it.\n   * </div>\n   *\n   * @param {*} value value from the view.\n   * @param {string} [trigger] Event that triggered the update.\n   */\n  $setViewValue(value, trigger) {\n    this.$viewValue = value;\n\n    if (this.$options?.getOption(\"updateOnDefault\")) {\n      this._debounceViewValueCommit(trigger);\n    }\n  }\n\n  /**\n   * @param {string | undefined} trigger\n   */\n  _debounceViewValueCommit(trigger) {\n    let debounceDelay = this.$options.getOption(\"debounce\");\n\n    if (trigger) {\n      const debounceVal = /** @type {Record<string, any>} */ (debounceDelay)[\n        trigger\n      ];\n\n      if (isNumber(debounceVal)) {\n        debounceDelay = debounceVal;\n      } else if (\n        isNumber(\n          /** @type {Object.<string, number>} */ (debounceDelay).default,\n        ) &&\n        /** @type {string} */ (this.$options.getOption(\"updateOn\")).indexOf(\n          trigger,\n        ) === -1\n      ) {\n        debounceDelay = /** @type {Object.<string, number>} */ (debounceDelay)\n          .default;\n      }\n    } else if (\n      isNumber(/** @type {Record<string, any>} */ (debounceDelay)[\"*\"])\n    ) {\n      debounceDelay = /** @type {Record<string, any>} */ (debounceDelay)[\"*\"];\n    }\n\n    this._pendingDebounce && clearTimeout(this._pendingDebounce);\n    const that = this;\n\n    if (/** @type {number} */ (debounceDelay) > 0) {\n      // this fails if debounceDelay is an object\n      this._pendingDebounce = setTimeout(() => {\n        that.$commitViewValue();\n      }, /** @type {number} */ (debounceDelay));\n    } else {\n      this.$commitViewValue();\n    }\n  }\n\n  /**\n   *\n   * Override the current model options settings programmatically.\n   *\n   * The previous `ModelOptions` value will not be modified. Instead, a\n   * new `ModelOptions` object will inherit from the previous one overriding\n   * or inheriting settings that are defined in the given parameter.\n   *\n   * See {@link ngModelOptions} for information about what options can be specified\n   * and how model option inheritance works.\n   *\n   * <div class=\"alert alert-warning\">\n   * **Note:** this function only affects the options set on the `ngModelController`,\n   * and not the options on the {@link ngModelOptions} directive from which they might have been\n   * obtained initially.\n   * </div>\n   *\n   * <div class=\"alert alert-danger\">\n   * **Note:** it is not possible to override the `getterSetter` option.\n   * </div>\n   *\n   * @param {import(\"./interface.ts\").NgModelOptions} options a hash of settings to override the previous options\n   *\n   */\n  $overrideModelOptions(options) {\n    this._removeAllEventListeners();\n    this.$options = this.$options.createChild(options);\n    this._updateEvents = this.$options._options.updateOn;\n    this._setUpdateOnEvents();\n  }\n\n  /**\n   * Runs the model -> view pipeline on the current\n   * {@link ngModel.NgModelController#$modelValue $modelValue}.\n   *\n   * The following actions are performed by this method:\n   *\n   * - the `$modelValue` is run through the {@link ngModel.NgModelController#$formatters $formatters}\n   * and the result is set to the {@link ngModel.NgModelController#$viewValue $viewValue}\n   * - the `ng-empty` or `ng-not-empty` class is set on the element\n   * - if the `$viewValue` has changed:\n   *   - {@link ngModel.NgModelController#$render $render} is called on the control\n   *   - the {@link ngModel.NgModelController#$validators $validators} are run and\n   *   the validation status is set.\n   *\n   * This method is called by ngModel internally when the bound scope value changes.\n   * Application developers usually do not have to call this function themselves.\n   *\n   * This function can be used when the `$viewValue` or the rendered DOM value are not correctly\n   * formatted and the `$modelValue` must be run through the `$formatters` again.\n   *\n   * @example\n   * Consider a text input with an autocomplete list (for fruit), where the items are\n   * objects with a name and an id.\n   * A user enters `ap` and then selects `Apricot` from the list.\n   * Based on this, the autocomplete widget will call `$setViewValue({name: 'Apricot', id: 443})`,\n   * but the rendered value will still be `ap`.\n   * The widget can then call `ctrl.$processModelValue()` to run the model -> view\n   * pipeline again, which formats the object to the string `Apricot`,\n   * then updates the `$viewValue`, and finally renders it in the DOM.\n   *\n   * <example module=\"inputExample\" name=\"ng-model-process\">\n     <file name=\"index.html\">\n      <div ng-controller=\"inputController\" style=\"display: flex;\">\n        <div style=\"margin-right: 30px;\">\n          Search Fruit:\n          <basic-autocomplete items=\"items\" on-select=\"selectedFruit = item\"></basic-autocomplete>\n        </div>\n        <div>\n          Model:<br>\n          <pre>{{selectedFruit | json}}</pre>\n        </div>\n      </div>\n     </file>\n     <file name=\"app.js\">\n      angular.module('inputExample', [])\n        .controller('inputController', function($scope) {\n          $scope.items = [\n            {name: 'Apricot', id: 443},\n            {name: 'Clementine', id: 972},\n            {name: 'Durian', id: 169},\n            {name: 'Jackfruit', id: 982},\n            {name: 'Strawberry', id: 863}\n          ];\n        })\n        .component('basicAutocomplete', {\n          bindings: {\n            items: '<',\n            onSelect: '&'\n          },\n          templateUrl: 'autocomplete.html',\n          controller: function($element, $scope) {\n            let that = this;\n            let ngModel;\n\n            that.$postLink = function() {\n              ngModel = $element.querySelectorAll('input').controller('ngModel');\n\n              ngModel.$formatters.push(function(value) {\n                return (value && value.name) || value;\n              });\n\n              ngModel.$parsers.push(function(value) {\n                let match = value;\n                for (let i = 0; i < that.items.length; i++) {\n                  if (that.items[i].name === value) {\n                    match = that.items[i];\n                    break;\n                  }\n                }\n\n                return match;\n              });\n            };\n\n            that.selectItem = function(item) {\n              ngModel.$setViewValue(item);\n              ngModel.$processModelValue();\n              that.onSelect({item: item});\n            };\n          }\n        });\n     </file>\n     <file name=\"autocomplete.html\">\n       <div>\n         <input type=\"search\" ng-model=\"$ctrl.searchTerm\" />\n         <ul>\n           <li ng-repeat=\"item in $ctrl.items | filter:$ctrl.searchTerm\">\n             <button ng-click=\"$ctrl.selectItem(item)\">{{ item.name }}</button>\n           </li>\n         </ul>\n       </div>\n     </file>\n   * </example>\n   *\n   */\n  $processModelValue() {\n    const viewValue = this._format();\n\n    if (this.$viewValue !== viewValue) {\n      this._updateEmptyClasses(viewValue);\n      this.$viewValue = this._lastCommittedViewValue = viewValue;\n      this.$render();\n      // It is possible that model and view value have been updated during render\n      this._runValidators(this.$modelValue, this.$viewValue, () => {\n        /* empty */\n      });\n    }\n  }\n\n  /**\n   * This method is called internally to run the $formatters on the $modelValue\n   */\n  _format() {\n    const formatters = this.$formatters;\n\n    let idx = formatters.length;\n\n    let viewValue = this.$modelValue;\n\n    while (idx--) {\n      viewValue = formatters[idx](viewValue);\n    }\n\n    return viewValue;\n  }\n\n  /**\n   * @ignore This method is called internally when the bound scope value changes.\n   * @param {any} modelValue\n   */\n  _setModelValue(modelValue) {\n    this.$modelValue = this._rawModelValue = modelValue;\n    this._parserValid = undefined;\n    this.$processModelValue();\n  }\n\n  /**\n   * @ignore\n   */\n  _removeAllEventListeners() {\n    this._eventRemovers.forEach((removeCallback) => removeCallback());\n    this._eventRemovers.clear();\n  }\n\n  _setUpdateOnEvents() {\n    if (this._updateEvents) {\n      this._updateEvents.split(\" \").forEach((ev) => {\n        this._element.addEventListener(ev, this._updateEventHandler);\n        this._eventRemovers.add(() =>\n          this._element.removeEventListener(ev, this._updateEventHandler),\n        );\n      });\n    }\n\n    this._updateEvents = /** @type {string} */ (\n      this.$options.getOption(\"updateOn\")\n    );\n\n    if (this._updateEvents) {\n      this._updateEvents.split(\" \").forEach((ev) => {\n        this._element.addEventListener(ev, this._updateEventHandler);\n        this._eventRemovers.add(() =>\n          this._element.removeEventListener(ev, this._updateEventHandler),\n        );\n      });\n    }\n  }\n\n  /**\n   * @param {Event} ev\n   */\n  _updateEventHandler(ev) {\n    this._debounceViewValueCommit(ev && ev.type);\n  }\n}\n\n/**\n * @param {NgModelController} ctrl\n */\nfunction setupModelWatcher(ctrl) {\n  // model -> value\n  // Note: we cannot use a normal scope.$watch as we want to detect the following:\n  // 1. scope value is 'a'\n  // 2. user enters 'b'\n  // 3. ng-change kicks in and reverts scope value to 'a'\n  //    -> scope value did not change since the last digest as\n  //       ng-change executes in apply phase\n  // 4. view should be changed back to 'a'\n  ctrl._scope.$watch(\"value\", () => {\n    const modelValue = ctrl._ngModelGet(ctrl._scope);\n\n    // if scope model value and ngModel value are out of sync\n    // This cannot be moved to the action function, because it would not catch the\n    // case where the model is changed in the ngChange function or the model setter\n    if (\n      modelValue !== ctrl.$modelValue &&\n      // checks for NaN is needed to allow setting the model to NaN when there's an asyncValidator\n\n      (!Number.isNaN(ctrl.$modelValue) || !Number.isNaN(modelValue))\n    ) {\n      ctrl._setModelValue(modelValue);\n    }\n  });\n}\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngModelDirective() {\n  return {\n    restrict: \"A\",\n    require: [\"ngModel\", \"^?form\", \"^?ngModelOptions\"],\n    controller: NgModelController,\n    // Prelink needs to run before any input directive\n    // so that we can set the NgModelOptions in NgModelController\n    // before anyone else uses it.\n    priority: 1,\n    compile:\n      /** @param {Element} element  */\n      (element) => {\n        // Setup initial state of the control\n        element.classList.add(PRISTINE_CLASS, UNTOUCHED_CLASS, VALID_CLASS);\n\n        return {\n          pre: (scope, _element, attr, ctrls) => {\n            const modelCtrl = ctrls[0];\n\n            const formCtrl = ctrls[1] || modelCtrl._parentForm;\n\n            const optionsCtrl = ctrls[2];\n\n            if (optionsCtrl) {\n              modelCtrl.$options = optionsCtrl.$options;\n            }\n            modelCtrl._initGetterSetters();\n\n            // notify others, especially parent forms\n            formCtrl.$addControl(modelCtrl);\n\n            attr.$observe(\"name\", (newValue) => {\n              if (modelCtrl.$name !== newValue) {\n                modelCtrl._parentForm._renameControl(modelCtrl, newValue);\n              }\n            });\n            const deregisterWatch = /** @type {() => void} */ (\n              scope.$watch(attr.ngModel, (val) => {\n                modelCtrl._setModelValue(deProxy(val));\n              })\n            );\n\n            scope.$on(\"$destroy\", () => {\n              modelCtrl._parentForm.$removeControl(modelCtrl);\n              deregisterWatch();\n            });\n          },\n          post: (scope, elementPost, _attr, ctrls) => {\n            const modelCtrl = ctrls[0];\n\n            modelCtrl._setUpdateOnEvents();\n\n            function setTouched() {\n              modelCtrl.$setTouched();\n            }\n\n            elementPost.addEventListener(\"blur\", () => {\n              if (modelCtrl.$touched) return;\n              setTouched();\n            });\n\n            modelCtrl.$viewChangeListeners.push(() => {\n              const { change } = elementPost.dataset;\n\n              change && scope.$eval(change);\n            });\n          },\n        };\n      },\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport {\n  deProxy,\n  equals,\n  isDefined,\n  isNumber,\n  isNumberNaN,\n  isObject,\n  isProxy,\n  isString,\n  isUndefined,\n  nextUid,\n  trim,\n} from \"../../shared/utils.js\";\nimport { ngModelMinErr } from \"./../model/model.js\";\n\n/** @typedef {import(\"../model/model.js\").NgModelController} NgModelController */\n/** @typedef {import(\"./interface.ts\").NgModelControllerProxied} NgModelControllerProxied */\n\n// Regex code was initially obtained from SO prior to modification: https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231\nexport const ISO_DATE_REGEXP =\n  /^\\d{4,}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+(?:[+-][0-2]\\d:[0-5]\\d|Z)$/;\n// See valid URLs in RFC3987 (http://tools.ietf.org/html/rfc3987)\n// Note: We are being more lenient, because browsers are too.\n//   1. Scheme\n//   2. Slashes\n//   3. Username\n//   4. Password\n//   5. Hostname\n//   6. Port\n//   7. Path\n//   8. Query\n//   9. Fragment\n//                 1111111111111111 222   333333    44444        55555555555555555555555     666     77777777     8888888     999\nexport const URL_REGEXP =\n  /^[a-z][a-z\\d.+-]*:\\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\\s:/?#]+|\\[[a-f\\d:]+])(?::\\d+)?(?:\\/[^?#]*)?(?:\\?[^#]*)?(?:#.*)?$/i;\n\nexport const EMAIL_REGEXP =\n  /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\nconst NUMBER_REGEXP = /^\\s*([-+])?(\\d+|(\\d*(\\.\\d*)))([eE][+-]?\\d+)?\\s*$/;\n\nconst DATE_REGEXP = /^(\\d{4,})-(\\d{2})-(\\d{2})$/;\n\nconst DATETIMELOCAL_REGEXP =\n  /^(\\d{4,})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/;\n\nconst WEEK_REGEXP = /^(\\d{4,})-W(\\d\\d)$/;\n\nconst MONTH_REGEXP = /^(\\d{4,})-(\\d\\d)$/;\n\nconst TIME_REGEXP = /^(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/;\n\n// The name of a form control's ValidityState property.\n// This is used so that it's possible for internal tests to create mock ValidityStates.\nexport const VALIDITY_STATE_PROPERTY = \"validity\";\n\nconst PARTIAL_VALIDATION_EVENTS = \"keydown wheel mousedown\";\n\n/**\n * @type {Map<string, boolean>}\n */\nconst PARTIAL_VALIDATION_TYPES = new Map();\n\n\"date,datetime-local,month,time,week\".split(\",\").forEach((type) => {\n  PARTIAL_VALIDATION_TYPES.set(type, true);\n});\n/** @type {Record<string, import(\"./interface.js\").InputTypeHandler>} */\nconst inputType = {\n  text: textInputType,\n  date: createStringDateInputType(\"date\", DATE_REGEXP),\n  \"datetime-local\": createStringDateInputType(\n    \"datetimelocal\",\n    DATETIMELOCAL_REGEXP,\n  ),\n  time: createStringDateInputType(\"time\", TIME_REGEXP),\n  week: createStringDateInputType(\"week\", WEEK_REGEXP),\n  month: createStringDateInputType(\"month\", MONTH_REGEXP),\n  number: numberInputType,\n  url: urlInputType,\n  email: emailInputType,\n  radio: radioInputType,\n  range: rangeInputType,\n  checkbox: checkboxInputType,\n  hidden: () => {\n    /* empty */\n  },\n  button: () => {\n    /* empty */\n  },\n  submit: () => {\n    /* empty */\n  },\n  reset: () => {\n    /* empty */\n  },\n  file: () => {\n    /* empty */\n  },\n};\n\n/**\n * @param {NgModelController} ctrl\n */\nfunction stringBasedInputType(ctrl) {\n  ctrl.$formatters.push((value) =>\n    ctrl.$isEmpty(value) ? value : value.toString(),\n  );\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n */\nfunction textInputType(scope, element, attr, ctrl) {\n  baseInputType(scope, element, attr, ctrl);\n  stringBasedInputType(ctrl);\n}\n\n/**\n * @param {ng.Scope} _scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n */\nfunction baseInputType(_scope, element, attr, ctrl) {\n  const type = element.type.toLowerCase();\n\n  let composing = false;\n\n  // In composition mode, users are still inputting intermediate text buffer,\n  // hold the listener until composition is done.\n  // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent\n  element.addEventListener(\"compositionstart\", () => {\n    composing = true;\n  });\n\n  element.addEventListener(\"compositionend\", () => {\n    composing = false;\n    listener();\n  });\n\n  /**\n   * @type {number | null | undefined}\n   */\n  let timeout;\n\n  /** @type {(ev?: Event) => void} */\n  const listener = function (ev) {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n\n    if (composing) return;\n    let { value } = element;\n\n    const event = ev && ev.type;\n\n    // By default we will trim the value\n    // If the attribute ng-trim exists we will avoid trimming\n    // If input type is 'password', the value is never trimmed\n    if (type !== \"password\" && (!attr.ngTrim || attr.ngTrim !== \"false\")) {\n      value = trim(value);\n    }\n\n    // If a control is suffering from bad input (due to native validators), browsers discard its\n    // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the\n    // control's value is the same empty value twice in a row.\n    if (\n      ctrl.$viewValue !== value ||\n      (value === \"\" && ctrl._hasNativeValidators)\n    ) {\n      ctrl.$target.$setViewValue(value, event);\n    }\n  };\n\n  [\"input\", \"change\", \"paste\", \"drop\", \"cut\"].forEach((event) => {\n    element.addEventListener(event, listener);\n  });\n\n  // Some native input types (date-family) have the ability to change validity without\n  // firing any input/change events.\n  // For these event types, when native validators are present and the browser supports the type,\n  // check for validity changes on various DOM events.\n  if (\n    PARTIAL_VALIDATION_TYPES.has(type) &&\n    ctrl._hasNativeValidators &&\n    type === attr.type\n  ) {\n    element.addEventListener(PARTIAL_VALIDATION_EVENTS, (ev) => {\n      if (!timeout) {\n        const validity = element[VALIDITY_STATE_PROPERTY];\n\n        const origBadInput = validity.badInput;\n\n        const origTypeMismatch = validity.typeMismatch;\n\n        timeout = setTimeout(() => {\n          timeout = null;\n\n          if (\n            validity.badInput !== origBadInput ||\n            validity.typeMismatch !== origTypeMismatch\n          ) {\n            listener(ev);\n          }\n        });\n      }\n    });\n  }\n\n  ctrl.$render = function () {\n    // Workaround for Firefox validation #12102.\n    const value = ctrl.$isEmpty(ctrl.$viewValue) ? \"\" : ctrl.$viewValue;\n\n    if (element.value !== value) {\n      element.value = value;\n    }\n  };\n}\n\n/**\n * @param {string} type\n * @param {RegExp} regexp\n * @returns {*}\n */\nexport function createStringDateInputType(type, regexp) {\n  /**\n   * @param {ng.Scope} scope\n   * @param {HTMLInputElement} element\n   * @param {ng.Attributes} attr\n   * @param {NgModelControllerProxied} ctrl\n   * @param {ng.ParseService} $parse\n   */\n  return function stringDateInputType(scope, element, attr, ctrl, $parse) {\n    baseInputType(scope, element, attr, ctrl);\n    ctrl.$parsers.push((/** @type {string} */ value) => {\n      if (ctrl.$isEmpty(value)) return null;\n\n      if (regexp.test(value)) return value;\n\n      ctrl._parserName = type;\n\n      return undefined;\n    });\n\n    ctrl.$formatters.push((/** @type {unknown} */ value) => {\n      if (ctrl.$isEmpty(value)) return \"\";\n\n      if (!isString(value)) {\n        throw ngModelMinErr(\"datefmt\", \"Expected `{0}` to be a string\", value);\n      }\n\n      return value;\n    });\n\n    // Optional min/max\n    if (isDefined(attr.min) || attr.ngMin) {\n      let minVal = attr.min || $parse?.(attr.ngMin)(scope);\n\n      ctrl.$validators.min = (\n        /** @type {any} */ _modelValue,\n        /** @type {number} */ viewValue,\n      ) => ctrl.$isEmpty(viewValue) || viewValue >= minVal;\n      attr.$observe(\"min\", (val) => {\n        minVal = val;\n        ctrl.$validate();\n      });\n    }\n\n    if (isDefined(attr.max) || attr.ngMax) {\n      let maxVal = attr.max || $parse?.(attr.ngMax)(scope);\n\n      ctrl.$validators.max = (\n        /** @type {any} */ _modelValue,\n        /** @type {number} */ viewValue,\n      ) => ctrl.$isEmpty(viewValue) || viewValue <= maxVal;\n      attr.$observe(\"max\", (val) => {\n        maxVal = val;\n        ctrl.$validate();\n      });\n    }\n  };\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n * @param {string} parserName\n */\nexport function badInputChecker(scope, element, attr, ctrl, parserName) {\n  const nativeValidation = (ctrl._hasNativeValidators = isObject(\n    element.validity,\n  ));\n\n  if (nativeValidation) {\n    ctrl.$parsers.push((/** @type {any} */ value) => {\n      const validity = element[VALIDITY_STATE_PROPERTY] || {};\n\n      if (validity.badInput || validity.typeMismatch) {\n        ctrl._parserName = parserName;\n\n        return undefined;\n      }\n\n      return value;\n    });\n  }\n}\n\n/**\n * @param {NgModelController} ctrl\n */\nexport function numberFormatterParser(ctrl) {\n  ctrl.$parsers.push((value) => {\n    if (ctrl.$isEmpty(value)) return null;\n\n    if (NUMBER_REGEXP.test(value)) return parseFloat(value);\n\n    ctrl._parserName = \"number\";\n\n    return undefined;\n  });\n\n  ctrl.$formatters.push((value) => {\n    if (!ctrl.$isEmpty(value)) {\n      if (!isNumber(value)) {\n        throw ngModelMinErr(\"numfmt\", \"Expected `{0}` to be a number\", value);\n      }\n      value = value.toString();\n    }\n\n    return value;\n  });\n}\n\n/**\n * @param {any} val\n * @return {number|undefined}\n */\nfunction parseNumberAttrVal(val) {\n  if (isDefined(val) && !isNumber(val)) {\n    val = parseFloat(val);\n  }\n\n  return !isNumberNaN(val) ? val : undefined;\n}\n\n/**\n * @param {any} num\n * @return {boolean}\n */\nexport function isNumberInteger(num) {\n  // See http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is-an-integer-in-javascript#14794066\n  // (minus the assumption that `num` is a number)\n\n  return (num | 0) === num;\n}\n\n/**\n * @param {number} num\n * @return {number}\n */\nexport function countDecimals(num) {\n  const numString = num.toString();\n\n  const decimalSymbolIndex = numString.indexOf(\".\");\n\n  if (decimalSymbolIndex === -1) {\n    if (num > -1 && num < 1) {\n      // It may be in the exponential notation format (`1e-X`)\n      const match = /e-(\\d+)$/.exec(numString);\n\n      if (match) {\n        return Number(match[1]);\n      }\n    }\n\n    return 0;\n  }\n\n  return numString.length - decimalSymbolIndex - 1;\n}\n\n/**\n * @param {any} viewValue\n * @param {number} stepBase\n * @param {number | undefined} step\n */\nexport function isValidForStep(viewValue, stepBase, step) {\n  // At this point `stepBase` and `step` are expected to be non-NaN values\n  // and `viewValue` is expected to be a valid stringified number.\n  let value = Number(viewValue);\n\n  const isNonIntegerValue = !isNumberInteger(value);\n\n  const isNonIntegerStepBase = !isNumberInteger(stepBase);\n\n  const isNonIntegerStep = !isNumberInteger(step);\n\n  // Due to limitations in Floating Point Arithmetic (e.g. `0.3 - 0.2 !== 0.1` or\n  // `0.5 % 0.1 !== 0`), we need to convert all numbers to integers.\n  if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {\n    const valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;\n\n    const stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;\n\n    const stepDecimals = isNonIntegerStep\n      ? countDecimals(/** @type {number} */ (step))\n      : 0;\n\n    const decimalCount = Math.max(\n      valueDecimals,\n      stepBaseDecimals,\n      stepDecimals,\n    );\n\n    const multiplier = 10 ** decimalCount;\n\n    value *= multiplier;\n    stepBase *= multiplier;\n    /** @type {number} */ (step) *= multiplier;\n\n    if (isNonIntegerValue) value = Math.round(value);\n\n    if (isNonIntegerStepBase) stepBase = Math.round(stepBase);\n\n    if (isNonIntegerStep) step = Math.round(/** @type {number} */ (step));\n  }\n\n  return (value - stepBase) % /** @type {number} */ (step) === 0;\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n * @param {ng.ParseService} $parse\n */\nexport function numberInputType(scope, element, attr, ctrl, $parse) {\n  badInputChecker(scope, element, attr, ctrl, \"number\");\n  numberFormatterParser(ctrl);\n  baseInputType(scope, element, attr, ctrl);\n\n  /**\n   * @type {number | undefined}\n   */\n  let parsedMinVal;\n\n  if (isDefined(attr.min) || attr.ngMin) {\n    let minVal = attr.min || $parse(attr.ngMin)(scope);\n\n    parsedMinVal = parseNumberAttrVal(minVal);\n\n    ctrl.$validators.min = function (\n      /** @type {any} */ modelValue,\n      /** @type {number} */ viewValue,\n    ) {\n      return (\n        ctrl.$isEmpty(viewValue) ||\n        isUndefined(parsedMinVal) ||\n        viewValue >= /** @type {number} */ (parsedMinVal)\n      );\n    };\n\n    attr.$observe(\"min\", (val) => {\n      if (val !== minVal) {\n        parsedMinVal = parseNumberAttrVal(val);\n        minVal = val;\n        // TODO(matsko): implement validateLater to reduce number of validations\n        ctrl.$validate();\n      }\n    });\n  }\n\n  if (isDefined(attr.max) || attr.ngMax) {\n    let maxVal = attr.max || $parse(attr.ngMax)(scope);\n\n    let parsedMaxVal = parseNumberAttrVal(maxVal);\n\n    ctrl.$validators.max = function (\n      /** @type {any} */ modelValue,\n      /** @type {number} */ viewValue,\n    ) {\n      return (\n        ctrl.$isEmpty(viewValue) ||\n        isUndefined(parsedMaxVal) ||\n        viewValue <= /** @type {number} */ (parsedMaxVal)\n      );\n    };\n\n    attr.$observe(\"max\", (val) => {\n      if (val !== maxVal) {\n        parsedMaxVal = parseNumberAttrVal(val);\n        maxVal = val;\n        // TODO(matsko): implement validateLater to reduce number of validations\n        ctrl.$validate();\n      }\n    });\n  }\n\n  if (isDefined(attr.step) || attr.ngStep) {\n    let stepVal = attr.step || $parse(attr.ngStep)(scope);\n\n    let parsedStepVal = parseNumberAttrVal(stepVal);\n\n    ctrl.$validators.step = function (\n      /** @type {any} */ modelValue,\n      /** @type {any} */ viewValue,\n    ) {\n      return (\n        ctrl.$isEmpty(viewValue) ||\n        isUndefined(parsedStepVal) ||\n        isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal)\n      );\n    };\n\n    attr.$observe(\"step\", (val) => {\n      // TODO(matsko): implement validateLater to reduce number of validations\n      if (val !== stepVal) {\n        parsedStepVal = parseNumberAttrVal(val);\n        stepVal = val;\n        ctrl.$validate();\n      }\n    });\n  }\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n */\nexport function rangeInputType(scope, element, attr, ctrl) {\n  badInputChecker(scope, element, attr, ctrl, \"range\");\n  numberFormatterParser(ctrl);\n  baseInputType(scope, element, attr, ctrl);\n\n  const supportsRange = ctrl._hasNativeValidators && element.type === \"range\";\n\n  let minVal = supportsRange ? 0 : undefined;\n\n  let maxVal = supportsRange ? 100 : undefined;\n\n  let stepVal = supportsRange ? 1 : undefined;\n\n  const { validity } = element;\n\n  const hasMinAttr = isDefined(attr.min);\n\n  const hasMaxAttr = isDefined(attr.max);\n\n  const hasStepAttr = isDefined(attr.step);\n\n  const originalRender = ctrl.$render;\n\n  ctrl.$render =\n    supportsRange &&\n    isDefined(validity.rangeUnderflow) &&\n    isDefined(validity.rangeOverflow)\n      ? // Browsers that implement range will set these values automatically, but reading the adjusted values after\n        // $render would cause the min / max validators to be applied with the wrong value\n        function rangeRender() {\n          originalRender();\n          ctrl.$setViewValue(element.value);\n        }\n      : originalRender;\n\n  if (hasMinAttr) {\n    minVal = parseNumberAttrVal(attr.min);\n\n    ctrl.$validators.min = supportsRange\n      ? // Since all browsers set the input to a valid value, we don't need to check validity\n        function noopMinValidator() {\n          return true;\n        }\n      : // non-support browsers validate the min val\n        function minValidator(\n          /** @type {any} */ modelValue,\n          /** @type {number} */ viewValue,\n        ) {\n          return (\n            ctrl.$isEmpty(viewValue) ||\n            isUndefined(minVal) ||\n            viewValue >= /** @type {number} */ (minVal)\n          );\n        };\n\n    setInitialValueAndObserver(\"min\", minChange);\n  }\n\n  if (hasMaxAttr) {\n    maxVal = parseNumberAttrVal(attr.max);\n\n    ctrl.$validators.max = supportsRange\n      ? // Since all browsers set the input to a valid value, we don't need to check validity\n        function noopMaxValidator() {\n          return true;\n        }\n      : // non-support browsers validate the max val\n        function maxValidator(\n          /** @type {any} */ modelValue,\n          /** @type {number} */ viewValue,\n        ) {\n          return (\n            ctrl.$isEmpty(viewValue) ||\n            isUndefined(maxVal) ||\n            viewValue <= /** @type {number} */ (maxVal)\n          );\n        };\n\n    setInitialValueAndObserver(\"max\", maxChange);\n  }\n\n  if (hasStepAttr) {\n    stepVal = parseNumberAttrVal(attr.step);\n\n    ctrl.$validators.step = supportsRange\n      ? function nativeStepValidator() {\n          // Currently, only FF implements the spec on step change correctly (i.e. adjusting the\n          // input element value to a valid value). It's possible that other browsers set the stepMismatch\n          // validity error instead, so we can at least report an error in that case.\n          return !validity.stepMismatch;\n        }\n      : // ngStep doesn't set the setp attr, so the browser doesn't adjust the input value as setting step would\n        function stepValidator(\n          /** @type {any} */ modelValue,\n          /** @type {any} */ viewValue,\n        ) {\n          return (\n            ctrl.$isEmpty(viewValue) ||\n            isUndefined(stepVal) ||\n            isValidForStep(viewValue, minVal || 0, stepVal)\n          );\n        };\n\n    setInitialValueAndObserver(\"step\", stepChange);\n  }\n\n  /**\n   * @param {string} htmlAttrName\n   * @param {(val: string | undefined) => void} changeFn\n   */\n  function setInitialValueAndObserver(htmlAttrName, changeFn) {\n    // interpolated attributes set the attribute value only after a digest, but we need the\n    // attribute value when the input is first rendered, so that the browser can adjust the\n    // input value based on the min/max value\n    element.setAttribute(htmlAttrName, attr[htmlAttrName]);\n    let oldVal = attr[htmlAttrName];\n\n    attr.$observe(htmlAttrName, (val) => {\n      if (val !== oldVal) {\n        oldVal = val;\n        changeFn(val);\n      }\n    });\n  }\n\n  /**\n   * @param {any} val\n   */\n  function minChange(val) {\n    minVal = parseNumberAttrVal(val);\n\n    // ignore changes before model is initialized\n    if (isNumberNaN(ctrl.$modelValue)) {\n      return;\n    }\n\n    if (supportsRange) {\n      // Browser already normalizes element.value against min\n      ctrl.$setViewValue(element.value);\n    } else {\n      // TODO(matsko): implement validateLater to reduce number of validations\n      ctrl.$validate();\n    }\n  }\n\n  /**\n   * @param {any} val\n   */\n  function maxChange(val) {\n    maxVal = parseNumberAttrVal(val);\n\n    // ignore changes before model is initialized\n    if (isNumberNaN(ctrl.$modelValue)) {\n      return;\n    }\n\n    if (supportsRange) {\n      // Browser normalizes element.value against max\n      ctrl.$setViewValue(element.value);\n    } else {\n      // TODO(matsko): implement validateLater to reduce number of validations\n      ctrl.$validate();\n    }\n  }\n\n  /**\n   * @param {any} val\n   */\n  function stepChange(val) {\n    stepVal = parseNumberAttrVal(val);\n\n    // ignore changes before model is initialized\n    if (isNumberNaN(ctrl.$modelValue)) {\n      return;\n    }\n\n    // Some browsers don't adjust the input value correctly, but set the stepMismatch error\n    if (!supportsRange) {\n      // TODO(matsko): implement validateLater to reduce number of validations\n      ctrl.$validate();\n    } else if (ctrl.$viewValue !== element.value) {\n      ctrl.$setViewValue(element.value);\n    }\n  }\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n */\nfunction urlInputType(scope, element, attr, ctrl) {\n  // Note: no badInputChecker here by purpose as `url` is only a validation\n  // in browsers, i.e. we can always read out input.value even if it is not valid!\n  baseInputType(scope, element, attr, ctrl);\n  stringBasedInputType(ctrl);\n\n  ctrl.$validators.url = function (\n    /** @type {any} */ modelValue,\n    /** @type {any} */ viewValue,\n  ) {\n    const value = modelValue || viewValue;\n\n    return ctrl.$isEmpty(value) || URL_REGEXP.test(value);\n  };\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n */\nfunction emailInputType(scope, element, attr, ctrl) {\n  // Note: no badInputChecker here by purpose as `url` is only a validation\n  // in browsers, i.e. we can always read out input.value even if it is not valid!\n  baseInputType(scope, element, attr, ctrl);\n  stringBasedInputType(ctrl);\n\n  ctrl.$validators.email = function (\n    /** @type {any} */ modelValue,\n    /** @type {any} */ viewValue,\n  ) {\n    const value = modelValue || viewValue;\n\n    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);\n  };\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {NgModelControllerProxied} ctrl\n */\nfunction radioInputType(scope, element, attr, ctrl) {\n  const doTrim = !attr.ngTrim || trim(attr.ngTrim) !== \"false\";\n\n  // make the name unique, if not defined\n  if (isUndefined(attr.name)) {\n    element.setAttribute(\"name\", `${nextUid()}`);\n  }\n\n  const listener = function (/** @type {Event} */ ev) {\n    if (element.checked) {\n      let { value } = attr;\n\n      if (doTrim) {\n        value = trim(value);\n      }\n      ctrl.$setViewValue(value, ev && ev.type);\n    }\n  };\n\n  element.addEventListener(\"change\", listener);\n  // NgModelController call\n  ctrl.$render = function () {\n    let { value } = attr;\n\n    if (doTrim) {\n      value = trim(value);\n    }\n    const deproxy = isProxy(ctrl.$viewValue)\n      ? /** @type {ng.Scope} */ (ctrl.$viewValue).$target\n      : ctrl.$viewValue;\n\n    // the proxy may reach down two levels\n    element.checked = deProxy(value) === deProxy(deproxy);\n  };\n\n  attr.$observe(\"value\", ctrl.$render);\n}\n\n/**\n *\n * @param {ng.ParseService} $parse\n * @param {*} context\n * @param {*} name\n * @param {*} expression\n * @param {*} fallback\n * @returns\n */\nfunction parseConstantExpr($parse, context, name, expression, fallback) {\n  let parseFn;\n\n  if (isDefined(expression)) {\n    parseFn = $parse(expression);\n\n    if (!parseFn.constant) {\n      throw ngModelMinErr(\n        \"constexpr\",\n        \"Expected constant expression for `{0}`, but saw \" + \"`{1}`.\",\n        name,\n        expression,\n      );\n    }\n\n    return parseFn(context);\n  }\n\n  return fallback;\n}\n\n/**\n *\n * @param {ng.Scope} scope\n * @param {HTMLInputElement} element\n * @param {ng.Attributes} attr\n * @param {*} ctrl\n * @param {ng.ParseService} $parse\n */\nfunction checkboxInputType(scope, element, attr, ctrl, $parse) {\n  const trueValue = parseConstantExpr(\n    $parse,\n    scope,\n    \"ngTrueValue\",\n    attr.ngTrueValue,\n    true,\n  );\n\n  const falseValue = parseConstantExpr(\n    $parse,\n    scope,\n    \"ngFalseValue\",\n    attr.ngFalseValue,\n    false,\n  );\n\n  const listener = function (/** @type {Event} */ ev) {\n    ctrl.$setViewValue(element.checked, ev && ev.type);\n  };\n\n  element.addEventListener(\"change\", listener);\n\n  ctrl.$render = function () {\n    element.checked = ctrl.$viewValue;\n  };\n\n  // Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`\n  // This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert\n  // it to a boolean.\n  ctrl.$isEmpty = function (/** @type {boolean} */ value) {\n    return value === false;\n  };\n\n  ctrl.$formatters.push((/** @type {any} */ value) => equals(value, trueValue));\n\n  ctrl.$parsers.push((/** @type {any} */ value) =>\n    value ? trueValue : falseValue,\n  );\n}\n\ninputDirective.$inject = [$injectTokens._parse];\n\n/**\n * @param {ng.ParseService} $parse\n * @returns {ng.Directive}\n */\nexport function inputDirective($parse) {\n  return {\n    restrict: \"E\",\n    require: [\"?ngModel\"],\n    link: {\n      pre(scope, element, attr, ctrls) {\n        if (ctrls[0]) {\n          (inputType[attr.type?.toLowerCase()] || inputType.text)(\n            scope,\n            /** @type {HTMLInputElement} */ (element),\n            attr,\n            ctrls[0],\n            $parse,\n          );\n        }\n      },\n    },\n  };\n}\n\n/**\n * @returns {ng.Directive}\n */\nexport function hiddenInputDirective() {\n  return {\n    restrict: \"E\",\n    compile(_, attr) {\n      if (attr.type?.toLowerCase() !== \"hidden\") return undefined;\n\n      return {\n        pre(_scope, element) {\n          /** @type {HTMLInputElement} */ (element).value =\n            element.getAttribute(\"value\") ?? \"\";\n        },\n      };\n    },\n  };\n}\n\nconst CONSTANT_VALUE_REGEXP = /^(true|false|\\d+)$/;\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngValueDirective() {\n  /**\n   * inputs use the value attribute as their default value if the value property is not set.\n   * Once the value property has been set (by adding input), it will not react to changes to\n   * the value attribute anymore. Setting both attribute and property fixes this behavior, and\n   * makes it possible to use ngValue as a sort of one-way bind.\n   * @param {HTMLInputElement} element\n   * @param {ng.Attributes} attr\n   * @param {any} value\n   */\n  function updateElementValue(element, attr, value) {\n    element.value = deProxy(value ?? \"\");\n    attr.$set(\"value\", value);\n  }\n\n  return {\n    restrict: \"A\",\n    priority: 100,\n    compile(_, tplAttr) {\n      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {\n        return function (scope, elm, attr) {\n          const value = scope.$eval(attr.ngValue);\n\n          updateElementValue(\n            /** @type {HTMLInputElement} */ (elm),\n            attr,\n            value,\n          );\n        };\n      }\n\n      return function (scope, elm, attr) {\n        scope.$watch(attr.ngValue, (value) => {\n          updateElementValue(\n            /** @type {HTMLInputElement} */ (elm),\n            attr,\n            value,\n          );\n        });\n      };\n    },\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\n\nscriptDirective.$inject = [$injectTokens._templateCache];\n\n/**\n * @param {ng.TemplateCacheService} $templateCache\n * @returns {ng.Directive}\n */\nexport function scriptDirective($templateCache) {\n  return {\n    restrict: \"E\",\n    terminal: true,\n    compile(element, attr) {\n      if (attr.type === \"text/ng-template\") {\n        $templateCache.set(attr.id, element.innerText);\n      }\n    },\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { getCacheData } from \"../../shared/dom.js\";\nimport { NodeType } from \"../../shared/node.js\";\nimport {\n  assertNotHasOwnProperty,\n  equals,\n  hashKey,\n  includes,\n  isDefined,\n  isNullOrUndefined,\n  isUndefined,\n  shallowCopy,\n} from \"../../shared/utils.js\";\n\n/**\n * The controller for the {@link ng.select select} directive.\n * The controller exposes a few utility methods that can be used to augment\n * the behavior of a regular or an {@link ng.ngOptions ngOptions} select element.\n */\nclass SelectController {\n  static $nonscope = [\n    \"ngModelCtrl\",\n    \"selectValueMap\",\n    \"emptyOption\",\n    \"optionsMap\",\n  ];\n\n  /**\n   * @type {Array<string>}\n   */\n  /* @ignore */ static $inject = [$injectTokens._element, $injectTokens._scope];\n\n  /**\n   * @param {HTMLSelectElement} $element\n   * @param {ng.Scope} $scope\n   */\n  constructor($element, $scope) {\n    /** @type {HTMLSelectElement} */\n    this._element = $element;\n\n    /** @type {ng.Scope} */\n    this._scope = $scope;\n\n    /** @type {Object<string, any>} */\n    this._selectValueMap = {};\n\n    /** @type {any} */\n    this._ngModelCtrl = {};\n\n    /** @type {boolean} */\n    this._multiple = false;\n\n    /** @private @type {HTMLOptionElement} */\n    this._unknownOption = document.createElement(\"option\");\n\n    /** @type {boolean} */\n    this._hasEmptyOption = false;\n\n    /** @type {HTMLOptionElement|undefined} */\n    this._emptyOption = undefined;\n\n    /** @type {Map<any, number>} */\n    this._optionsMap = new Map();\n\n    /** @type {boolean} */\n    this._renderScheduled = false;\n\n    /** @type {boolean} */\n    this._updateScheduled = false;\n\n    $scope.$on(\"$destroy\", () => {\n      // disable unknown option so that we don't do work when the whole select is being destroyed\n      this._renderUnknownOption = () => {\n        /* empty */\n      };\n    });\n  }\n\n  /**\n   * Render the unknown option when the viewValue doesn't match any options.\n   * @param {*} val\n   */\n  _renderUnknownOption(val) {\n    const unknownVal = this._generateUnknownOptionValue(val);\n\n    this._unknownOption.value = unknownVal;\n    this._element.prepend(this._unknownOption);\n    this._unknownOption.selected = true;\n    this._unknownOption.setAttribute(\"selected\", \"selected\");\n    this._element.value = unknownVal;\n  }\n\n  /**\n   * Update the unknown option if it's already rendered.\n   * @param {*} val\n   */\n  _updateUnknownOption(val) {\n    const unknownVal = this._generateUnknownOptionValue(val);\n\n    this._unknownOption.value = unknownVal;\n    this._unknownOption.selected = true;\n    this._unknownOption.setAttribute(\"selected\", \"selected\");\n    this._element.value = unknownVal;\n  }\n\n  /**\n   * Generate a special value used for unknown options.\n   * @param {*} val\n   * @returns {string}\n   */\n  _generateUnknownOptionValue(val) {\n    if (isUndefined(val)) {\n      return `? undefined:undefined ?`;\n    }\n\n    return `? ${hashKey(val)} ?`;\n  }\n\n  /**\n   * Remove the unknown option from the select element if it exists.\n   */\n  _removeUnknownOption() {\n    if (this._unknownOption.parentElement) this._unknownOption.remove();\n  }\n\n  /**\n   * Select the empty option (value=\"\") if it exists.\n   */\n  _selectEmptyOption() {\n    if (this._emptyOption) {\n      this._element.value = \"\";\n      this._emptyOption.selected = true;\n      this._emptyOption.setAttribute(\"selected\", \"selected\");\n    }\n  }\n\n  /**\n   * Unselect the empty option if present.\n   */\n  _un_selectEmptyOption() {\n    if (this._hasEmptyOption) {\n      /** @type {HTMLOptionElement} */ (this._emptyOption).selected = false;\n    }\n  }\n\n  /**\n   * Read the current value from the select element.\n   * @returns {*|null}\n   */\n  _readValue() {\n    const val = this._element.value;\n\n    const realVal =\n      val in this._selectValueMap ? this._selectValueMap[val] : val;\n\n    return this._hasOption(realVal) ? realVal : null;\n  }\n\n  /**\n   * Write a value to the select control.\n   * @param {*} value\n   */\n  _writeValue(value) {\n    const currentlySelectedOption =\n      this._element.options[this._element.selectedIndex];\n\n    if (currentlySelectedOption) currentlySelectedOption.selected = false;\n\n    if (this._hasOption(value)) {\n      this._removeUnknownOption();\n\n      const hashedVal = hashKey(value);\n\n      this._element.value =\n        hashedVal in this._selectValueMap ? hashedVal : value;\n      const selectedOption = this._element.options[this._element.selectedIndex];\n\n      if (!selectedOption) {\n        this._selectUnknownOrEmptyOption(value);\n      } else {\n        selectedOption.selected = true;\n      }\n    } else {\n      this._selectUnknownOrEmptyOption(value);\n    }\n  }\n\n  /**\n   * Register a new option with the controller.\n   * @param {*} value\n   * @param {HTMLOptionElement} element\n   */\n  _addOption(value, element) {\n    if (element.nodeType === NodeType._COMMENT_NODE) return;\n\n    assertNotHasOwnProperty(value, '\"option value\"');\n\n    if (value === \"\") {\n      this._hasEmptyOption = true;\n      this._emptyOption = element;\n    }\n    const count = this._optionsMap.get(value) || 0;\n\n    this._optionsMap.set(value, count + 1);\n    this._scheduleRender();\n  }\n\n  /**\n   * Remove an option from the controller.\n   * @param {*} value\n   */\n  _removeOption(value) {\n    const count = this._optionsMap.get(value);\n\n    if (count) {\n      if (count === 1) {\n        this._optionsMap.delete(value);\n\n        if (value === \"\") {\n          this._hasEmptyOption = false;\n          this._emptyOption = undefined;\n        }\n      } else {\n        this._optionsMap.set(value, count - 1);\n      }\n    }\n  }\n\n  /**\n   * Check if an option exists for the given value.\n   * @param {*} value\n   * @returns {boolean}\n   */\n  _hasOption(value) {\n    return !!this._optionsMap.get(value);\n  }\n\n  /**\n   * @returns {boolean} Whether the select element currently has an empty option.\n   */\n  $hasEmptyOption() {\n    return this._hasEmptyOption;\n  }\n\n  /**\n   * @returns {boolean} Whether the unknown option is currently selected.\n   */\n  $isUnknownOptionSelected() {\n    return this._element.options[0] === this._unknownOption;\n  }\n\n  /**\n   * @returns {boolean} Whether the empty option is selected.\n   */\n  $isEmptyOptionSelected() {\n    return (\n      this._hasEmptyOption &&\n      this._element.options[this._element.selectedIndex] === this._emptyOption\n    );\n  }\n\n  /**\n   * Select unknown or empty option depending on the value.\n   * @param {*} value\n   */\n  _selectUnknownOrEmptyOption(value) {\n    if (isNullOrUndefined(value) && this._emptyOption) {\n      this._removeUnknownOption();\n      this._selectEmptyOption();\n    } else if (this._unknownOption.parentElement) {\n      this._updateUnknownOption(value);\n    } else {\n      this._renderUnknownOption(value);\n    }\n  }\n\n  /**\n   * Schedule a render at the end of the digest cycle.\n   */\n  _scheduleRender() {\n    if (this._renderScheduled) return;\n    this._renderScheduled = true;\n    this._scope.$postUpdate(() => {\n      this._renderScheduled = false;\n      this._ngModelCtrl.$render();\n    });\n  }\n\n  /**\n   * Schedule a view value update at the end of the digest cycle.\n   * @param {boolean} [renderAfter=false]\n   */\n  _scheduleViewValueUpdate(renderAfter = false) {\n    if (this._updateScheduled) return;\n\n    this._updateScheduled = true;\n\n    this._scope.$postUpdate(() => {\n      if (this._scope._destroyed) return;\n\n      this._updateScheduled = false;\n      this._ngModelCtrl.$setViewValue(this._readValue());\n\n      if (renderAfter) this._ngModelCtrl.$render();\n    });\n  }\n\n  /**\n   * Register an option with interpolation or dynamic value/text.\n   * @param {any} optionScope\n   * @param {HTMLOptionElement} optionElement\n   * @param {any} optionAttrs\n   * @param {Function} [interpolateValueFn]\n   * @param {Function} [interpolateTextFn]\n   */\n  registerOption(\n    optionScope,\n    optionElement,\n    optionAttrs,\n    interpolateValueFn,\n    interpolateTextFn,\n  ) {\n    /**\n     * @type {any}\n     */\n    let oldVal;\n\n    /**\n     * @type {string}\n     */\n    let hashedVal;\n\n    if (optionAttrs.$attr.ngValue) {\n      optionAttrs.$observe(\"value\", (/** @type {any} */ newVal) => {\n        let removal;\n\n        const previouslySelected = optionElement.selected;\n\n        if (isDefined(hashedVal)) {\n          this._removeOption(oldVal);\n          delete this._selectValueMap[hashedVal];\n          removal = true;\n        }\n\n        hashedVal = hashKey(newVal);\n        oldVal = newVal;\n        this._selectValueMap[hashedVal] = newVal;\n        this._addOption(newVal, optionElement);\n        optionElement.setAttribute(\"value\", hashedVal);\n\n        if (removal && previouslySelected) {\n          this._scheduleViewValueUpdate();\n        }\n      });\n    } else if (interpolateValueFn) {\n      optionAttrs.$observe(\"value\", (/** @type {any} */ newVal) => {\n        this._readValue();\n        let removal;\n\n        const previouslySelected = optionElement.selected;\n\n        if (isDefined(oldVal)) {\n          this._removeOption(oldVal);\n          removal = true;\n        }\n        oldVal = newVal;\n        this._addOption(newVal, optionElement);\n\n        if (removal && previouslySelected) {\n          this._scheduleViewValueUpdate();\n        }\n      });\n    } else if (interpolateTextFn) {\n      optionScope.value = interpolateTextFn(optionScope);\n\n      if (!optionAttrs.value) {\n        optionAttrs.$set(\"value\", optionScope.value);\n        this._addOption(optionScope.value, optionElement);\n      }\n\n      optionScope.$watch(\"value\", () => {\n        const newVal = interpolateTextFn(optionScope);\n\n        if (!optionAttrs.value) {\n          optionAttrs.$set(\"value\", newVal);\n        }\n        const previouslySelected = optionElement.selected;\n\n        if (oldVal !== newVal) {\n          this._removeOption(oldVal);\n          oldVal = newVal;\n        }\n        this._addOption(newVal, optionElement);\n\n        if (oldVal && previouslySelected) {\n          this._scheduleViewValueUpdate();\n        }\n      });\n    } else {\n      this._addOption(optionAttrs.value, optionElement);\n    }\n\n    optionAttrs.$observe(\"disabled\", (/** @type {string} */ newVal) => {\n      if (newVal === \"true\" || (newVal && optionElement.selected)) {\n        if (this._multiple) {\n          this._scheduleViewValueUpdate(true);\n        } else {\n          this._ngModelCtrl.$setViewValue(null);\n          this._ngModelCtrl.$render();\n        }\n      }\n    });\n\n    optionElement.addEventListener(\"$destroy\", () => {\n      const currentValue = this._readValue();\n\n      const removeValue = optionAttrs.value;\n\n      this._removeOption(removeValue);\n      this._scheduleRender();\n\n      if (\n        (this._multiple &&\n          currentValue &&\n          currentValue.indexOf(removeValue) !== -1) ||\n        currentValue === removeValue\n      ) {\n        this._scheduleViewValueUpdate(true);\n      }\n    });\n  }\n}\n\n/**\n * @returns {ng.Directive}\n */\nexport function selectDirective() {\n  return {\n    restrict: \"E\",\n    require: [\"select\", \"?ngModel\"],\n    controller: SelectController,\n    priority: 1,\n    link: {\n      pre: selectPreLink,\n      post: selectPostLink,\n    },\n  };\n\n  /**\n   * @param {ng.Scope} _scope\n   * @param {{ addEventListener: (arg0: string, arg1: () => void) => void; getElementsByTagName: (arg0: string) => HTMLCollection; }} element\n   * @param {ng.Attributes} attr\n   * @param {any[]} ctrls\n   */\n  function selectPreLink(_scope, element, attr, ctrls) {\n    /** @type {SelectController} */\n    const selectCtrl = /** @type {SelectController} */ (ctrls[0]);\n\n    /** @type {import(\"../model/model.js\").NgModelController} */\n    const ngModelCtrl = ctrls[1];\n\n    // if ngModel is not defined, we don't need to do anything but set the registerOption\n    // function to noop, so options don't get added internally\n    if (!ngModelCtrl) {\n      selectCtrl.registerOption = () => {\n        /* empty */\n      };\n\n      return;\n    }\n    selectCtrl._ngModelCtrl = ngModelCtrl;\n\n    // When the selected item(s) changes we delegate getting the value of the select control\n    // to the `_readValue` method, which can be changed if the select can have multiple\n    // selected values or if the options are being generated by `ngOptions`\n    element.addEventListener(\"change\", () => {\n      selectCtrl._removeUnknownOption();\n      const viewValue = selectCtrl._readValue();\n\n      ngModelCtrl.$setViewValue(viewValue);\n    });\n\n    // If the select allows multiple values then we need to modify how we read and write\n    // values from and to the control; also what it means for the value to be empty and\n    // we have to add an extra watch since ngModel doesn't work well with arrays - it\n    // doesn't trigger rendering if only an item in the array changes.\n    if (attr.multiple) {\n      selectCtrl._multiple = true;\n\n      // Read value now needs to check each option to see if it is selected\n      selectCtrl._readValue = function () {\n        /**\n         * @type {any[]}\n         */\n        const array = [];\n\n        /**\n         * @type {HTMLCollection}\n         */\n        const options = element.getElementsByTagName(\"option\");\n\n        Array.from(options).forEach((option) => {\n          if (\n            /** @type {HTMLOptionElement} */ (option).selected &&\n            !(/** @type {HTMLOptionElement} */ (option).disabled)\n          ) {\n            const val = /** @type {HTMLOptionElement} */ (option).value;\n\n            array.push(\n              val in selectCtrl._selectValueMap\n                ? selectCtrl._selectValueMap[val]\n                : val,\n            );\n          }\n        });\n\n        return array;\n      };\n\n      // Write value now needs to set the selected property of each matching option\n      selectCtrl._writeValue = function (value) {\n        /**\n         * @type {HTMLCollection}\n         */\n        const options = element.getElementsByTagName(\"option\");\n\n        Array.from(options).forEach((option) => {\n          const shouldBeSelected =\n            !!value &&\n            (includes(value, /** @type {HTMLOptionElement} */ (option).value) ||\n              includes(\n                value,\n                selectCtrl._selectValueMap[\n                  /** @type {HTMLOptionElement} */ (option).value\n                ],\n              ));\n\n          const currentlySelected = /** @type {HTMLOptionElement} */ (option)\n            .selected;\n\n          // Support: IE 9-11 only, Edge 12-15+\n          // In IE and Edge adding options to the selection via shift+click/UP/DOWN\n          // will de-select already selected options if \"selected\" on those options was set\n          // more than once (i.e. when the options were already selected)\n          // So we only modify the selected property if necessary.\n          // Note: this behavior cannot be replicated via unit tests because it only shows in the\n          // actual user interface.\n          if (shouldBeSelected !== currentlySelected) {\n            /** @type {HTMLOptionElement} */ (option).selected =\n              shouldBeSelected;\n          }\n        });\n      };\n\n      // we have to do it on each watch since ngModel watches reference, but\n      // we need to work of an array, so we need to see if anything was inserted/removed\n      let lastView;\n\n      let lastViewRef = NaN;\n\n      if (\n        lastViewRef === ngModelCtrl.$viewValue &&\n        !equals(lastView, ngModelCtrl.$viewValue)\n      ) {\n        lastView = shallowCopy(ngModelCtrl.$viewValue);\n        ngModelCtrl.$render();\n      }\n      lastViewRef = ngModelCtrl.$viewValue;\n\n      // If we are a multiple select then value is now a collection\n      // so the meaning of $isEmpty changes\n      ngModelCtrl.$isEmpty = function (value) {\n        return !value || value.length === 0;\n      };\n    }\n  }\n\n  /**\n   * @param {ng.Scope} _scope\n   * @param {HTMLElement} _element\n   * @param {ng.Attributes} _attrs\n   * @param {any[]} ctrls\n   */\n  function selectPostLink(_scope, _element, _attrs, ctrls) {\n    // if ngModel is not defined, we don't need to do anything\n    const ngModelCtrl = ctrls[1];\n\n    if (!ngModelCtrl) return;\n\n    const selectCtrl = /** @type {SelectController} */ (ctrls[0]);\n\n    // We delegate rendering to the `_writeValue` method, which can be changed\n    // if the select can have multiple selected values or if the options are being\n    // generated by `ngOptions`.\n    // This must be done in the postLink fn to prevent $render to be called before\n    // all nodes have been linked correctly.\n    ngModelCtrl.$render = function () {\n      selectCtrl._writeValue(ngModelCtrl.$viewValue);\n    };\n  }\n}\n\n// The option directive is purely designed to communicate the existence (or lack of)\n// of dynamically created (and destroyed) option elements to their containing select\n// directive via its controller.\n\noptionDirective.$inject = [$injectTokens._interpolate];\n/**\n * @param {ng.InterpolateService} $interpolate\n * @returns {ng.Directive}\n */\nexport function optionDirective($interpolate) {\n  return {\n    restrict: \"E\",\n    priority: 100,\n    compile(element, attr) {\n      /**\n       * @type {import(\"../../core/interpolate/interface.ts\").InterpolationFunction | undefined}\n       */\n      let interpolateValueFn;\n\n      /**\n       * @type {import(\"../../core/interpolate/interface.ts\").InterpolationFunction | undefined}\n       */\n      let interpolateTextFn;\n\n      if (isDefined(attr.ngValue)) {\n        // Will be handled by registerOption\n      } else if (isDefined(attr.value)) {\n        // If the value attribute is defined, check if it contains an interpolation\n        interpolateValueFn = $interpolate(attr.value, true);\n      } else {\n        // If the value attribute is not defined then we fall back to the\n        // text content of the option element, which may be interpolated\n        interpolateTextFn = $interpolate(element.textContent, true);\n\n        if (!interpolateTextFn) {\n          attr.$set(\"value\", element.textContent);\n        }\n      }\n\n      return function (scope, elemParam, attrParam) {\n        // This is an optimization over using ^^ since we don't want to have to search\n        // all the way to the root of the DOM for every single option element\n        const selectCtrlName = \"$selectController\";\n\n        const parent = elemParam.parentElement;\n\n        const selectCtrl =\n          getCacheData(/** @type {HTMLElement} */ (parent), selectCtrlName) ||\n          getCacheData(\n            /** @type {HTMLElement} */ (\n              /** @type {HTMLElement} */ (parent).parentElement\n            ),\n            selectCtrlName,\n          ); // in case we are in optgroup\n\n        if (selectCtrl) {\n          selectCtrl.registerOption(\n            scope,\n            elemParam,\n            attrParam,\n            interpolateValueFn,\n            interpolateTextFn,\n          );\n        }\n      };\n    },\n  };\n}\n","import {\n  deProxy,\n  isDefined,\n  isNull,\n  isNullOrUndefined,\n  isUndefined,\n  stringify,\n} from \"../../shared/utils.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngBindDirective() {\n  return {\n    link(scope, element, attr) {\n      scope.$watch(\n        attr.ngBind,\n        (value) => {\n          element.textContent = /** @type {string} */ (\n            stringify(deProxy(value))\n          );\n        },\n        isDefined(attr.lazy),\n      );\n    },\n  };\n}\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngBindTemplateDirective() {\n  return {\n    link(_scope, element, attr) {\n      attr.$observe(\n        \"ngBindTemplate\",\n        (/** @type {string | null | undefined} */ value) => {\n          element.textContent = isNullOrUndefined(value) ? \"\" : value;\n        },\n      );\n    },\n  };\n}\n\nngBindHtmlDirective.$inject = [$injectTokens._parse];\n/**\n * @param {ng.ParseService} $parse\n * @returns {ng.Directive}\n */\nexport function ngBindHtmlDirective($parse) {\n  return {\n    restrict: \"A\",\n    compile(_tElement, tAttrs) {\n      $parse(tAttrs.ngBindHtml); // checks for interpolation errors\n\n      return (\n        /**\n         * @param {ng.Scope} scope\n         * @param {Element} element\n         */\n        (scope, element) => {\n          scope.$watch(tAttrs.ngBindHtml, (val) => {\n            if (isUndefined(val) || isNull(val)) {\n              val = \"\";\n            }\n            element.innerHTML = val;\n          });\n        }\n      );\n    },\n  };\n}\n","import { getCacheData, setCacheData } from \"../../shared/dom.js\";\nimport {\n  hasAnimate,\n  isArray,\n  isObject,\n  isString,\n  keys,\n  nullObject,\n} from \"../../shared/utils.js\";\n\n/**\n * @param {string} name\n * @param {boolean|number} selector\n * @returns {ng.DirectiveFactory}\n */\nfunction classDirective(name, selector) {\n  name = `ngClass${name}`;\n\n  /**\n   * @returns {ng.Directive}\n   */\n  return function () {\n    return {\n      /**\n       * @param {ng.Scope} scope\n       * @param {HTMLElement} element\n       * @param {ng.Attributes} attr\n       */\n      link(scope, element, attr) {\n        /** @type {Record<string, number>} */\n        let classCounts = getCacheData(element, \"$classCounts\");\n\n        // `ngClassOdd/ngClassEven` use `$index & 1` values (0/1). Plain `ngClass` uses `true`.\n        /** @type {number | boolean} */\n        let oldModulo = true;\n\n        /** @type {string} */\n        let oldClassString = \"\";\n\n        if (!classCounts) {\n          // Use Object.create(null) to prevent assumptions involving Object.prototype keys.\n          classCounts = /** @type {Record<string, number>} */ (nullObject());\n          setCacheData(element, \"$classCounts\", classCounts);\n        }\n\n        // Cache once; `hasAnimate(element)` should be stable for this directive instance.\n        const animate = hasAnimate(element);\n\n        if (name !== \"ngClass\") {\n          scope.$watch(\"$index\", () => {\n            ngClassIndexWatchAction(scope.$index & 1);\n          });\n        }\n\n        scope.$watch(attr[name], (val) => {\n          ngClassWatchAction(toClassString(val));\n        });\n\n        /**\n         * @param {string} classString\n         */\n        function addClasses(classString) {\n          const toAdd = digestClassCounts(split(classString), 1);\n\n          if (!toAdd.length) return;\n\n          if (animate) {\n            attr.$addClass(toAdd.join(\" \"));\n          } else {\n            scope.$postUpdate(() => {\n              element.classList.add(...toAdd);\n            });\n          }\n        }\n\n        /**\n         * @param {string} classString\n         */\n        function removeClasses(classString) {\n          const toRemove = digestClassCounts(split(classString), -1);\n\n          if (!toRemove.length) return;\n\n          if (animate) {\n            attr.$removeClass(toRemove.join(\" \"));\n          } else {\n            scope.$postUpdate(() => {\n              element.classList.remove(...toRemove);\n            });\n          }\n        }\n\n        /**\n         * @param {string} oldClassStringParam\n         * @param {string} newClassStringParam\n         */\n        function updateClasses(oldClassStringParam, newClassStringParam) {\n          const oldClassArray = split(oldClassStringParam);\n\n          const newClassArray = split(newClassStringParam);\n\n          const toRemoveArray = arrayDifference(oldClassArray, newClassArray);\n\n          const toAddArray = arrayDifference(newClassArray, oldClassArray);\n\n          const toRemove = digestClassCounts(toRemoveArray, -1);\n\n          const toAdd = digestClassCounts(toAddArray, 1);\n\n          if (animate) {\n            if (toAdd.length) attr.$addClass(toAdd.join(\" \"));\n\n            if (toRemove.length) attr.$removeClass(toRemove.join(\" \"));\n          } else {\n            if (toAdd.length) element.classList.add(...toAdd);\n\n            if (toRemove.length) element.classList.remove(...toRemove);\n          }\n        }\n\n        /**\n         * Updates reference-counts for classes and returns the classes that should be\n         * applied/removed for this operation.\n         *\n         * @param {string[]} classArray\n         * @param {number} count\n         * @returns {string[]}\n         */\n        function digestClassCounts(classArray, count) {\n          /** @type {string[]} */\n          const classesToUpdate = [];\n\n          for (let i = 0; i < classArray.length; i++) {\n            const className = classArray[i];\n\n            if (!className) continue;\n\n            // Only decrement if we have a count, otherwise we can go negative and\n            // remove classes that were never added.\n            if (count > 0 || classCounts[className]) {\n              const next = (classCounts[className] || 0) + count;\n\n              classCounts[className] = next;\n\n              // When adding: push when transitioning 0 -> 1.\n              // When removing: push when transitioning 1 -> 0.\n              if (next === (count > 0 ? 1 : 0)) {\n                classesToUpdate.push(className);\n              }\n            }\n          }\n\n          return classesToUpdate;\n        }\n\n        /**\n         * @param {number | boolean} newModulo\n         */\n        function ngClassIndexWatchAction(newModulo) {\n          // Runs before `ngClassWatchAction()`: it adds/removes `oldClassString`.\n          if (newModulo === selector) {\n            addClasses(oldClassString);\n          } else {\n            removeClasses(oldClassString);\n          }\n\n          oldModulo = newModulo;\n        }\n\n        /**\n         * @param {string} newClassString\n         */\n        function ngClassWatchAction(newClassString) {\n          if (oldModulo === selector) {\n            updateClasses(oldClassString, newClassString);\n          }\n\n          oldClassString = newClassString;\n        }\n      },\n    };\n  };\n}\n\n// Helpers\n\n/**\n * Returns all items from `tokens1` that are not present in `tokens2`.\n *\n * @param {string[]} tokens1\n * @param {string[]} tokens2\n * @returns {string[]}\n */\nexport function arrayDifference(tokens1, tokens2) {\n  if (!tokens1 || !tokens1.length) return [];\n\n  if (!tokens2 || !tokens2.length) return tokens1;\n\n  const set2 = new Set(tokens2);\n\n  /** @type {string[]} */\n  const out = [];\n\n  for (let i = 0; i < tokens1.length; i++) {\n    const x = tokens1[i];\n\n    if (!set2.has(x)) out.push(x);\n  }\n\n  return out;\n}\n\n/**\n * Split a class string into tokens.\n *\n * - Trims leading/trailing whitespace\n * - Collapses any whitespace runs (space/tab/newline) into token boundaries\n *\n * @param {string} classString\n * @return {string[]}\n */\nexport function split(classString) {\n  if (!classString) return [];\n  const trimmed = classString.trim();\n\n  return trimmed ? trimmed.split(/\\s+/) : [];\n}\n\n/**\n * Convert an `ngClass` expression value into a space-delimited class string.\n *\n * Supports:\n * - string: returned as-is\n * - array: flattened and joined with spaces (falsy items are ignored)\n * - object: keys with truthy values are included\n * - other primitives: stringified\n *\n * @param {unknown} classValue\n * @returns {string}\n */\nexport function toClassString(classValue) {\n  if (!classValue) return \"\";\n\n  if (isArray(classValue)) {\n    // Recursively stringify and omit empty results.\n    return classValue.map(toClassString).filter(Boolean).join(\" \");\n  }\n\n  if (isObject(classValue)) {\n    const valueMap = /** @type {Record<string, any>} */ (classValue);\n\n    const ks = keys(valueMap);\n\n    let out = \"\";\n\n    for (let i = 0; i < ks.length; i++) {\n      const k = ks[i];\n\n      if (valueMap[k]) out += (out ? \" \" : \"\") + k;\n    }\n\n    return out;\n  }\n\n  if (isString(classValue)) {\n    return classValue;\n  }\n\n  return String(classValue);\n}\n\nexport const ngClassDirective = classDirective(\"\", true);\nexport const ngClassOddDirective = classDirective(\"Odd\", 0);\nexport const ngClassEvenDirective = classDirective(\"Even\", 1);\n","/**\n * @returns {ng.Directive}\n */\nexport function ngCloakDirective() {\n  return {\n    compile(_, attr) {\n      attr.$set(\"ngCloak\", null);\n    },\n  };\n}\n","/**\n * @returns {ng.Directive}\n */\nexport function ngControllerDirective() {\n  return {\n    restrict: \"A\",\n    scope: true,\n    controller: \"@\",\n    priority: 500,\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { hasAnimate } from \"../../shared/utils.js\";\n\nconst NG_HIDE_CLASS = \"ng-hide\";\n\nconst NG_HIDE_IN_PROGRESS_CLASS = \"ng-hide-animate\";\n\nngShowDirective.$inject = [$injectTokens._animate];\n/**\n * @param {ng.AnimateService} $animate\n * @returns {ng.Directive}\n */\nexport function ngShowDirective($animate) {\n  return {\n    restrict: \"A\",\n    /**\n     * @param scope\n     * @param {Element} element\n     * @param $attr\n     */\n    link(scope, element, $attr) {\n      scope.$watch($attr.ngShow, (value) => {\n        // we're adding a temporary, animation-specific class for ng-hide since this way\n        // we can control when the element is actually displayed on screen without having\n        // to have a global/greedy CSS selector that breaks when other animations are run.\n        // Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845\n        if (hasAnimate(element)) {\n          $animate[value ? \"removeClass\" : \"addClass\"](element, NG_HIDE_CLASS, {\n            tempClasses: NG_HIDE_IN_PROGRESS_CLASS,\n          });\n        } else {\n          if (value) {\n            element.classList.remove(NG_HIDE_CLASS);\n          } else {\n            element.classList.add(NG_HIDE_CLASS);\n          }\n        }\n      });\n    },\n  };\n}\n\nngHideDirective.$inject = [$injectTokens._animate];\n/**\n * @param {ng.AnimateService} $animate\n * @returns {ng.Directive}\n */\nexport function ngHideDirective($animate) {\n  return {\n    restrict: \"A\",\n    link(scope, element, attr) {\n      scope.$watch(attr.ngHide, (value) => {\n        // The comment inside of the ngShowDirective explains why we add and\n        // remove a temporary class for the show/hide animation\n        if (hasAnimate(element)) {\n          $animate[value ? \"addClass\" : \"removeClass\"](element, NG_HIDE_CLASS, {\n            tempClasses: NG_HIDE_IN_PROGRESS_CLASS,\n          });\n        } else {\n          if (value) {\n            element.classList.add(NG_HIDE_CLASS);\n          } else {\n            element.classList.remove(NG_HIDE_CLASS);\n          }\n        }\n      });\n    },\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { removeElement } from \"../../shared/dom.js\";\nimport { hasAnimate } from \"../../shared/utils.js\";\n\nngIfDirective.$inject = [$injectTokens._animate];\n/**\n * @param {ng.AnimateService} $animate\n * @returns {ng.Directive}\n */\nexport function ngIfDirective($animate) {\n  return {\n    transclude: \"element\",\n    priority: 600,\n    terminal: true,\n    restrict: \"A\",\n    link($scope, $element, $attr, _ctrl, $transclude) {\n      /** @type {Element | null | undefined} */\n      let block;\n\n      /** @type {ng.Scope | null | undefined} */\n      let childScope;\n\n      /** @type {Element | null | undefined} */\n      let previousElements;\n\n      $scope.$watch($attr.ngIf, (value) => {\n        if (value) {\n          if (!childScope) {\n            /** @type {ng.TranscludeFn} */ ($transclude)((clone, newScope) => {\n              childScope = newScope;\n              // Note: We only need the first/last node of the cloned nodes.\n              // However, we need to keep the reference to the dom wrapper as it might be changed later\n              // by a directive with templateUrl when its template arrives.\n              block = /** @type {Element} */ (clone);\n\n              if (hasAnimate(/** @type {Node} */ (clone))) {\n                $animate.enter(\n                  /** @type {Element} */ (clone),\n                  /** @type {Element} */ ($element.parentElement),\n                  $element,\n                );\n              } else {\n                $element.after(/** @type {Node} */ (clone));\n              }\n            });\n          }\n        } else {\n          if (previousElements) {\n            removeElement(previousElements);\n            previousElements = null;\n          }\n\n          if (childScope) {\n            childScope.$destroy();\n            childScope = null;\n          }\n\n          if (block) {\n            previousElements = block;\n\n            if (hasAnimate(previousElements)) {\n              $animate.leave(previousElements).done((response) => {\n                if (response !== false) previousElements = null;\n              });\n            } else {\n              $element.nextElementSibling?.remove();\n            }\n            block = null;\n          }\n        }\n      });\n    },\n  };\n}\n","import { isDefined, hasAnimate } from \"../../shared/utils.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n\nngIncludeDirective.$inject = [\n  $t._templateRequest,\n  $t._anchorScroll,\n  $t._animate,\n  $t._exceptionHandler,\n];\n\n/**\n *\n * @param {ng.TemplateRequestService} $templateRequest\n * @param {ng.AnchorScrollService} $anchorScroll\n * @param {ng.AnimateService} $animate\n * @param {ng.ExceptionHandlerService} $exceptionHandler\n * @returns {ng.Directive}\n */\nexport function ngIncludeDirective(\n  $templateRequest,\n  $anchorScroll,\n  $animate,\n  $exceptionHandler,\n) {\n  return {\n    priority: 400,\n    terminal: true,\n    transclude: \"element\",\n    controller: () => {\n      /* empty */\n    },\n    compile(_element, attr) {\n      const srcExp = attr.ngInclude || attr.src;\n\n      const onloadExp = attr.onload || \"\";\n\n      const autoScrollExp = attr.autoscroll;\n\n      return (scope, $element, _$attr, ctrl, $transclude) => {\n        function maybeScroll() {\n          if (\n            isDefined(autoScrollExp) &&\n            (!autoScrollExp || scope.$eval(autoScrollExp))\n          ) {\n            $anchorScroll();\n          }\n        }\n\n        let changeCounter = 0;\n\n        /**\n         * @type {(ProxyConstructor & import(\"../../docs.js\").Scope & Record<string, any>) | null}\n         */\n        let currentScope;\n\n        /**\n         * @type {HTMLElement | null}\n         */\n        let previousElement;\n\n        /**\n         * @type {HTMLElement | null}\n         */\n        let currentElement;\n\n        const cleanupLastIncludeContent = () => {\n          if (previousElement) {\n            previousElement.remove();\n            previousElement = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentElement) {\n            if (hasAnimate(currentElement)) {\n              $animate.leave(currentElement).done((response) => {\n                if (response !== false) previousElement = null;\n              });\n            } else {\n              currentElement.remove();\n            }\n\n            previousElement = currentElement;\n            currentElement = null;\n          }\n        };\n\n        scope.$watch(srcExp, async (src) => {\n          const afterAnimation = function (/** @type {boolean} */ response) {\n            response !== false && maybeScroll();\n          };\n\n          const thisChangeId = ++changeCounter;\n\n          if (src) {\n            scope.$emit(\"$includeContentRequested\", src);\n            $templateRequest(src)\n              .then((response) => {\n                if (scope._destroyed) return;\n\n                if (thisChangeId !== changeCounter) return;\n                const newScope = scope.$new();\n\n                ctrl.template = response;\n\n                // Note: This will also link all children of ng-include that were contained in the original\n                // html. If that content contains controllers, ... they could pollute/change the scope.\n                // However, using ng-include on an element with additional content does not make sense...\n                // Note: We can't remove them in the cloneAttchFn of $transclude as that\n                // function is called before linking the content, which would apply child\n                // directives to non existing elements.\n                const clone = /** @type {HTMLElement} */ (\n                  /** @type {ng.TranscludeFn} */ ($transclude)(\n                    newScope,\n                    /** @param {import(\"../../core/compile/interface.ts\").TranscludedNodes | undefined} cloneParam */ (\n                      cloneParam,\n                    ) => {\n                      cleanupLastIncludeContent();\n\n                      if (hasAnimate(/** @type {HTMLElement} */ (cloneParam))) {\n                        $animate\n                          .enter(\n                            /** @type {HTMLElement} */ (cloneParam),\n                            null,\n                            $element,\n                          )\n                          .done(afterAnimation);\n                      } else {\n                        $element.after(/** @type {HTMLElement} */ (cloneParam));\n                        maybeScroll();\n                      }\n                    },\n                  )\n                );\n\n                currentScope = newScope;\n                currentElement = clone;\n                currentScope.$emit(\"$includeContentLoaded\", src);\n                scope.$eval(onloadExp);\n              })\n              .catch((err) => {\n                if (scope._destroyed) return;\n\n                if (thisChangeId === changeCounter) {\n                  cleanupLastIncludeContent();\n                  scope.$emit(\"$includeContentError\", src);\n                }\n                $exceptionHandler(new Error(err));\n              });\n          } else {\n            cleanupLastIncludeContent();\n            ctrl.template = null;\n          }\n        });\n      };\n    },\n  };\n}\n\n// This directive is called during the $transclude call of the first `ngInclude` directive.\n// It will replace and compile the content of the element with the loaded template.\n// We need this directive so that the element content is already filled when\n// the link function of another directive on the same element as ngInclude\n// is called.\nngIncludeFillContentDirective.$inject = [$t._compile];\n\n/**\n * @param {ng.CompileService} $compile\n * @returns {ng.Directive}\n */\nexport function ngIncludeFillContentDirective($compile) {\n  return {\n    priority: -400,\n    require: \"ngInclude\",\n    link(scope, $element, _$attr, ctrl) {\n      $element.innerHTML = ctrl.template;\n      $compile($element.childNodes)(scope);\n    },\n  };\n}\n","import { getController } from \"../../shared/dom.js\";\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngInitDirective() {\n  return {\n    priority: 450,\n    compile() {\n      return {\n        pre(scope, element, attrs) {\n          const controller = getController(element);\n\n          if (controller) {\n            controller.$eval(attrs.ngInit);\n          } else {\n            scope.$eval(attrs.ngInit);\n          }\n        },\n      };\n    },\n  };\n}\n","/**\n * @returns {ng.Directive}\n */\nexport function ngNonBindableDirective() {\n  return {\n    terminal: true,\n    priority: 1000,\n  };\n}\n","import {\n  directiveNormalize,\n  getNodeName,\n  hasOwn,\n  minErr,\n} from \"../../shared/utils.js\";\nimport { getCacheData } from \"../../shared/dom.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/**\n * The `ngRef` attribute tells AngularTS to assign the controller of a component (or a directive)\n * to the given property in the current scope.\n *\n * If the element with `ngRef` is destroyed `null` is assigned to the property.\n *\n * Note that if you want to assign from a child into the parent scope, you must initialize the\n * target property on the parent scope, otherwise `ngRef` will assign on the child scope.\n * This commonly happens when assigning elements or components wrapped in {@link ngIf} or\n * {@link ngRepeat}. See the second example below.\n *\n *\n * @element ANY\n * @param {string} ngRef property name - A valid AngularTS expression identifier to which the\n *                       controller or dom-wrapped DOM element will be bound.\n * @param {string=} ngRefRead read value - The name of a directive (or component) on this element,\n *                            or the special string `$element`. If a name is provided, `ngRef` will\n *                            assign the matching controller. If `$element` is provided, the element\n *                            itself is assigned (even if a controller is available).\n */\n\nconst ngRefMinErr = minErr(\"ngRef\");\n\nngRefDirective.$inject = [$injectTokens._parse];\n\n/**\n * @param {ng.ParseService} $parse\n * @return {ng.Directive}\n */\nexport function ngRefDirective($parse) {\n  return {\n    priority: -1, // Needed for compatibility with element transclusion on the same element\n    restrict: \"A\",\n    compile(tElement, tAttrs) {\n      // Get the expected controller name, converts <data-some-thing> into \"someThing\"\n      const controllerName = directiveNormalize(getNodeName(tElement));\n\n      // Get the expression for value binding\n      const getter = $parse(tAttrs.ngRef);\n\n      const setter =\n        getter._assign ||\n        function () {\n          throw ngRefMinErr(\n            \"nonassign\",\n            'Expression in ngRef=\"{0}\" is non-assignable!',\n            tAttrs.ngRef,\n          );\n        };\n\n      return (scope, element, attrs) => {\n        let refValue;\n\n        if (hasOwn(attrs, \"ngRefRead\")) {\n          if (attrs.ngRefRead === \"$element\") {\n            refValue = element;\n          } else {\n            refValue = getCacheData(element, `$${attrs.ngRefRead}Controller`);\n\n            if (!refValue) {\n              throw ngRefMinErr(\n                \"noctrl\",\n                'The controller for ngRefRead=\"{0}\" could not be found on ngRef=\"{1}\"',\n                attrs.ngRefRead,\n                tAttrs.ngRef,\n              );\n            }\n          }\n        } else {\n          refValue = getCacheData(element, `$${controllerName}Controller`);\n        }\n\n        refValue = refValue || element;\n\n        setter(scope, refValue);\n\n        // when the element is removed, remove it (nullify it)\n        element.addEventListener(\"$destroy\", () => {\n          // only remove it if value has not changed,\n          // because animations (and other procedures) may duplicate elements\n          if (getter(scope) === refValue) {\n            setter(scope, null);\n          }\n        });\n      };\n    },\n  };\n}\n","import {\n  callBackOnce,\n  hasOwn,\n  hashKey,\n  isArrayLike,\n  isDefined,\n  minErr,\n  nullObject,\n} from \"../../shared/utils.js\";\nimport { getBlockNodes, removeElement } from \"../../shared/dom.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\nconst NG_REMOVED = \"$$NG_REMOVED\";\n\nconst ngRepeatMinErr = minErr(\"ngRepeat\");\n\n/**\n * Regular expression to match either:\n * 1. A single variable name (optionally preceded by whitespace), e.g. \"foo\", \"   $bar\"\n * 2. A pair of variable names inside parentheses separated by a comma (with optional whitespace), e.g. \"(x, y)\", \"($foo, _bar123)\"\n *\n * Capturing groups:\n * - Group 1: The single variable name (if present)\n * - Group 2: The first variable in the tuple (if present)\n * - Group 3: The second variable in the tuple (if present)\n *\n * Examples:\n *  - Matches: \"foo\", \"   $var\", \"(x, y)\", \"($a, $b)\"\n *  - Does NOT match: \"x,y\", \"(x)\", \"(x y)\", \"\"\n *\n * @constant {RegExp}\n */\nconst VAR_OR_TUPLE_REGEX =\n  /^(?:(\\s*[$\\w]+)|\\(\\s*([$\\w]+)\\s*,\\s*([$\\w]+)\\s*\\))$/;\n\nngRepeatDirective.$inject = [$injectTokens._animate];\n\n/**\n * @param {ng.AnimateService}  $animate\n * @returns {ng.Directive}\n */\nexport function ngRepeatDirective($animate) {\n  /**\n   * @param {ng.Scope} scope\n   * @param {number} index\n   * @param {string | number} valueIdentifier\n   * @param {any} value\n   * @param {string | number} keyIdentifier\n   * @param {any} key\n   * @param {number} arrayLength\n   */\n  function updateScope(\n    scope,\n    index,\n    valueIdentifier,\n    value,\n    keyIdentifier,\n    key,\n    arrayLength,\n  ) {\n    // TODO(perf): generate setters to shave off ~40ms or 1-1.5%\n    if (scope[valueIdentifier] !== value) {\n      scope[valueIdentifier] = value;\n    }\n\n    if (keyIdentifier) scope[keyIdentifier] = key;\n\n    if (value) {\n      scope.$target._hashKey = value._hashKey;\n    }\n    scope.$index = index;\n    scope.$first = index === 0;\n    scope.$last = index === arrayLength - 1;\n    scope.$middle = !(scope.$first || scope.$last);\n    scope.$odd = !(scope.$even = (index & 1) === 0);\n  }\n\n  /**\n   * @param {{ clone: any; }} block\n   */\n  function getBlockStart(block) {\n    return block.clone;\n  }\n\n  /**\n   * @param {{ clone: any; }} block\n   */\n  function getBlockEnd(block) {\n    return block.clone;\n  }\n\n  /**\n   * @param {ng.Scope} _$scope\n   * @param {any} _key\n   * @param {any} value\n   */\n  function trackByIdArrayFn(_$scope, _key, value) {\n    return hashKey(value);\n  }\n\n  /**\n   * @param {ng.Scope} _$scope\n   * @param {any} key\n   */\n  function trackByIdObjFn(_$scope, key) {\n    return key;\n  }\n\n  return {\n    restrict: \"A\",\n    transclude: \"element\",\n    priority: 1000,\n    terminal: true,\n    compile(_$element, $attr) {\n      const expression = $attr.ngRepeat;\n\n      const hasAnimate = !!$attr.animate;\n\n      let match = expression.match(\n        /^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/,\n      );\n\n      if (!match) {\n        throw ngRepeatMinErr(\n          \"iexp\",\n          \"Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.\",\n          expression,\n        );\n      }\n\n      const lhs = match[1];\n\n      const rhs = match[2];\n\n      const aliasAs = match[3];\n\n      match = lhs.match(VAR_OR_TUPLE_REGEX);\n\n      if (!match) {\n        throw ngRepeatMinErr(\n          \"iidexp\",\n          \"'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.\",\n          lhs,\n        );\n      }\n      const valueIdentifier = match[3] || match[1];\n\n      const keyIdentifier = match[2];\n\n      if (\n        aliasAs &&\n        (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||\n          /^(null|undefined|this|\\$index|\\$first|\\$middle|\\$last|\\$even|\\$odd|\\$parent|\\$root|\\$id)$/.test(\n            aliasAs,\n          ))\n      ) {\n        throw ngRepeatMinErr(\n          \"badident\",\n          \"alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.\",\n          aliasAs,\n        );\n      }\n\n      let trackByIdExpFn;\n\n      const swap = callBackOnce(() => {\n        if (isDefined($attr.lazy) && isDefined($attr.swap)) {\n          document\n            .querySelectorAll($attr.swap)\n            .forEach((x) => removeElement(x));\n        }\n      });\n\n      /**\n       * @param {ng.Scope} $scope\n       * @param {HTMLElement} $element\n       * @param {ng.Attributes} attr\n       * @param {any} _ctrl\n       * @param {ng.TranscludeFn=} $transclude\n       */\n      function ngRepeatLink($scope, $element, attr, _ctrl, $transclude) {\n        // Store a list of elements from previous run. This is a hash where key is the item from the\n        // iterator, and the value is objects with following properties.\n        //   - scope: bound scope\n        //   - clone: previous element.\n        //   - index: position\n        //\n        // We are using no-proto object so that we don't need to guard against inherited props via\n        // hasOwnProperty.\n        let lastBlockMap = nullObject();\n\n        // watch props\n        $scope.$watch(\n          rhs,\n          (collection) => {\n            swap();\n            /**\n             * @type {number}\n             */\n            let index;\n\n            let previousNode = $element; // node that cloned nodes should be inserted after\n\n            // initialized to the comment node anchor\n            /** @type {Record<string, any>} */\n            let nextNode;\n\n            const // Same as lastBlockMap but it has the current state. It will become the\n              // lastBlockMap on the next iteration.\n              nextBlockMap = nullObject();\n\n            /**\n             * @type {string | number}\n             */\n            let key;\n\n            /**\n             * @type {any}\n             */\n            let value; // key/value of iteration\n\n            let trackById;\n\n            let trackByIdFn;\n\n            let collectionKeys;\n\n            /**\n             * @type {{ clone: any; scope?: any; id?: any; }}\n             */\n            let block; // last object information {scope, element, id}\n\n            let elementsToRemove;\n\n            if (aliasAs) {\n              $scope[aliasAs] = collection;\n            }\n\n            if (isArrayLike(collection)) {\n              collectionKeys = collection;\n              trackByIdFn = trackByIdExpFn || trackByIdArrayFn;\n            } else {\n              trackByIdFn = trackByIdExpFn || trackByIdObjFn;\n              // if object, extract keys, in enumeration order, unsorted\n              collectionKeys = [];\n\n              for (const itemKey in collection) {\n                if (hasOwn(collection, itemKey) && itemKey.charAt(0) !== \"$\") {\n                  collectionKeys.push(itemKey);\n                }\n              }\n            }\n\n            const collectionLength = collectionKeys.length;\n\n            const nextBlockOrder = new Array(collectionLength);\n\n            // locate existing items\n            for (index = 0; index < collectionLength; index++) {\n              key =\n                collection === collectionKeys ? index : collectionKeys[index];\n              value = collection[key];\n              trackById = trackByIdFn($scope, key, value);\n\n              if (lastBlockMap[trackById]) {\n                // found previously seen block\n                block = lastBlockMap[trackById];\n                delete lastBlockMap[trackById];\n                nextBlockMap[trackById] = block;\n                nextBlockOrder[index] = block;\n              } else if (nextBlockMap[trackById]) {\n                // if collision detected. restore lastBlockMap and throw an error\n                Object.values(nextBlockOrder).forEach((x) => {\n                  if (x && x.scope) lastBlockMap[x.id] = block;\n                });\n                throw ngRepeatMinErr(\n                  \"dupes\",\n                  \"Duplicates keys in a repeater are not allowed. Repeater: {0}, Duplicate key: {1} for value: {2}\",\n                  expression,\n                  trackById,\n                  value,\n                );\n              } else {\n                // new never before seen block\n                nextBlockOrder[index] = {\n                  id: trackById,\n                  scope: undefined,\n                  clone: undefined,\n                };\n                nextBlockMap[trackById] = true;\n              }\n            }\n\n            // remove leftover items\n            for (const blockKey in lastBlockMap) {\n              block = lastBlockMap[blockKey];\n              elementsToRemove = block.clone;\n\n              if (hasAnimate) {\n                $animate.leave(elementsToRemove);\n              } else {\n                elementsToRemove.remove();\n              }\n\n              if (elementsToRemove.parentNode) {\n                // if the element was not removed yet because of pending animation, mark it as deleted\n                // so that we can ignore it later\n                for (let i = 0, j = elementsToRemove.length; i < j; i++) {\n                  elementsToRemove[i][NG_REMOVED] = true;\n                }\n              }\n              block.scope.$destroy();\n            }\n\n            for (index = 0; index < collectionLength; index++) {\n              key =\n                collection === collectionKeys ? index : collectionKeys[index];\n              value = collection[key];\n              block = nextBlockOrder[index];\n\n              if (block.scope) {\n                // if we have already seen this object, then we need to reuse the\n                // associated scope/element\n\n                nextNode = previousNode;\n\n                // skip nodes that are already pending removal via leave animation\n                do {\n                  nextNode = nextNode.nextSibling;\n                } while (nextNode && nextNode[NG_REMOVED]);\n\n                if (getBlockStart(block) !== nextNode) {\n                  // existing item which got moved\n                  $animate.move(\n                    /** @type {any} */ (getBlockNodes(block.clone)),\n                    null,\n                    previousNode,\n                  );\n                }\n                previousNode = getBlockEnd(block);\n                updateScope(\n                  block.scope,\n                  index,\n                  valueIdentifier,\n                  value,\n                  keyIdentifier,\n                  key,\n                  collectionLength,\n                );\n              } else {\n                // new item which we don't know about\n                /** @type {ng.TranscludeFn} */ ($transclude)((clone, scope) => {\n                  block.scope = scope;\n                  const endNode = clone;\n\n                  if (hasAnimate) {\n                    $animate.enter(\n                      /** @type {HTMLElement} */ (clone),\n                      null,\n                      previousNode,\n                    );\n                  } else {\n                    previousNode.after(/** @type {HTMLElement} */ (clone));\n                  }\n\n                  previousNode = /** @type {HTMLElement} */ (endNode);\n                  // Note: We only need the first/last node of the cloned nodes.\n                  // However, we need to keep the reference to the dom wrapper as it might be changed later\n                  // by a directive with templateUrl when its template arrives.\n                  block.clone = clone;\n                  nextBlockMap[block.id] = block;\n                  updateScope(\n                    block.scope,\n                    index,\n                    valueIdentifier,\n                    value,\n                    keyIdentifier,\n                    key,\n                    collectionLength,\n                  );\n                });\n              }\n            }\n            lastBlockMap = nextBlockMap;\n          },\n          isDefined(attr.lazy),\n        );\n      }\n\n      return ngRepeatLink;\n    },\n  };\n}\n","/**\n * @returns {ng.Directive}\n */\nexport function ngStyleDirective() {\n  return {\n    restrict: \"A\",\n    link(scope, element, attr) {\n      /** @type {Record<string, string> | null} */\n      let oldStyles = null;\n\n      scope.$watch(attr.ngStyle, (newStyles) => {\n        const target = newStyles?.$target || newStyles;\n\n        if (oldStyles) {\n          for (const key in oldStyles) {\n            element.style.removeProperty(key);\n          }\n        }\n\n        if (target) {\n          oldStyles = {};\n\n          for (const key in target) {\n            const value = target[key];\n\n            element.style.setProperty(key, value);\n            oldStyles[key] = value;\n          }\n        } else {\n          oldStyles = null;\n        }\n      });\n    },\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { domInsert } from \"../../shared/dom.js\";\nimport { hasAnimate } from \"../../shared/utils.js\";\n\nngSwitchDirective.$inject = [$injectTokens._animate];\n\n/**\n * @param {ng.AnimateService} $animate\n * @returns {ng.Directive}\n */\nexport function ngSwitchDirective($animate) {\n  return {\n    require: \"ngSwitch\",\n\n    // asks for $scope to fool the BC controller module\n    controller: [\n      $injectTokens._scope,\n      class {\n        constructor() {\n          this.cases = {};\n        }\n      },\n    ],\n    link(scope, _element, attr, ngSwitchController) {\n      const watchExpr = attr.ngSwitch || attr.on;\n\n      let selectedTranscludes = [];\n\n      /**\n       * @type {any[]}\n       */\n      const selectedElements = [];\n\n      /**\n       * @type {import(\"../../docs.js\").AnimateRunner[]}\n       */\n      const previousLeaveAnimations = [];\n\n      /**\n       * @type {any[]}\n       */\n      const selectedScopes = [];\n\n      const spliceFactory = function (\n        /** @type {any[]} */ array,\n        /** @type {number} */ index,\n      ) {\n        return function (/** @type {boolean} */ response) {\n          if (response !== false) array.splice(index, 1);\n        };\n      };\n\n      scope.$watch(watchExpr, (value) => {\n        let i;\n\n        let ii;\n\n        let runner;\n\n        // Start with the last, in case the array is modified during the loop\n        while (previousLeaveAnimations.length) {\n          $animate.cancel(\n            /** @type {import(\"../../docs.js\").AnimateRunner} */ (\n              previousLeaveAnimations.pop()\n            ),\n          );\n        }\n\n        for (i = 0, ii = selectedScopes.length; i < ii; ++i) {\n          const selected = selectedElements[i].clone;\n\n          selectedScopes[i].$destroy();\n\n          if (hasAnimate(selected)) {\n            runner = previousLeaveAnimations[i] = $animate.leave(selected);\n\n            runner.done(spliceFactory(previousLeaveAnimations, i));\n          } else {\n            selected.remove();\n          }\n        }\n\n        selectedElements.length = 0;\n        selectedScopes.length = 0;\n\n        if (\n          (selectedTranscludes =\n            ngSwitchController.cases[`!${value}`] ||\n            ngSwitchController.cases[\"?\"])\n        ) {\n          Object.values(selectedTranscludes).forEach((selectedTransclude) => {\n            selectedTransclude.transclude(\n              (\n                /** @type {Node} */ caseElement,\n                /** @type {any} */ selectedScope,\n              ) => {\n                selectedScopes.push(selectedScope);\n                const anchor = selectedTransclude.element;\n\n                // TODO removing this breaks repeater test\n                const block = {\n                  clone: caseElement,\n                  comment: document.createComment(\"\"),\n                };\n\n                selectedElements.push(block);\n\n                if (hasAnimate(caseElement)) {\n                  if (runner) {\n                    requestAnimationFrame(() => {\n                      $animate.enter(\n                        /** @type {HTMLElement} */ (caseElement),\n                        anchor.parentElement,\n                        anchor,\n                      );\n                    });\n                  } else {\n                    $animate.enter(\n                      /** @type {HTMLElement} */ (caseElement),\n                      anchor.parentElement,\n                      anchor,\n                    );\n                  }\n                } else {\n                  domInsert(\n                    /** @type {HTMLElement} */ (caseElement),\n                    anchor.parentElement,\n                    anchor,\n                  );\n                }\n              },\n            );\n          });\n        }\n      });\n    },\n  };\n}\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngSwitchWhenDirective() {\n  return {\n    transclude: \"element\",\n    terminal: true,\n    priority: 1200,\n\n    require: \"^ngSwitch\",\n    link(scope, element, attrs, ctrl, $transclude) {\n      const cases = attrs.ngSwitchWhen\n        .split(attrs.ngSwitchWhenSeparator)\n        .sort()\n        .filter(\n          // Filter duplicate cases\n          (elementParam, index, array) => array[index - 1] !== elementParam,\n        );\n\n      cases.forEach((whenCase) => {\n        ctrl.cases[`!${whenCase}`] = ctrl.cases[`!${whenCase}`] || [];\n        ctrl.cases[`!${whenCase}`].push({\n          transclude: $transclude,\n          element,\n        });\n      });\n    },\n  };\n}\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngSwitchDefaultDirective() {\n  return {\n    transclude: \"element\",\n    terminal: true,\n    priority: 1200,\n    require: \"^ngSwitch\",\n    link(_scope, element, _attr, ctrl, $transclude) {\n      ctrl.cases[\"?\"] = ctrl.cases[\"?\"] || [];\n      ctrl.cases[\"?\"].push({ transclude: $transclude, element });\n    },\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { emptyElement, removeElement, startingTag } from \"../../shared/dom.js\";\nimport { NodeType } from \"../../shared/node.js\";\nimport {\n  equals,\n  hasOwn,\n  hashKey,\n  includes,\n  isArrayLike,\n  isDefined,\n  minErr,\n} from \"../../shared/utils.js\";\n\nconst ngOptionsMinErr = minErr(\"ngOptions\");\n\n/** @type {HTMLOptionElement} */\nconst optionTemplate = document.createElement(\"option\");\n\n/** @type {HTMLOptGroupElement} */\nconst optGroupTemplate = document.createElement(\"optgroup\");\n\nconst NG_OPTIONS_REGEXP =\n  /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([$\\w][$\\w]*)|(?:\\(\\s*([$\\w][$\\w]*)\\s*,\\s*([$\\w][$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/;\n\n// 1: value expression (valueFn)\n// 2: label expression (displayFn)\n// 3: group by expression (groupByFn)\n// 4: disable when expression (disableWhenFn)\n// 5: array item variable name\n// 6: object item key variable name\n// 7: object item value variable name\n// 8: collection expression\n// 9: track by expression\n\nclass OptionItem {\n  /** @type {HTMLOptionElement | null} */\n  element = null;\n\n  /**\n   * @param {any} selectValue\n   * @param {any} viewValue\n   * @param {any} label\n   * @param {any} group\n   * @param {any} disabled\n   */\n  constructor(selectValue, viewValue, label, group, disabled) {\n    this.selectValue = selectValue;\n    this.viewValue = viewValue;\n    this.label = label;\n    this.group = group;\n    this.disabled = disabled;\n  }\n}\n\nngOptionsDirective.$inject = [$injectTokens._compile, $injectTokens._parse];\n/**\n *\n * @param {ng.CompileService} $compile\n * @param {ng.ParseService} $parse\n * @returns {ng.Directive}\n */\nexport function ngOptionsDirective($compile, $parse) {\n  /**\n   * @param {import('../../interface.ts').Expression} optionsExp\n   * @param {HTMLSelectElement} selectElement\n   * @param {ng.Scope} scope\n   * @returns\n   */\n  function parseOptionsExpression(optionsExp, selectElement, scope) {\n    const match = optionsExp.match(NG_OPTIONS_REGEXP);\n\n    if (!match) {\n      throw ngOptionsMinErr(\n        \"iexp\",\n        \"Expected expression in form of \" +\n          \"'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'\" +\n          \" but got '{0}'. Element: {1}\",\n        optionsExp,\n        startingTag(selectElement),\n      );\n    }\n    // Extract the parts from the ngOptions expression\n\n    // The variable name for the value of the item in the collection\n    const valueName = match[5] || match[7];\n\n    // The variable name for the key of the item in the collection\n    const keyName = match[6];\n\n    // An expression that generates the viewValue for an option if there is a label expression\n    const selectAs = / as /.test(match[0]) && match[1];\n\n    // An expression that is used to track the id of each object in the options collection\n    const trackBy = match[9];\n\n    // An expression that generates the viewValue for an option if there is no label expression\n    const valueFn = $parse(match[2] ? match[1] : valueName);\n\n    const selectAsFn = selectAs && $parse(selectAs);\n\n    const viewValueFn = selectAsFn || valueFn;\n\n    const trackByFn = trackBy && $parse(trackBy);\n\n    // Get the value by which we are going to track the option\n    // if we have a trackFn then use that (passing scope and locals)\n    // otherwise just hash the given viewValue\n    const getTrackByValueFn = trackBy\n      ? function (/** @type {any} */ value, /** @type {any} */ locals) {\n          return /** @type {import(\"../../docs.ts\").CompiledExpression} */ (\n            trackByFn\n          )(scope, locals);\n        }\n      : function getHashOfValue(/** @type {any} */ value) {\n          return hashKey(value);\n        };\n\n    const getTrackByValue = function (\n      /** @type {any} */ value,\n      /** @type {any=} */ key,\n    ) {\n      return getTrackByValueFn(value, getLocals(value, key));\n    };\n\n    const displayFn = $parse(match[2] || match[1]);\n\n    const groupByFn = $parse(match[3] || \"\");\n\n    const disableWhenFn = $parse(match[4] || \"\");\n\n    const valuesFn = $parse(match[8]);\n\n    /** @type {Record<string, any>} */\n    const locals = {};\n\n    const getLocals = keyName\n      ? function (/** @type {any} */ value, /** @type {any} */ key) {\n          locals[keyName] = key;\n          locals[valueName] = value;\n\n          return locals;\n        }\n      : function (/** @type {any} */ value) {\n          locals[valueName] = value;\n\n          return locals;\n        };\n\n    /**\n     * @param {any[]} optionValues\n     */\n    function getOptionValuesKeys(optionValues) {\n      let optionValuesKeys;\n\n      if (!keyName && isArrayLike(optionValues)) {\n        optionValuesKeys = optionValues;\n      } else {\n        // if object, extract keys, in enumeration order, unsorted\n        optionValuesKeys = [];\n\n        for (const itemKey in optionValues) {\n          if (hasOwn(optionValues, itemKey) && itemKey.charAt(0) !== \"$\") {\n            optionValuesKeys.push(itemKey);\n          }\n        }\n      }\n\n      return optionValuesKeys;\n    }\n\n    return {\n      trackBy,\n      getTrackByValue,\n      getWatchables: valuesFn,\n      getOptions() {\n        /** @type {OptionItem[]} */\n        const optionItems = [];\n\n        /** @type {Object.<string, OptionItem>} */\n        const selectValueMap = {};\n\n        // The option values were already computed in the `getWatchables` fn,\n        // which must have been called to trigger `getOptions`\n        const optionValues = valuesFn(scope) || [];\n\n        const optionValuesKeys = getOptionValuesKeys(optionValues);\n\n        const optionValuesLength = optionValuesKeys.length;\n\n        for (let index = 0; index < optionValuesLength; index++) {\n          const key =\n            optionValues === optionValuesKeys ? index : optionValuesKeys[index];\n\n          const value = optionValues[key];\n\n          const updatedLocals = getLocals(value, key);\n\n          const viewValue = viewValueFn(scope, updatedLocals);\n\n          const selectValue = getTrackByValueFn(viewValue, updatedLocals);\n\n          const label = displayFn(scope, updatedLocals);\n\n          const group = groupByFn(scope, updatedLocals);\n\n          const disabled = disableWhenFn(scope, updatedLocals);\n\n          const optionItem = new OptionItem(\n            selectValue,\n            viewValue,\n            label,\n            group,\n            disabled,\n          );\n\n          optionItems.push(optionItem);\n          selectValueMap[selectValue] = optionItem;\n        }\n\n        return {\n          items: optionItems,\n          selectValueMap,\n          /**\n           * @param {any} value\n           */\n          getOptionFromViewValue(value) {\n            return selectValueMap[getTrackByValue(value, undefined)];\n          },\n          /**\n           * @param {{ viewValue: any; }} option\n           */\n          getViewValueFromOption(option) {\n            // If the viewValue could be an object that may be mutated by the application,\n            // we need to make a copy and not return the reference to the value on the option.\n            return trackBy\n              ? structuredClone(option.viewValue)\n              : option.viewValue;\n          },\n        };\n      },\n    };\n  }\n\n  /**\n   *\n   * @param {ng.Scope} scope\n   * @param {HTMLSelectElement} selectElement\n   * @param {ng.Attributes} attr\n   * @param {*} ctrls\n   */\n  function ngOptionsPostLink(scope, selectElement, attr, ctrls) {\n    const selectCtrl = ctrls[0];\n\n    const ngModelCtrl = ctrls[1];\n\n    const { multiple } = attr;\n\n    // The emptyOption allows the application developer to provide their own custom \"empty\"\n    // option when the viewValue does not match any of the option values.\n    for (\n      let i = 0, children = selectElement.childNodes, ii = children.length;\n      i < ii;\n      i++\n    ) {\n      if (/** @type {HTMLOptionElement} */ (children[i]).value === \"\") {\n        selectCtrl.hasEmptyOption = true;\n        selectCtrl.emptyOption = children[i];\n        break;\n      }\n    }\n\n    // The empty option will be compiled and rendered before we first generate the options\n    emptyElement(selectElement);\n\n    const providedEmptyOption = !!selectCtrl.emptyOption;\n\n    const unknownOption = optionTemplate.cloneNode(false);\n\n    // TODO double check\n    unknownOption.nodeValue = \"?\";\n\n    /**\n     * @type {{ getOptionFromViewValue: any; selectValueMap: any; getViewValueFromOption: any; items: any; }}\n     */\n    let options;\n\n    const ngOptions = parseOptionsExpression(\n      attr.ngOptions,\n      selectElement,\n      scope,\n    );\n\n    // This stores the newly created options before they are appended to the select.\n    // Since the contents are removed from the fragment when it is appended,\n    // we only need to create it once.\n    const listFragment = document.createDocumentFragment();\n\n    // Overwrite the implementation. ngOptions doesn't use hashes\n    selectCtrl._generateUnknownOptionValue = () => \"?\";\n\n    // Update the controller methods for multiple selectable options\n    if (!multiple) {\n      selectCtrl._writeValue = function writeNgOptionsValue(\n        /** @type {any} */ value,\n      ) {\n        // The options might not be defined yet when ngModel tries to render\n        if (!options) return;\n\n        const selectedOption =\n          selectElement.options[selectElement.selectedIndex];\n\n        const option = options.getOptionFromViewValue(value);\n\n        // Make sure to remove the selected attribute from the previously selected option\n        // Otherwise, screen readers might get confused\n        if (selectedOption) selectedOption.removeAttribute(\"selected\");\n\n        if (option) {\n          // Don't update the option when it is already selected.\n          // For example, the browser will select the first option by default. In that case,\n          // most properties are set automatically - except the `selected` attribute, which we\n          // set always\n\n          if (selectElement.value !== option.selectValue) {\n            selectCtrl._removeUnknownOption();\n\n            selectElement.value = option.selectValue;\n            option.element.selected = true;\n          }\n\n          option.element.setAttribute(\"selected\", \"selected\");\n        } else {\n          selectCtrl._selectUnknownOrEmptyOption(value);\n        }\n      };\n\n      selectCtrl._readValue = function readNgOptionsValue() {\n        const selectedOption = options.selectValueMap[selectElement.value];\n\n        if (selectedOption && !selectedOption.disabled) {\n          selectCtrl._un_selectEmptyOption();\n          selectCtrl._removeUnknownOption();\n\n          return options.getViewValueFromOption(selectedOption);\n        }\n\n        return null;\n      };\n\n      // If we are using `track by` then we must watch the tracked value on the model\n      // since ngModel only watches for object identity change\n      // FIXME: When a user selects an option, this watch will fire needlessly\n      if (ngOptions.trackBy) {\n        scope.$watch(\n          ngOptions.getTrackByValue(ngModelCtrl.$viewValue, undefined),\n          () => {\n            ngModelCtrl.$render();\n          },\n        );\n      }\n    } else {\n      selectCtrl._writeValue = function writeNgOptionsMultiple(\n        /** @type {any[]} */ values,\n      ) {\n        // The options might not be defined yet when ngModel tries to render\n        if (!options) return;\n\n        // Only set `<option>.selected` if necessary, in order to prevent some browsers from\n        // scrolling to `<option>` elements that are outside the `<select>` element's viewport.\n        const selectedOptions =\n          (values && values.map(getAndUpdateSelectedOption)) || [];\n\n        options.items.forEach(\n          /** @param {OptionItem} option */ (option) => {\n            if (\n              option.element?.selected &&\n              !includes(selectedOptions, option)\n            ) {\n              option.element.selected = false;\n            }\n          },\n        );\n      };\n\n      selectCtrl._readValue = function readNgOptionsMultiple() {\n        const selections = [];\n\n        const optionsEls = selectElement.options;\n\n        for (let i = 0; i < optionsEls.length; i++) {\n          const optionEl = optionsEls[i];\n\n          if (optionEl.selected) {\n            const option = options.selectValueMap[optionEl.value];\n\n            if (option && !option.disabled) {\n              selections.push(options.getViewValueFromOption(option));\n            }\n          }\n        }\n\n        return selections;\n      };\n\n      // If we are using `track by` then we must watch these tracked values on the model\n      // since ngModel only watches for object identity change\n      // if (ngOptions.trackBy) {\n      //   scope.$watchCollection(\n      //     () => {\n      //       if (isArray(ngModelCtrl.$viewValue)) {\n      //         return ngModelCtrl.$viewValue.map((value) =>\n      //           ngOptions.getTrackByValue(value),\n      //         );\n      //       }\n      //     },\n      //     () => {\n      //       ngModelCtrl.$render();\n      //     },\n      //   );\n      // }\n    }\n\n    if (providedEmptyOption) {\n      // compile the element since there might be bindings in it\n      const linkFn = $compile(selectCtrl.emptyOption);\n\n      selectElement.prepend(selectCtrl.emptyOption);\n      linkFn(scope);\n\n      if (selectCtrl.emptyOption.nodeType === NodeType._COMMENT_NODE) {\n        // This means the empty option has currently no actual DOM node, probably because\n        // it has been modified by a transclusion directive.\n        selectCtrl.hasEmptyOption = false;\n\n        // Redefine the registerOption function, which will catch\n        // options that are added by ngIf etc. (rendering of the node is async because of\n        // lazy transclusion)\n        selectCtrl.registerOption = function (\n          /** @type {ng.Scope} */ _optionScope,\n          /** @type {HTMLOptionElement} */ optionEl,\n        ) {\n          if (optionEl.value === \"\") {\n            selectCtrl.hasEmptyOption = true;\n            selectCtrl.emptyOption = optionEl;\n            // This ensures the new empty option is selected if previously no option was selected\n            ngModelCtrl.$render();\n\n            optionEl.addEventListener(\"$destroy\", () => {\n              const needsRerender = selectCtrl.$isEmptyOptionSelected();\n\n              selectCtrl.hasEmptyOption = false;\n              selectCtrl.emptyOption = undefined;\n\n              if (needsRerender) ngModelCtrl.$render();\n            });\n          }\n        };\n      }\n    }\n\n    // We will re-render the option elements if the option values or labels change\n\n    // let watchables = ngOptions.getWatchables();\n    // watchables.forEach((i) => {\n    //   scope.$watch(i, updateOptions);\n    // });\n    const prop = /** @type {string} */ (\n      /** @type {import('../../core/parse/ast/ast-node.ts').LiteralNode} */ (\n        /** @type {import('../../core/parse/ast/ast-node.ts').ExpressionNode} */ (\n          ngOptions.getWatchables._decoratedNode.body[0]\n        ).expression\n      )?.name\n    );\n\n    scope.$watch(prop, updateOptions);\n\n    // ------------------------------------------------------------------ //\n\n    /**\n     * @param {OptionItem} option\n     * @param {DocumentFragment} parent\n     */\n    function _addOptionElement(option, parent) {\n      /**\n       * @type {HTMLOptionElement}\n       */\n      const optionElement = /** @type {HTMLOptionElement} */ (\n        optionTemplate.cloneNode(false)\n      );\n\n      parent.appendChild(optionElement);\n      updateOptionElement(option, optionElement);\n    }\n\n    /**\n     * @param {any} viewValue\n     */\n    function getAndUpdateSelectedOption(viewValue) {\n      const option = options.getOptionFromViewValue(viewValue);\n\n      const element = option && option.element;\n\n      if (element && !element.selected) element.selected = true;\n\n      return option;\n    }\n\n    /**\n     * @param {OptionItem} option\n     * @param {HTMLOptionElement} element\n     */\n    function updateOptionElement(option, element) {\n      option.element = element;\n      element.disabled = option.disabled;\n\n      // Support: IE 11 only, Edge 12-13 only\n      // NOTE: The label must be set before the value, otherwise IE 11 & Edge create unresponsive\n      // selects in certain circumstances when multiple selects are next to each other and display\n      // the option list in listbox style, i.e. the select is [multiple], or specifies a [size].\n      // See https://github.com/angular/angular.js/issues/11314 for more info.\n      // This is unfortunately untestable with unit / e2e tests\n      if (option.label !== element.label) {\n        element.label = option.label;\n        element.textContent = option.label;\n      }\n      element.value = option.selectValue;\n    }\n\n    function updateOptions() {\n      const previousValue = options && selectCtrl._readValue();\n\n      // We must remove all current options, but cannot simply set innerHTML = null\n      // since the providedEmptyOption might have an ngIf on it that inserts comments which we\n      // must preserve.\n      // Instead, iterate over the current option elements and remove them or their optgroup\n      // parents\n      if (options) {\n        for (let i = options.items.length - 1; i >= 0; i--) {\n          const option = options.items[i];\n\n          if (isDefined(option.group)) {\n            removeElement(option.element.parentNode);\n          } else {\n            removeElement(option.element);\n          }\n        }\n      }\n\n      options = ngOptions.getOptions();\n\n      /** @type {Record<string, any>} */\n      const groupElementMap = {};\n\n      options.items.forEach(\n        /** @param {OptionItem} option */ (option) => {\n          let groupElement;\n\n          if (isDefined(option.group)) {\n            // This option is to live in a group\n            // See if we have already created this group\n            groupElement = groupElementMap[option.group];\n\n            if (!groupElement) {\n              groupElement = optGroupTemplate.cloneNode(false);\n              listFragment.appendChild(groupElement);\n\n              // Update the label on the group element\n              // \"null\" is special cased because of Safari\n              /** @type {HTMLOptGroupElement} */\n              (groupElement).label =\n                option.group === null ? \"null\" : option.group;\n\n              // Store it for use later\n              groupElementMap[option.group] = groupElement;\n            }\n\n            _addOptionElement(option, groupElement);\n          } else {\n            // This option is not in a group\n            _addOptionElement(option, listFragment);\n          }\n        },\n      );\n\n      selectElement.appendChild(listFragment);\n\n      ngModelCtrl.$render();\n\n      // Check to see if the value has changed due to the update to the options\n      if (!ngModelCtrl.$isEmpty(previousValue)) {\n        const nextValue = selectCtrl._readValue();\n\n        const isNotPrimitive = ngOptions.trackBy || multiple;\n\n        if (\n          isNotPrimitive\n            ? !equals(previousValue, nextValue)\n            : previousValue !== nextValue\n        ) {\n          ngModelCtrl.$setViewValue(nextValue);\n          ngModelCtrl.$render();\n        }\n      }\n    }\n  }\n\n  return {\n    restrict: \"A\",\n    terminal: true,\n    require: [\"select\", \"ngModel\"],\n    link: {\n      pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {\n        // Deactivate the SelectController.register method to prevent\n        // option directives from accidentally registering themselves\n        // (and unwanted $destroy handlers etc.)\n        ctrls[0].registerOption = () => {\n          /* empty */\n        };\n      },\n      post: /** @type {import(\"../../interface.ts\").DirectiveLinkFn<any>} */ (\n        ngOptionsPostLink\n      ),\n    },\n  };\n}\n","import { minErr } from \"../../shared/utils.js\";\nimport { emptyElement, startingTag } from \"../../shared/dom.js\";\nimport { NodeType } from \"../../shared/node.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/**\n * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.\n *\n * You can specify that you want to insert a named transclusion slot, instead of the default slot, by providing the slot name\n * as the value of the `ng-transclude` or `ng-transclude-slot` attribute.\n *\n * If the transcluded content is not empty (i.e. contains one or more DOM nodes, including whitespace text nodes), any existing\n * content of this element will be removed before the transcluded content is inserted.\n * If the transcluded content is empty (or only whitespace), the existing content is left intact. This lets you provide fallback\n * content in the case that no transcluded content is provided.\n *\n * @element ANY\n *\n * @param {string} ngTransclude|ngTranscludeSlot the name of the slot to insert at this point. If this is not provided, is empty\n *                                               or its value is the same as the name of the attribute then the default slot is used.\n */\nconst ngTranscludeMinErr = minErr(\"ngTransclude\");\n\nngTranscludeDirective.$inject = [$injectTokens._compile];\n/**\n * @param {ng.CompileService} $compile\n * @returns {ng.Directive}\n */\nexport function ngTranscludeDirective($compile) {\n  return {\n    compile: function ngTranscludeCompile(tElement) {\n      // Remove and cache any original content to act as a fallback\n      const fallbackLinkFn = $compile(tElement.childNodes);\n\n      emptyElement(tElement);\n\n      /**\n       *\n       * @param {ng.Scope} $scope\n       * @param {Element} $element\n       * @param {ng.Attributes} $attrs\n       * @param {*} _controller\n       * @param {*} $transclude\n       */\n      function ngTranscludePostLink(\n        $scope,\n        $element,\n        $attrs,\n        _controller,\n        $transclude,\n      ) {\n        if (!$transclude) {\n          throw ngTranscludeMinErr(\n            \"orphan\",\n            \"Illegal use of ngTransclude directive in the template! \" +\n              \"No parent directive that requires a transclusion found. \" +\n              \"Element: {0}\",\n            startingTag($element),\n          );\n        }\n\n        // If the attribute is of the form: `ng-transclude=\"ng-transclude\"` then treat it like the default\n        if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {\n          $attrs.ngTransclude = \"\";\n        }\n        const slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;\n\n        // If the slot is required and no transclusion content is provided then this call will throw an error\n        $transclude(ngTranscludeCloneAttachFn, null, slotName);\n\n        // If the slot is optional and no transclusion content is provided then use the fallback content\n        if (slotName && !$transclude.isSlotFilled(slotName)) {\n          useFallbackContent();\n        }\n\n        /**\n         * @param {NodeList | Node} clone\n         * @param {ng.Scope} transcludedScope\n         */\n        function ngTranscludeCloneAttachFn(clone, transcludedScope) {\n          if (notWhitespace(clone)) {\n            if (clone instanceof NodeList) {\n              Array.from(clone).forEach((el) => {\n                $element.append(el);\n              });\n            } else {\n              $element.append(/** @type {Node} */ (clone));\n            }\n          } else {\n            useFallbackContent();\n            // There is nothing linked against the transcluded scope since no content was available,\n            // so it should be safe to clean up the generated scope.\n            transcludedScope.$destroy();\n          }\n        }\n\n        function useFallbackContent() {\n          // Since this is the fallback content rather than the transcluded content,\n          // we link against the scope of this directive rather than the transcluded scope\n          fallbackLinkFn($scope, (clone) => {\n            $element.append(/** @type {Node} */ (clone));\n          });\n        }\n\n        /**\n         * @param {Node | NodeList} node\n         */\n        function notWhitespace(node) {\n          if (node instanceof Array) {\n            return false;\n          } else if (\n            /** @type {Node} */ (node).nodeType !== NodeType._TEXT_NODE ||\n            /** @type {String} */ (/** @type {Node} */ (node).nodeValue).trim()\n          ) {\n            return true;\n          }\n\n          return false;\n        }\n      }\n\n      return ngTranscludePostLink;\n    },\n  };\n}\n","import { BOOLEAN_ATTR } from \"../../shared/dom.js\";\nimport { directiveNormalize, entries } from \"../../shared/utils.js\";\nimport { ALIASED_ATTR } from \"../../shared/constants.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\nexport const REGEX_STRING_REGEXP = /^\\/(.+)\\/([a-z]*)$/;\n\n/**\n * @type {Record<string, ng.DirectiveFactory>}\n */\nexport const ngAttributeAliasDirectives = {};\n\n// boolean attrs are evaluated\nBOOLEAN_ATTR.forEach((i) => {\n  // binding to multiple is not supported\n  if (i === \"multiple\") return;\n\n  /**\n   * @param {ng.Scope} scope\n   * @param {Element} _element\n   * @param {ng.Attributes} attr\n   */\n  function defaultLinkFn(scope, _element, attr) {\n    scope.$watch(attr[normalized], (value) => {\n      attr.$set(i, !!value);\n    });\n  }\n\n  const normalized = directiveNormalize(`ng-${i}`);\n\n  let linkFn = defaultLinkFn;\n\n  if (i === \"checked\") {\n    linkFn = function (scope, element, attr) {\n      // ensuring ngChecked doesn't interfere with ngModel when both are set on the same input\n      if (attr.ngModel !== attr[normalized]) {\n        defaultLinkFn(scope, element, attr);\n      }\n    };\n  }\n\n  ngAttributeAliasDirectives[normalized] = function () {\n    return {\n      restrict: \"A\",\n      priority: 100,\n      link: linkFn,\n    };\n  };\n});\n\n// aliased input attrs are evaluated\nentries(ALIASED_ATTR).forEach(([ngAttr]) => {\n  ngAttributeAliasDirectives[ngAttr] = function () {\n    return {\n      priority: 100,\n      link(scope, element, attr) {\n        // special case ngPattern when a literal regular expression value\n        // is used as the expression (this way we don't have to watch anything).\n        if (ngAttr === \"ngPattern\" && attr.ngPattern.charAt(0) === \"/\") {\n          const match = attr.ngPattern.match(REGEX_STRING_REGEXP);\n\n          if (match) {\n            attr.$set(\"ngPattern\", new RegExp(match[1], match[2]).toString());\n\n            return;\n          }\n        }\n\n        scope.$watch(attr[ngAttr], (value) => {\n          attr.$set(ngAttr, value);\n        });\n      },\n    };\n  };\n});\n\n// ng-src, ng-srcset, ng-href are interpolated\n[\"src\", \"srcset\", \"href\"].forEach((attrName) => {\n  const normalized = directiveNormalize(`ng-${attrName}`);\n\n  ngAttributeAliasDirectives[normalized] = [\n    $injectTokens._sce,\n    /**\n     * @param {ng.SceService} $sce\n     * @returns {ng.Directive}\n     */\n    function ($sce) {\n      return {\n        priority: 99, // it needs to run after the attributes are interpolated\n        link(_scope, element, attr) {\n          let name = attrName;\n\n          if (\n            attrName === \"href\" &&\n            toString.call(/** @type {HTMLLinkElement} */ (element).href) ===\n              \"[object SVGAnimatedString]\"\n          ) {\n            name = \"xlinkHref\";\n            attr.$attr[name] = \"href\";\n          }\n\n          // We need to sanitize the url at least once, in case it is a constant\n          // non-interpolated attribute.\n          attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized]));\n\n          attr.$observe(normalized, (value) => {\n            if (!value) {\n              if (attrName === \"href\") {\n                attr.$set(name, null);\n              }\n\n              return;\n            }\n\n            attr.$set(name, value);\n          });\n        },\n      };\n    },\n  ];\n});\n","import {\n  hasOwn,\n  isNumberNaN,\n  isUndefined,\n  minErr,\n} from \"../../shared/utils.js\";\nimport { REGEX_STRING_REGEXP } from \"./../attrs/attrs.js\";\nimport { startingTag } from \"../../shared/dom.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n\n/**\n *\n * @param {string} ngRequired AngularTS expression. If it evaluates to `true`, it sets the\n *                                `required` attribute to the element and adds the `required`\n *                                {@link ngModel.NgModelController#$validators `validator`}.\n *\n *\n * ngRequired adds the required {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.\n * It is most often used for {@link input `input`} and {@link select `select`} controls, but can also be\n * applied to custom controls.\n *\n * The directive sets the `required` attribute on the element if the AngularTS expression inside\n * `ngRequired` evaluates to true. A special directive for setting `required` is necessary because we\n * cannot use interpolation inside `required`. See the {@link guide/interpolation interpolation guide}\n * for more info.\n *\n * The validator will set the `required` error key to true if the `required` attribute is set and\n * calling {@link ngModel.NgModelController#$isEmpty `NgModelController.$isEmpty`} with the\n * {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`} returns `true`. For example, the\n * `$isEmpty()` implementation for `input[text]` checks the length of the `$viewValue`. When developing\n * custom controls, `$isEmpty()` can be overwritten to account for a $viewValue that is not string-based.\n *\n */\nexport const requiredDirective = [\n  $t._parse,\n  /**\n   * @param {import(\"../../core/parse/interface.ts\").ParseService} $parse\n   * @returns {ng.Directive}\n   */\n  ($parse) => ({\n    restrict: \"A\",\n    require: \"?ngModel\",\n    link:\n      /**\n       * @param {ng.Scope} scope\n       * @param {Element} _elm\n       * @param {ng.Attributes} attr\n       * @param {ng.NgModelController} ctrl\n       * @returns\n       */\n      (scope, _elm, attr, ctrl) => {\n        if (!ctrl) return;\n        // For boolean attributes like required, presence means true\n        let value =\n          hasOwn(attr, \"required\") ||\n          (attr.ngRequired && $parse(attr.ngRequired)(scope));\n\n        if (!attr.ngRequired) {\n          // force truthy in case we are on non input element\n          // (input elements do this automatically for boolean attributes like required)\n          attr.required = \"true\";\n        }\n\n        ctrl.$validators.required = (_modelValue, viewValue) => {\n          return !value || !ctrl.$isEmpty(viewValue);\n        };\n\n        attr.$observe(\"required\", (newVal) => {\n          if (value !== newVal) {\n            value = newVal;\n            ctrl.$validate();\n          }\n        });\n      },\n  }),\n];\n\n/**\n * @param {String|RegExp} ngPattern AngularTS expression that must evaluate to a `RegExp` or a `String`\n *                                      parsable into a `RegExp`, or a `RegExp` literal. See above for\n *                                      more details.\n *\n *\n *\n * ngPattern adds the pattern {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.\n * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.\n *\n * The validator sets the `pattern` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}\n * does not match a RegExp which is obtained from the `ngPattern` attribute value:\n * - the value is an AngularTS expression:\n *   - If the expression evaluates to a RegExp object, then this is used directly.\n *   - If the expression evaluates to a string, then it will be converted to a RegExp after wrapping it\n *     in `^` and `$` characters. For instance, `\"abc\"` will be converted to `new RegExp('^abc$')`.\n * - If the value is a RegExp literal, e.g. `ngPattern=\"/^\\d+$/\"`, it is used directly.\n *\n * <div class=\"alert alert-info\">\n * **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to\n * start at the index of the last search's match, thus not taking the whole input value into\n * account.\n * </div>\n *\n * <div class=\"alert alert-info\">\n * **Note:** This directive is also added when the plain `pattern` attribute is used, with two\n * differences:\n * <ol>\n *   <li>\n *     `ngPattern` does not set the `pattern` attribute and therefore HTML5 constraint validation is\n *     not available.\n *   </li>\n *   <li>\n *     The `ngPattern` attribute must be an expression, while the `pattern` value must be\n *     interpolated.\n *   </li>\n * </ol>\n * </div>\n */\nexport const patternDirective = [\n  $t._parse,\n  /**\n   * @param {ng.ParseService} $parse\n   * @returns {ng.Directive}\n   */\n  ($parse) => ({\n    restrict: \"A\",\n    require: \"?ngModel\",\n    compile: (_Elm, tAttr) => {\n      /**\n       * @type {string}\n       */\n      let patternExp;\n\n      /**\n       * @type {(() => any) | ((arg0: ng.Scope) => string)}\n       */\n      let parseFn;\n\n      if (tAttr.ngPattern) {\n        patternExp = tAttr.ngPattern;\n\n        // ngPattern might be a scope expression, or an inlined regex, which is not parsable.\n        // We get value of the attribute here, so we can compare the old and the new value\n        // in the observer to avoid unnecessary validations\n        if (\n          tAttr.ngPattern.charAt(0) === \"/\" &&\n          REGEX_STRING_REGEXP.test(tAttr.ngPattern)\n        ) {\n          parseFn = function () {\n            return tAttr.ngPattern;\n          };\n        } else {\n          parseFn = tAttr.ngPattern && $parse(tAttr.ngPattern);\n        }\n      }\n\n      return function (scope, elm, attr, ctrl) {\n        if (!ctrl) return;\n        let attrVal = attr.pattern;\n\n        if (attr.ngPattern) {\n          attrVal = parseFn(scope);\n        } else {\n          patternExp = attr.pattern;\n        }\n        let regexp = attrVal && parsePatternAttr(attrVal, patternExp, elm);\n\n        attr.$observe(\"pattern\", (newVal) => {\n          const oldRegexp = regexp;\n\n          regexp = newVal && parsePatternAttr(newVal, patternExp, elm);\n\n          if (\n            (oldRegexp && oldRegexp.toString()) !==\n            (regexp && regexp.toString())\n          ) {\n            ctrl.$validate();\n          }\n        });\n\n        ctrl.$validators.pattern = (\n          /** @type {any} */ _modelValue,\n          /** @type {any} */ viewValue,\n        ) => {\n          // HTML5 pattern constraint validates the input value, so we validate the viewValue\n          return (\n            ctrl.$isEmpty(viewValue) ||\n            isUndefined(regexp) ||\n            /** @type {RegExp} */ (regexp).test(viewValue)\n          );\n        };\n      };\n    },\n  }),\n];\n\n/**\n * @param {string} ngMaxlength AngularTS expression that must evaluate to a `Number` or `String`\n *                                 parsable into a `Number`. Used as value for the `maxlength`\n *                                 {@link ngModel.NgModelController#$validators validator}.\n *\n *\n *\n * ngMaxlength adds the maxlength {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.\n * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.\n *\n * The validator sets the `maxlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}\n * is longer than the integer obtained by evaluating the AngularTS expression given in the\n * `ngMaxlength` attribute value.\n *\n * <div class=\"alert alert-info\">\n * **Note:** This directive is also added when the plain `maxlength` attribute is used, with two\n * differences:\n * <ol>\n *   <li>\n *     `ngMaxlength` does not set the `maxlength` attribute and therefore HTML5 constraint\n *     validation is not available.\n *   </li>\n *   <li>\n *     The `ngMaxlength` attribute must be an expression, while the `maxlength` value must be\n *     interpolated.\n *   </li>\n * </ol>\n * </div>\n *\n */\nexport const maxlengthDirective = [\n  $t._parse,\n  /**\n   * @param {ng.ParseService} $parse\n   * @returns {ng.Directive}\n   */\n  ($parse) => ({\n    restrict: \"A\",\n    require: \"?ngModel\",\n    link:\n      /**\n       * @param {ng.Scope} scope\n       * @param {Element} _elm\n       * @param {ng.Attributes} attr\n       * @param {ng.NgModelController} ctrl\n       * @returns\n       */\n      (scope, _elm, attr, ctrl) => {\n        if (!ctrl) return;\n\n        let maxlength =\n          attr.maxlength ||\n          (attr.ngMaxlength && $parse(attr.ngMaxlength)(scope));\n\n        let maxlengthParsed = parseLength(maxlength);\n\n        attr.$observe(\"maxlength\", (value) => {\n          if (maxlength !== value) {\n            maxlengthParsed = parseLength(value);\n            maxlength = value;\n            ctrl.$validate();\n          }\n        });\n        ctrl.$validators.maxlength = function (_modelValue, viewValue) {\n          return (\n            maxlengthParsed < 0 ||\n            ctrl.$isEmpty(viewValue) ||\n            viewValue.length <= maxlengthParsed\n          );\n        };\n      },\n  }),\n];\n\n/**\n *\n * @param {string} ngMinlength AngularTS expression that must evaluate to a `Number` or `String`\n *                                 parsable into a `Number`. Used as value for the `minlength`\n *                                 {@link ngModel.NgModelController#$validators validator}.\n *\n *\n *\n * ngMinlength adds the minlength {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.\n * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.\n *\n * The validator sets the `minlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}\n * is shorter than the integer obtained by evaluating the AngularTS expression given in the\n * `ngMinlength` attribute value.\n *\n * <div class=\"alert alert-info\">\n * **Note:** This directive is also added when the plain `minlength` attribute is used, with two\n * differences:\n * <ol>\n *   <li>\n *     `ngMinlength` does not set the `minlength` attribute and therefore HTML5 constraint\n *     validation is not available.\n *   </li>\n *   <li>\n *     The `ngMinlength` value must be an expression, while the `minlength` value must be\n *     interpolated.\n *   </li>\n * </ol>\n * </div>\n *\n */\nexport const minlengthDirective = [\n  $t._parse,\n  /** @param {ng.ParseService} $parse @return {ng.Directive} */ ($parse) => ({\n    restrict: \"A\",\n    require: \"?ngModel\",\n    link(scope, _elm, attr, ctrl) {\n      if (!ctrl) return;\n\n      let minlength =\n        attr.minlength || (attr.ngMinlength && $parse(attr.ngMinlength)(scope));\n\n      let minlengthParsed = parseLength(minlength) || -1;\n\n      attr.$observe(\"minlength\", (value) => {\n        if (minlength !== value) {\n          minlengthParsed = parseLength(value) || -1;\n          minlength = value;\n          ctrl.$validate();\n        }\n      });\n      ctrl.$validators.minlength = function (\n        /** @type {any} */ modelValue,\n        /** @type {string | any[]} */ viewValue,\n      ) {\n        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;\n      };\n    },\n  }),\n];\n\n/**\n * @param {string | RegExp} input\n * @param {string} patternExp\n * @param {Element | Node} elm\n * @returns {RegExp}\n */\nfunction parsePatternAttr(input, patternExp, elm) {\n  /** @type {RegExp | string} */\n  let regex = input;\n\n  if (typeof regex === \"string\") {\n    const match = regex.match(/^\\/(.*)\\/([gimsuy]*)$/);\n\n    regex = match ? new RegExp(match[1], match[2]) : new RegExp(`^${regex}$`);\n  }\n\n  if (typeof regex.test !== \"function\") {\n    throw minErr(\"ngPattern\")(\n      \"noregexp\",\n      \"Expected {0} to be a RegExp but was {1}. Element: {2}\",\n      patternExp,\n      regex,\n      startingTag(elm),\n    );\n  }\n\n  return regex;\n}\n\n/**\n * @param {string} val\n */\nfunction parseLength(val) {\n  const intVal = parseInt(val, 10);\n\n  return isNumberNaN(intVal) ? -1 : intVal;\n}\n","import {\n  getNodeName,\n  isFunction,\n  isNumber,\n  isString,\n} from \"../../shared/utils.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\nimport { urlResolve } from \"../../shared/url-utils/url-utils.js\";\n\nexport class AnchorScrollProvider {\n  constructor() {\n    this.autoScrollingEnabled = true;\n  }\n\n  $get = [\n    $t._location,\n    $t._rootScope,\n    /**\n     *\n     * @param {ng.LocationService} $location\n     * @param {ng.Scope} $rootScope\n     * @returns {ng.AnchorScrollService}\n     */\n    ($location, $rootScope) => {\n      // Helper function to get first anchor from a NodeList\n      // (using `Array#some()` instead of `angular#forEach()` since it's more performant\n      //  and working in all supported browsers.)\n      /**\n       * @param {NodeListOf<HTMLElement>} list\n       * @returns {HTMLAnchorElement | undefined}\n       */\n      function getFirstAnchor(list) {\n        for (let i = 0; i < list.length; i++) {\n          const el = list[i];\n\n          if (getNodeName(el) === \"a\") {\n            return /** @type {HTMLAnchorElement} */ (el);\n          }\n        }\n\n        return undefined;\n      }\n\n      function getYOffset() {\n        // Figure out a better way to configure this other than bolting on a property onto a function\n        let offset = scroll.yOffset;\n\n        if (isFunction(offset)) {\n          offset = /** @type {Function} */ (offset)();\n        } else if (offset instanceof Element) {\n          const style = window.getComputedStyle(offset);\n\n          if (style.position !== \"fixed\") {\n            offset = 0;\n          } else {\n            offset = offset.getBoundingClientRect().bottom;\n          }\n        } else if (!isNumber(offset)) {\n          offset = 0;\n        }\n\n        return offset;\n      }\n\n      /**\n       * @param {HTMLElement} [elem]\n       */\n      function scrollTo(elem) {\n        if (elem) {\n          const rect = elem.getBoundingClientRect();\n\n          elem.scrollIntoView();\n\n          const offset = /** @type {number} */ (getYOffset());\n\n          if (offset) {\n            // `offset` is how many pixels we want the element to appear below the top of the viewport.\n            //\n            // `scrollIntoView()` does not always align the element at the top (e.g. near the bottom\n            // of the page). Therefore, we measure the elements actual position after scrolling and\n            // only adjust by the difference needed to reach the desired offset.\n            window.scrollBy(0, rect.top - offset);\n          }\n        } else {\n          window.scrollTo(0, 0);\n        }\n      }\n\n      /** @type {ng.AnchorScrollService} */\n      const scroll = (hashOrElement) => {\n        // Direct element scrolling\n        if (hashOrElement instanceof HTMLElement) {\n          scrollTo(hashOrElement);\n\n          return;\n        }\n        // Allow numeric hashes\n        const hash = isString(hashOrElement)\n          ? hashOrElement\n          : isNumber(hashOrElement)\n            ? hashOrElement.toString()\n            : $location.getHash();\n\n        let elm;\n\n        // empty hash, scroll to the top of the page\n        if (!hash) {\n          scrollTo();\n        }\n        // element with given id\n        else if ((elm = document.getElementById(hash))) scrollTo(elm);\n        // first anchor with given name :-D\n        else if ((elm = getFirstAnchor(document.getElementsByName(hash))))\n          scrollTo(elm);\n        // no element and hash === 'top', scroll to the top of the page\n        else if (hash === \"top\") scrollTo();\n      };\n\n      // does not scroll when user clicks on anchor link that is currently on\n      // (no url change, no $location.getHash() change), browser native does scroll\n      if (this.autoScrollingEnabled) {\n        $rootScope.$on(\n          \"$locationChangeSuccess\",\n          /** @param {ng.ScopeEvent} _e  @param {string} newVal @param {string} oldVal */ (\n            _e,\n            newVal,\n            oldVal,\n          ) => {\n            const newUrl = urlResolve(newVal);\n\n            const ordUrl = urlResolve(oldVal);\n\n            if (newUrl.hash === ordUrl.hash && newUrl.hash === \"\") return;\n\n            const action = () => scroll(newUrl.hash);\n\n            if (document.readyState === \"complete\") {\n              // Force the action to be run async for consistent behavior\n              // from the action's point of view\n              // i.e. it will definitely not be in a $apply\n              queueMicrotask(() => action());\n            } else {\n              window.addEventListener(\"load\", () => action());\n            }\n          },\n        );\n      }\n\n      return scroll;\n    },\n  ];\n}\n","import { isArray, isString } from \"../shared/utils.js\";\nimport { NodeType } from \"../shared/node.js\";\n\nexport const ADD_CLASS_SUFFIX = \"-add\";\nexport const REMOVE_CLASS_SUFFIX = \"-remove\";\nexport const EVENT_CLASS_PREFIX = \"ng-\";\nexport const ACTIVE_CLASS_SUFFIX = \"-active\";\nexport const PREPARE_CLASS_SUFFIX = \"-prepare\";\n\nexport const NG_ANIMATE_CLASSNAME = \"ng-animate\";\nexport const NG_ANIMATE_CHILDREN_DATA = \"$$ngAnimateChildren\";\n\n/**\n * @param {ng.AnimationOptions} options\n */\nexport function packageStyles(options) {\n  return options?.to || options?.from\n    ? { to: options.to, from: options.from }\n    : {};\n}\n\n/**\n * @param {string | string[]} classes\n * @param {string} fix\n * @param {boolean | undefined} [isPrefix]\n */\nexport function pendClasses(classes, fix, isPrefix) {\n  const arrayClasses = isArray(classes)\n    ? classes\n    : classes && isString(classes)\n      ? classes.trim().split(/\\s+/)\n      : [];\n\n  return arrayClasses\n    .filter(Boolean)\n    .map((klass) => (isPrefix ? fix + klass : klass + fix))\n    .join(\" \");\n}\n\n/**\n *\n * @param {NodeList|Node} element\n * @returns {Node[]|Node|undefined}\n */\nexport function stripCommentsFromElement(element) {\n  if (element instanceof NodeList) {\n    return Array.from(element).filter(\n      (x) => x.nodeType === NodeType._ELEMENT_NODE,\n    );\n  } else if (element.nodeType === NodeType._ELEMENT_NODE) {\n    return /** @type {Node} */ (element);\n  } else {\n    return undefined;\n  }\n}\n\nexport function applyAnimationClassesFactory() {\n  return function (\n    /** @type {HTMLElement} */ element,\n    /** @type {ng.AnimationOptions} */ options,\n  ) {\n    if (options.addClass) {\n      element.classList.add(...options.addClass.trim().split(\" \"));\n      options.addClass = undefined;\n    }\n\n    if (options.removeClass) {\n      element.classList.remove(...options.removeClass.trim().split(\" \"));\n      options.removeClass = undefined;\n    }\n  };\n}\n\n/**\n * @param {ng.AnimationOptions | undefined} options\n */\nexport function prepareAnimationOptions(options) {\n  const animateOptions = options || /** @type {ng.AnimationOptions} */ ({});\n\n  if (!animateOptions._prepared) {\n    let domOperation =\n      animateOptions.domOperation ||\n      (() => {\n        /* empty */\n      });\n\n    animateOptions.domOperation = function () {\n      animateOptions._domOperationFired = true;\n      domOperation();\n      domOperation = () => {\n        /* empty */\n      };\n    };\n    animateOptions._prepared = true;\n  }\n\n  return animateOptions;\n}\n\n/**\n * @param {HTMLElement} element\n * @param {ng.AnimationOptions | undefined} options\n */\nexport function applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\n/**\n * Applies initial animation styles to a DOM element.\n *\n * This function sets the element's inline styles using the properties\n * defined in `options.from`, then clears the property to prevent reuse.\n *\n * @param {HTMLElement} element - The target DOM element to apply styles to.\n * @param {ng.AnimationOptions} [options] - options containing a `from` object with CSS propertyvalue pairs.\n */\nexport function applyAnimationFromStyles(element, options) {\n  if (options && options.from) {\n    Object.assign(element.style, options.from);\n    options.from = undefined;\n  }\n}\n\n/**\n * Applies final animation styles to a DOM element.\n *\n * This function sets the element's inline styles using the properties\n * defined in `options.to`, then clears the property to prevent reuse.\n *\n * @param {HTMLElement} element - The target DOM element to apply styles to.\n * @param {ng.AnimationOptions} [options] - options containing a `from` object with CSS propertyvalue pairs.\n */\nexport function applyAnimationToStyles(element, options) {\n  if (options && options.to) {\n    Object.assign(element.style, options.to);\n    options.to = undefined;\n  }\n}\n\n/**\n * Merge old and new animation options for an element, computing\n * the final addClass and removeClass values.\n *\n * @param {HTMLElement} element - The DOM element being animated.\n * @param {{ options?: ng.AnimationOptions; addClass?: string; removeClass?: string }} oldAnimation\n * @param {{ options?: ng.AnimationOptions; addClass?: string; removeClass?: string; preparationClasses?: string }} newAnimation\n * @returns {ng.AnimationOptions} - The merged animation options.\n */\nexport function mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  const target =\n    oldAnimation.options || /** @type {ng.AnimationOptions} */ ({});\n\n  const newOptions =\n    newAnimation.options || /** @type {ng.AnimationOptions} */ ({});\n\n  // Merge preparation classes if any\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = [\n      newOptions.preparationClasses,\n      target.preparationClasses,\n    ]\n      .filter(Boolean)\n      .join(\" \");\n    delete newOptions.preparationClasses;\n  }\n\n  // Merge other properties except addClass/removeClass\n  Object.assign(target, newOptions);\n\n  // Combine addClass / removeClass\n  const addList = `${target.addClass || \"\"} ${newOptions.addClass || \"\"}`\n    .trim()\n    .split(/\\s+/)\n    .filter(Boolean);\n\n  const removeList =\n    `${target.removeClass || \"\"} ${newOptions.removeClass || \"\"}`\n      .trim()\n      .split(/\\s+/)\n      .filter(Boolean);\n\n  // Track existing classes on the element\n  const existingSet = new Set(\n    (element.getAttribute(\"class\") || \"\").split(/\\s+/).filter(Boolean),\n  );\n\n  // Compute final addClass and removeClass\n  /** @type {string[]} */\n  const finalAdd = [];\n\n  /** @type {string[]} */\n  const finalRemove = [];\n\n  addList.forEach(function (cls) {\n    if (!existingSet.has(cls)) finalAdd.push(cls);\n  });\n\n  removeList.forEach(function (cls) {\n    if (existingSet.has(cls)) finalRemove.push(cls);\n  });\n\n  target.addClass = finalAdd.length\n    ? /** @type {string} */ (finalAdd.join(\" \"))\n    : undefined;\n  target.removeClass = finalRemove.length\n    ? /** @type {string} */ (finalRemove.join(\" \"))\n    : undefined;\n\n  // Update oldAnimation references\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\n/**\n * @param {HTMLElement} element\n * @param {string | null} event\n * @param {ng.AnimationOptions} options\n */\nexport function applyGeneratedPreparationClasses(element, event, options) {\n  let classes = \"\";\n\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n\n  if (options.addClass) {\n    classes = concatWithSpace(\n      classes,\n      pendClasses(options.addClass, ADD_CLASS_SUFFIX),\n    );\n  }\n\n  if (options.removeClass) {\n    classes = concatWithSpace(\n      classes,\n      pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX),\n    );\n  }\n\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.className += ` ${classes}`;\n  }\n}\n\n/**\n * @param {HTMLElement} element\n * @param {ng.AnimationOptions} options\n */\nexport function clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    options.preparationClasses\n      .split(\" \")\n      .forEach((cls) => element.classList.remove(cls));\n    options.preparationClasses = undefined;\n  }\n\n  if (options.activeClasses) {\n    options.activeClasses\n      .split(\" \")\n      .forEach((cls) => element.classList.remove(cls));\n    options.activeClasses = undefined;\n  }\n}\n\n/**\n * @param {HTMLElement} node\n * @param {boolean} applyBlock\n * @returns {string[]}\n */\nexport function _blockKeyframeAnimations(node, applyBlock) {\n  const value = applyBlock ? \"paused\" : \"\";\n\n  const key = `animationPlayState`;\n\n  applyInlineStyle(node, [key, value]);\n\n  return [key, value];\n}\n\n/**\n * @param {HTMLElement} node\n * @param {any[]} styleTuple\n */\nexport function applyInlineStyle(node, styleTuple) {\n  const prop = styleTuple[0];\n\n  node.style[prop] = styleTuple[1];\n}\n\n/**\n * @param {string} a\n * @param {string} b\n * @returns {string}\n */\nexport function concatWithSpace(a, b) {\n  return [a, b].filter(Boolean).join(\" \");\n}\n","import {\n  extend,\n  hasAnimate,\n  isFunction,\n  isInstanceOf,\n  isObject,\n  mergeClasses,\n  minErr,\n  nullObject,\n} from \"../shared/utils.js\";\nimport { animatedomInsert, domInsert, removeElement } from \"../shared/dom.js\";\nimport { NG_ANIMATE_CLASSNAME } from \"./shared.js\";\nimport { $injectTokens } from \"../injection-tokens.js\";\n\nconst $animateMinErr = minErr(\"$animate\");\n\n// if any other type of options value besides an Object value is\n// passed into the $animate.method() animation then this helper code\n// will be run which will ignore it. While this patch is not the\n// greatest solution to this, a lot of existing plugins depend on\n// $animate to either call the callback (< 1.2) or return a promise\n// that can be changed. This helper function ensures that the options\n// are wiped clean incase a callback function is provided.\n/**\n * @param {import(\"./interface.ts\").AnimationOptions | undefined} options\n * @returns {import(\"./interface.ts\").AnimationOptions}\n */\nfunction prepareAnimateOptions(options) {\n  return isObject(options)\n    ? options\n    : /** @type {import(\"./interface.ts\").AnimationOptions} */ ({});\n}\n\nAnimateProvider.$inject = [$injectTokens._provide];\n\n/** @param {ng.ProvideService} $provide */\nexport function AnimateProvider($provide) {\n  const provider = this;\n\n  /**\n   * @type {RegExp | null}\n   */\n  let classNameFilter;\n\n  /**\n   * @type {Function | null}\n   */\n  let customFilter;\n\n  this._registeredAnimations = nullObject();\n\n  /**\n   * Registers a new injectable animation factory function. The factory function produces the\n   * animation object which contains callback functions for each event that is expected to be\n   * animated.\n   *\n   *   * `eventFn`: `function(element, ... , doneFunction, options)`\n   *   The element to animate, the `doneFunction` and the options fed into the animation. Depending\n   *   on the type of animation additional arguments will be injected into the animation function. The\n   *   list below explains the function signatures for the different animation methods:\n   *\n   *   - setClass: function(element, addedClasses, removedClasses, doneFunction, options)\n   *   - addClass: function(element, addedClasses, doneFunction, options)\n   *   - removeClass: function(element, removedClasses, doneFunction, options)\n   *   - enter, leave, move: function(element, doneFunction, options)\n   *   - animate: function(element, fromStyles, toStyles, doneFunction, options)\n   *\n   *   Make sure to trigger the `doneFunction` once the animation is fully complete.\n   *\n   * ```js\n   *   return {\n   *     //enter, leave, move signature\n   *     eventFn : function(element, done, options) {\n   *       //code to run the animation\n   *       //once complete, then run done()\n   *       return function endFunction(wasCancelled) {\n   *         //code to cancel the animation\n   *       }\n   *     }\n   *   }\n   * ```\n   *\n   * @param {string} name The name of the animation (this is what the class-based CSS value will be compared to).\n   * @param {import(\"../interface.ts\").Injectable<any>} factory The factory function that will be executed to return the animation\n   *                           object.\n   */\n  this.register = function (name, factory) {\n    if (name && name.charAt(0) !== \".\") {\n      throw $animateMinErr(\n        \"notcsel\",\n        \"Expecting class selector starting with '.' got '{0}'.\",\n        name,\n      );\n    }\n\n    const key = `${name}-animation`;\n\n    provider._registeredAnimations[name.substring(1)] = key;\n    $provide.factory(key, factory);\n  };\n\n  /**\n   * Sets and/or returns the custom filter function that is used to \"filter\" animations, i.e.\n   * determine if an animation is allowed or not. When no filter is specified (the default), no\n   * animation will be blocked. Setting the `customFilter` value will only allow animations for\n   * which the filter function's return value is truthy.\n   *\n   * This allows to easily create arbitrarily complex rules for filtering animations, such as\n   * allowing specific events only, or enabling animations on specific subtrees of the DOM, etc.\n   * Filtering animations can also boost performance for low-powered devices, as well as\n   * applications containing a lot of structural operations.\n   *\n   * <div class=\"alert alert-success\">\n   *   **Best Practice:**\n   *   Keep the filtering function as lean as possible, because it will be called for each DOM\n   *   action (e.g. insertion, removal, class change) performed by \"animation-aware\" directives.\n   *   See {@link guide/animations#which-directives-support-animations- here} for a list of built-in\n   *   directives that support animations.\n   *   Performing computationally expensive or time-consuming operations on each call of the\n   *   filtering function can make your animations sluggish.\n   * </div>\n   *\n   * **Note:** If present, `customFilter` will be checked before\n   * {@link $animateProvider#classNameFilter classNameFilter}.\n   *\n   * @param {Function=} filterFn - The filter function which will be used to filter all animations.\n   *   If a falsy value is returned, no animation will be performed. The function will be called\n   *   with the following arguments:\n   *   - **node** `{Element}` - The DOM element to be animated.\n   *   - **event** `{String}` - The name of the animation event (e.g. `enter`, `leave`, `addClass`\n   *     etc).\n   *   - **options** `{Object}` - A collection of options/styles used for the animation.\n   * @return {Function | null} The current filter function or `null` if there is none set.\n   */\n  this.customFilter = function (filterFn) {\n    if (arguments.length === 1) {\n      customFilter = isFunction(filterFn) ? filterFn : null;\n    }\n\n    return customFilter;\n  };\n\n  /**\n   * Sets and/or returns the CSS class regular expression that is checked when performing\n   * an animation. Upon bootstrap the classNameFilter value is not set at all and will\n   * therefore enable $animate to attempt to perform an animation on any element that is triggered.\n   * When setting the `classNameFilter` value, animations will only be performed on elements\n   * that successfully match the filter expression. This in turn can boost performance\n   * for low-powered devices as well as applications containing a lot of structural operations.\n   *\n   * **Note:** If present, `classNameFilter` will be checked after\n   * {@link $animateProvider#customFilter customFilter}. If `customFilter` is present and returns\n   * false, `classNameFilter` will not be checked.\n   *\n   * @param {RegExp=} expression The className expression which will be checked against all animations\n   * @return {RegExp | null} The current CSS className expression value. If null then there is no expression value\n   */\n  this.classNameFilter = function (expression) {\n    if (arguments.length === 1) {\n      classNameFilter = expression instanceof RegExp ? expression : null;\n\n      if (classNameFilter) {\n        const reservedRegex = new RegExp(\n          `[(\\\\s|\\\\/)]${NG_ANIMATE_CLASSNAME}[(\\\\s|\\\\/)]`,\n        );\n\n        if (reservedRegex.test(classNameFilter.toString())) {\n          classNameFilter = null;\n          throw $animateMinErr(\n            \"nongcls\",\n            '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the \"{0}\" CSS class.',\n            NG_ANIMATE_CLASSNAME,\n          );\n        }\n      }\n    }\n\n    return classNameFilter;\n  };\n\n  this.$get = [\n    $injectTokens._animateQueue,\n    /**\n     * @param {import(\"./queue/interface.ts\").AnimateQueueService} $$animateQueue\n     * @returns {ng.AnimateService}\n     */\n    function ($$animateQueue) {\n      /**\n       * The $animate service exposes a series of DOM utility methods that provide support\n       * for animation hooks. The default behavior is the application of DOM operations, however,\n       * when an animation is detected (and animations are enabled), $animate will do the heavy lifting\n       * to ensure that animation runs with the triggered DOM operation.\n       *\n       * By default $animate doesn't trigger any animations. This is because the `ngAnimate` module isn't\n       * included and only when it is active then the animation hooks that `$animate` triggers will be\n       * functional. Once active then all structural `ng-` directives will trigger animations as they perform\n       * their DOM-related operations (enter, leave and move). Other directives such as `ngClass`,\n       * `ngShow`, `ngHide` and `ngMessages` also provide support for animations.\n       *\n       * It is recommended that the`$animate` service is always used when executing DOM-related procedures within directives.\n       */\n      return {\n        /**\n         *\n         * Sets up an event listener to fire whenever the animation event (enter, leave, move, etc...)\n         *    has fired on the given element or among any of its children. Once the listener is fired, the provided callback\n         *    is fired with the following params:\n         *\n         * ```js\n         * $animate.on('enter', container,\n         *    function callback(element, phase) {\n         *      // cool we detected an enter animation within the container\n         *    }\n         * );\n         * ```\n         *\n         * <div class=\"alert alert-warning\">\n         * **Note**: Generally, the events that are fired correspond 1:1 to `$animate` method names,\n         * e.g. {@link ng.$animate#addClass addClass()} will fire `addClass`, and {@link ng.ngClass}\n         * will fire `addClass` if classes are added, and `removeClass` if classes are removed.\n         * However, there are two exceptions:\n         *\n         * <ul>\n         *   <li>if both an {@link ng.$animate#addClass addClass()} and a\n         *   {@link ng.$animate#removeClass removeClass()} action are performed during the same\n         *   animation, the event fired will be `setClass`. This is true even for `ngClass`.</li>\n         *   <li>an {@link ng.$animate#animate animate()} call that adds and removes classes will fire\n         *   the `setClass` event, but if it either removes or adds classes,\n         *   it will fire `animate` instead.</li>\n         * </ul>\n         *\n         * </div>\n         *\n         * @param {string} event the animation event that will be captured (e.g. enter, leave, move, addClass, removeClass, etc...)\n         * @param {Element} container the container element that will capture each of the animation events that are fired on itself\n         *     as well as among its children\n         * @param {Function} callback the callback function that will be fired when the listener is triggered.\n         *\n         * The arguments present in the callback function are:\n         * * `element` - The captured DOM element that the animation was fired on.\n         * * `phase` - The phase of the animation. The two possible phases are **start** (when the animation starts) and **close** (when it ends).\n         * * `data` - an object with these properties:\n         *     * addClass - `{string|null}` - space-separated CSS classes to add to the element\n         *     * removeClass - `{string|null}` - space-separated CSS classes to remove from the element\n         *     * from - `{Object|null}` - CSS properties & values at the beginning of the animation\n         *     * to - `{Object|null}` - CSS properties & values at the end of the animation\n         *\n         * Note that the callback does not trigger a scope digest. Wrap your call into a\n         * {@link $rootScope.Scope#$apply scope.$apply} to propagate changes to the scope.\n         */\n        on: $$animateQueue.on,\n\n        /**\n         * Deregisters an event listener based on the event which has been associated with the provided element. This method\n         * can be used in three different ways depending on the arguments:\n         *\n         * ```js\n         * // remove all the animation event listeners listening for `enter`\n         * $animate.off('enter');\n         *\n         * // remove listeners for all animation events from the container element\n         * $animate.off(container);\n         *\n         * // remove all the animation event listeners listening for `enter` on the given element and its children\n         * $animate.off('enter', container);\n         *\n         * // remove the event listener function provided by `callback` that is set\n         * // to listen for `enter` on the given `container` as well as its children\n         * $animate.off('enter', container, callback);\n         * ```\n         *\n         * @param {string|Element} event|container the animation event (e.g. enter, leave, move,\n         * addClass, removeClass, etc...), or the container element. If it is the element, all other\n         * arguments are ignored.\n         * @param {Element=} container the container element the event listener was placed on\n         * @param {Function=} callback the callback function that was registered as the listener\n         */\n        off: $$animateQueue.off,\n\n        /**\n         *  Associates the provided element with a host parent element to allow the element to be animated even if it exists\n         *  outside of the DOM structure of the AngularTS application. By doing so, any animation triggered via `$animate` can be issued on the\n         *  element despite being outside the realm of the application or within another application. Say for example if the application\n         *  was bootstrapped on an element that is somewhere inside of the `<body>` tag, but we wanted to allow for an element to be situated\n         *  as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind\n         *  that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.\n         *\n         *  Note that this feature is only active when the `ngAnimate` module is used.\n         *\n         * @param {Element} element the external element that will be pinned\n         * @param {Element} parentElement the host parent element that will be associated with the external element\n         */\n        pin: $$animateQueue.pin,\n\n        /**\n         * Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This\n         * function can be called in four ways:\n         *\n         * ```js\n         * // returns true or false\n         * $animate.enabled();\n         *\n         * // changes the enabled state for all animations\n         * $animate.enabled(false);\n         * $animate.enabled(true);\n         *\n         * // returns true or false if animations are enabled for an element\n         * $animate.enabled(element);\n         *\n         * // changes the enabled state for an element and its children\n         * $animate.enabled(element, true);\n         * $animate.enabled(element, false);\n         * ```\n         *\n         * @param {Element=} element the element that will be considered for checking/setting the enabled state\n         * @param {boolean=} enabled whether or not the animations will be enabled for the element\n         *\n         * @return {boolean} whether or not animations are enabled\n         */\n        enabled: (element, enabled) => {\n          if (enabled !== undefined) {\n            return hasAnimate(/** @type {Element} */ (element));\n          } else {\n            /** @type {Element} */ (element).setAttribute(\n              \"animate\",\n              `${enabled}`,\n            );\n          }\n\n          return true;\n        },\n\n        /**\n         * Cancels the provided animation and applies the end state of the animation.\n         * Note that this does not cancel the underlying operation, e.g. the setting of classes or\n         * adding the element to the DOM.\n         *\n         * @param {ng.AnimateRunner} runner An animation runner returned by an $animate function.\n         */\n        cancel(runner) {\n          if (runner.cancel) {\n            runner.cancel();\n          }\n        },\n\n        /**\n         * Inserts the element into the DOM either after the `after` element (if provided) or\n         * as the first child within the `parent` element and then triggers an animation.\n         * A promise is returned that will be resolved during the next digest once the animation\n         * has completed.\n         *\n         * @param {Element} element - the element which will be inserted into the DOM\n         * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)\n         * @param {ChildNode | null | undefined} [after] - after the sibling element after which the element will be appended\n         * @param {import(\"./interface.ts\").AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.\n         * @returns {ng.AnimateRunner} the animation runner\n         */\n        enter(element, parent, after, options) {\n          parent = parent || (after && after.parentElement);\n\n          if (\n            isInstanceOf(element, HTMLElement) &&\n            isInstanceOf(parent, HTMLElement)\n          ) {\n            animatedomInsert(element, parent, after);\n          } else {\n            domInsert(element, parent, after);\n          }\n\n          return $$animateQueue.push(\n            element,\n            \"enter\",\n            prepareAnimateOptions(options),\n          );\n        },\n\n        /**\n         * Inserts (moves) the element into its new position in the DOM either after\n         * the `after` element (if provided) or as the first child within the `parent` element\n         * and then triggers an animation. A promise is returned that will be resolved\n         * during the next digest once the animation has completed.\n         *\n         * @param {Element} element - the element which will be inserted into the DOM\n         * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)\n         * @param {Element} after - after the sibling element after which the element will be appended\n         * @param {import(\"./interface.ts\").AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.\n         * @returns {ng.AnimateRunner} the animation runner\n         */\n        move(element, parent, after, options) {\n          parent = parent || after.parentElement;\n\n          if (\n            isInstanceOf(element, HTMLElement) &&\n            isInstanceOf(parent, HTMLElement)\n          ) {\n            animatedomInsert(element, parent, after);\n          } else {\n            domInsert(element, parent, after);\n          }\n\n          return $$animateQueue.push(\n            element,\n            \"move\",\n            prepareAnimateOptions(options),\n          );\n        },\n\n        /**\n         * Triggers an animation and then removes the element from the DOM.\n         * When the function is called a promise is returned that will be resolved during the next\n         * digest once the animation has completed.\n         *\n         * @param {Element} element the element which will be removed from the DOM\n         * @param {import(\"./interface.ts\").AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.\n         * @returns {ng.AnimateRunner} the animation runner\n         */\n        leave(element, options) {\n          return $$animateQueue.push(\n            element,\n            \"leave\",\n            prepareAnimateOptions(options),\n            () => {\n              removeElement(element);\n            },\n          );\n        },\n\n        /**\n         * Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon\n         * execution, the addClass operation will only be handled after the next digest and it will not trigger an\n         * animation if element already contains the CSS class or if the class is removed at a later step.\n         * Note that class-based animations are treated differently compared to structural animations\n         * (like enter, move and leave) since the CSS classes may be added/removed at different points\n         * depending if CSS or JavaScript animations are used.\n         *\n         * @param {Element} element the element which the CSS classes will be applied to\n         * @param {string} className the CSS class(es) that will be added (multiple classes are separated via spaces)\n         * @param {import(\"./interface.ts\").AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.\n         * @return {ng.AnimateRunner}} animationRunner the animation runner\n         */\n        addClass(element, className, options) {\n          options = prepareAnimateOptions(options);\n          options.addClass = mergeClasses(options.addClass, className);\n\n          return $$animateQueue.push(element, \"addClass\", options);\n        },\n\n        /**\n         * Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon\n         * execution, the removeClass operation will only be handled after the next digest and it will not trigger an\n         * animation if element does not contain the CSS class or if the class is added at a later step.\n         * Note that class-based animations are treated differently compared to structural animations\n         * (like enter, move and leave) since the CSS classes may be added/removed at different points\n         * depending if CSS or JavaScript animations are used.\n         *\n         * @param {Element} element the element which the CSS classes will be applied to\n         * @param {string} className the CSS class(es) that will be removed (multiple classes are separated via spaces)\n         * @param {import(\"./interface.ts\").AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.         *\n         * @return {ng.AnimateRunner} animationRunner the animation runner\n         */\n        removeClass(element, className, options) {\n          options = prepareAnimateOptions(options);\n          options.removeClass = mergeClasses(options.removeClass, className);\n\n          return $$animateQueue.push(element, \"removeClass\", options);\n        },\n\n        /**\n         * Performs both the addition and removal of a CSS classes on an element and (during the process)\n         * triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and\n         * `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has\n         * passed. Note that class-based animations are treated differently compared to structural animations\n         * (like enter, move and leave) since the CSS classes may be added/removed at different points\n         * depending if CSS or JavaScript animations are used.\n         *\n         * @param {Element} element the element which the CSS classes will be applied to\n         * @param {string} add the CSS class(es) that will be added (multiple classes are separated via spaces)\n         * @param {string} remove the CSS class(es) that will be removed (multiple classes are separated via spaces)\n         * @param {import(\"./interface.ts\").AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.\n         *\n         * @return {ng.AnimateRunner} the animation runner\n         */\n        setClass(element, add, remove, options) {\n          options = prepareAnimateOptions(options);\n          options.addClass = mergeClasses(options.addClass, add);\n          options.removeClass = mergeClasses(options.removeClass, remove);\n\n          return $$animateQueue.push(element, \"setClass\", options);\n        },\n\n        /**\n         * Performs an inline animation on the element which applies the provided to and from CSS styles to the element.\n         * If any detected CSS transition, keyframe or JavaScript matches the provided className value, then the animation will take\n         * on the provided styles. For example, if a transition animation is set for the given className, then the provided `from` and\n         * `to` styles will be applied alongside the given transition. If the CSS style provided in `from` does not have a corresponding\n         * style in `to`, the style in `from` is applied immediately, and no animation is run.\n         * If a JavaScript animation is detected then the provided styles will be given in as function parameters into the `animate`\n         * method (or as part of the `options` parameter):\n         *\n         * ```js\n         * ngModule.animation('.my-inline-animation', function() {\n         *   return {\n         *     animate : function(element, from, to, done, options) {\n         *       //animation\n         *       done();\n         *     }\n         *   }\n         * });\n         * ```\n         *\n         * @param {Element} element the element which will be animated\n         * @param {Record<string, string | number>} from the initial CSS styles for the animation\n         * @param {Record<string, string | number>} to the final CSS styles for the animation\n         * @param {string=} className an optional CSS class name to apply for the animation\n         * @param {import(\"./interface.ts\").AnimationOptions=} options an optional collection of options/styles that will be applied to the element.\n         * @return {ng.AnimateRunner} the animation runner\n         */\n        animate(element, from, to, className, options) {\n          options = prepareAnimateOptions(options);\n          options.from = options.from\n            ? /** @type {Record<string, string | number>} */ (\n                extend(options.from, from)\n              )\n            : from;\n          options.to = options.to\n            ? /** @type {Record<string, string | number>} */ (\n                extend(options.to, to)\n              )\n            : to;\n\n          className = className || \"ng-inline-animate\";\n          options.tempClasses = mergeClasses(options.tempClasses, className);\n\n          return $$animateQueue.push(element, \"animate\", options);\n        },\n      };\n    },\n  ];\n}\n","/**\n * Provides an instance of a cache that can be used to store and retrieve template content.\n */\nexport class TemplateCacheProvider {\n  constructor() {\n    /** @type {ng.TemplateCacheService} */\n    this.cache = new Map();\n  }\n\n  /**\n   * @returns {ng.TemplateCacheService}\n   */\n  $get() {\n    return this.cache;\n  }\n}\n","/**\n * Unified exception handler used throughout AngularTS.\n *\n * This service receives uncaught exceptions from both synchronous and asynchronous operations.\n * Its purpose is to provide a central point through which the framework\n * processes errors.\n *\n * By default, `$exceptionHandler` simply rethrows the exception. This ensures fail-fast\n * behavior, making errors visible immediately in development and in unit tests.\n * Applications may override this service to introduce custom error handling.\n *\n * ### Example: Custom `$exceptionHandler`\n *\n * ```js\n * angular\n *   .module('app')\n *   .factory('$exceptionHandler', function(myLogger) {\n *     return function handleError(error) {\n *       myLogger.capture(error);\n *       // Rethrow to preserve fail-fast behavior:\n *       throw error;\n *     };\n *   });\n * ```\n *\n * IMPORTANT: custom implementation should always rethrow the error as the framework assumes that `$exceptionHandler` always does the throwing.\n *\n * ### Manual Invocation\n *\n * You can invoke the exception handler directly when catching errors in your own code:\n *\n * ```js\n * try {\n *   riskyOperation();\n * } catch (err) {\n *   $exceptionHandler(err);\n * }\n * ```\n *\n * @see {@link ng.ExceptionHandlerService} ExceptionHandlerService\n */\n\n/**\n * Provider for the `$exceptionHandler` service.\n *\n * The default implementation rethrows exceptions, enabling strict fail-fast behavior.\n * Applications may replace the handler via by setting `errorHandler`property or by providing their own\n * `$exceptionHandler` factory.\n */\nexport class ExceptionHandlerProvider {\n  constructor() {\n    /** @type {ng.ExceptionHandlerService} */\n    this.handler = (exception) => {\n      throw exception;\n    };\n  }\n\n  /**\n   * @returns {ng.ExceptionHandlerService}\n   */\n  $get() {\n    return (exception) => this.handler(exception);\n  }\n}\n","import {\n  equals,\n  hasCustomToString,\n  isArray,\n  isArrayLike,\n  isFunction,\n  isNullOrUndefined,\n  isObject,\n  isUndefined,\n  minErr,\n} from \"../shared/utils.js\";\n\n/**\n * @returns {ng.FilterFn}\n */\nexport function filterFilter() {\n  /**\n   * @param {Array<any>} array The source array.\n   * @param {string|Object|function(any, number, []):[]} expression The predicate to be used for selecting items from `array`.\n   * @param {function(any, any):boolean|boolean} [comparator] Comparator which is used in determining if values retrieved using `expression`\n   * (when it is not a function) should be considered a match based on the expected value (from the filter expression) and actual value (from the object in the array).\n   * @param {string} [anyPropertyKey] The special property name that matches against any property.\n   * @return {Array<any>} Filtered array\n   */\n  return function (array, expression, comparator, anyPropertyKey) {\n    if (!isArrayLike(array)) {\n      if (isNullOrUndefined(array)) {\n        return array;\n      }\n      throw minErr(\"filter\")(\n        \"notarray\",\n        \"Expected array but received: {0}\",\n        array,\n      );\n    }\n\n    anyPropertyKey = anyPropertyKey || \"$\";\n    let predicateFn;\n\n    switch (getTypeForFilter(expression)) {\n      case \"function\":\n        predicateFn = expression;\n        break;\n      case \"boolean\":\n      case \"null\":\n      case \"number\":\n      case \"string\":\n        predicateFn = createPredicateFn(\n          expression,\n          comparator,\n          anyPropertyKey,\n          true,\n        );\n        break;\n\n      case \"object\":\n        predicateFn = createPredicateFn(\n          expression,\n          comparator,\n          anyPropertyKey,\n          false,\n        );\n        break;\n\n      default:\n        return array;\n    }\n\n    return Array.from(array).filter(\n      /** @type {(item: any) => boolean} */ (predicateFn),\n    );\n  };\n}\n\n// Helper functions for `filterFilter`\n/**\n * Creates a predicate function that can be used with `Array.prototype.filter`\n * to match items against a given filter expression.\n *\n * @param {string | Object & Record<string, any> | null} expression\n *   The filter expression to match items against. Can be:\n *     - `string`: matched as a case-insensitive substring\n *     - `object`: matched by property values (supports special `anyPropertyKey`)\n *     - `null`: treated as a literal match\n *\n * @param {boolean | ((actual: any, expected: any) => boolean)} [comparator=false]\n *   Comparator to determine equality between actual array values and expected values:\n *     - `true`  uses strict equality (angular.equals)\n *     - `false` (default)  performs case-insensitive substring match for primitives\n *     - `function(actual, expected)`  custom comparator returning boolean\n *\n * @param {string} [anyPropertyKey=\"$\"]\n *   Special property key that allows matching against any property of an object.\n *   Defaults to `$`.\n *\n * @param {boolean} [matchAgainstAnyProp=false]\n *   If true, allows matching against any property in the object.\n *   Typically true when filtering with primitive expressions.\n *\n * @returns {(item: any) => boolean}\n *   Predicate function that returns `true` if `item` matches the expression.\n */\nfunction createPredicateFn(\n  expression,\n  comparator,\n  anyPropertyKey,\n  matchAgainstAnyProp,\n) {\n  anyPropertyKey = anyPropertyKey ?? \"$\";\n  const shouldMatchPrimitives =\n    isObject(expression) && anyPropertyKey in expression;\n\n  if (comparator === true) {\n    comparator = equals;\n  } else if (!isFunction(comparator)) {\n    comparator = function (\n      /** @type {string | any[] | null} */ actual,\n      /** @type {string | null} */ expected,\n    ) {\n      if (isUndefined(actual)) {\n        // No substring matching against `undefined`\n        return false;\n      }\n\n      if (actual === null || expected === null) {\n        // No substring matching against `null`; only match against `null`\n        return actual === expected;\n      }\n\n      if (\n        isObject(expected) ||\n        (isObject(actual) && !hasCustomToString(actual))\n      ) {\n        // Should not compare primitives against objects, unless they have custom `toString` method\n        return false;\n      }\n\n      actual = `${actual}`.toLowerCase();\n      expected = `${expected}`.toLowerCase();\n\n      return actual.indexOf(expected) !== -1;\n    };\n  }\n\n  const predicateFn = function (/** @type {string | Object | null} */ item) {\n    if (shouldMatchPrimitives && !isObject(item)) {\n      return deepCompare(\n        item,\n        expression[anyPropertyKey],\n        comparator,\n        anyPropertyKey,\n        false,\n      );\n    }\n\n    return deepCompare(\n      item,\n      expression,\n      comparator,\n      anyPropertyKey,\n      !!matchAgainstAnyProp, // coerce undefined  false\n    );\n  };\n\n  return predicateFn;\n}\n\n/**\n * @param {string | Object | null} actual\n * @param {string | Object | null} expected\n * @param {(arg0: any, arg1: any) => any} comparator\n * @param {string} anyPropertyKey\n * @param {boolean} matchAgainstAnyProp\n * @param {boolean | undefined} [dontMatchWholeObject]\n * @returns {boolean}\n */\nfunction deepCompare(\n  actual,\n  expected,\n  comparator,\n  anyPropertyKey,\n  matchAgainstAnyProp,\n  dontMatchWholeObject,\n) {\n  const actualType = getTypeForFilter(actual);\n\n  const expectedType = getTypeForFilter(expected);\n\n  if (\n    expectedType === \"string\" &&\n    /** @type {string} */ (expected).charAt(0) === \"!\"\n  ) {\n    return !deepCompare(\n      actual,\n      /** @type {string} */ (expected).substring(1),\n      comparator,\n      anyPropertyKey,\n      matchAgainstAnyProp,\n    );\n  }\n\n  if (isArray(actual)) {\n    // In case `actual` is an array, consider it a match\n    // if ANY of it's items matches `expected`\n    return actual.some((item) =>\n      deepCompare(\n        item,\n        expected,\n        comparator,\n        anyPropertyKey,\n        matchAgainstAnyProp,\n      ),\n    );\n  }\n\n  switch (actualType) {\n    case \"object\":\n      if (matchAgainstAnyProp) {\n        for (const key in /** @type {Record<string, any>} */ (actual)) {\n          // Under certain, rare, circumstances, key may not be a string and `charAt` will be undefined\n          // See: https://github.com/angular/angular.js/issues/15644\n          if (\n            key.charAt &&\n            key.charAt(0) !== \"$\" &&\n            deepCompare(\n              /** @type {Record<string, any>} */ (actual)[key],\n              expected,\n              comparator,\n              anyPropertyKey,\n              true,\n            )\n          ) {\n            return true;\n          }\n        }\n\n        return dontMatchWholeObject\n          ? false\n          : deepCompare(actual, expected, comparator, anyPropertyKey, false);\n      }\n\n      if (expectedType === \"object\") {\n        for (const key in /** @type {Record<string, any>} */ (expected)) {\n          const expectedVal = /** @type {Record<string, any>} */ (expected)[\n            key\n          ];\n\n          if (isFunction(expectedVal) || isUndefined(expectedVal)) {\n            continue;\n          }\n\n          const matchAnyProperty = key === anyPropertyKey;\n\n          const actualVal = matchAnyProperty\n            ? actual\n            : /** @type {Record<string, any>} */ (actual)[key];\n\n          if (\n            !deepCompare(\n              actualVal,\n              expectedVal,\n              comparator,\n              anyPropertyKey,\n              matchAnyProperty,\n              matchAnyProperty,\n            )\n          ) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return comparator(actual, expected);\n\n    case \"function\":\n      return false;\n    default:\n      return comparator(actual, expected);\n  }\n}\n\n// Used for easily differentiating between `null` and actual `object`\n/**\n * @param {string | Object | null} val\n * @return {string}\n */\nfunction getTypeForFilter(val) {\n  return val === null ? \"null\" : typeof val;\n}\n","import { isUndefined, toJson } from \"../shared/utils.js\";\n\n/**\n * @returns {ng.FilterFn}\n */\nexport function jsonFilter() {\n  return function (object, spacing) {\n    if (isUndefined(spacing)) {\n      spacing = 2;\n    }\n\n    return toJson(object, spacing);\n  };\n}\n","import {\n  isArrayLike,\n  isFunction,\n  isNumber,\n  isNumberNaN,\n  isString,\n} from \"../shared/utils.js\";\n\n/**\n * @returns {ng.FilterFn}\n */\nexport function limitToFilter() {\n  /**\n   * Limits the size of an array, array-like object, string, or number.\n   *\n   * - If `input` is a function, it will be invoked and its return value used.\n   * - If `input` is a number, it will be converted to a string.\n   * - Nonarray-like values are returned unchanged.\n   *\n   * @param {Array<any>|ArrayLike<any>|string|number} input\n   *   The value to limit.\n   * @param {string|number} limit\n   *   The maximum length of the returned value. Negative values limit from the end.\n   * @param {string|number} [begin]\n   *   Index at which to begin the limitation. A negative value is an offset from the end.\n   *   Defaults to `0`.\n   * @returns {Array<any>|ArrayLike<any>|string|number}\n   *   A limited array or string, or the original input if it cannot be limited.\n   */\n  return function (input, limit, begin) {\n    if (isFunction(input)) {\n      input = /** @type {Function} */ (input)();\n    }\n\n    if (Math.abs(Number(limit)) === Infinity) {\n      limit = Number(limit);\n    } else {\n      limit = parseInt(/** @type {string} */ (limit), 10);\n    }\n\n    if (isNumberNaN(limit)) return input;\n\n    if (isNumber(input)) input = input.toString();\n\n    if (!isArrayLike(input)) return input;\n\n    begin =\n      !begin || isNaN(/** @type {any} */ (begin))\n        ? 0\n        : parseInt(/** @type {string} */ (begin), 10);\n    begin =\n      begin < 0 ? Math.max(0, /** @type {[]} */ (input).length + begin) : begin;\n\n    if (limit >= 0) {\n      return sliceFn(input, begin, begin + limit);\n    } else {\n      if (begin === 0) {\n        return sliceFn(input, limit, /** @type {[]} */ (input).length);\n      } else {\n        return sliceFn(input, Math.max(0, begin + limit), begin);\n      }\n    }\n  };\n}\n\n/**\n * Returns a shallow copy of a portion of an array-like or string.\n *\n * - For strings, this delegates to `String.prototype.slice`\n * - For array-like objects, this delegates to `Array.prototype.slice`\n *\n * @param {string|ArrayLike<any>} input\n *   The value to slice. Must be a string or array-like object.\n * @param {number} [begin]\n *   Zero-based index at which to begin extraction.\n * @param {number} [end]\n *   Zero-based index before which to end extraction.\n * @returns {string|Array<any>}\n *   A sliced string if input is a string, otherwise an array.\n */\nfunction sliceFn(input, begin, end) {\n  if (isString(input)) return input.slice(begin, end);\n\n  return [].slice.call(input, begin, end);\n}\n","import {\n  hasCustomToString,\n  isArray,\n  isArrayLike,\n  isFunction,\n  isNullOrUndefined,\n  isObject,\n  isString,\n  minErr,\n} from \"../shared/utils.js\";\nimport { $injectTokens } from \"../injection-tokens.js\";\n\n/**\n * @typedef {Object} ComparisonObject\n * @property {*} value\n * @property {{ value: number, type: string, index: number }} tieBreaker\n * @property {Array<{ value: any, type: string, index: number }>} predicateValues\n */\n\norderByFilter.$inject = [$injectTokens._parse];\n\n/**\n * @param {ng.ParseService} $parse\n * @returns {ng.FilterFn}\n */\nexport function orderByFilter($parse) {\n  /**\n   * Sorts an array or array-like collection based on one or more predicates.\n   *\n   * The collection can be:\n   * - An array\n   * - An array-like object\n   * - A function returning an array\n   *\n   * Predicates can be:\n   * - Property names (strings)\n   * - Getter functions\n   * - Strings with \"+\" or \"-\" prefix to indicate ascending/descending order\n   *\n   * @param {Array<any>|ArrayLike<any>|Function} array\n   *   The collection to be sorted.\n   * @param {string|Function|Array<string|Function>} [sortPredicate]\n   *   A single predicate or array of predicates used for sorting.\n   * @param {boolean} [reverseOrder=false]\n   *   If true, reverses the sort order.\n   * @param {Function} [compareFn]\n   *   Optional comparator function. Defaults to a type-aware comparison function.\n   * @returns {Array<any>|ArrayLike<any>}\n   *   A new array containing the sorted values.\n   *\n   * @throws {Error} Throws if `array` is not array-like.\n   */\n  return function (array, sortPredicate, reverseOrder, compareFn) {\n    if (isNullOrUndefined(array)) return array;\n\n    if (isFunction(array)) return array();\n\n    if (!isArrayLike(array)) {\n      throw minErr(\"orderBy\")(\n        \"notarray\",\n        \"Expected array but received: {0}\",\n        array,\n      );\n    }\n\n    if (!isArray(sortPredicate)) {\n      sortPredicate = [sortPredicate ?? \"+\"]; // if undefined, default to \"+\"\n    }\n\n    if (sortPredicate.length === 0) {\n      sortPredicate = [\"+\"];\n    }\n\n    const predicates = processPredicates(sortPredicate);\n\n    const descending = reverseOrder ? -1 : 1;\n\n    // Define the `compare()` function. Use a default comparator if none is specified.\n    const compare = isFunction(compareFn) ? compareFn : defaultCompare;\n\n    // The next three lines are a version of a Swartzian Transform idiom from Perl\n    // (sometimes called the Decorate-Sort-Undecorate idiom)\n    // See https://en.wikipedia.org/wiki/Schwartzian_transform\n    const compareValues = /** @type {ComparisonObject[]} */ (\n      Array.prototype.map.call(array, getComparisonObject)\n    );\n\n    compareValues.sort(doComparison);\n    array = compareValues.map((item) => item.value);\n\n    return array;\n\n    /**\n     * Creates a comparison object for a given value in the array.\n     * This object is used to perform stable sorting with multiple predicates.\n     *\n     * @param {*} value - The value from the array to wrap for comparison.\n     * @param {number} index - The index of the value in the original array.\n     * @returns {{\n     *   value: *,\n     *   tieBreaker: { value: number, type: string, index: number },\n     *   predicateValues: Array<{ value: *, type: string, index: number }>\n     * }}\n     *   An object containing:\n     *     - `value`: the original value,\n     *     - `tieBreaker`: a stable sort fallback using the original index,\n     *     - `predicateValues`: an array of values derived from each sort predicate.\n     */\n    function getComparisonObject(value, index) {\n      // NOTE: We are adding an extra `tieBreaker` value based on the element's index.\n      // This will be used to keep the sort stable when none of the input predicates can\n      // distinguish between two elements.\n      return {\n        value,\n        tieBreaker: { value: index, type: \"number\", index },\n        predicateValues: predicates.map((predicate) =>\n          getPredicateValue(predicate.get(value), index),\n        ),\n      };\n    }\n\n    /**\n     * Comparator used to sort decorated collection items.\n     *\n     * Iterates over all sort predicates and compares their corresponding\n     * predicate values. The first non-zero comparison result determines\n     * the ordering.\n     *\n     * If all predicate comparisons are equal, a tie-breaker based on the\n     * original index is used to guarantee a stable sort.\n     *\n     * @param {ComparisonObject} v1 First decorated comparison object\n     * @param {ComparisonObject} v2 Second decorated comparison object\n     * @returns {number} -1 if v1 < v2, 1 if v1 > v2, 0 if equivalent\n     */\n    function doComparison(v1, v2) {\n      for (let i = 0, ii = predicates.length; i < ii; i++) {\n        const result = compare(v1.predicateValues[i], v2.predicateValues[i]);\n\n        if (result) {\n          return result * predicates[i].descending * descending;\n        }\n      }\n\n      return (\n        (compare(v1.tieBreaker, v2.tieBreaker) ||\n          defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending\n      );\n    }\n  };\n\n  /**\n   * Processes an array of sort predicates into getter functions and sort directions.\n   *\n   * Each predicate can be:\n   * - A function: used directly to extract values for comparison.\n   * - A string starting with `+` or `-` to indicate ascending or descending order.\n   *   The remainder of the string is interpreted as a property path.\n   *\n   * @param {(string|Function)[]} sortPredicates - Array of predicates to process. Each predicate\n   *   can be a string (property name, optionally prefixed with \"+\" or \"-\") or a function.\n   * @return {Array<{get: Function, descending: number}>} Array of objects, each containing:\n   *   - `get`: Function to extract the value from an item.\n   *   - `descending`: `1` for ascending, `-1` for descending.\n   */\n  function processPredicates(sortPredicates) {\n    return sortPredicates.map((predicate) => {\n      let descending = 1;\n\n      /**\n       * @type {function(*): *}\n       */\n      let get = (x) => x;\n\n      if (isFunction(predicate)) {\n        get = /** @type {function(*): *} */ (predicate);\n      } else if (isString(predicate)) {\n        if (predicate.charAt(0) === \"+\" || predicate.charAt(0) === \"-\") {\n          descending = predicate.charAt(0) === \"-\" ? -1 : 1;\n          predicate = predicate.substring(1);\n        }\n\n        if (predicate !== \"\") {\n          const parsed = $parse(predicate);\n\n          if (parsed.constant) {\n            const key = parsed();\n\n            get = /** @type {Record<string, any>} value */ (value) =>\n              value[key];\n          } else {\n            get = parsed;\n          }\n        }\n      }\n\n      return { get, descending };\n    });\n  }\n\n  /**\n   * @param {any} value\n   * @return {boolean}\n   */\n  function isPrimitive(value) {\n    switch (typeof value) {\n      case \"number\": /* falls through */\n      case \"boolean\": /* falls through */\n      case \"string\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Converts an object to a primitive value for comparison purposes.\n   *\n   * - If the object has a valid `valueOf()` method that returns a primitive, it uses that.\n   * - Otherwise, if the object has a custom `toString()` method, it uses that.\n   * - If neither yields a primitive, returns the original object.\n   *\n   * @param {*} value - The object to convert.\n   * @returns {*} The primitive representation of the object if possible; otherwise, the original object.\n   */\n  function objectValue(value) {\n    // If `valueOf` is a valid function use that\n    if (isFunction(value.valueOf)) {\n      value = value.valueOf();\n\n      if (isPrimitive(value)) return value;\n    }\n\n    // If `toString` is a valid function and not the one from `Object.prototype` use that\n    if (hasCustomToString(value)) {\n      value = value.toString();\n\n      if (isPrimitive(value)) return value;\n    }\n\n    return value;\n  }\n\n  /**\n   * Normalizes a value for sorting by determining its type and\n   * converting objects to primitive representations when possible.\n   *\n   * @param {*} value - The value to normalize for comparison.\n   * @param {number} index - The original index of the value in the array.\n   * @returns {{\n   *   value: *,\n   *   type: string,\n   *   index: number\n   * }}\n   *   An object containing:\n   *     - `value`: the normalized value (primitive if possible),\n   *     - `type`: a string representing the type of the value (`number`, `string`, `boolean`, `null`, etc.),\n   *     - `index`: the original index to maintain stable sorting.\n   */\n  function getPredicateValue(value, index) {\n    /** @type {String} */ let type = typeof value;\n\n    if (value === null) {\n      type = \"null\";\n    } else if (type === \"object\") {\n      value = objectValue(value);\n    }\n\n    return { value, type, index };\n  }\n\n  /**\n   * Default comparison function used by the `orderBy` filter.\n   *\n   * Compares two wrapped predicate values and returns a sort order indicator.\n   * Comparison rules:\n   * - Values of the same type are compared directly\n   * - Strings are compared case-insensitively\n   * - Objects fall back to their original index to preserve stability\n   * - `undefined` and `null` are ordered last\n   *\n   * @param {{ value: any, type: string, index: number }} v1\n   *   First comparison object.\n   * @param {{ value: any, type: string, index: number }} v2\n   *   Second comparison object.\n   * @returns {number}\n   *   Returns `-1` if `v1 < v2`, `1` if `v1 > v2`, or `0` if equal.\n   */\n  function defaultCompare(v1, v2) {\n    let result = 0;\n\n    const type1 = v1.type;\n\n    const type2 = v2.type;\n\n    if (type1 === type2) {\n      let value1 = v1.value;\n\n      let value2 = v2.value;\n\n      if (type1 === \"string\") {\n        // Compare strings case-insensitively\n        value1 = value1.toLowerCase();\n        value2 = value2.toLowerCase();\n      } else if (type1 === \"object\") {\n        // For basic objects, use the position of the object\n        // in the collection instead of the value\n        if (isObject(value1)) value1 = v1.index;\n\n        if (isObject(value2)) value2 = v2.index;\n      }\n\n      if (value1 !== value2) {\n        result = value1 < value2 ? -1 : 1;\n      }\n    } else {\n      result =\n        type1 === \"undefined\"\n          ? 1\n          : type2 === \"undefined\"\n            ? -1\n            : type1 === \"null\"\n              ? 1\n              : type2 === \"null\"\n                ? -1\n                : type1 < type2\n                  ? -1\n                  : 1;\n    }\n\n    return result;\n  }\n}\n","import { $injectTokens as $t } from \"../../injection-tokens.js\";\nimport { filterFilter } from \"../../filters/filter.js\";\nimport { jsonFilter } from \"../../filters/json.js\";\nimport { limitToFilter } from \"../../filters/limit-to.js\";\nimport { orderByFilter } from \"../../filters/order-by.js\";\nimport { assert, entries, isDefined, isFunction } from \"../../shared/utils.js\";\nimport { validate, validateIsString } from \"../../shared/validate.js\";\n\n/* @ignore */\nconst SUFFIX = \"Filter\";\n\n/**\n * $filterProvider - $filter - provider in module ng\n *\n * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To achieve this a filter definition consists of a factory function which is annotated with dependencies and is responsible for creating a filter function.\n * @extends {ng.ServiceProvider}\n */\nexport class FilterProvider {\n  /* @ignore */ static $inject = [$t._provide];\n\n  /**\n   * @param {ng.ProvideService} $provide\n   */\n  constructor($provide) {\n    assert(isDefined($provide));\n    this._$provide = $provide;\n    entries({\n      filter: filterFilter,\n      json: jsonFilter,\n      limitTo: limitToFilter,\n      orderBy: orderByFilter,\n    }).forEach(([k, v]) =>\n      this.register(k, /** @type {ng.FilterFactory} */ (v)),\n    );\n  }\n\n  /**\n   * Register a filter a config phase;\n   * @param {string} name\n   * @param {ng.FilterFactory} factory\n   * @return {ng.FilterProvider}\n   */\n  register(name, factory) {\n    validateIsString(name, \"name\");\n    validate(isFunction, factory, \"factory\");\n    this._$provide.factory(name + SUFFIX, factory);\n\n    return this;\n  }\n\n  $get = [\n    $t._injector,\n    /**\n     * @param {ng.InjectorService} $injector\n     * @returns {ng.FilterService}\n     */\n    ($injector) => (name) => {\n      validateIsString(name, \"name\");\n\n      return $injector.get(name + SUFFIX);\n    },\n  ];\n}\n","import {\n  isDefined,\n  isUndefined,\n  minErr,\n  stringify,\n} from \"../../shared/utils.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n\nconst $interpolateMinErr = minErr(\"$interpolate\");\n\n/**\n * @param {string} text\n */\nfunction throwNoconcat(text) {\n  throw $interpolateMinErr(\n    \"noconcat\",\n    \"Error while interpolating: {0}\\nStrict Contextual Escaping disallows \" +\n      \"interpolations that concatenate multiple expressions when a trusted value is \" +\n      \"required.  See http://docs.angularjs.org/api/ng.$sce\",\n    text,\n  );\n}\n\n/**\n * @param {string} text\n * @param {Error} err\n */\nfunction interr(text, err) {\n  throw $interpolateMinErr(\n    \"interr\",\n    \"Can't interpolate: {0}\\n{1}\",\n    text,\n    err.toString(),\n  );\n}\n\n/**\n *\n * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.\n *\n * <div class=\"alert alert-danger\">\n * This feature is sometimes used to mix different markup languages, e.g. to wrap an AngularTS\n * template within a Python Jinja template (or any other template language). Mixing templating\n * languages is **very dangerous**. The embedding template language will not safely escape AngularTS\n * expressions, so any user-controlled values in the template will cause Cross Site Scripting (XSS)\n * security bugs!\n * </div>\n */\nexport class InterpolateProvider {\n  constructor() {\n    /**\n     * @type {string} Symbol to denote start of expression in the interpolated string. Defaults to `{{`.\n     */\n    this.startSymbol = \"{{\";\n\n    /**\n     * @type {string} Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n     */\n    this.endSymbol = \"}}\";\n  }\n\n  $get = [\n    $t._parse,\n    $t._sce,\n    /**\n     *\n     * @param {ng.ParseService} $parse\n     * @param {ng.SceService} $sce\n     * @returns {ng.InterpolateService}\n     */\n    ($parse, $sce) => {\n      /** @type {InterpolateProvider} */\n      const provider = this;\n\n      const startSymbolLength = this.startSymbol.length;\n\n      const endSymbolLength = this.endSymbol.length;\n\n      const escapedStartRegexp = new RegExp(\n        provider.startSymbol.replace(/./g, escape),\n        \"g\",\n      );\n\n      const escapedEndRegexp = new RegExp(\n        provider.endSymbol.replace(/./g, escape),\n        \"g\",\n      );\n\n      /**\n       * @param {any} ch\n       */\n      function escape(ch) {\n        return `\\\\\\\\\\\\${ch}`;\n      }\n\n      /**\n       * @param {string} text\n       */\n      function unescapeText(text) {\n        return text\n          .replace(escapedStartRegexp, provider.startSymbol)\n          .replace(escapedEndRegexp, provider.endSymbol);\n      }\n\n      /**\n       *\n       * Compiles a string with markup into an interpolation function. This service is used by the\n       * HTML {@link ng.$compile $compile} service for data binding. See\n       * {@link ng.$interpolateProvider $interpolateProvider} for configuring the\n       * interpolation markup.\n       *\n       *\n       * ```js\n       *   let $interpolate = ...; // injected\n       *   let exp = $interpolate('Hello {{name | uppercase}}!');\n       *   expect(exp({name:'AngularTS'})).toEqual('Hello ANGULARJS!');\n       * ```\n       *\n       * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is\n       * `true`, the interpolation function will return `undefined` unless all embedded expressions\n       * evaluate to a value other than `undefined`.\n       *\n       * ```js\n       *   let $interpolate = ...; // injected\n       *   let context = {greeting: 'Hello', name: undefined };\n       *\n       *   // default \"forgiving\" mode\n       *   let exp = $interpolate('{{greeting}} {{name}}!');\n       *   expect(exp(context)).toEqual('Hello !');\n       *\n       *   // \"allOrNothing\" mode\n       *   exp = $interpolate('{{greeting}} {{name}}!', false, null, true);\n       *   expect(exp(context)).toBeUndefined();\n       *   context.name = 'AngularTS';\n       *   expect(exp(context)).toEqual('Hello AngularTS!');\n       * ```\n       *\n       * `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.\n       *\n       * #### Escaped Interpolation\n       * $interpolate provides a mechanism for escaping interpolation markers. Start and end markers\n       * can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).\n       * It will be rendered as a regular start/end marker, and will not be interpreted as an expression\n       * or binding.\n       *\n       * This enables web-servers to prevent script injection attacks and defacing attacks, to some\n       * degree, while also enabling code examples to work without relying on the\n       * {@link ng.directive:ngNonBindable ngNonBindable} directive.\n       *\n       * **For security purposes, it is strongly encouraged that web servers escape user-supplied data,\n       * replacing angle brackets (&lt;, &gt;) with &amp;lt; and &amp;gt; respectively, and replacing all\n       * interpolation start/end markers with their escaped counterparts.**\n       *\n       * Escaped interpolation markers are only replaced with the actual interpolation markers in rendered\n       * output when the $interpolate service processes the text. So, for HTML elements interpolated\n       * by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter\n       * set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,\n       * this is typically useful only when user-data is used in rendering a template from the server, or\n       * when otherwise untrusted data is used by a directive.\n       *\n       * <example name=\"interpolation\">\n       *  <file name=\"index.html\">\n       *    <div ng-init=\"username='A user'\">\n       *      <p ng-init=\"apptitle='Escaping demo'\">{{apptitle}}: \\{\\{ username = \"defaced value\"; \\}\\}\n       *        </p>\n       *      <p><strong>{{username}}</strong> attempts to inject code which will deface the\n       *        application, but fails to accomplish their task, because the server has correctly\n       *        escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)\n       *        characters.</p>\n       *      <p>Instead, the result of the attempted script injection is visible, and can be removed\n       *        from the database by an administrator.</p>\n       *    </div>\n       *  </file>\n       * </example>\n       *\n       * @knownIssue\n       * It is currently not possible for an interpolated expression to contain the interpolation end\n       * symbol. For example, `{{ '}}' }}` will be incorrectly interpreted as `{{ ' }}` + `' }}`, i.e.\n       * an interpolated expression consisting of a single-quote (`'`) and the `' }}` string.\n       *\n       * @knownIssue\n       * All directives and components must use the standard `{{` `}}` interpolation symbols\n       * in their templates. If you change the application interpolation symbols the {@link $compile}\n       * service will attempt to denormalize the standard symbols to the custom symbols.\n       * The denormalization process is not clever enough to know not to replace instances of the standard\n       * symbols where they would not normally be treated as interpolation symbols. For example in the following\n       * code snippet the closing braces of the literal object will get incorrectly denormalized:\n       *\n       * ```\n       * <div data-context='{\"context\":{\"id\":3,\"type\":\"page\"}}\">\n       * ```\n       *\n       * The workaround is to ensure that such instances are separated by whitespace:\n       * ```\n       * <div data-context='{\"context\":{\"id\":3,\"type\":\"page\"} }\">\n       * ```\n       *\n       * See https://github.com/angular/angular.js/pull/14610#issuecomment-219401099 for more information.\n       *\n       * @param {string} text The text with markup to interpolate.\n       * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have\n       *    embedded expression in order to return an interpolation function. Strings with no\n       *    embedded expression will return null for the interpolation function.\n       * @param {string=} trustedContext when provided, the returned function passes the interpolated\n       *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,\n       *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that\n       *    provides Strict Contextual Escaping for details.\n       * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined\n       *    unless all embedded expressions evaluate to a value other than `undefined`.\n       * @returns {import(\"./interface.ts\").InterpolationFunction | undefined} an interpolation function which is used to compute the\n       *    interpolated string. The function has these parameters:\n       *\n       * - `context`: evaluation context for all expressions embedded in the interpolated text\n       */\n      function $interpolate(\n        text,\n        mustHaveExpression,\n        trustedContext,\n        allOrNothing,\n      ) {\n        const contextAllowsConcatenation =\n          trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;\n\n        // Provide a quick exit and simplified result function for text with no interpolation\n        if (!text.length || text.indexOf(provider.startSymbol) === -1) {\n          if (mustHaveExpression) return undefined;\n\n          let unescapedText = unescapeText(text);\n\n          if (contextAllowsConcatenation) {\n            unescapedText = $sce.getTrusted(trustedContext, unescapedText);\n          }\n\n          /**\n           * @type {any}\n           */\n          const constantInterp = () => unescapedText;\n\n          constantInterp.exp = text;\n          constantInterp.expressions = [];\n\n          return constantInterp;\n        }\n\n        allOrNothing = !!allOrNothing;\n        let startIndex;\n\n        let endIndex;\n\n        let index = 0;\n\n        /**\n         * @type {string[]}\n         */\n        const expressions = [];\n\n        const textLength = text.length;\n\n        let exp;\n\n        /**\n         * @type {any[]}\n         */\n        const concat = [];\n\n        /**\n         * @type {number[]}\n         */\n        const expressionPositions = [];\n\n        while (index < textLength) {\n          if (\n            (startIndex = text.indexOf(provider.startSymbol, index)) !== -1 &&\n            (endIndex = text.indexOf(\n              provider.endSymbol,\n              startIndex + startSymbolLength,\n            )) !== -1\n          ) {\n            if (index !== startIndex) {\n              concat.push(unescapeText(text.substring(index, startIndex)));\n            }\n            exp = text.substring(startIndex + startSymbolLength, endIndex);\n            expressions.push(exp);\n            index = endIndex + endSymbolLength;\n            expressionPositions.push(concat.length);\n            concat.push(\"\"); // Placeholder that will get replaced with the evaluated expression.\n          } else {\n            // we did not find an interpolation, so we have to add the remainder to the separators array\n            if (index !== textLength) {\n              concat.push(unescapeText(text.substring(index)));\n            }\n            break;\n          }\n        }\n\n        const singleExpression =\n          concat.length === 1 && expressionPositions.length === 1;\n\n        // Intercept expression if we need to stringify concatenated inputs, which may be SCE trusted\n        // objects rather than simple strings\n        // (we don't modify the expression if the input consists of only a single trusted input)\n        const interceptor =\n          contextAllowsConcatenation && singleExpression\n            ? undefined\n            : parseStringifyInterceptor;\n\n        const parseFns = expressions.map((x) => $parse(x, interceptor));\n\n        // Concatenating expressions makes it hard to reason about whether some combination of\n        // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a\n        // single expression be used for some $sce-managed secure contexts (RESOURCE_URLs mostly),\n        // we ensure that the value that's used is assigned or constructed by some JS code somewhere\n        // that is more testable or make it obvious that you bound the value to some user controlled\n        // value.  This helps reduce the load when auditing for XSS issues.\n\n        // Note that URL and MEDIA_URL $sce contexts do not need this, since `$sce` can sanitize the values\n        // passed to it. In that case, `$sce.getTrusted` will be called on either the single expression\n        // or on the overall concatenated string (losing trusted types used in the mix, by design).\n        // Both these methods will sanitize plain strings. Also, HTML could be included, but since it's\n        // only used in srcdoc attributes, this would not be very useful.\n\n        if (!mustHaveExpression || expressions.length) {\n          const compute = function (/** @type {any[]} */ values) {\n            for (let i = 0, ii = expressions.length; i < ii; i++) {\n              if (allOrNothing && isUndefined(values[i])) return undefined;\n              concat[expressionPositions[i]] = values[i];\n            }\n\n            if (contextAllowsConcatenation) {\n              // If `singleExpression` then `concat[0]` might be a \"trusted\" value or `null`, rather than a string\n              return $sce.getTrusted(\n                trustedContext,\n                singleExpression ? concat[0] : concat.join(\"\"),\n              );\n            }\n\n            if (trustedContext && concat.length > 1) {\n              // This context does not allow more than one part, e.g. expr + string or exp + exp.\n              throwNoconcat(text);\n            }\n\n            // In an unprivileged context or only one part: just concatenate and return.\n            return concat.join(\"\");\n          };\n\n          /**\n           * @type {import(\"./interface.ts\").InterpolationFunction}\n           */\n          const fn = (\n            /** @type {ng.Scope} */ context,\n            /** @type {(val: any) => void=} */ cb,\n          ) => {\n            const ii = expressions.length;\n\n            const values = new Array(ii);\n\n            try {\n              for (let i = 0; i < ii; i++) {\n                if (cb) {\n                  const watchProp = expressions[i].trim();\n\n                  context.$watch(watchProp, () => {\n                    const vals = new Array(ii);\n\n                    for (let j = 0; j < ii; j++) {\n                      vals[j] = parseFns[j](context);\n                    }\n\n                    cb(compute(vals));\n                  });\n                }\n\n                values[i] = parseFns[i](context);\n              }\n\n              return compute(values);\n            } catch (err) {\n              return interr(text, /** @type {Error} */ (err));\n            }\n          };\n\n          // Attach required properties so TS sees them\n          /** @type {string} */\n          fn.exp = text;\n          /** @type {any[]} */\n          fn.expressions = expressions;\n\n          return fn;\n        }\n\n        /**\n         * @param {string} value\n         */\n        function parseStringifyInterceptor(value) {\n          try {\n            // In concatenable contexts, getTrusted comes at the end, to avoid sanitizing individual\n            // parts of a full URL. We don't care about losing the trustedness here.\n            // In non-concatenable contexts, where there is only one expression, this interceptor is\n            // not applied to the expression.\n            value =\n              trustedContext && !contextAllowsConcatenation\n                ? $sce.getTrusted(trustedContext, value)\n                : $sce.valueOf(value);\n\n            return allOrNothing && !isDefined(value) ? value : stringify(value);\n          } catch (err) {\n            return interr(text, /** @type {Error} */ (err));\n          }\n        }\n\n        return undefined;\n      }\n\n      /**\n       * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.\n       *\n       * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change\n       * the symbol.\n       *\n       * @returns {string} start symbol.\n       */\n      $interpolate.startSymbol = function () {\n        return provider.startSymbol;\n      };\n\n      /**\n       * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n       *\n       * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change\n       * the symbol.\n       *\n       * @returns {string} end symbol.\n       */\n      $interpolate.endSymbol = function () {\n        return provider.endSymbol;\n      };\n\n      return $interpolate;\n    },\n  ];\n}\n","import { trimEmptyHash, urlResolve } from \"../../shared/url-utils/url-utils.js\";\nimport {\n  encodeUriSegment,\n  entries,\n  equals,\n  isDefined,\n  isNull,\n  isNumber,\n  isObject,\n  isString,\n  isUndefined,\n  minErr,\n  parseKeyValue,\n  startsWith,\n  toKeyValue,\n} from \"../../shared/utils.js\";\nimport { getBaseHref } from \"../../shared/dom.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\nimport { validateRequired } from \"../../shared/validate.js\";\n\nconst PATH_MATCH = /^([^?#]*)(\\?([^#]*))?(#(.*))?$/;\n\nconst $locationMinErr = minErr(\"$location\");\n\nlet urlUpdatedByLocation = false;\n\n/**\n * @ignore\n * The pathname, beginning with \"/\"\n * @type {string}\n */\nlet _path;\n\n/**\n * @type {Object.<string, string|number|boolean|Array<string|number|boolean>>}\n */\nlet _search;\n\n/**\n * @ignore\n * The hash string, minus the hash symbol\n * @type {string}\n */\nlet _hash;\n\nexport class Location {\n  /**\n   * @ignore\n   * Current url\n   * @type {string | undefined}\n   */\n  _url;\n\n  /**\n   * @ignore\n   * Callback to update browser url\n   * @type {Function | undefined}\n   */\n  _updateBrowser;\n\n  /**\n   * @param {string} appBase application base URL\n   * @param {string} appBaseNoFile application base URL stripped of any filename\n   * @param {boolean} [html5] Defaults to true\n   * @param {string} [prefix] URL path prefix for html5 mode or hash prefix for hashbang mode\n   */\n  constructor(appBase, appBaseNoFile, html5 = true, prefix) {\n    /** @type {string} */\n    this.appBase = appBase;\n\n    /** @type {string} */\n    this.appBaseNoFile = appBaseNoFile;\n\n    /** @type {boolean} */\n    this.html5 = html5;\n\n    /** @type {string | undefined} */\n    this.basePrefix = html5 ? prefix || \"\" : undefined;\n\n    /** @type {string | undefined} */\n    this.hashPrefix = html5 ? undefined : prefix;\n\n    /**\n     * An absolute URL is the full URL, including protocol (http/https ), the optional subdomain (e.g. www ), domain (example.com), and path (which includes the directory and slug)\n     * with all segments encoded according to rules specified in [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).\n     * @type {string}\n     */\n    this.absUrl = \"\";\n  }\n\n  /**\n   * Change path, search and hash, when called with parameter and return `$location`.\n   *\n   * @param {string} url New URL without base prefix (e.g. `/path?a=b#hash`)\n   * @return {Location} url\n   */\n  setUrl(url) {\n    validateRequired(url, \"url\");\n    const match = PATH_MATCH.exec(url);\n\n    if (!match) {\n      throw $locationMinErr(\"badurl\", 'Invalid url \"{0}\".', url);\n    }\n\n    if (match[1] || url === \"\") {\n      this.setPath(match[1] || \"\");\n    }\n\n    if (match[2] || match[1] || url === \"\") {\n      this.setSearch(match[3] || \"\");\n    }\n\n    this.setHash(match[5] || \"\");\n\n    return this;\n  }\n\n  /**\n   * Return URL (e.g. `/path?a=b#hash`) when called without any parameter.\n   *\n   * @return {string} url\n   */\n  getUrl() {\n    return /** @type {string} */ (this._url);\n  }\n\n  /**\n   * Change path parameter and return `$location`.\n   *\n   * @param {(string|number)} path New path\n   * @return {Location}\n   */\n  setPath(path) {\n    validateRequired(path, \"path\");\n    let newPath = path !== null ? path.toString() : \"\";\n\n    if (this.html5) {\n      newPath = decodePath(newPath, this.html5);\n    }\n    _path = newPath.charAt(0) === \"/\" ? newPath : `/${newPath}`;\n    this._compose();\n\n    return this;\n  }\n\n  /**\n   *\n   * Return path of current URL\n   *\n   * @return {string}\n   */\n  getPath() {\n    return _path;\n  }\n\n  /**\n   * Changes the hash fragment when called with a parameter and returns `$location`.\n   * @param {(string|number)} hash New hash fragment\n   * @return {Location} hash\n   */\n  setHash(hash) {\n    validateRequired(hash, \"hash\");\n    _hash = hash !== null ? hash.toString() : \"\";\n    this._compose();\n\n    return this;\n  }\n\n  /**\n   * Returns the hash fragment when called without any parameters.\n   * @return {string} hash\n   */\n  getHash() {\n    return _hash;\n  }\n\n  /**\n   * Sets the search part (as object) of current URL\n   *\n   * @param {string|Object} search New search params - string or hash object.\n   * @param {(string|number|Array<string>|boolean)=} paramValue If search is a string or number, then paramValue will override only a single search property.\n   * @returns {Object} Search object or Location object\n   */\n  setSearch(search, paramValue) {\n    validateRequired(search, \"search\");\n    switch (arguments.length) {\n      case 1:\n        if (isString(search) || isNumber(search)) {\n          search = search.toString();\n          _search = parseKeyValue(/** @type {string} */ (search));\n        } else if (isObject(search)) {\n          search = structuredClone(search, {});\n          // remove object undefined or null properties\n          entries(search).forEach(([key, value]) => {\n            if (isNull(value))\n              delete (/** @type {Record<string, any>} */ (search)[key]);\n          });\n\n          _search = /** @type {Record<string, any>} */ (search);\n        } else {\n          throw $locationMinErr(\n            \"isrcharg\",\n            \"The first argument of the `$location#search()` call must be a string or an object.\",\n          );\n        }\n        break;\n      default:\n        if (isUndefined(paramValue) || paramValue === null) {\n          delete _search[/** @type {string} */ (search)];\n        } else {\n          /** @type {Record<string, any>} */ (_search)[\n            /** @type {string} */ (search)\n          ] = paramValue;\n        }\n    }\n\n    this._compose();\n\n    return this;\n  }\n\n  /**\n   * Returns the search part (as object) of current URL\n   *\n   * @returns {Object} Search object or Location object\n   */\n  getSearch() {\n    return _search;\n  }\n\n  /**\n   * @private\n   * Compose url and update `url` and `absUrl` property\n   */\n  _compose() {\n    this._url = normalizePath(_path, _search, _hash);\n    this.absUrl = this.html5\n      ? this.appBaseNoFile + this._url.substring(1)\n      : this.appBase + (this._url ? this.hashPrefix + this._url : \"\");\n    urlUpdatedByLocation = true;\n    setTimeout(() => this._updateBrowser && this._updateBrowser());\n  }\n\n  /**\n   * Change the history state object when called with one parameter and return `$location`.\n   * The state object is later passed to `pushState` or `replaceState`.\n   * See {@link https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#state|History.state}\n   *\n   * NOTE: This method is supported only in HTML5 mode and only in browsers supporting\n   * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support\n   * older browsers (like IE9 or Android < 4.0), don't use this method.\n   * @param {any} state\n   * @returns {Location}\n   */\n  setState(state) {\n    if (!this.html5) {\n      throw $locationMinErr(\n        \"nostate\",\n        \"History API state support is available only in HTML5 mode\",\n      );\n    }\n    // The user might modify `stateObject` after invoking `$location.setState(stateObject)`\n    // but we're changing the _statereference to $browser.state() during the $digest\n    // so the modification window is narrow.\n    this._state = isUndefined(state) ? null : state;\n    urlUpdatedByLocation = true;\n\n    return this;\n  }\n\n  /**\n   * Return the history state object\n   * @returns {any}\n   */\n  getState() {\n    return this._state;\n  }\n\n  /**\n   * @param {string} url\n   * @param {string} relHref\n   * @returns {boolean}\n   */\n  parseLinkUrl(url, relHref) {\n    if (this.html5) {\n      if (relHref && relHref[0] === \"#\") {\n        // special case for links to hash fragments:\n        // keep the old url and only replace the hash fragment\n        this.setHash(relHref.slice(1));\n\n        return true;\n      }\n      let appUrl;\n\n      let prevAppUrl;\n\n      let rewrittenUrl;\n\n      if (isDefined((appUrl = stripBaseUrl(this.appBase, url)))) {\n        prevAppUrl = appUrl;\n\n        if (\n          this.basePrefix &&\n          isDefined((appUrl = stripBaseUrl(this.basePrefix, appUrl)))\n        ) {\n          rewrittenUrl =\n            this.appBaseNoFile + (stripBaseUrl(\"/\", appUrl) || appUrl);\n        } else {\n          rewrittenUrl = this.appBase + prevAppUrl;\n        }\n      } else if (isDefined((appUrl = stripBaseUrl(this.appBaseNoFile, url)))) {\n        rewrittenUrl = this.appBaseNoFile + appUrl;\n      } else if (this.appBaseNoFile === `${url}/`) {\n        rewrittenUrl = this.appBaseNoFile;\n      }\n\n      if (rewrittenUrl) {\n        this.parse(rewrittenUrl);\n      }\n\n      return !!rewrittenUrl;\n    } else {\n      if (stripHash(this.appBase) === stripHash(url)) {\n        this.parse(url);\n\n        return true;\n      }\n\n      return false;\n    }\n  }\n\n  /**\n   * Parse given HTML5 (regular) URL string into properties\n   * @param {string} url HTML5 URL\n   */\n  parse(url) {\n    if (this.html5) {\n      const pathUrl = stripBaseUrl(this.appBaseNoFile, url);\n\n      if (!isString(pathUrl)) {\n        throw $locationMinErr(\n          \"ipthprfx\",\n          'Invalid url \"{0}\", missing path prefix \"{1}\".',\n          url,\n          this.appBaseNoFile,\n        );\n      }\n\n      parseAppUrl(pathUrl, true);\n\n      if (!_path) {\n        _path = \"/\";\n      }\n\n      this._compose();\n    } else {\n      const withoutBaseUrl = /** @type {string} */ (\n        stripBaseUrl(this.appBase, url) || stripBaseUrl(this.appBaseNoFile, url)\n      );\n\n      let withoutHashUrl;\n\n      if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === \"#\") {\n        // The rest of the URL starts with a hash so we have\n        // got either a hashbang path or a plain hash fragment\n        withoutHashUrl = stripBaseUrl(\n          /** @type {string} */ (this.hashPrefix),\n          withoutBaseUrl,\n        );\n\n        if (isUndefined(withoutHashUrl)) {\n          // There was no hashbang prefix so we just have a hash fragment\n          withoutHashUrl = withoutBaseUrl;\n        }\n      } else {\n        // There was no hashbang path nor hash fragment:\n        // If we are in HTML5 mode we use what is left as the path;\n        // Otherwise we ignore what is left\n        if (this.html5) {\n          withoutHashUrl = withoutBaseUrl;\n        } else {\n          withoutHashUrl = \"\";\n\n          if (isUndefined(withoutBaseUrl)) {\n            this.appBase = url;\n          }\n        }\n      }\n\n      parseAppUrl(/** @type {string} */ (withoutHashUrl), false);\n      this._compose();\n    }\n  }\n}\n\nexport class LocationProvider {\n  constructor() {\n    /** @type {string} */\n    this.hashPrefixConf = \"!\";\n\n    /** @type {import(\"./interface.ts\").Html5Mode} */\n    this.html5ModeConf = {\n      enabled: true,\n      requireBase: false,\n      rewriteLinks: true,\n    };\n\n    /** @private @type {Array<import(\"./interface.ts\").UrlChangeListener>} */\n    this._urlChangeListeners = [];\n    /** @private */\n    this._urlChangeInit = false;\n\n    /** @private @type {History['state']} */\n    this._cachedState = null;\n    /** @private @type {History['state']} */\n    this._lastHistoryState = null;\n    /** @private @type {string} */\n    this._lastBrowserUrl = window.location.href;\n    this.cacheState();\n  }\n\n  /// ///////////////////////////////////////////////////////////\n  // URL API\n  /// ///////////////////////////////////////////////////////////\n\n  /**\n   * Updates the browser's current URL and history state.\n   *\n   * @param {string|undefined} url - The target URL to navigate to.\n   * @param {*} [state=null] - Optional history state object to associate with the new URL.\n   * @returns {LocationProvider}\n   */\n  setUrl(url, state) {\n    if (state === undefined) {\n      state = null;\n    }\n\n    if (url) {\n      url = new URL(url).href;\n\n      if (this._lastBrowserUrl === url && this._lastHistoryState === state) {\n        return this;\n      }\n\n      this._lastBrowserUrl = url;\n      this._lastHistoryState = state;\n      history.pushState(state, \"\", url);\n      this.cacheState();\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns the current URL with any empty hash (`#`) removed.\n   * @return {string}\n   */\n  getBrowserUrl() {\n    return trimEmptyHash(window.location.href);\n  }\n\n  /**\n   * Returns the cached state.\n   * @returns {History['state']} The cached state.\n   */\n  state() {\n    return this._cachedState;\n  }\n\n  /**\n   * Caches the current state.\n   *\n   * @private\n   */\n  cacheState() {\n    const currentState = history.state ?? null;\n\n    if (!equals(currentState, this.lastCachedState)) {\n      this._cachedState = currentState;\n      this.lastCachedState = currentState;\n      this._lastHistoryState = currentState;\n    }\n  }\n\n  /**\n   * Fires the state or URL change event.\n   */\n  #fireStateOrUrlChange() {\n    const prevLastHistoryState = this._lastHistoryState;\n\n    this.cacheState();\n\n    if (\n      this._lastBrowserUrl === this.getBrowserUrl() &&\n      prevLastHistoryState === this._cachedState\n    ) {\n      return;\n    }\n    this._lastBrowserUrl = this.getBrowserUrl();\n    this._lastHistoryState = this._cachedState;\n    this._urlChangeListeners.forEach((listener) => {\n      listener(trimEmptyHash(window.location.href), this._cachedState);\n    });\n  }\n\n  /**\n   * Registers a callback to be called when the URL changes.\n   *\n   * @param {import(\"./interface.ts\").UrlChangeListener} callback - The callback function to register.\n   * @returns void\n   */\n  #onUrlChange(callback) {\n    if (!this._urlChangeInit) {\n      window.addEventListener(\n        \"popstate\",\n        this.#fireStateOrUrlChange.bind(this),\n      );\n      window.addEventListener(\n        \"hashchange\",\n        this.#fireStateOrUrlChange.bind(this),\n      );\n      this._urlChangeInit = true;\n    }\n    this._urlChangeListeners.push(callback);\n  }\n\n  $get = [\n    $t._rootScope,\n    $t._rootElement,\n    $t._exceptionHandler,\n    /**\n     *\n     * @param {ng.Scope} $rootScope\n     * @param {HTMLElement} $rootElement\n     * @param {ng.ExceptionHandlerService} $exceptionHandler\n     * @returns {Location}\n     */\n    ($rootScope, $rootElement, $exceptionHandler) => {\n      const baseHref = getBaseHref(); // if base[href] is undefined, it defaults to ''\n\n      const initialUrl = trimEmptyHash(window.location.href);\n\n      let appBase;\n\n      if (this.html5ModeConf.enabled) {\n        if (!baseHref && this.html5ModeConf.requireBase) {\n          throw $locationMinErr(\n            \"nobase\",\n            \"$location in HTML5 mode requires a <base> tag to be present!\",\n          );\n        }\n        appBase = serverBase(initialUrl) + (baseHref || \"/\");\n      } else {\n        appBase = stripHash(initialUrl);\n      }\n      const appBaseNoFile = stripFile(appBase);\n\n      const $location = new Location(\n        appBase,\n        appBaseNoFile,\n        this.html5ModeConf.enabled,\n        `#${this.hashPrefixConf}`,\n      );\n\n      $location.parseLinkUrl(initialUrl, initialUrl);\n\n      $location._state = this.state();\n\n      const IGNORE_URI_REGEXP = /^\\s*(javascript|mailto):/i;\n\n      const setBrowserUrlWithFallback = (\n        /** @type {string | undefined} */ url,\n        /** @type {any} */ state,\n      ) => {\n        const oldUrl = $location.getUrl();\n\n        const oldState = $location._state;\n\n        try {\n          this.setUrl(url, state);\n\n          // Make sure $location.getState() returns referentially identical (not just deeply equal)\n          // state object; this makes possible quick checking if the state changed in the digest\n          // loop. Checking deep equality would be too expensive.\n          $location._state = this.state();\n        } catch (err) {\n          // Restore old values if pushState fails\n          $location.setUrl(/** @type {string} */ (oldUrl));\n          $location._state = oldState;\n          $exceptionHandler(err);\n        }\n      };\n\n      $rootElement.addEventListener(\n        \"click\",\n        /** @param {MouseEvent} event */\n        (event) => {\n          const { rewriteLinks } = this.html5ModeConf;\n          // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)\n          // currently we open nice url link and redirect then\n\n          if (\n            !rewriteLinks ||\n            event.ctrlKey ||\n            event.metaKey ||\n            event.shiftKey ||\n            event.button === 2\n          ) {\n            return;\n          }\n          let elm = /** @type {HTMLElement} */ (event.target);\n\n          // traverse the DOM up to find first A tag\n          while (elm.nodeName.toLowerCase() !== \"a\") {\n            // ignore rewriting if no A tag (reached root element, or no parent - removed from document)\n\n            if (\n              elm === $rootElement ||\n              !(elm = /** @type {HTMLElement} */ (elm.parentElement))\n            )\n              return;\n          }\n\n          if (\n            isString(rewriteLinks) &&\n            isUndefined(elm.getAttribute(/** @type {string} */ (rewriteLinks)))\n          ) {\n            return;\n          }\n\n          let absHref = /** @type {HTMLAnchorElement} */ (elm).href;\n\n          const relHref = elm.getAttribute(\"href\");\n\n          if (\n            isObject(absHref) &&\n            /** @type {Object} */ (absHref).toString() ===\n              \"[object SVGAnimatedString]\"\n          ) {\n            // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during\n            // an animation.\n\n            const scvAnimatedString = /** @type {unknown} */ (absHref);\n\n            absHref = new URL(\n              /** @type {SVGAnimatedString } */ (scvAnimatedString).animVal,\n            ).href;\n          }\n\n          // Ignore when url is started with javascript: or mailto:\n          if (IGNORE_URI_REGEXP.test(absHref)) return;\n\n          if (\n            absHref &&\n            !elm.getAttribute(\"target\") &&\n            !event.defaultPrevented\n          ) {\n            if (\n              $location.parseLinkUrl(absHref, /** @type {string} */ (relHref))\n            ) {\n              // We do a preventDefault for all urls that are part of the AngularTS application,\n              // in html5mode and also without, so that we are able to abort navigation without\n              // getting double entries in the location history.\n              event.preventDefault();\n            }\n          }\n        },\n      );\n\n      // rewrite hashbang url <> html5 url\n      if ($location.absUrl !== initialUrl) {\n        this.setUrl($location.absUrl, true);\n      }\n\n      let initializing = true;\n\n      // update $location when $browser url changes\n      this.#onUrlChange((newUrl, newState) => {\n        if (!startsWith(newUrl, appBaseNoFile)) {\n          // If we are navigating outside of the app then force a reload\n          window.location.href = newUrl;\n\n          return;\n        }\n\n        queueMicrotask(() => {\n          const oldUrl = $location.absUrl;\n\n          const oldState = $location._state;\n\n          $location.parse(newUrl);\n          $location._state = newState;\n\n          const { defaultPrevented } = $rootScope.$broadcast(\n            \"$locationChangeStart\",\n            newUrl,\n            oldUrl,\n            newState,\n            oldState,\n          );\n\n          // if the location was changed by a `$locationChangeStart` handler then stop\n          // processing this location change\n          if ($location.absUrl !== newUrl) return;\n\n          if (defaultPrevented) {\n            $location.parse(oldUrl);\n            $location._state = oldState;\n            setBrowserUrlWithFallback(oldUrl, oldState);\n          } else {\n            initializing = false;\n            afterLocationChange(oldUrl, oldState);\n          }\n        });\n      });\n\n      // update browser\n      const updateBrowser = () => {\n        if (initializing || urlUpdatedByLocation) {\n          urlUpdatedByLocation = false;\n\n          const oldUrl = /** @type {string} */ (this.getBrowserUrl());\n\n          let newUrl = $location.absUrl;\n\n          const oldState = this.state();\n\n          const urlOrStateChanged =\n            !urlsEqual(oldUrl, newUrl) ||\n            ($location.html5 && oldState !== $location._state);\n\n          if (initializing || urlOrStateChanged) {\n            initializing = false;\n\n            setTimeout(() => {\n              newUrl = $location.absUrl;\n\n              const { defaultPrevented } = $rootScope.$broadcast(\n                \"$locationChangeStart\",\n                $location.absUrl,\n                oldUrl,\n                $location._state,\n                oldState,\n              );\n\n              // if the location was changed by a `$locationChangeStart` handler then stop\n              // processing this location change\n              if ($location.absUrl !== newUrl) return;\n\n              if (defaultPrevented) {\n                $location.parse(oldUrl);\n                $location._state = oldState;\n              } else {\n                if (urlOrStateChanged) {\n                  setBrowserUrlWithFallback(\n                    newUrl,\n                    oldState === $location._state ? null : $location._state,\n                  );\n                }\n                afterLocationChange(oldUrl, oldState);\n              }\n            });\n          }\n        }\n      };\n\n      $location._updateBrowser = updateBrowser;\n      updateBrowser();\n      $rootScope.$on(\"$updateBrowser\", updateBrowser);\n\n      return $location;\n\n      /**\n       * @param {string} oldUrl\n       * @param {any} oldState\n       */\n      function afterLocationChange(oldUrl, oldState) {\n        $rootScope.$broadcast(\n          \"$locationChangeSuccess\",\n          $location.absUrl,\n          oldUrl,\n          $location._state,\n          oldState,\n        );\n      }\n    },\n  ];\n}\n\n/**\n * ///////////////////////////\n *     PRIVATE HELPERS\n * ///////////////////////////\n */\n\n/**\n * @ignore\n * Encodes a URL path by encoding each path segment individually using `encodeUriSegment`,\n * while preserving forward slashes (`/`) as segment separators.\n *\n * This function first decodes any existing percent-encodings (such as `%20` or `%2F`)\n * in each segment to prevent double encoding, except for encoded forward slashes (`%2F`),\n * which are replaced with literal slashes before decoding to keep path boundaries intact.\n *\n * After decoding, each segment is re-encoded with `encodeUriSegment` according to RFC 3986,\n * encoding only characters that must be encoded in a path segment.\n *\n * The encoded segments are then rejoined with `/` to form the encoded path.\n *\n * @param {string} path - The URL path string to encode. May contain multiple segments separated by `/`.\n * @returns {string} The encoded path, where each segment is encoded, but forward slashes are preserved.\n *\n * @example\n * encodePath(\"user profile/images/pic 1.jpg\")\n * // returns \"user%20profile/images/pic%201.jpg\"\n *\n * @example\n * encodePath(\"folder1%2Fsub/folder2\")\n * // returns \"folder1%2Fsub/folder2\"\n */\nexport function encodePath(path) {\n  const segments = path.split(\"/\");\n\n  let i = segments.length;\n\n  while (i--) {\n    // Decode any existing encodings (e.g. %20, %2F) to prevent double-encoding\n    // But keep slashes intact (they were split on)\n    const decodedSegment = decodeURIComponent(\n      segments[i].replace(/%2F/gi, \"/\"),\n    );\n\n    segments[i] = encodeUriSegment(decodedSegment);\n  }\n\n  return segments.join(\"/\");\n}\n\n/**\n * @ignore\n * Decodes each segment of a URL path.\n *\n * Splits the input path by \"/\", decodes each segment using decodeURIComponent,\n * and if html5Mode is enabled, re-encodes any forward slashes inside segments\n * as \"%2F\" to avoid confusion with path separators.\n *\n * @param {string} path - The URL path to decode.\n * @param {boolean} html5Mode - If true, encodes forward slashes in segments as \"%2F\".\n * @returns {string} The decoded path with segments optionally encoding slashes.\n */\nexport function decodePath(path, html5Mode) {\n  const segments = path.split(\"/\");\n\n  let i = segments.length;\n\n  while (i--) {\n    segments[i] = decodeURIComponent(segments[i]);\n\n    if (html5Mode) {\n      // encode forward slashes to prevent them from being mistaken for path separators\n      segments[i] = segments[i].replace(/\\//g, \"%2F\");\n    }\n  }\n\n  return segments.join(\"/\");\n}\n\n/**\n * @ignore\n * Normalizes a URL path by encoding the path segments, query parameters, and hash fragment.\n *\n * - Path segments are encoded using `encodePath`, which encodes each segment individually.\n * - Query parameters (`searchValue`) are converted to a query string using `toKeyValue`.\n * - Hash fragment (`hashValue`) is encoded using `encodeUriSegment` and prefixed with `#`.\n *\n * This function returns a fully constructed URL path with optional query and hash components.\n *\n * @param {string} pathValue - The base URL path (e.g., \"folder/item name\").\n * @param {Object.<string, any> | string | null} searchValue - An object or string representing query parameters.\n *   - If an object, it can contain strings, numbers, booleans, or arrays of values.\n *   - If a string, it is assumed to be a raw query string.\n *   - If null or undefined, no query string is added.\n * @param {string | null} hashValue - The URL fragment (everything after `#`). If null or undefined, no hash is added.\n *\n * @returns {string} The normalized URL path including encoded path, optional query string, and optional hash.\n *\n * @example\n * normalizePath(\"products/list\", { category: \"books\", page: 2 }, \"section1\")\n * // returns \"products/list?category=books&page=2#section1\"\n *\n * @example\n * normalizePath(\"user profile/images\", null, null)\n * // returns \"user%20profile/images\"\n */\nexport function normalizePath(pathValue, searchValue, hashValue) {\n  const search = toKeyValue(searchValue);\n\n  const hash = hashValue ? `#${encodeUriSegment(hashValue)}` : \"\";\n\n  const path = encodePath(pathValue);\n\n  return path + (search ? `?${search}` : \"\") + hash;\n}\n\n/**\n * @ignore\n * Parses the application URL and updates the location object with path, search, and hash.\n *\n * @param {string} url - The URL string to parse.\n * @param {boolean} html5Mode - Whether HTML5 mode is enabled (affects decoding).\n * @throws Will throw an error if the URL starts with invalid slashes.\n */\nexport function parseAppUrl(url, html5Mode) {\n  if (/^\\s*[\\\\/]{2,}/.test(url)) {\n    throw $locationMinErr(\"badpath\", 'Invalid url \"{0}\".', url);\n  }\n\n  const prefixed = url.charAt(0) !== \"/\";\n\n  if (prefixed) {\n    url = `/${url}`;\n  }\n  const match = urlResolve(url);\n\n  const path =\n    prefixed && match.pathname.charAt(0) === \"/\"\n      ? match.pathname.substring(1)\n      : match.pathname;\n\n  _path = decodePath(path, html5Mode);\n  _search = parseKeyValue(match.search);\n  _hash = decodeURIComponent(match.hash);\n\n  // make sure path starts with '/';\n  if (_path && _path.charAt(0) !== \"/\") {\n    _path = `/${_path}`;\n  }\n}\n\n/**\n * @ignore\n * Returns the substring of `url` after the `base` string if `url` starts with `base`.\n * Returns `undefined` if `url` does not start with `base`.\n * @param {string} base\n * @param {string} url\n * @returns {string|undefined} returns text from `url` after `base` or `undefined` if it does not begin with\n *                   the expected string.\n */\nexport function stripBaseUrl(base, url) {\n  if (startsWith(url, base)) {\n    return url.substring(base.length);\n  }\n\n  return undefined;\n}\n\n/**\n * @ignore\n * Removes the hash fragment (including the '#') from the given URL string.\n *\n * @param {string} url - The URL string to process.\n * @returns {string} The URL without the hash fragment.\n */\nexport function stripHash(url) {\n  const index = url.indexOf(\"#\");\n\n  return index === -1 ? url : url.substring(0, index);\n}\n\n/**\n * @ignore\n * Removes the file name (and any hash) from a URL, returning the base directory path.\n *\n * For example:\n * - Input: \"https://example.com/path/to/file.js\"\n *   Output: \"https://example.com/path/to/\"\n *\n * - Input: \"https://example.com/path/to/file.js#section\"\n *   Output: \"https://example.com/path/to/\"\n *\n * @param {string} url - The URL from which to strip the file name and hash.\n * @returns {string} The base path of the URL, ending with a slash.\n */\nexport function stripFile(url) {\n  return url.substring(0, stripHash(url).lastIndexOf(\"/\") + 1);\n}\n\n/**\n * @ignore\n * Extracts the base server URL (scheme, host, and optional port) from a full URL.\n *\n * If no path is present, returns the full URL.\n *\n * For example:\n * - Input: \"https://example.com/path/to/file\"\n *   Output: \"https://example.com\"\n *\n * - Input: \"http://localhost:3000/api/data\"\n *   Output: \"http://localhost:3000\"\n *\n * @param {string} url - The full URL to extract the server base from.\n * @returns {string} The server base, including scheme and host (and port if present).\n */\nexport function serverBase(url) {\n  const start = url.indexOf(\"//\") + 2;\n\n  const slashIndex = url.indexOf(\"/\", start);\n\n  return slashIndex === -1 ? url : url.substring(0, slashIndex);\n}\n\n/**\n * @ignore\n * Determine if two URLs are equal despite potential differences in encoding,\n * trailing slashes, or empty hash fragments, such as between $location.absUrl() and $browser.url().\n *\n * @param {string} x - First URL to compare.\n * @param {string} y - Second URL to compare.\n * @returns {boolean} True if URLs are equivalent after normalization.\n */\nexport function urlsEqual(x, y) {\n  return normalizeUrl(x) === normalizeUrl(y);\n}\n\n/**\n * @ignore\n * Normalize a URL by resolving it via a DOM anchor element,\n * removing trailing slashes (except root), and trimming empty hashes.\n *\n * @param {string} url - URL to normalize.\n * @returns {string} Normalized URL string.\n */\nfunction normalizeUrl(url) {\n  const anchor = document.createElement(\"a\");\n\n  anchor.href = url;\n\n  let normalized = anchor.href;\n\n  // Remove trailing slash unless it's root (e.g., https://example.com/)\n  if (normalized.endsWith(\"/\") && !/^https?:\\/\\/[^/]+\\/$/.test(normalized)) {\n    normalized = normalized.slice(0, -1);\n  }\n\n  // Remove empty hash (e.g., https://example.com/foo# -> https://example.com/foo)\n  if (normalized.endsWith(\"#\")) {\n    normalized = normalized.slice(0, -1);\n  }\n\n  return normalized;\n}\n","import { isError } from \"../../shared/utils.js\";\n\n/**\n * Configuration provider for `$log` service\n */\nexport class LogProvider {\n  /** @private */\n  constructor() {\n    /** @type {boolean} */\n    this.debug = false;\n    /** @private @type {import(\"./interface.ts\").LogServiceFactory | null} */\n    this._override = null;\n  }\n\n  /**\n   * Override the default {@link LogService} implemenation\n   * @param {import(\"./interface.ts\").LogServiceFactory} fn\n   */\n  setLogger(fn) {\n    this._override = fn;\n  }\n\n  /**\n   * @private\n   * @param {unknown} arg\n   *\n   */\n  _formatError(arg) {\n    if (isError(arg)) {\n      if (arg.stack) {\n        arg =\n          arg.message && arg.stack.indexOf(arg.message) === -1\n            ? `Error: ${arg.message}\\n${arg.stack}`\n            : arg.stack;\n      }\n    }\n\n    return arg;\n  }\n\n  /**\n   * @private\n   * @param {string} type\n   */\n  _consoleLog(type) {\n    const console =\n      window.console || /** @type {Partial<Record<string, Function>>} */ ({});\n\n    const logFn =\n      console[type] ||\n      console.log ||\n      (() => {\n        /* empty */\n      });\n\n    return (/** @type {any[]} */ ...args) => {\n      const formattedArgs = args.map((arg) => this._formatError(arg));\n\n      return logFn.apply(console, formattedArgs);\n    };\n  }\n\n  /**\n   * @returns {ng.LogService}\n   */\n  $get() {\n    if (this._override) {\n      return this._override();\n    }\n\n    return {\n      log: this._consoleLog(\"log\"),\n      info: this._consoleLog(\"info\"),\n      warn: this._consoleLog(\"warn\"),\n      error: this._consoleLog(\"error\"),\n      debug: (() => {\n        const fn = this._consoleLog(\"debug\");\n\n        return (...args) => {\n          if (this.debug) {\n            fn.apply(this, args);\n          }\n        };\n      })(),\n    };\n  }\n}\n","/* eslint-disable id-length */\n/* eslint-disable no-magic-numbers */\nimport { isDefined, minErr } from \"../../../shared/utils.js\";\n\n/**\n * @typedef {import(\"./token.ts\").Token} Token\n */\n\nconst $parseMinErr = minErr(\"$parse\");\n\n/** @type {Record<string, any>} */\nconst ESCAPE = {\n  n: \"\\n\",\n  f: \"\\f\",\n  r: \"\\r\",\n  t: \"\\t\",\n  v: \"\\v\",\n  \"'\": \"'\",\n  '\"': '\"',\n};\n\nconst OPERATORS = new Set(\n  \"+ - * / % === !== == != < > <= >= && || ! = |\".split(\" \"),\n);\n\n/**\n * Represents a lexer that tokenizes input text. The Lexer takes the original expression string and returns an array of tokens parsed from that string.\n * For example, the string \"a + b\" would result in tokens for a, +, and b.\n */\nexport class Lexer {\n  /**\n   * Creates an instance of Lexer.\n   */\n  constructor() {\n    this._text = \"\";\n    this._index = 0;\n  }\n\n  /**\n   * Tokenizes the input text.\n   * @param {string} text Input text to lex.\n   * @returns {Array<Token>} Array of tokens.\n   */\n  _lex(text) {\n    this._text = text;\n    this._index = 0;\n    /** @type {Array<Token>} */\n    this._tokens = [];\n\n    while (this._index < this._text.length) {\n      const ch = this._text.charAt(this._index);\n\n      if (ch === '\"' || ch === \"'\") {\n        this._readString(ch);\n      } else if (\n        this._isNumber(ch) ||\n        (ch === \".\" && this._isNumber(/** @type {string} */ (this._peek())))\n      ) {\n        this._readNumber();\n      } else if (this._isIdentifierStart(this._peekMultichar())) {\n        this._readIdent();\n      } else if (this._is(ch, \"(){}[].,;:?\")) {\n        this._tokens.push({ index: this._index, text: ch });\n        this._index++;\n      } else if (this._isWhitespace(ch)) {\n        this._index++;\n      } else {\n        const ch2 = ch + this._peek();\n\n        const ch3 = ch2 + this._peek(2);\n\n        const op1 = OPERATORS.has(ch);\n\n        const op2 = OPERATORS.has(ch2);\n\n        const op3 = OPERATORS.has(ch3);\n\n        if (op1 || op2 || op3) {\n          const token = op3 ? ch3 : op2 ? ch2 : ch;\n\n          this._tokens.push({\n            index: this._index,\n            text: token,\n            operator: true,\n          });\n          this._index += token.length;\n        } else {\n          this._throwError(\n            \"Unexpected next character \",\n            this._index,\n            this._index + 1,\n          );\n        }\n      }\n    }\n\n    return this._tokens;\n  }\n\n  /**\n   * Checks if a character is contained in a set of characters.\n   * @param {string} ch Character to check.\n   * @param {string} chars Set of characters.\n   * @returns {boolean} True if character is in the set, false otherwise.\n   */\n  _is(ch, chars) {\n    return chars.indexOf(ch) !== -1;\n  }\n\n  /**\n   * Peeks at the next character in the text.\n   * @param {number} [i=1] Number of characters to peek.\n   * @returns {string|false} Next character or false if end of text.\n   */\n  _peek(i) {\n    const num = i || 1;\n\n    return this._index + num < this._text.length\n      ? this._text.charAt(this._index + num)\n      : false;\n  }\n\n  /**\n   * Checks if a character is a number.\n   * @param {string} ch Character to check.\n   * @returns {boolean} True if character is a number, false otherwise.\n   */\n  _isNumber(ch) {\n    return ch >= \"0\" && ch <= \"9\" && typeof ch === \"string\";\n  }\n\n  /**\n   * Checks if a character is whitespace.\n   * @param {string} ch Character to check.\n   * @returns {boolean} True if character is whitespace, false otherwise.\n   */\n  _isWhitespace(ch) {\n    return (\n      ch === \" \" || ch === \"\\r\" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\v\"\n    );\n  }\n\n  /**\n   * Checks if a character is a valid identifier start.\n   * @param {string} ch Character to check.\n   * @returns {boolean} True if character is a valid identifier start, false otherwise.\n   */\n  _isIdentifierStart(ch) {\n    return (\n      (ch >= \"a\" && ch <= \"z\") ||\n      (ch >= \"A\" && ch <= \"Z\") ||\n      ch === \"_\" ||\n      ch === \"$\"\n    );\n  }\n\n  /**\n   * Checks if a character is a valid identifier continuation.\n   * @param {string} ch Character to check.\n   * @returns {boolean} True if character is a valid identifier continuation, false otherwise.\n   */\n  _isIdentifierContinue(ch) {\n    return (\n      (ch >= \"a\" && ch <= \"z\") ||\n      (ch >= \"A\" && ch <= \"Z\") ||\n      ch === \"_\" ||\n      ch === \"$\" ||\n      (ch >= \"0\" && ch <= \"9\")\n    );\n  }\n\n  /**\n   * Peeks at the next multicharacter sequence in the text.\n   * @returns {string} Next multicharacter sequence.\n   */\n  _peekMultichar() {\n    const ch = this._text.charAt(this._index);\n\n    const peek = this._peek();\n\n    if (!peek) {\n      return ch;\n    }\n    const cp1 = ch.charCodeAt(0);\n\n    const cp2 = peek.charCodeAt(0);\n\n    if (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {\n      return ch + peek;\n    }\n\n    return ch;\n  }\n\n  /**\n   * Checks if a character is an exponent operator.\n   * @param {string} ch Character to check.\n   * @returns {boolean} True if character is an exponent operator, false otherwise.\n   */\n  _isExpOperator(ch) {\n    return ch === \"-\" || ch === \"+\" || this._isNumber(ch);\n  }\n\n  /**\n   * Throws a lexer error.\n   * @param {string} error Error message.\n   * @param {number} [start] Start index.\n   * @param {number} [end] End index.\n   * @throws {Error} Lexer error.\n   */\n  _throwError(error, start, end) {\n    end = end || this._index;\n    const colStr = isDefined(start)\n      ? `s ${start}-${this._index} [${this._text.substring(start, end)}]`\n      : ` ${end}`;\n\n    throw $parseMinErr(\n      \"lexerr\",\n      `Lexer Error: ${error} at column${colStr} in expression [${this._text}].`,\n    );\n  }\n\n  /**\n   * Reads and tokenizes a number from the text.\n   * @return {void}\n   */\n  _readNumber() {\n    let number = \"\";\n\n    const start = this._index;\n\n    while (this._index < this._text.length) {\n      const ch = this._text.charAt(this._index).toLowerCase();\n\n      if (ch === \".\" || this._isNumber(ch)) {\n        number += ch;\n      } else {\n        const peekCh = this._peek();\n\n        if (ch === \"e\" && this._isExpOperator(/** @type {string} */ (peekCh))) {\n          number += ch;\n        } else if (\n          this._isExpOperator(ch) &&\n          peekCh &&\n          this._isNumber(peekCh) &&\n          number.charAt(number.length - 1) === \"e\"\n        ) {\n          number += ch;\n        } else if (\n          this._isExpOperator(ch) &&\n          (!peekCh || !this._isNumber(peekCh)) &&\n          number.charAt(number.length - 1) === \"e\"\n        ) {\n          this._throwError(\"Invalid exponent\");\n        } else {\n          break;\n        }\n      }\n      this._index++;\n    }\n    /** @type {Array<Token>} */ (this._tokens).push({\n      index: start,\n      text: number,\n      constant: true,\n      value: Number(number),\n    });\n  }\n\n  /**\n   * Reads and tokenizes an identifier from the text.\n   */\n  _readIdent() {\n    const start = this._index;\n\n    this._index += this._peekMultichar().length;\n\n    while (this._index < this._text.length) {\n      const ch = this._peekMultichar();\n\n      if (!this._isIdentifierContinue(ch)) {\n        break;\n      }\n      this._index += ch.length;\n    }\n    /** @type {Array<Token>} */ (this._tokens).push({\n      index: start,\n      text: this._text.slice(start, this._index),\n      identifier: true,\n    });\n  }\n\n  /**\n   * Reads and tokenizes a string from the text.\n   * @param {string} quote Quote character used for the string.\n   */\n  _readString(quote) {\n    const start = this._index;\n\n    let string = \"\";\n\n    let escape = false;\n\n    this._index++; // Skip opening quote\n\n    while (this._index < this._text.length) {\n      const ch = this._text[this._index];\n\n      if (escape) {\n        if (ch === \"u\") {\n          // Handle unicode escapes\n          // Simplified for brevity\n          string += this._handleUnicodeEscape();\n        } else {\n          string += ESCAPE[ch] || ch;\n        }\n        escape = false;\n      } else if (ch === \"\\\\\") {\n        escape = true;\n      } else if (ch === quote) {\n        /** @type {Array<Token>} */ (this._tokens).push({\n          index: start,\n          text: this._text.slice(start, this._index + 1),\n          constant: true,\n          value: string,\n        });\n        this._index++; // Skip closing quote\n\n        return;\n      } else {\n        string += ch;\n      }\n\n      this._index++;\n    }\n\n    this._throwError(\"Unterminated quote\", start);\n  }\n\n  /**\n   * @returns {string}\n   */\n  _handleUnicodeEscape() {\n    const hex = this._text.substring(this._index + 1, this._index + 5);\n\n    if (!hex.match(/[\\da-f]{4}/i)) {\n      this._throwError(`Invalid unicode escape [\\\\u${hex}]`);\n    }\n    this._index += 4; // Move index past the four hexadecimal digits\n\n    return String.fromCharCode(parseInt(hex, 16));\n  }\n}\n","/**\n * @readonly\n * @enum {number}\n */\nexport const ASTType = {\n  _Program: 1,\n  _ExpressionStatement: 2,\n  _AssignmentExpression: 3,\n  _ConditionalExpression: 4,\n  _LogicalExpression: 5,\n  _BinaryExpression: 6,\n  _UnaryExpression: 7,\n  _CallExpression: 8,\n  _MemberExpression: 9,\n  _Identifier: 10,\n  _Literal: 11,\n  _ArrayExpression: 12,\n  _Property: 13,\n  _ObjectExpression: 14,\n  _ThisExpression: 15,\n  _LocalsExpression: 16,\n  _NGValueParameter: 17,\n};\n","import {\n  deProxy,\n  entries,\n  isDefined,\n  isFunction,\n  isNullOrUndefined,\n  isObject,\n  isProxy,\n} from \"../../shared/utils.js\";\nimport { ASTType } from \"./ast-type.js\";\n\n/** @typedef {import(\"./ast/ast-node.ts\").ASTNode} ASTNode */\n/** @typedef {import(\"./ast/ast-node.ts\").BodyNode} BodyNode */\n/** @typedef {import(\"./ast/ast-node.ts\").ExpressionNode} ExpressionNode */\n/** @typedef {import(\"./ast/ast-node.ts\").ArrayNode} ArrayNode */\n/** @typedef {import(\"./ast/ast-node.ts\").LiteralNode} LiteralNode */\n/** @typedef {import(\"./ast/ast-node.ts\").ObjectNode} ObjectNode */\n/** @typedef {import(\"./ast/ast-node.ts\").ObjectPropertyNode} ObjectPropertyNode */\n/** @typedef {import(\"./interface.ts\").CompiledExpression} CompiledExpression */\n/** @typedef {import(\"./interface.ts\").CompiledExpressionFunction} CompiledExpressionFunction */\n\nexport const PURITY_ABSOLUTE = 1;\nexport const PURITY_RELATIVE = 2;\n\nexport class ASTInterpreter {\n  /**\n   * @param {ng.FilterService} $filter\n   */\n  constructor($filter) {\n    /** @type {ng.FilterService} */\n    this._$filter = $filter;\n  }\n\n  /**\n   * Compiles the AST into a function.\n   * @param {ASTNode} ast - The AST to compile.\n   * @returns {CompiledExpression}\n   */\n  compile(ast) {\n    const decoratedNode = findConstantAndWatchExpressions(ast, this._$filter);\n\n    const { body } = /** @type {BodyNode} */ (decoratedNode);\n\n    const assignable = assignableAST(/** @type {BodyNode} */ (decoratedNode));\n\n    /** @type {CompiledExpression | undefined } */\n    let assign;\n\n    if (assignable) {\n      assign = /** @type {CompiledExpression} */ (this.#recurse(assignable));\n    }\n\n    const toWatch = getInputs(body);\n\n    let inputs;\n\n    if (toWatch) {\n      inputs = [];\n\n      for (const [key, watch] of entries(toWatch)) {\n        const input = /** @type {CompiledExpression} */ (this.#recurse(watch));\n\n        watch.input = input;\n        inputs.push(input);\n        watch.watchId = key;\n      }\n    }\n    /**\n     * @type {CompiledExpressionFunction[]}\n     */\n    const expressions = [];\n\n    body.forEach(\n      /** @param {ExpressionNode} expression */ (expression) => {\n        expressions.push(\n          this.#recurse(/** @type {ExpressionNode} */ (expression.expression)),\n        );\n      },\n    );\n\n    const fnRaw =\n      body.length === 0\n        ? () => {\n            /* empty */\n          }\n        : body.length === 1\n          ? /** @type {CompiledExpression} */ (expressions[0])\n          : /** @type {CompiledExpressionFunction} */ (\n              function (scope, locals) {\n                let lastValue;\n\n                for (let i = 0; i < expressions.length; i++) {\n                  lastValue = expressions[i](scope, locals);\n                }\n\n                return lastValue;\n              }\n            );\n\n    const fn = /** @type {CompiledExpression} */ (fnRaw);\n\n    if (assign) {\n      fn._assign = /** @type {CompiledExpressionFunction}  */ (\n        (scope, value, locals) => assign(scope, locals, value)\n      );\n    }\n\n    if (inputs) {\n      fn._inputs = inputs;\n    }\n\n    fn._decoratedNode = /** @type {BodyNode} */ (decoratedNode);\n\n    return fn;\n  }\n\n  /**\n   * Recurses the AST nodes.\n   * @param {ExpressionNode & LiteralNode} ast - The AST node.\n   * @param {Object} [context] - The context.\n   * @param {boolean|1} [create] - The create flag.\n   * @returns {CompiledExpressionFunction} The recursive function.\n   */\n  #recurse(ast, context, create) {\n    /**\n     * @type {Function}\n     */\n    let left;\n\n    /**\n     * @type {string | Function | undefined}\n     */\n    let right;\n\n    /** @type {ASTInterpreter & Record<string, any>} */\n    const self = this;\n\n    /**\n     * @type {any[]}\n     */\n    let args;\n\n    switch (ast.type) {\n      case ASTType._Literal:\n        return this.value(ast.value, context);\n      case ASTType._UnaryExpression:\n        right = this.#recurse(/** @type {ExpressionNode} */ (ast.argument));\n\n        return self[`unary${ast.operator}`](right, context);\n      case ASTType._BinaryExpression:\n        left = this.#recurse(/** @type {ASTNode} */ (ast.left));\n        right = this.#recurse(/** @type {ASTNode} */ (ast.right));\n\n        return self[`binary${ast.operator}`](left, right, context);\n      case ASTType._LogicalExpression:\n        left = this.#recurse(/** @type {ASTNode} */ (ast.left));\n        right = this.#recurse(/** @type {ASTNode} */ (ast.right));\n\n        return self[`binary${ast.operator}`](left, right, context);\n      case ASTType._ConditionalExpression:\n        return /** @type {import(\"./interface.ts\").CompiledExpressionFunction} */ (\n          this[\"ternary?:\"](\n            this.#recurse(/** @type {ASTNode} */ (ast.test)),\n            this.#recurse(/** @type {ASTNode} */ (ast.alternate)),\n            this.#recurse(/** @type {ASTNode} */ (ast.consequent)),\n            context,\n          )\n        );\n      case ASTType._Identifier:\n        return self.identifier(\n          /** @type {string} */ (ast.name),\n          context,\n          create,\n        );\n      case ASTType._MemberExpression:\n        left = this.#recurse(\n          /** @type {ASTNode} */ (ast.object),\n          false,\n          !!create,\n        );\n\n        if (!ast.computed) {\n          right = /** @type {LiteralNode} */ (ast.property).name;\n        }\n\n        if (ast.computed)\n          right = this.#recurse(/** @type {ASTNode} */ (ast.property));\n\n        return /** @type {CompiledExpressionFunction} */ (\n          ast.computed\n            ? this.#computedMember(\n                left,\n                /** @type {function } */ (right),\n                context,\n                create,\n              )\n            : this.nonComputedMember(\n                left,\n                /** @type {string } */ (right),\n                context,\n                create,\n              )\n        );\n      case ASTType._CallExpression:\n        args = [];\n        /** @type {ASTNode[]} */ (\n          /** @type {ExpressionNode} */ (ast).arguments\n        ).forEach((expr) => {\n          args.push(self.#recurse(expr));\n        });\n\n        if (/** @type {ExpressionNode} */ (ast).filter)\n          right = this._$filter(\n            /** @type {string} */ (\n              /** @type {LiteralNode} */ (\n                /** @type {ExpressionNode} */ (ast).callee\n              ).name\n            ),\n          );\n\n        if (!(/** @type {ExpressionNode} */ (ast).filter))\n          right = this.#recurse(\n            /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).callee),\n            true,\n          );\n\n        return ast.filter\n          ? (scope, locals, assign) => {\n              /**\n               * @type {any[]}\n               */\n              const values = [];\n\n              for (let i = 0; i < args.length; ++i) {\n                const res = args[i](scope && deProxy(scope), locals, assign);\n\n                values.push(res);\n              }\n              const value = () => {\n                return /** @type {Function} */ (right).apply(undefined, values);\n              };\n\n              return context\n                ? { context: undefined, name: undefined, value }\n                : value();\n            }\n          : (scope, locals, assign) => {\n              const rhs = /** @type {Function} */ (right)(\n                /** @type {ng.Scope} */ (scope).$target\n                  ? /** @type {ng.Scope} */ (scope).$target\n                  : scope,\n                locals,\n                assign,\n              );\n\n              let value;\n\n              if (!isNullOrUndefined(rhs.value) && isFunction(rhs.value)) {\n                const values = [];\n\n                for (let i = 0; i < args.length; ++i) {\n                  const res = args[i](scope, locals, assign);\n\n                  values.push(isFunction(res) ? res() : res);\n                }\n                value = rhs.value.apply(rhs.context, values);\n              }\n\n              return context ? { value } : value;\n            };\n      case ASTType._AssignmentExpression:\n        left = this.#recurse(/** @type {ASTNode} */ (ast.left), true, 1);\n        right = this.#recurse(/** @type {ASTNode} */ (ast.right));\n\n        return (scope, locals, assign) => {\n          const lhs = left(scope, locals, assign);\n\n          const rhs = /** @type {Function} */ (right)(scope, locals, assign);\n\n          // lhs.context[lhs.name] = rhs;\n          const ctx = isProxy(lhs.context)\n            ? lhs.context\n            : (lhs.context.$proxy ?? lhs.context);\n\n          ctx[lhs.name] = rhs;\n\n          return context ? { value: rhs } : rhs;\n        };\n      case ASTType._ArrayExpression:\n        args = [];\n        /** @type {ArrayNode} */ (ast).elements.forEach((expr) => {\n          args.push(self.#recurse(expr));\n        });\n\n        return (scope, locals, assign) => {\n          const value = [];\n\n          for (let i = 0; i < args.length; ++i) {\n            value.push(args[i](scope, locals, assign));\n          }\n\n          return context ? { value } : value;\n        };\n      case ASTType._ObjectExpression:\n        args = [];\n        /** @type {ObjectPropertyNode[]} */ (\n          /** @type {ObjectNode} */ (ast).properties\n        ).forEach(\n          /** @param {ObjectPropertyNode} property */ (property) => {\n            if (property.computed) {\n              args.push({\n                key: self.#recurse(property.key),\n                computed: true,\n                value: self.#recurse(property.value),\n              });\n            } else {\n              args.push({\n                key:\n                  property.key.type === ASTType._Identifier\n                    ? /** @type {LiteralNode} */ (property.key).name\n                    : `${/** @type {LiteralNode} */ (property.key).value}`,\n                computed: false,\n                value: self.#recurse(property.value),\n              });\n            }\n          },\n        );\n\n        return (scope, locals, assign) => {\n          /** @type {Record<string, any>} */\n          const value = {};\n\n          for (let i = 0; i < args.length; ++i) {\n            if (args[i].computed) {\n              value[args[i].key(scope, locals, assign)] = args[i].value(\n                scope,\n                locals,\n                assign,\n              );\n            } else {\n              value[args[i].key] = args[i].value(scope, locals, assign);\n            }\n          }\n\n          return context ? { value } : value;\n        };\n      case ASTType._ThisExpression:\n        return (scope) =>\n          context ? { value: scope } : /** @type {ng.Scope} */ (scope).$proxy;\n      case ASTType._LocalsExpression:\n        return (scope, locals) => (context ? { value: locals } : locals);\n      case ASTType._NGValueParameter:\n        return (scope, locals, assign) =>\n          context ? { value: assign } : assign;\n    }\n\n    throw new Error(`Unknown AST type ${ast.type}`);\n  }\n\n  /**\n   * Unary plus operation.\n   * @param {function} argument - The argument function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The unary plus function.\n   */\n  \"unary+\"(argument, context) {\n    return (scope, locals, assign) => {\n      let arg = argument(scope, locals, assign);\n\n      if (isDefined(arg)) {\n        arg = +arg;\n      } else {\n        arg = 0;\n      }\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Unary minus operation.\n   * @param {function} argument - The argument function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The unary minus function.\n   */\n  \"unary-\"(argument, context) {\n    return (scope, locals, assign) => {\n      let arg = argument(scope, locals, assign);\n\n      if (isDefined(arg)) {\n        arg = -arg;\n      } else {\n        arg = -0;\n      }\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Unary negation operation.\n   * @param {function} argument - The argument function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The unary negation function.\n   */\n  \"unary!\"(argument, context) {\n    return (scope, locals, assign) => {\n      const arg = !argument(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary plus operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary plus function.\n   */\n  \"binary+\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const lhs = left(scope, locals, assign);\n\n      const rhs = right(scope, locals, assign);\n\n      const arg = plusFn(lhs, rhs);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary minus operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary minus function.\n   */\n  \"binary-\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const lhs = left(scope, locals, assign);\n\n      const rhs = right(scope, locals, assign);\n\n      const arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary multiplication operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary multiplication function.\n   */\n  \"binary*\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) * right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary division operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary division function.\n   */\n  \"binary/\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) / right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary modulo operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary division function.\n   */\n  \"binary%\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) % right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary strict equality operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary strict equality function.\n   */\n  \"binary===\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) === right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary strict inequality operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary strict inequality function.\n   */\n  \"binary!==\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) !== right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary equality operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary equality function.\n   */\n  \"binary==\"(left, right, context) {\n    return (scope, locals, assign) => {\n      // eslint-disable-next-line eqeqeq\n      const arg = left(scope, locals, assign) == right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary inequality operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary inequality function.\n   */\n  \"binary!=\"(left, right, context) {\n    return (scope, locals, assign) => {\n      // eslint-disable-next-line eqeqeq\n      const arg = left(scope, locals, assign) != right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary less-than operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary less-than function.\n   */\n  \"binary<\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) < right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary greater-than operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary greater-than function.\n   */\n  \"binary>\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) > right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary less-than-or-equal-to operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary less-than-or-equal-to function.\n   */\n  \"binary<=\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) <= right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary greater-than-or-equal-to operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary greater-than-or-equal-to function.\n   */\n  \"binary>=\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) >= right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary logical AND operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary logical AND function.\n   */\n  \"binary&&\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) && right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Binary logical OR operation.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The binary logical OR function.\n   */\n  \"binary||\"(left, right, context) {\n    return (scope, locals, assign) => {\n      const arg = left(scope, locals, assign) || right(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Ternary conditional operation.\n   * @param {function} test - The test function.\n   * @param {function} alternate - The alternate function.\n   * @param {function} consequent - The consequent function.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The ternary conditional function.\n   */\n  \"ternary?:\"(test, alternate, consequent, context) {\n    return (scope, locals, assign) => {\n      const arg = test(scope, locals, assign)\n        ? alternate(scope, locals, assign)\n        : consequent(scope, locals, assign);\n\n      return context ? { value: arg } : arg;\n    };\n  }\n\n  /**\n   * Returns the value of a literal.\n   * @param {*} value - The literal value.\n   * @param {Object} [context] - The context.\n   * @returns {CompiledExpressionFunction} The function returning the literal value.\n   */\n  value(value, context) {\n    return () =>\n      context ? { context: undefined, name: undefined, value } : value;\n  }\n\n  /**\n   * Returns the value of an identifier.\n   * @param {string} name - The identifier name.\n   * @param {Object} [context] - The context.\n   * @param {boolean|1} [create] - Whether to create the identifier if it does not exist.\n   *  @returns {CompiledExpressionFunction}  The function returning the identifier value.\n   */\n  identifier(name, context, create) {\n    return (scope, locals) => {\n      /** @type {ng.Scope | Record<string, any> | undefined } */\n      const base =\n        locals && name in locals\n          ? locals\n          : ((scope && /** @type {ng.Scope} */ (scope).$proxy) ?? scope);\n\n      if (create && create !== 1 && base && isNullOrUndefined(base[name])) {\n        base[name] = {};\n      }\n      let value = undefined;\n\n      if (base) {\n        value = /** @type {Record<string, any>} */ (deProxy(base))[name];\n      }\n\n      if (context) {\n        return { context: base, name, value };\n      }\n\n      return value;\n    };\n  }\n\n  /**\n   * Returns the value of a computed member expression.\n   * @param {function} left - The left operand function.\n   * @param {function} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @param {boolean|1} [create] - Whether to create the member if it does not exist.\n   * @returns {CompiledExpressionFunction}  The function returning the computed member value.\n   */\n  #computedMember(left, right, context, create) {\n    return (scope, locals, assign) => {\n      const lhs = left(scope, locals, assign);\n\n      let rhs;\n\n      let value;\n\n      if (!isNullOrUndefined(lhs)) {\n        rhs = right(scope, locals, assign);\n        rhs = getStringValue(rhs);\n\n        if (create && create !== 1) {\n          if (lhs && !lhs[rhs]) {\n            lhs[rhs] = {};\n          }\n        }\n        value = lhs[rhs];\n      }\n\n      if (context) {\n        return { context: lhs, name: rhs, value };\n      }\n\n      return value;\n    };\n  }\n\n  /**\n   * Returns the value of a non-computed member expression.\n   * @param {function} left - The left operand function.\n   * @param {string} right - The right operand function.\n   * @param {Object} [context] - The context.\n   * @param {boolean|1} [create] - Whether to create the member if it does not exist.\n   * @returns {CompiledExpressionFunction}  The function returning the non-computed member value.\n   */\n  nonComputedMember(left, right, context, create) {\n    return (scope, locals, assign) => {\n      const lhs = left(scope, locals, assign);\n\n      if (create && create !== 1) {\n        if (lhs && isNullOrUndefined(lhs[right])) {\n          lhs[right] = {};\n        }\n      }\n      const value = !isNullOrUndefined(lhs) ? lhs[right] : undefined;\n\n      if (context) {\n        return { context: lhs, name: right, value };\n      }\n\n      return value;\n    };\n  }\n}\n\n/**\n * Decorates an AST node with constant, toWatch, and isPure metadata.\n *\n * This function recursively traverses the AST and sets:\n * - `constant`  whether the node is a constant expression\n * - `toWatch`  list of expressions to observe for changes\n * - `isPure`  whether the expression is pure (Angular-specific)\n *\n * @param {ASTNode} ast - The AST node to decorate\n * @param {ng.FilterService} $filter - Angular filter service\n * @param {boolean|1|2} [parentIsPure] - Optional flag indicating purity of the parent node\n * @returns {ASTNode} The same node, now decorated\n * @throws {Error} If the AST type is unknown\n */\nfunction findConstantAndWatchExpressions(ast, $filter, parentIsPure) {\n  /**\n   * @type {boolean | undefined}\n   */\n  let allConstants;\n\n  /**\n   * @type {any[]}\n   */\n  let argsToWatch;\n\n  let isFilter;\n\n  const decoratedNode = /** @type  {BodyNode & ExpressionNode} */ (ast);\n\n  let decoratedLeft,\n    decoratedRight,\n    decoratedTest,\n    decoratedAlternate,\n    decoratedConsequent,\n    decoratedObject,\n    decoratedProperty,\n    decoratedKey;\n\n  const astIsPure = (decoratedNode.isPure = !!isPure(ast, parentIsPure));\n\n  switch (ast.type) {\n    case ASTType._Program:\n      allConstants = true;\n      /** @type {import(\"./ast/ast-node.ts\").BodyNode} */ (\n        decoratedNode\n      ).body.forEach((expr) => {\n        const decorated = findConstantAndWatchExpressions(\n          /** @type {import(\"./ast/ast-node.ts\").ExpressionStatementNode} */ (\n            expr\n          ).expression,\n          $filter,\n          astIsPure,\n        );\n\n        allConstants = allConstants && decorated.constant;\n      });\n      decoratedNode.constant = allConstants;\n\n      return decoratedNode;\n    case ASTType._Literal:\n      decoratedNode.constant = true;\n      decoratedNode.toWatch = [];\n\n      return decoratedNode;\n    case ASTType._UnaryExpression: {\n      /** @type {BodyNode} */\n      const decorated = /** @type {BodyNode} */ (\n        findConstantAndWatchExpressions(\n          /** @type {ASTNode} */ (\n            /** @type {ExpressionNode} */ (decoratedNode).argument\n          ),\n          $filter,\n          astIsPure,\n        )\n      );\n\n      decoratedNode.constant = decorated.constant;\n      decoratedNode.toWatch = decorated.toWatch || [];\n\n      return decoratedNode;\n    }\n    case ASTType._BinaryExpression:\n      decoratedLeft = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (decoratedNode.left),\n        $filter,\n        astIsPure,\n      );\n      decoratedRight = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (\n          /** @type {ExpressionNode} */ (decoratedNode).right\n        ),\n        $filter,\n        astIsPure,\n      );\n      decoratedNode.constant =\n        decoratedLeft.constant && decoratedRight.constant;\n      decoratedNode.toWatch = /** @type {ASTNode[]} */ (\n        /** @type {BodyNode} */ (decoratedLeft).toWatch.concat(\n          /** @type {BodyNode} */ (decoratedRight).toWatch,\n        )\n      );\n\n      return decoratedNode;\n    case ASTType._LogicalExpression:\n      decoratedLeft = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (decoratedNode.left),\n        $filter,\n        astIsPure,\n      );\n      decoratedRight = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (\n          /** @type {ExpressionNode} */ (decoratedNode).right\n        ),\n        $filter,\n        astIsPure,\n      );\n      decoratedNode.constant =\n        decoratedLeft.constant && decoratedRight.constant;\n      decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];\n\n      return decoratedNode;\n    case ASTType._ConditionalExpression:\n      decoratedTest = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).test),\n        $filter,\n        astIsPure,\n      );\n      decoratedAlternate = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).alternate),\n        $filter,\n        astIsPure,\n      );\n      decoratedConsequent = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).consequent),\n        $filter,\n        astIsPure,\n      );\n      decoratedNode.constant =\n        decoratedTest.constant &&\n        decoratedAlternate.constant &&\n        decoratedConsequent.constant;\n      decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];\n\n      return decoratedNode;\n    case ASTType._Identifier:\n      decoratedNode.constant = false;\n      decoratedNode.toWatch = [ast];\n\n      return decoratedNode;\n    case ASTType._MemberExpression:\n      decoratedObject = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).object),\n        $filter,\n        astIsPure,\n      );\n\n      if (/** @type {ExpressionNode} */ (ast).computed) {\n        decoratedProperty = findConstantAndWatchExpressions(\n          /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).property),\n          $filter,\n          astIsPure,\n        );\n      }\n      decoratedNode.constant =\n        decoratedObject.constant &&\n        (!decoratedNode.computed || decoratedProperty?.constant);\n      decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];\n\n      return decoratedNode;\n    case ASTType._CallExpression:\n      isFilter = /** @type {ExpressionNode} */ (ast).filter;\n      allConstants = isFilter;\n      argsToWatch = [];\n      /** @type {ASTNode[]} */ (\n        /** @type {ExpressionNode} */ (ast).arguments\n      ).forEach((expr) => {\n        const decorated = findConstantAndWatchExpressions(\n          expr,\n          $filter,\n          astIsPure,\n        );\n\n        allConstants = allConstants && decorated.constant;\n        argsToWatch.push.apply(\n          argsToWatch,\n          /** @type {BodyNode} */ (decorated).toWatch,\n        );\n      });\n      decoratedNode.constant = allConstants;\n      decoratedNode.toWatch = isFilter ? argsToWatch : [decoratedNode];\n\n      return decoratedNode;\n    case ASTType._AssignmentExpression:\n      decoratedLeft = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).left),\n        $filter,\n        astIsPure,\n      );\n      decoratedRight = findConstantAndWatchExpressions(\n        /** @type {ASTNode} */ (/** @type {ExpressionNode} */ (ast).right),\n        $filter,\n        astIsPure,\n      );\n      decoratedNode.constant =\n        decoratedLeft.constant && decoratedRight.constant;\n      decoratedNode.toWatch = [decoratedNode];\n\n      return decoratedNode;\n    case ASTType._ArrayExpression:\n      allConstants = true;\n      argsToWatch = [];\n      /** @type {ArrayNode} */ (ast).elements.forEach((expr) => {\n        const decorated = findConstantAndWatchExpressions(\n          expr,\n          $filter,\n          astIsPure,\n        );\n\n        allConstants = allConstants && decorated.constant;\n        argsToWatch.push.apply(\n          argsToWatch,\n          /** @type {BodyNode} */ (decorated).toWatch,\n        );\n      });\n      decoratedNode.constant = allConstants;\n      decoratedNode.toWatch = argsToWatch;\n\n      return decoratedNode;\n    case ASTType._ObjectExpression:\n      allConstants = true;\n      argsToWatch = [];\n      /** @type {ObjectNode} */ (ast).properties.forEach((property) => {\n        const decorated = findConstantAndWatchExpressions(\n          /** @type {LiteralNode} */ (property).value,\n          $filter,\n          astIsPure,\n        );\n\n        allConstants = allConstants && decorated.constant;\n        argsToWatch.push.apply(\n          argsToWatch,\n          /** @type {BodyNode} */ (decorated).toWatch,\n        );\n\n        if (/** @type {ExpressionNode} */ (property).computed) {\n          // `{[key]: value}` implicitly does `key.toString()` which may be non-pure\n          decoratedKey = findConstantAndWatchExpressions(\n            /** @type {ObjectPropertyNode} */ (property).key,\n            $filter,\n            false,\n          );\n          allConstants = allConstants && decoratedKey.constant;\n          argsToWatch.push.apply(\n            argsToWatch,\n            /** @type {BodyNode} */ (decorated).toWatch,\n          );\n        }\n      });\n      decoratedNode.constant = allConstants;\n      decoratedNode.toWatch = argsToWatch;\n\n      return decoratedNode;\n    case ASTType._ThisExpression:\n      decoratedNode.constant = false;\n      decoratedNode.toWatch = [];\n\n      return decoratedNode;\n    case ASTType._LocalsExpression:\n      decoratedNode.constant = false;\n      decoratedNode.toWatch = [];\n\n      return decoratedNode;\n    default:\n      throw new Error(`Unknown AST node type: ${ast.type}`);\n  }\n}\n\n/**\n * Converts a single expression AST node into an assignment expression if the expression is assignable.\n *\n * @param {import(\"./ast/ast-node.ts\").BodyNode} ast\n * @returns {import(\"./ast/ast-node.ts\").ExpressionNode | undefined}\n */\nfunction assignableAST(ast) {\n  const stmt = /** @type {import(\"./ast/ast-node.ts\").ExpressionNode} */ (\n    ast.body[0]\n  );\n\n  if (\n    ast.body.length === 1 &&\n    stmt?.expression &&\n    isAssignable(stmt.expression)\n  ) {\n    return {\n      type: ASTType._AssignmentExpression,\n      left: stmt.expression, // left-hand side is an expression\n      right: { type: ASTType._NGValueParameter }, // right-hand side leaf expression\n      operator: \"=\",\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * @param {string | number} left\n * @param {string | number} right\n */\nfunction plusFn(left, right) {\n  if (typeof left === \"undefined\" || isObject(left)) return right;\n\n  if (typeof right === \"undefined\" || isObject(right)) return left;\n\n  return /** @type {number} */ (left) + /** @type {number} */ (right);\n}\n\n/**\n *\n * @param {ASTNode[]} body\n * @returns {any}\n */\nfunction getInputs(body) {\n  if (body.length !== 1) return undefined;\n  const lastExpression = /** @type {ExpressionNode} */ (body[0]).expression;\n\n  const candidate = /** @type {BodyNode} */ (lastExpression).toWatch;\n\n  if (candidate.length !== 1) return candidate;\n\n  return candidate[0] !== lastExpression ? candidate : undefined;\n}\n\n/**\n * Detect nodes which could depend on non-shallow state of objects\n * @param {ASTNode} node\n * @param {boolean|PURITY_ABSOLUTE|PURITY_RELATIVE} [parentIsPure]\n * @returns {number|boolean}\n */\nfunction isPure(node, parentIsPure) {\n  switch (node.type) {\n    // Computed members might invoke a stateful toString()\n    case ASTType._MemberExpression:\n      if (/** @type {ExpressionNode} */ (node).computed) {\n        return false;\n      }\n      break;\n\n    // Unary always convert to primitive\n    case ASTType._UnaryExpression:\n      return PURITY_ABSOLUTE;\n\n    // The binary + operator can invoke a stateful toString().\n    case ASTType._BinaryExpression:\n      return /** @type {ExpressionNode} */ (node).operator !== \"+\"\n        ? PURITY_ABSOLUTE\n        : false;\n\n    // Functions / filters probably read state from within objects\n    case ASTType._CallExpression:\n      return false;\n  }\n\n  return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;\n}\n\n/**\n * Converts parameter to  strings property name for use  as keys in an object.\n * Any non-string object, including a number, is typecasted into a string via the toString method.\n * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names}\n *\n * @param {!any} name\n * @returns {string}\n */\nfunction getStringValue(name) {\n  return `${name}`;\n}\n\n/**\n * @param {import(\"./ast/ast\").ASTNode} ast\n * @returns {boolean}\n */\nexport function isAssignable(ast) {\n  return (\n    ast.type === ASTType._Identifier || ast.type === ASTType._MemberExpression\n  );\n}\n","import { isAssignable } from \"../interpreter.js\";\nimport { ASTType } from \"../ast-type.js\";\nimport { hasOwn, isDefined, minErr } from \"../../../shared/utils.js\";\n\n/**\n * @typedef {import(\"./ast-node.ts\").ASTNode} ASTNode\n * @typedef {import(\"../lexer/token.js\").Token} Token\n */\n\nconst $parseMinErr = minErr(\"$parse\");\n\n/** @type {Record<string, any>} */\nconst literals = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n};\n\nexport class AST {\n  /**\n   * @param {import('../lexer/lexer.js').Lexer} lexer - The lexer instance for tokenizing input\n   */\n  constructor(lexer) {\n    /** @type {import('../lexer/lexer.js').Lexer} */\n    this._lexer = lexer;\n    /** @type {Record<string, any>} */\n    this._selfReferential = {\n      this: { type: ASTType._ThisExpression },\n      $locals: { type: ASTType._LocalsExpression },\n    };\n    this._index = 0;\n  }\n\n  /**\n   * Parses the input text and generates an AST.\n   * @param {string} text - The input text to parse.\n   * @returns {ASTNode} The root node of the AST.\n   */\n  _ast(text) {\n    this._text = text;\n    this._tokens = this._lexer._lex(text);\n\n    const value = this._program();\n\n    if (this._tokens.length > this._index) {\n      this._throwError(\"is an unexpected token\", this._tokens[this._index]);\n    }\n\n    return value;\n  }\n\n  /**\n   * Parses a program.\n   * @returns {ASTNode} The program node.\n   */\n  _program() {\n    const body = [];\n\n    let hasMore = true;\n\n    while (hasMore) {\n      if (\n        this._tokens &&\n        this._tokens.length > this._index &&\n        !this._peek(\"}\", \")\", \";\", \"]\")\n      )\n        body.push(this._expressionStatement());\n\n      if (!this._expect(\";\")) {\n        hasMore = false;\n      }\n    }\n\n    return { type: ASTType._Program, body };\n  }\n\n  /**\n   * Parses an expression statement.\n   * @returns {ASTNode} The expression statement node.\n   */\n  _expressionStatement() {\n    return {\n      type: ASTType._ExpressionStatement,\n      expression: this._filterChain(),\n    };\n  }\n\n  /**\n   * Parses a filter chain.\n   * @returns {ASTNode} The filter chain node.\n   */\n  _filterChain() {\n    let left = this._assignment();\n\n    while (this._expect(\"|\")) {\n      left = this._filter(left);\n    }\n\n    return left;\n  }\n\n  /**\n   * Parses an assignment expression.\n   * @returns {ASTNode} The assignment expression node.\n   */\n  _assignment() {\n    let result = this._ternary();\n\n    if (this._expect(\"=\")) {\n      if (!isAssignable(result)) {\n        throw $parseMinErr(\"lval\", \"Trying to assign a value to a non l-value\");\n      }\n\n      result = {\n        type: ASTType._AssignmentExpression,\n        left: result,\n        right: this._assignment(),\n        operator: \"=\",\n      };\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses a ternary expression.\n   * @returns {ASTNode} The ternary expression node.\n   */\n  _ternary() {\n    const test = this._logicalOR();\n\n    if (this._expect(\"?\")) {\n      const alternate = this._assignment();\n\n      if (this._consume(\":\")) {\n        const consequent = this._assignment();\n\n        return {\n          type: ASTType._ConditionalExpression,\n          test,\n          alternate,\n          consequent,\n        };\n      }\n    }\n\n    return test;\n  }\n\n  /**\n   * Parses a logical OR expression.\n   * @returns {ASTNode} The logical OR expression node.\n   */\n  _logicalOR() {\n    let left = this._logicalAND();\n\n    while (this._expect(\"||\")) {\n      left = {\n        type: ASTType._LogicalExpression,\n        operator: \"||\",\n        left,\n        right: this._logicalAND(),\n      };\n    }\n\n    return left;\n  }\n\n  /**\n   * Parses a logical AND expression.\n   * @returns {ASTNode} The logical AND expression node.\n   */\n  _logicalAND() {\n    let left = this._equality();\n\n    while (this._expect(\"&&\")) {\n      left = {\n        type: ASTType._LogicalExpression,\n        operator: \"&&\",\n        left,\n        right: this._equality(),\n      };\n    }\n\n    return left;\n  }\n\n  /**\n   * Parses an equality expression.\n   * @returns {ASTNode} The equality expression node.\n   */\n  _equality() {\n    let left = this._relational();\n\n    let token;\n\n    while ((token = this._expect(\"==\", \"!=\", \"===\", \"!==\"))) {\n      left = {\n        type: ASTType._BinaryExpression,\n        operator: /** @type {Token} */ (token).text,\n        left,\n        right: this._relational(),\n      };\n    }\n\n    return left;\n  }\n\n  /**\n   * Parses a relational expression.\n   * @returns {ASTNode} The relational expression node.\n   */\n  _relational() {\n    let left = this._additive();\n\n    let token;\n\n    while ((token = this._expect(\"<\", \">\", \"<=\", \">=\"))) {\n      left = {\n        type: ASTType._BinaryExpression,\n        operator: /** @type {Token} */ (token).text,\n        left,\n        right: this._additive(),\n      };\n    }\n\n    return left;\n  }\n\n  /**\n   * Parses an additive expression.\n   * @returns {ASTNode} The additive expression node.\n   */\n  _additive() {\n    let left = this._multiplicative();\n\n    let token;\n\n    while ((token = this._expect(\"+\", \"-\"))) {\n      left = {\n        type: ASTType._BinaryExpression,\n        operator: /** @type {Token} */ (token).text,\n        left,\n        right: this._multiplicative(),\n      };\n    }\n\n    return left;\n  }\n\n  /**\n   * Parses a multiplicative expression.\n   * @returns {ASTNode} The multiplicative expression node.\n   */\n  _multiplicative() {\n    let left = this._unary();\n\n    let token;\n\n    while ((token = this._expect(\"*\", \"/\", \"%\"))) {\n      left = {\n        type: ASTType._BinaryExpression,\n        operator: /** @type {import(\"../lexer/lexer.js\").Token} */ (token).text,\n        left,\n        right: this._unary(),\n      };\n    }\n\n    return left;\n  }\n\n  /**\n   * Parses a unary expression.\n   * @returns {ASTNode} The unary expression node.\n   */\n  _unary() {\n    let token;\n\n    if ((token = this._expect(\"+\", \"-\", \"!\"))) {\n      return {\n        type: ASTType._UnaryExpression,\n        operator: /** @type {import(\"../lexer/lexer.js\").Token} */ (token).text,\n        prefix: true,\n        argument: this._unary(),\n      };\n    }\n\n    return this._primary();\n  }\n\n  /**\n   * Parses a primary expression.\n   * @returns {ASTNode} The primary expression node.\n   */\n  _primary() {\n    let primary;\n\n    if (this._expect(\"(\")) {\n      primary = this._filterChain();\n      this._consume(\")\");\n    } else if (this._expect(\"[\")) {\n      primary = this._arrayDeclaration();\n    } else if (this._expect(\"{\")) {\n      primary = this._object();\n    } else if (\n      hasOwn(\n        this._selfReferential,\n        /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek()).text,\n      )\n    ) {\n      primary = structuredClone(this._selfReferential[this._consume().text]);\n    } else if (\n      hasOwn(\n        literals,\n        /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek()).text,\n      )\n    ) {\n      primary = {\n        type: ASTType._Literal,\n        value: literals[this._consume().text],\n      };\n    } else if (\n      /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek()).identifier\n    ) {\n      primary = this._identifier();\n    } else if (\n      /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek()).constant\n    ) {\n      primary = this._constant();\n    } else {\n      this._throwError(\n        \"not a primary expression\",\n        /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek()),\n      );\n    }\n\n    let next;\n\n    while ((next = this._expect(\"(\", \"[\", \".\"))) {\n      if (\n        /** @type {import(\"../lexer/lexer.js\").Token} */ (next).text === \"(\"\n      ) {\n        primary = {\n          type: ASTType._CallExpression,\n          callee: primary,\n          arguments: this._parseArguments(),\n        };\n        this._consume(\")\");\n      } else if (\n        /** @type {import(\"../lexer/lexer.js\").Token} */ (next).text === \"[\"\n      ) {\n        primary = {\n          type: ASTType._MemberExpression,\n          object: primary,\n          property: this._assignment(),\n          computed: true,\n        };\n        this._consume(\"]\");\n      } else if (\n        /** @type {import(\"../lexer/lexer.js\").Token} */ (next).text === \".\"\n      ) {\n        primary = {\n          type: ASTType._MemberExpression,\n          object: primary,\n          property: this._identifier(),\n          computed: false,\n        };\n      } else {\n        throw new Error(\"IMPOSSIBLE\");\n      }\n    }\n\n    return primary;\n  }\n\n  /**\n   * Parses a filter.\n   * @param {ASTNode} baseExpression - The base expression to apply the filter to.\n   * @returns {ASTNode} The filter node.\n   */\n  _filter(baseExpression) {\n    /** @type {ASTNode[]} */\n    const args = [baseExpression];\n\n    const result = {\n      type: ASTType._CallExpression,\n      callee: this._identifier(),\n      arguments: args,\n      filter: true,\n    };\n\n    while (this._expect(\":\")) {\n      args.push(this._assignment());\n    }\n\n    return result;\n  }\n\n  /**\n   * Parses function arguments.\n   * @returns {ASTNode[]} The arguments array.\n   */\n  _parseArguments() {\n    /** @type {ASTNode[]} */\n    const args = [];\n\n    if (this._peekToken().text !== \")\") {\n      do {\n        args.push(this._filterChain());\n      } while (this._expect(\",\"));\n    }\n\n    return args;\n  }\n\n  /**\n   * Parses an identifier.\n   * @returns {ASTNode} The identifier node.\n   */\n  _identifier() {\n    const token = this._consume();\n\n    if (!token.identifier) {\n      this._throwError(\"is not a valid identifier\", token);\n    }\n\n    return { type: ASTType._Identifier, name: token.text };\n  }\n\n  /**\n   * Parses a constant.\n   * @returns {ASTNode} The constant node.\n   */\n  _constant() {\n    // TODO check that it is a constant\n    return { type: ASTType._Literal, value: this._consume().value };\n  }\n\n  /**\n   * Parses an array declaration.\n   * @returns {ASTNode} The array declaration node.\n   */\n  _arrayDeclaration() {\n    /** @type {ASTNode[]} */\n    const elements = [];\n\n    if (this._peekToken().text !== \"]\") {\n      do {\n        if (this._peek(\"]\")) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n        elements.push(this._assignment());\n      } while (this._expect(\",\"));\n    }\n    this._consume(\"]\");\n\n    return { type: ASTType._ArrayExpression, elements };\n  }\n\n  /**\n   * Parses an object.\n   * @returns {ASTNode} The object node.\n   */\n  _object() {\n    /** @type {ASTNode[]} */\n    const properties = [];\n\n    /** @type {import(\"./ast-node.ts\").ObjectPropertyNode} */\n    let property;\n\n    if (this._peekToken().text !== \"}\") {\n      do {\n        if (this._peek(\"}\")) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n        property = /** @type {import(\"./ast-node.ts\").ObjectPropertyNode} */ ({\n          type: ASTType._Property,\n          kind: \"init\",\n        });\n\n        if (/** @type {Token} */ (this._peek()).constant) {\n          property.key = this._constant();\n          property.computed = false;\n          this._consume(\":\");\n          property.value = this._assignment();\n        } else if (\n          /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek())\n            .identifier\n        ) {\n          property.key = this._identifier();\n          property.computed = false;\n\n          if (this._peek(\":\")) {\n            this._consume(\":\");\n            property.value = this._assignment();\n          } else {\n            property.value = property.key;\n          }\n        } else if (this._peek(\"[\")) {\n          this._consume(\"[\");\n          property.key = this._assignment();\n          this._consume(\"]\");\n          property.computed = true;\n          this._consume(\":\");\n          property.value = this._assignment();\n        } else {\n          this._throwError(\n            \"invalid key\",\n            /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek()),\n          );\n        }\n        properties.push(property);\n      } while (this._expect(\",\"));\n    }\n    this._consume(\"}\");\n\n    return { type: ASTType._ObjectExpression, properties };\n  }\n\n  /**\n   * Throws a syntax error.\n   * @param {string} msg - The error message.\n   * @param {import(\"../lexer/lexer.js\").Token} token - The token that caused the error.\n   */\n  _throwError(msg, token) {\n    throw $parseMinErr(\n      \"syntax\",\n      \"Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].\",\n      token.text,\n      msg,\n      token.index + 1,\n      this._text,\n      this._text?.substring(token.index),\n    );\n  }\n\n  /**\n   * Consumes a token if it matches the expected type.\n   * @param {string} [e1] - The expected token type.\n   * @returns {import(\"../lexer/lexer.js\").Token} The consumed token.\n   */\n  _consume(e1) {\n    if (this._tokens && this._tokens.length === this._index) {\n      throw $parseMinErr(\n        \"ueoe\",\n        \"Unexpected end of expression: {0}\",\n        this._text,\n      );\n    }\n\n    const token = isDefined(e1) ? this._expect(e1) : this._expect();\n\n    if (!token) {\n      this._throwError(\n        `is unexpected, expecting [${e1}]`,\n        /** @type {import(\"../lexer/lexer.js\").Token} */ (this._peek()),\n      );\n\n      return /** @type {never} */ (undefined);\n    } else {\n      return /** @type  {import(\"../lexer/lexer.js\").Token} */ (token);\n    }\n  }\n\n  /**\n   * Returns the next token without consuming it.\n   * @returns {import(\"../lexer/lexer.js\").Token} The next token.\n   */\n  _peekToken() {\n    if (!this._tokens || this._tokens.length === this._index) {\n      throw $parseMinErr(\n        \"ueoe\",\n        \"Unexpected end of expression: {0}\",\n        this._text,\n      );\n    } else {\n      return this._tokens[this._index];\n    }\n  }\n\n  /**\n   * Checks if the next token matches any of the expected types.\n   * @param {...string} expected - The expected token types.\n   * @returns {import('../lexer/lexer.js').Token|boolean} The next token if it matches, otherwise false.\n   */\n  _peek(...expected) {\n    const token = this._tokens && this._tokens[this._index];\n\n    if (!token) return false;\n\n    const j = expected.length;\n\n    if (!j) return token;\n\n    const txt = token.text;\n\n    if (expected.length === 1) return expected[0] === txt ? token : false;\n\n    for (let i = 0; i < j; i++) {\n      if (expected[i] === txt || !expected[i]) return token;\n    }\n\n    return false;\n  }\n\n  /**\n   * Consumes the next token if it matches any of the expected types.\n   * @param {...string} expected - The expected token types.\n   * @returns {import(\"../lexer/lexer.js\").Token|boolean} The consumed token if it matches, otherwise false.\n   */\n  _expect(...expected) {\n    const token = this._peek(...expected);\n\n    if (token) {\n      this._index++;\n\n      return token;\n    }\n\n    return false;\n  }\n}\n","import { AST } from \"../ast/ast.js\";\nimport { ASTType } from \"../ast-type.js\";\nimport { ASTInterpreter } from \"../interpreter.js\";\n\n/**\n * @constructor\n */\nexport class Parser {\n  /**\n   *\n   * @param {import('../lexer/lexer.js').Lexer} lexer\n   * @param {ng.FilterService} $filter\n   */\n  constructor(lexer, $filter) {\n    /** @type {AST} */\n    this._ast = new AST(lexer);\n\n    /** @type {ASTInterpreter} */\n    this._astCompiler = new ASTInterpreter($filter);\n  }\n\n  /**\n   * @param {string} exp - Expression to be parsed\n   * @returns {import(\"../interface.ts\").CompiledExpression}\n   */\n  _parse(exp) {\n    exp = exp.trim();\n    const ast = this._ast._ast(exp);\n\n    const fn = this._astCompiler.compile(ast);\n\n    fn._literal = isLiteral(\n      /** @type {import(\"../ast/ast-node.ts\").BodyNode} */ (ast),\n    );\n    fn.constant = !!ast.constant;\n\n    return fn;\n  }\n}\n\n/**\n * @param {import(\"../ast/ast-node.ts\").BodyNode} ast\n * @returns {boolean}\n */\nfunction isLiteral(ast) {\n  const { body } = ast;\n\n  // non-single-expression programs are literals\n  if (!body || body.length !== 1) {\n    return true;\n  }\n\n  if (body && body.length === 1) {\n    switch (\n      /** @type {import(\"../ast/ast-node.ts\").ExpressionNode} */ (body[0])\n        .expression?.type\n    ) {\n      case ASTType._Literal:\n      case ASTType._ArrayExpression:\n      case ASTType._ObjectExpression:\n        return true;\n      default:\n        return false;\n    }\n  } else {\n    return true;\n  }\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { deProxy, isFunction, nullObject } from \"../../shared/utils.js\";\nimport { Lexer } from \"./lexer/lexer.js\";\nimport { Parser } from \"./parser/parser.js\";\nimport { validateRequired } from \"../../shared/validate.js\";\n\nconst lexer = new Lexer();\n\nexport class ParseProvider {\n  constructor() {\n    const cache = nullObject();\n\n    this.$get = [\n      $injectTokens._filter,\n      /**\n       *\n       * @param {ng.FilterService} $filter\n       * @returns {ng.ParseService}\n       */\n      function ($filter) {\n        return $parse;\n\n        /** @type {ng.ParseService} */\n        function $parse(exp, interceptorFn) {\n          validateRequired(exp, \"exp\"); // Note: changing this to a stricter validateInstance breaks multiple tests\n          /** @type {import(\"./interface.ts\").CompiledExpression} */\n          let parsedExpression;\n\n          exp = exp.trim();\n          const cacheKey = exp;\n\n          parsedExpression = cache[cacheKey];\n\n          if (!parsedExpression) {\n            const parser = new Parser(lexer, $filter);\n\n            parsedExpression = parser._parse(exp);\n          }\n\n          return addInterceptor(parsedExpression, interceptorFn);\n        }\n\n        /**\n         * @param {import(\"./interface.ts\").CompiledExpression} parsedExpression\n         * @param {(value: any) => any} [interceptorFn]\n         * @returns {import('./interface.ts').CompiledExpression|*}\n         */\n        function addInterceptor(parsedExpression, interceptorFn) {\n          if (!interceptorFn) {\n            return parsedExpression;\n          }\n\n          /**\n           *\n           * @param {ng.Scope} scope\n           * @param {Object} [locals]\n           * @param {*} [assign]\n           * @returns\n           */\n          const fn = function interceptedExpression(scope, locals, assign) {\n            // Do not invoke for getters\n            if (scope?.getter) {\n              return undefined;\n            }\n            const value = parsedExpression(scope, locals, assign);\n\n            const res = isFunction(value) ? value() : value;\n\n            return interceptorFn(deProxy(res));\n          };\n\n          fn._interceptor = interceptorFn;\n\n          fn._literal = parsedExpression._literal;\n\n          fn.constant = parsedExpression.constant;\n\n          fn._decoratedNode = parsedExpression._decoratedNode;\n\n          return fn;\n        }\n      },\n    ];\n  }\n}\n","import {\n  assert,\n  concat,\n  entries,\n  hasOwn,\n  isArray,\n  isDefined,\n  isFunction,\n  isObject,\n  isProxy,\n  isProxySymbol,\n  isString,\n  isUndefined,\n  keys,\n  nextUid,\n  nullObject,\n} from \"../../shared/utils.js\";\nimport { ASTType } from \"../parse/ast-type.js\";\nimport { $injectTokens as $t } from \"../../injection-tokens.js\";\n\n/** @typedef {import(\"../parse/ast/ast-node.ts\").ExpressionNode} ExpressionNode */\n/** @typedef {import(\"../parse/ast/ast-node.ts\").LiteralNode} LiteralNode */\n/** @typedef {import(\"../parse/ast/ast-node.ts\").BodyNode} BodyNode */\n/** @typedef {import(\"../parse/ast/ast-node.ts\").ArrayNode} ArrayNode */\n/** @typedef {import(\"../parse/ast/ast-node.ts\").ObjectNode} ObjectNode */\n/** @typedef {import(\"../parse/ast/ast-node.ts\").ObjectPropertyNode} ObjectPropertyNode */\n\n/**\n * @type {number}\n */\nlet uid = 0;\n\nfunction nextId() {\n  uid += 1;\n\n  return uid;\n}\n\n/**\n * @type {ng.ParseService}\n */\nlet $parse;\n\n/**@type {ng.ExceptionHandlerService} */\nlet $exceptionHandler;\n\n/** @ignore @type {Function[]} */\nexport const $postUpdateQueue = [];\n\nexport class RootScopeProvider {\n  constructor() {\n    this.rootScope = createScope();\n  }\n\n  $get = [\n    $t._exceptionHandler,\n    $t._parse,\n    /**\n     * @param {ng.ExceptionHandlerService} exceptionHandler\n     * @param {ng.ParseService} parse\n     */\n    (exceptionHandler, parse) => {\n      $exceptionHandler = exceptionHandler;\n      $parse = parse;\n\n      return this.rootScope;\n    },\n  ];\n}\n\n/**\n * @private\n * Creates a deep proxy for the target object, intercepting property changes\n * and recursively applying proxies to nested objects.\n *\n * @param {Object & {$nonscope?: import(\"./interface.ts\").NonScope} & Record<string, any>} target - The object to be wrapped in a proxy.\n * @param {Scope} [context] - The context for the handler, used to track listeners.\n * @returns {Scope|Object} - A proxy that intercepts operations on the target object,\n *                                     or the original value if the target is not an object.\n */\nexport function createScope(target = {}, context) {\n  if (!isObject(target) || isNonScope(target)) return target;\n\n  const proxy = new Proxy(target, context || new Scope());\n\n  const keyList = keys(target);\n\n  const ctorNonScope = isArray(target.constructor?.$nonscope)\n    ? target.constructor.$nonscope\n    : null;\n\n  const instNonScope = isArray(target.$nonscope) ? target.$nonscope : null;\n\n  for (let i = 0, l = keyList.length; i < l; i++) {\n    const key = keyList[i];\n\n    if (ctorNonScope?.includes(key) || instNonScope?.includes(key)) continue;\n    target[key] = createScope(target[key], proxy.$handler);\n  }\n\n  return proxy;\n}\n\nconst global = globalThis;\n\nconst wStr = \"[object Window]\";\n\n/**\n * Checks if a target should be excluded from scope observability\n * @param {any} target\n * @returns {boolean}\n */\nexport function isNonScope(target) {\n  // 1. Null or primitive types are non-scope\n  if (\n    target === null ||\n    typeof target === \"undefined\" ||\n    typeof target === \"number\" ||\n    typeof target === \"string\" ||\n    typeof target === \"boolean\" ||\n    typeof target === \"symbol\" ||\n    typeof target === \"bigint\"\n  ) {\n    return true;\n  }\n\n  // 2. Explicit non-scope flags\n  if (target.$nonscope === true || target?.constructor?.$nonscope === true) {\n    return true;\n  }\n\n  // 3. Global objects\n  if (\n    target === global.window ||\n    target === global.document ||\n    target === global.self ||\n    target === global.frames\n  ) {\n    return true;\n  }\n\n  // 4. Safe instanceof checks\n  const nonScopeConstructors = [\n    Window,\n    Document,\n    Element,\n    Node,\n    EventTarget,\n    Promise,\n    HTMLCollection,\n    NodeList,\n    Event,\n    Date,\n    RegExp,\n    Map,\n    Set,\n    WeakMap,\n    WeakSet,\n    ArrayBuffer,\n    DataView,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Float32Array,\n    Float64Array,\n    Function,\n    Error,\n    Blob,\n    File,\n    FormData,\n    URL,\n    URLSearchParams,\n  ];\n\n  for (const Ctor of nonScopeConstructors) {\n    try {\n      if (target instanceof /** @type {any} */ (Ctor)) return true;\n    } catch {\n      /* empty */\n    }\n  }\n\n  try {\n    return Object.prototype.toString.call(target) === wStr;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Scope class for the Proxy. It intercepts operations like property access (get)\n * and property setting (set), and adds support for deep change tracking and\n * observer-like behavior.\n * @extends {Record<string, any>}\n */\nexport class Scope {\n  /**\n   * Initializes the handler with the target object and a context.\n   *\n   * @param {Scope} [context] - The context containing listeners.\n   * @param {Scope} [parent] - Custom parent.\n   */\n  constructor(context, parent) {\n    /** @ignore @type {Map<string, Array<import('./interface.ts').Listener>>} Watch listeners */\n    this._watchers = context?._watchers ?? new Map();\n\n    /** @private @type {Map<String, Function[]>} Event listeners */\n    this._listeners = new Map();\n\n    /** @private @type {Map<string, Array<import('./interface.ts').Listener>>} Watch listeners from other proxies */\n    this._foreignListeners = context?._foreignListeners ?? new Map();\n\n    /** @private @type {Set<Proxy<ng.Scope>>} */\n    this._foreignProxies = context?._foreignProxies ?? new Set();\n\n    /** @private @type {WeakMap<Object, Array<string>>} */\n    this._objectListeners = context?._objectListeners ?? new WeakMap();\n\n    /** @type {Proxy<Scope>} Current proxy being operated on */\n    this.$proxy;\n\n    /** @type {Scope} This is the reference to the Scope object with acts as the actual proxy */\n    this.$handler = /** @type {Scope} */ (this);\n\n    /** @type {*} Current target being called on */\n    this.$target = null;\n\n    /**\n     * @ignore @type {Scope[]}\n     */\n    this._children = [];\n\n    /**\n     * @type {number} Unique model ID (monotonically increasing) useful for debugging.\n     */\n    this.$id = nextId();\n\n    /**\n     * @type {ng.RootScopeService}\n     */\n    this.$root = context ? context.$root : this;\n\n    /**\n     * @type {Scope | undefined}\n     */\n    this.$parent = parent || (this.$root === this ? undefined : context);\n\n    /** @ignore @type {boolean} */\n    this._destroyed = false;\n\n    /** @private @type {import(\"./interface.ts\").Listener[]} A list of scheduled Event listeners */\n    this._scheduled = [];\n\n    this.$scopename = undefined;\n\n    /** @private */\n    /** @type {Record<any, any>} */\n    this.propertyMap = {\n      $apply: this.$apply.bind(this),\n      $broadcast: this.$broadcast.bind(this),\n      _children: this._children,\n      $destroy: this.$destroy.bind(this),\n      $emit: this.$emit.bind(this),\n      $eval: this.$eval.bind(this),\n      $flushQueue: this.$flushQueue.bind(this),\n      $getById: this.$getById.bind(this),\n      $handler: /** @type {Scope} */ (this),\n      $id: this.$id,\n      $isRoot: this.#isRoot.bind(this),\n      $merge: this.$merge.bind(this),\n      $new: this.$new.bind(this),\n      $newIsolate: this.$newIsolate.bind(this),\n      $on: this.$on.bind(this),\n      $parent: this.$parent,\n      $postUpdate: this.$postUpdate.bind(this),\n      $proxy: this.$proxy,\n      $root: this.$root,\n      $scopename: this.$scopename,\n      $searchByName: this.$searchByName.bind(this),\n      $transcluded: this.$transcluded.bind(this),\n      $watch: this.$watch.bind(this),\n    };\n  }\n\n  /**\n   * Intercepts and handles property assignments on the target object. If a new value is\n   * an object, it will be recursively proxied.\n   *\n   * @param {Object & Record<string, any>} target - The target object.\n   * @param {string} property - The name of the property being set.\n   * @param {*} value - The new value being assigned to the property.\n   * @param {Proxy<Scope>} proxy - The proxy intercepting property access\n   * @returns {boolean} - Returns true to indicate success of the operation.\n   */\n  set(target, property, value, proxy) {\n    if (property === \"undefined\") {\n      return false;\n    }\n\n    if (property === \"$scopename\") {\n      this.$scopename = value;\n\n      return true;\n    }\n\n    const nonscopeProps = target.constructor?.$nonscope ?? target.$nonscope;\n\n    if (isArray(nonscopeProps) && nonscopeProps.includes(property)) {\n      target[property] = value;\n\n      return true;\n    }\n\n    this.$proxy = proxy;\n    this.$target = target;\n    const oldValue = target[property];\n\n    // Handle NaNs\n    if (\n      oldValue !== undefined &&\n      Number.isNaN(oldValue) &&\n      Number.isNaN(value)\n    ) {\n      return true;\n    }\n\n    if (oldValue && oldValue[isProxySymbol]) {\n      if (isArray(value)) {\n        if (oldValue !== value) {\n          const listeners = this._watchers.get(property);\n\n          if (listeners) {\n            this.#scheduleListener(listeners);\n          }\n\n          const _foreignListeners = this._foreignListeners.get(property);\n\n          if (_foreignListeners) {\n            this.#scheduleListener(_foreignListeners);\n          }\n        }\n\n        if (this._objectListeners.get(target[property])) {\n          this._objectListeners.delete(target[property]);\n        }\n        target[property] = createScope(value, this);\n        this._objectListeners.set(target[property], [property]);\n\n        return true;\n      }\n\n      if (isObject(value)) {\n        if (hasOwn(target, property)) {\n          const keyList = keys(oldValue);\n\n          for (const k of keyList) {\n            if (!value[k]) delete oldValue[k];\n          }\n        }\n\n        if (oldValue !== value) {\n          const listeners = this._watchers.get(property);\n\n          if (listeners) {\n            this.#scheduleListener(listeners);\n          }\n\n          const _foreignListeners = this._foreignListeners.get(property);\n\n          if (_foreignListeners) {\n            this.#scheduleListener(_foreignListeners);\n          }\n\n          this.#checkeListenersForAllKeys(value);\n        }\n        target[property] = createScope(value, this);\n\n        //setDeepValue(target[property], value);\n        return true;\n      }\n\n      if (isUndefined(value)) {\n        let called = false;\n\n        const keyList = keys(oldValue.$target);\n\n        const tgt = oldValue.$target;\n\n        let i = 0;\n\n        for (i; i < keyList.length; i++) {\n          const k = keyList[i];\n\n          const v = tgt[k];\n\n          if (v && v[isProxySymbol]) {\n            called = true;\n          }\n          delete oldValue[k];\n        }\n\n        target[property] = undefined;\n\n        if (!called) {\n          const listeners = this._watchers.get(property);\n\n          if (listeners) {\n            this.#scheduleListener(listeners);\n          }\n        }\n\n        return true;\n      }\n\n      if (isDefined(value)) {\n        target[property] = value;\n        const listeners = this._watchers.get(property);\n\n        if (listeners) {\n          this.#scheduleListener(listeners);\n        }\n\n        if (isArray(target)) {\n          if (this._objectListeners.has(proxy) && property !== \"length\") {\n            const keyList = /** @type {string[]} */ (\n              this._objectListeners.get(proxy)\n            );\n\n            for (let i = 0, l = keyList.length; i < l; i++) {\n              const currentListeners = this._watchers.get(keyList[i]);\n\n              if (currentListeners) this.#scheduleListener(currentListeners);\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return true;\n    } else {\n      if (isUndefined(target[property]) && isProxy(value)) {\n        this._foreignProxies.add(/** @type {Proxy<ng.Scope>} */ (value));\n        target[property] = value;\n\n        if (!this._watchers.has(property)) {\n          return true;\n        }\n      }\n\n      if (isUndefined(value)) {\n        target[property] = value;\n      } else {\n        target[property] = createScope(value, this);\n      }\n\n      if (oldValue !== value) {\n        let expectedTarget = this.$target;\n\n        const listeners = [];\n\n        // Handle the case where we need to start observing object after a watcher has been set\n        if (isUndefined(oldValue) && isObject(target[property])) {\n          if (!this._objectListeners.has(target[property])) {\n            this._objectListeners.set(target[property], [property]);\n          }\n          const keyList = keys(value);\n\n          for (let i = 0, l = keyList.length; i < l; i++) {\n            const key = keyList[i];\n\n            const keyListeners = this._watchers.get(key);\n\n            if (keyListeners) {\n              for (let j = 0, jl = keyListeners.length; j < jl; j++) {\n                listeners.push(keyListeners[j]);\n              }\n            }\n          }\n          expectedTarget = value;\n        }\n\n        if (isArray(target)) {\n          const lengthListeners = this._watchers.get(\"length\");\n\n          if (lengthListeners) {\n            for (let i = 0, l = lengthListeners.length; i < l; i++) {\n              listeners.push(lengthListeners[i]);\n            }\n          }\n        }\n\n        const propListeners = this._watchers.get(property);\n\n        if (propListeners) {\n          for (let i = 0, l = propListeners.length; i < l; i++) {\n            listeners.push(propListeners[i]);\n          }\n        }\n\n        if (listeners.length > 0) {\n          this.#scheduleListener(listeners, (list) => {\n            const scheduled = [];\n\n            for (let i = 0, l = list.length; i < l; i++) {\n              const x = list[i];\n\n              if (!x.watchProp) {\n                scheduled.push(x);\n                continue;\n              }\n\n              const wrapperExpr = x.watchProp.split(\".\").slice(0, -1).join(\".\");\n\n              const expectedHandler = $parse(wrapperExpr)(x.originalTarget);\n\n              if (expectedTarget === expectedHandler?.$target) {\n                scheduled.push(x);\n              }\n            }\n\n            return scheduled;\n          });\n        }\n\n        let _foreignListeners = this._foreignListeners.get(property);\n\n        if (!_foreignListeners && this.$parent?._foreignListeners) {\n          _foreignListeners = this.$parent._foreignListeners.get(property);\n        }\n\n        if (_foreignListeners) {\n          let scheduled = _foreignListeners;\n\n          // filter for repeaters\n          const hashKey = this.$target._hashKey;\n\n          if (hashKey) {\n            scheduled = [];\n\n            for (let i = 0, l = _foreignListeners.length; i < l; i++) {\n              const listener = _foreignListeners[i];\n\n              if (listener.originalTarget._hashKey === hashKey) {\n                scheduled.push(listener);\n              }\n            }\n          }\n\n          if (scheduled.length > 0) {\n            this.#scheduleListener(scheduled);\n          }\n        }\n      }\n\n      if (this._objectListeners.has(proxy) && property !== \"length\") {\n        const keyList = /** @type {string[]} */ (\n          this._objectListeners.get(proxy)\n        );\n\n        for (let i = 0, l = keyList.length; i < l; i++) {\n          const key = keyList[i];\n\n          const listeners = this._watchers.get(key);\n\n          if (listeners && this._scheduled !== listeners) {\n            this.#scheduleListener(listeners);\n          }\n        }\n      }\n\n      return true;\n    }\n  }\n\n  /**\n   * Intercepts property access on the target object. It checks for specific\n   * properties (`watch` and `sync`) and binds their methods. For other properties,\n   * it returns the value directly.\n   *\n   * @param {Object & Record<string, any>} target - The target object.\n   * @param {string|number|symbol} property - The name of the property being accessed.\n   * @param {Proxy<Scope>} proxy - The proxy object being invoked\n   * @returns {*} - The value of the property or a method if accessing `watch` or `sync`.\n   */\n  get(target, property, proxy) {\n    if (property === \"$scopename\" && this.$scopename) return this.$scopename;\n\n    if (property === \"$$watchersCount\") return calculateWatcherCount(this);\n\n    if (property === isProxySymbol) return true;\n\n    const targetProp = target[/** @type {string} */ (property)];\n\n    if (isProxy(targetProp)) {\n      this.$proxy = /** @type {Proxy<Scope>} */ (targetProp);\n    } else {\n      this.$proxy = proxy;\n    }\n\n    this.propertyMap.$target = target;\n    this.propertyMap.$proxy = proxy;\n\n    if (\n      isArray(target) &&\n      [\"pop\", \"shift\", \"unshift\"].includes(/** @type { string } */ (property))\n    ) {\n      if (this._objectListeners.has(proxy)) {\n        const keyList = /** @type {string []} */ (\n          this._objectListeners.get(proxy)\n        );\n\n        for (let i = 0, l = keyList.length; i < l; i++) {\n          const key = keyList[i];\n\n          const listeners = this._watchers.get(key);\n\n          if (listeners) {\n            this._scheduled = listeners;\n          }\n        }\n      }\n\n      if (property === \"unshift\") {\n        this.#scheduleListener(this._scheduled);\n      }\n    }\n\n    if (hasOwn(this.propertyMap, property)) {\n      this.$target = target;\n\n      return this.propertyMap[/** @type {string} */ (property)];\n    } else {\n      // we are a simple getter\n      return targetProp;\n    }\n  }\n\n  /**\n   * @param {Object & Record<string, any>} target - The target object.\n   * @param {string} property - The name of the property being deleted\n   */\n  deleteProperty(target, property) {\n    // Currently deletes $model\n    if (target[property] && target[property][isProxySymbol]) {\n      target[property] = undefined;\n\n      const listeners = this._watchers.get(property);\n\n      if (listeners) {\n        this.#scheduleListener(listeners);\n      }\n\n      if (this._objectListeners.has(this.$proxy)) {\n        const keyList = /** @type {string[]} */ (\n          this._objectListeners.get(this.$proxy)\n        );\n\n        for (let i = 0, l = keyList.length; i < l; i++) {\n          const key = keyList[i];\n\n          const currentListeners = this._watchers.get(key);\n\n          if (currentListeners) this.#scheduleListener(currentListeners);\n        }\n      }\n\n      if (this._scheduled) {\n        this.#scheduleListener(this._scheduled);\n        this._scheduled = [];\n      }\n\n      return true;\n    }\n\n    delete target[property];\n\n    if (this._objectListeners.has(this.$proxy)) {\n      const keyList = /** @type {string[]} */ (\n        this._objectListeners.get(this.$proxy)\n      );\n\n      for (let i = 0, l = keyList.length; i < l; i++) {\n        const key = keyList[i];\n\n        const listeners = this._watchers.get(key);\n\n        if (listeners) this.#scheduleListener(listeners);\n      }\n    } else {\n      const listeners = this._watchers.get(property);\n\n      if (listeners) {\n        this.#scheduleListener(listeners, target[property]);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {Object & Record<string, any>} value\n   */\n  #checkeListenersForAllKeys(value) {\n    if (isUndefined(value)) {\n      return;\n    }\n    keys(value).forEach((k) => {\n      const listeners = this._watchers.get(k);\n\n      if (listeners) {\n        this.#scheduleListener(listeners);\n      }\n\n      if (isObject(value[k])) {\n        this.#checkeListenersForAllKeys(value[k]);\n      }\n    });\n  }\n\n  /**\n   * @param {import('./interface.ts').Listener[]} listeners\n   * @param {(listeners: import('./interface').Listener[]) => import('./interface').Listener[]} filter\n   */\n  #scheduleListener(listeners, filter = (val) => val) {\n    queueMicrotask(() => {\n      let index = 0;\n\n      const filteredListeners = filter(listeners);\n\n      while (index < filteredListeners.length) {\n        const listener = filteredListeners[index];\n\n        this.#notifyListener(listener, this.$target);\n\n        index++;\n      }\n    });\n  }\n\n  /**\n   * Registers a watcher for a property along with a listener function. The listener\n   * function is invoked when changes to that property are detected.\n   *\n   * @param {string} watchProp - An expression to be watched in the context of this model.\n   * @param {ng.ListenerFn} [listenerFn] - A function to execute when changes are detected on watched context.\n   * @param {boolean} [lazy] - A flag to indicate if the listener should be invoked immediately. Defaults to false.\n   * @return {(() => void) | undefined} - A function to deregister the watcher, or undefined if no listener function is provided.\n   */\n  $watch(watchProp, listenerFn, lazy = false) {\n    assert(isString(watchProp), \"Watched property required\");\n    watchProp = watchProp.trim();\n    const get = $parse(watchProp);\n\n    // Constant are immediately passed to listener function\n    if (get.constant) {\n      if (listenerFn) {\n        queueMicrotask(() => {\n          let res = get();\n\n          while (isFunction(res)) {\n            res = res();\n          }\n          listenerFn(res, this.$target);\n        });\n      }\n\n      return () => {\n        /* empty */\n      };\n    }\n\n    const expr = /** @type {import(\"../parse/ast/ast-node.ts\").ASTNode} */ (\n      /** @type {ExpressionNode & BodyNode} */ (get._decoratedNode.body[0])\n        .expression\n    );\n\n    if (!listenerFn) {\n      let res = get(this.$target);\n\n      while (isFunction(res)) {\n        res = res(this.$target);\n      }\n\n      return undefined;\n    }\n\n    /** @type {ng.Listener} */\n    const listener = {\n      originalTarget: this.$target,\n      listenerFn,\n      watchFn: get,\n      scopeId: this.$id,\n      id: nextUid(),\n      property: [],\n    };\n\n    // simplest case\n    let key = /** @type {LiteralNode} */ (expr).name;\n\n    /**\n     * @type {string[]}\n     */\n    const keySet = [];\n\n    const { type } = expr;\n\n    switch (type) {\n      // 3\n      case ASTType._AssignmentExpression:\n        // assignment calls without listener functions\n        key = /** @type {LiteralNode} */ (\n          /** @type {ExpressionNode} */ (expr).left\n        )?.name;\n        break;\n      // 4\n      case ASTType._ConditionalExpression: {\n        key = /** @type {LiteralNode} */ (\n          /** @type {ExpressionNode} */ (\n            /** @type {BodyNode} */ (expr).toWatch[0]\n          )?.test\n        )?.name;\n        listener.property.push(/** @type {string} */ (key));\n        break;\n      }\n      // 5\n      case ASTType._LogicalExpression: {\n        const keyList = [\n          /** @type {LiteralNode} */ (\n            /** @type {BodyNode} */ (/** @type {ExpressionNode} */ (expr).left)\n              .toWatch[0]\n          )?.name,\n          /** @type {LiteralNode} */ (\n            /** @type {BodyNode} */ (/** @type {ExpressionNode} */ (expr).right)\n              .toWatch[0]\n          )?.name,\n        ];\n\n        for (let i = 0, l = keyList.length; i < l; i++) {\n          const registerKey = keyList[i];\n\n          if (registerKey) this.#registerKey(registerKey, listener);\n        }\n\n        return () => {\n          for (let i = 0, l = keyList.length; i < l; i++) {\n            const deregisterKey = keyList[i];\n\n            this.#deregisterKey(\n              /** @type {string} */ (deregisterKey),\n              listener.id,\n            );\n          }\n        };\n      }\n      // 6\n      case ASTType._BinaryExpression: {\n        if (/** @type {ExpressionNode} */ (expr).isPure) {\n          const watch = /** @type {BodyNode} */ (expr).toWatch[0];\n\n          key = /** @type {ExpressionNode} */ (watch).property\n            ? /** @type {LiteralNode} */ (\n                /** @type {ExpressionNode} */ (watch).property\n              ).name\n            : /** @type {LiteralNode} */ (watch).name;\n\n          if (!key) {\n            throw new Error(\"Unable to determine key\");\n          }\n          listener.property.push(key);\n          break;\n        } else {\n          const { toWatch } = /** @type {BodyNode} */ (expr);\n\n          for (let i = 0, l = toWatch.length; i < l; i++) {\n            const x = toWatch[i];\n\n            const registerKey = /** @type {ExpressionNode} */ (x).property\n              ? /** @type {LiteralNode} */ (\n                  /** @type {ExpressionNode} */ (x).property\n                ).name\n              : /** @type {LiteralNode} */ (x).name;\n\n            if (!registerKey) throw new Error(\"Unable to determine key\");\n\n            this.#registerKey(registerKey, listener);\n            this.#scheduleListener([listener]);\n          }\n\n          // Return deregistration function\n          return () => {\n            for (let i = 0, l = toWatch.length; i < l; i++) {\n              const x = toWatch[i];\n\n              const deregisterKey = /** @type {ExpressionNode} */ (x).property\n                ? /** @type {LiteralNode} */ (\n                    /** @type {ExpressionNode} */ (x).property\n                  ).name\n                : /** @type {LiteralNode} */ (x).name;\n\n              this.#deregisterKey(\n                /** @type {string} */ (deregisterKey),\n                listener.id,\n              );\n            }\n          };\n        }\n      }\n      // 7\n      case ASTType._UnaryExpression: {\n        const x = /** @type {BodyNode} */ (expr).toWatch[0];\n\n        key = /** @type {ExpressionNode} */ (x).property\n          ? /** @type {LiteralNode} */ (\n              /** @type {ExpressionNode} */ (x).property\n            ).name\n          : /** @type {LiteralNode} */ (x).name;\n\n        if (!key) {\n          throw new Error(\"Unable to determine key\");\n        }\n        listener.property.push(key);\n        break;\n      }\n      // 8 function\n      case ASTType._CallExpression: {\n        const { toWatch } = /** @type {BodyNode} */ (\n          /** @type {ExpressionNode} */ (expr)\n        );\n\n        for (let i = 0, l = toWatch.length; i < l; i++) {\n          const x = toWatch[i];\n\n          if (!isDefined(x)) continue;\n          this.#registerKey(\n            /** @type {string} */ (/** @type {LiteralNode} */ (x).name),\n            listener,\n          );\n          this.#scheduleListener([listener]);\n        }\n\n        return () => {\n          for (let i = 0, l = toWatch.length; i < l; i++) {\n            const x = toWatch[i];\n\n            if (!isDefined(x)) continue;\n            this.#deregisterKey(\n              /** @type {string} */ (/** @type {LiteralNode} */ (x).name),\n              listener.id,\n            );\n          }\n        };\n      }\n\n      // 9\n      case ASTType._MemberExpression: {\n        key = /** @type {LiteralNode} */ (\n          /** @type {ExpressionNode} */ (expr).property\n        ).name;\n\n        // array watcher\n        if (!key) {\n          key = /** @type {LiteralNode} */ (\n            /** @type {ExpressionNode} */ (expr).object\n          ).name;\n        }\n\n        listener.property.push(/** @type {string} */ (key));\n\n        if (watchProp !== key) {\n          // Handle nested expression call\n          listener.watchProp = watchProp;\n\n          const potentialProxy = $parse(\n            watchProp.split(\".\").slice(0, -1).join(\".\"),\n          )(/** @type {Scope} */ (listener.originalTarget));\n\n          if (potentialProxy && this._foreignProxies.has(potentialProxy)) {\n            potentialProxy.$handler._registerForeignKey(key, listener);\n            potentialProxy.$handler.#scheduleListener([listener]);\n\n            return () => {\n              potentialProxy.$handler._deregisterForeignKey(key, listener.id);\n\n              return potentialProxy.$handler.#deregisterKey(key, listener.id);\n            };\n          }\n        }\n        break;\n      }\n\n      // 10\n      case ASTType._Identifier: {\n        listener.property.push(\n          /** @type {string} */ (/** @type {LiteralNode} */ (expr).name),\n        );\n        break;\n      }\n\n      // 12\n      case ASTType._ArrayExpression: {\n        const { elements } = /** @type {ArrayNode} */ (expr);\n\n        for (let i = 0, l = elements.length; i < l; i++) {\n          const x = elements[i];\n\n          const registerKey =\n            x.type === ASTType._Literal\n              ? /** @type {LiteralNode} */ (x).value\n              : /** @type {LiteralNode} */ (\n                  /** @type {BodyNode} */ (x).toWatch[0]\n                )?.name;\n\n          if (!registerKey) continue;\n\n          this.#registerKey(registerKey, listener);\n          this.#scheduleListener([listener]);\n        }\n\n        return () => {\n          for (let i = 0, l = elements.length; i < l; i++) {\n            const x = elements[i];\n\n            const deregisterKey =\n              x.type === ASTType._Literal\n                ? /** @type {LiteralNode} */ (x).value\n                : /** @type {LiteralNode} */ (\n                    /** @type {BodyNode} */ (x).toWatch[0]\n                  ).name;\n\n            if (!deregisterKey) continue;\n\n            this.#deregisterKey(deregisterKey, listener.id);\n          }\n        };\n      }\n\n      // 14\n      case ASTType._ObjectExpression: {\n        const { properties } = /** @type {ObjectNode} */ (expr);\n\n        for (let i = 0, l = properties.length; i < l; i++) {\n          const prop = /** @type {ObjectPropertyNode} */ (properties[i]);\n\n          let currentKey;\n\n          if (prop.key.isPure === false) {\n            currentKey = /** @type {LiteralNode} */ (prop.key).name;\n          } else if (/** @type {LiteralNode} */ (prop.value)?.name) {\n            currentKey = /** @type {LiteralNode} */ (prop.value).name;\n          } else {\n            const target = /** @type {BodyNode} */ (expr).toWatch[0];\n\n            currentKey = /** @type {ExpressionNode} */ (target).property\n              ? /** @type {LiteralNode} */ (\n                  /** @type {ExpressionNode} */ (target).property\n                ).name\n              : /** @type {LiteralNode} */ (target).name;\n          }\n\n          if (currentKey) {\n            keySet.push(currentKey);\n            listener.property.push(currentKey);\n          }\n        }\n        break;\n      }\n      default: {\n        throw new Error(`Unsupported type ${type}`);\n      }\n    }\n\n    // if the target is an object, then start observing it\n    const listenerObject = listener.watchFn(this.$target);\n\n    if (isObject(listenerObject)) {\n      this._objectListeners.set(listenerObject, [/** @type {string} */ (key)]);\n    }\n\n    if (keySet.length > 0) {\n      for (let i = 0, l = keySet.length; i < l; i++) {\n        this.#registerKey(keySet[i], listener);\n      }\n    } else {\n      this.#registerKey(/** @type {string} */ (key), listener);\n    }\n\n    if (!lazy) {\n      this.#scheduleListener([listener]);\n    }\n\n    return () => {\n      if (keySet.length > 0) {\n        let res = true;\n\n        for (let i = 0, l = keySet.length; i < l; i++) {\n          const success = this.#deregisterKey(keySet[i], listener.id);\n\n          if (!success) {\n            res = false;\n          }\n        }\n\n        return res;\n      } else {\n        return this.#deregisterKey(/** @type {string} */ (key), listener.id);\n      }\n    };\n  }\n\n  /**\n   * @param {ng.Scope} [childInstance]\n   * @returns {Proxy<ng.Scope> & ng.Scope}\n   */\n  $new(childInstance) {\n    let child;\n\n    if (childInstance) {\n      const proto = Object.getPrototypeOf(childInstance);\n\n      // If child is plain object, or already inherits from target, set prototype to target\n      if (proto === Object.prototype || proto === this.$target) {\n        Object.setPrototypeOf(childInstance, this.$target);\n      } else {\n        // If child has some other prototype, preserve it but link to this.$target\n        Object.setPrototypeOf(proto || childInstance, this.$target);\n      }\n\n      child = childInstance;\n    } else {\n      child = Object.create(this.$target);\n    }\n\n    const proxy = new Proxy(child, new Scope(this));\n\n    this._children.push(proxy);\n\n    return proxy;\n  }\n\n  /**\n   * @param {ng.Scope} [instance]\n   * @returns {Proxy<ng.Scope> & ng.Scope}\n   */\n  $newIsolate(instance) {\n    const child = instance ? Object.create(instance) : nullObject();\n\n    const proxy = new Proxy(child, new Scope(this, this.$root));\n\n    this._children.push(proxy);\n\n    return proxy;\n  }\n\n  /**\n   * @param {ng.Scope} parentInstance\n   * @returns {Proxy<ng.Scope> & ng.Scope}\n   */\n  $transcluded(parentInstance) {\n    const child = Object.create(this.$target);\n\n    const proxy = new Proxy(child, new Scope(this, parentInstance));\n\n    this._children.push(proxy);\n\n    return proxy;\n  }\n\n  /**\n   * @param {string} key\n   * @param {import(\"./interface.ts\").Listener} listener\n   */\n  #registerKey(key, listener) {\n    if (this._watchers.has(key)) {\n      /** @type {import(\"./interface.ts\").Listener[]} */ (\n        this._watchers.get(key)\n      ).push(listener);\n    } else {\n      this._watchers.set(key, [listener]);\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {import(\"./interface.ts\").Listener} listener\n   */\n  _registerForeignKey(key, listener) {\n    if (this._foreignListeners.has(key)) {\n      /** @type {import(\"./interface.ts\").Listener[]} */ (\n        this._foreignListeners.get(key)\n      ).push(listener);\n    } else {\n      this._foreignListeners.set(key, [listener]);\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {number} id\n   */\n  #deregisterKey(key, id) {\n    const listenerList = this._watchers.get(key);\n\n    if (!listenerList) return false;\n\n    const index = listenerList.findIndex((x) => x.id === id);\n\n    if (index === -1) return false;\n\n    listenerList.splice(index, 1);\n\n    if (listenerList.length) {\n      this._watchers.set(key, listenerList);\n    } else {\n      this._watchers.delete(key);\n    }\n\n    return true;\n  }\n\n  /**\n   * @param {string} key\n   * @param {number} id\n   */\n  _deregisterForeignKey(key, id) {\n    const listenerList = this._foreignListeners.get(key);\n\n    if (!listenerList) return false;\n\n    const index = listenerList.findIndex((x) => x.id === id);\n\n    if (index === -1) return false;\n\n    listenerList.splice(index, 1);\n\n    if (listenerList.length) {\n      this._foreignListeners.set(key, listenerList);\n    } else {\n      this._foreignListeners.delete(key);\n    }\n\n    return true;\n  }\n\n  /**\n   * Evaluates an Angular expression in the context of this scope.\n   *\n   * @param {string} expr - Angular expression to evaluate\n   * @param {Record<string, any>} [locals] - Optional local variables\n   * @returns {any}\n   */\n  $eval(expr, locals) {\n    const fn = $parse(expr);\n\n    const res = fn(this, locals);\n\n    if (isUndefined(res) || res === null) {\n      return res;\n    }\n\n    if (res.name === Object.hasOwnProperty.name) {\n      return res;\n    }\n\n    if (isFunction(res)) {\n      return res();\n    }\n\n    if (Number.isNaN(res)) {\n      return 0;\n    }\n\n    return res;\n  }\n\n  /**\n   * @param {Object} newTarget\n   */\n  $merge(newTarget) {\n    const list = entries(newTarget);\n\n    for (let i = 0, l = list.length; i < l; i++) {\n      const [key, value] = list[i];\n\n      this.set(this.$target, key, value, this.$proxy);\n    }\n  }\n\n  /**\n   * @param {ng.Expression} expr\n   * @returns {any}\n   */\n  $apply(expr) {\n    try {\n      return $parse(expr)(this.$proxy);\n    } catch (err) {\n      return $exceptionHandler(err);\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @param {Function} listener\n   * @returns {(function(): void)|*}\n   */\n  $on(name, listener) {\n    let namedListeners = this._listeners.get(name);\n\n    if (!namedListeners) {\n      namedListeners = [];\n      this._listeners.set(name, namedListeners);\n    }\n    namedListeners.push(listener);\n\n    return () => {\n      const indexOfListener = namedListeners.indexOf(listener);\n\n      if (indexOfListener !== -1) {\n        namedListeners.splice(indexOfListener, 1);\n\n        if (namedListeners.length === 0) {\n          this._listeners.delete(name);\n        }\n      }\n    };\n  }\n\n  /**\n   * @param {string} name\n   * @param  {...any} args\n   * @returns {ng.ScopeEvent | undefined}\n   */\n  $emit(name, ...args) {\n    return this.#eventHelper(\n      { name, event: undefined, broadcast: false },\n      ...args,\n    );\n  }\n\n  /**\n   * @param {string} name\n   * @param  {...any} args\n   * @returns {any}\n   */\n  $broadcast(name, ...args) {\n    return this.#eventHelper(\n      { name, event: undefined, broadcast: true },\n      ...args,\n    );\n  }\n\n  /**\n   * Internal event propagation helper\n   * @param {{ name: string, event?: ng.ScopeEvent, broadcast: boolean }} param0 - Event info\n   * @param {...any} args - Additional arguments passed to listeners\n   * @returns {ng.ScopeEvent|undefined}\n   */\n  #eventHelper({ name, event, broadcast }, ...args) {\n    if (!broadcast) {\n      if (!this._listeners.has(name)) {\n        if (this.$parent) {\n          return this.$parent.$handler.#eventHelper(\n            { name, event, broadcast },\n            ...args,\n          );\n        }\n\n        return undefined;\n      }\n    }\n\n    if (event) {\n      event.currentScope = this.$proxy;\n    } else {\n      event = event || {\n        name,\n        targetScope: this.$proxy,\n        currentScope: this.$proxy,\n        stopped: false,\n        stopPropagation() {\n          /** @type {ng.ScopeEvent} */ (event).stopped = true;\n        },\n        preventDefault() {\n          /** @type {ng.ScopeEvent} */ (event).defaultPrevented = true;\n        },\n        defaultPrevented: false,\n      };\n    }\n\n    const listenerArgs = concat([event], [event].concat(args), 1);\n\n    const listeners = this._listeners.get(name);\n\n    if (listeners) {\n      let { length } = listeners;\n\n      for (let i = 0; i < length; i++) {\n        try {\n          const cb = listeners[i];\n\n          cb.apply(null, listenerArgs);\n\n          const currentLength = listeners.length;\n\n          if (currentLength !== length) {\n            if (currentLength < length) {\n              i--;\n            }\n            length = currentLength;\n          }\n        } catch (err) {\n          $exceptionHandler(err);\n        }\n      }\n    }\n\n    event.currentScope = null;\n\n    if (event.stopped) {\n      return event;\n    }\n\n    if (broadcast) {\n      if (this._children.length > 0) {\n        this._children.forEach((child) => {\n          event = child.$handler.#eventHelper(\n            { name, event, broadcast },\n            ...args,\n          );\n        });\n      }\n\n      return event;\n    } else {\n      if (this.$parent) {\n        return this.$parent.#eventHelper({ name, event, broadcast }, ...args);\n      } else {\n        return event;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @returns {boolean}\n   */\n  #isRoot() {\n    return this.$root === /** @type {Scope} */ (this);\n  }\n\n  /**\n   * @param {Function} fn\n   */\n  $postUpdate(fn) {\n    $postUpdateQueue.push(fn);\n  }\n\n  $destroy() {\n    if (this._destroyed) return;\n\n    this.$broadcast(\"$destroy\");\n\n    for (const [key, val] of this._watchers) {\n      for (let i = val.length - 1; i >= 0; i--) {\n        if (val[i].scopeId === this.$id) {\n          val.splice(i, 1);\n        }\n      }\n\n      if (val.length === 0) {\n        this._watchers.delete(key);\n      } else {\n        this._watchers.set(key, val);\n      }\n    }\n\n    if (this.#isRoot()) {\n      this._watchers.clear();\n    } else {\n      const children = /** @type {Scope} */ (this.$parent)._children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        if (children[i].$id === this.$id) {\n          children.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this._listeners.clear();\n    this._destroyed = true;\n  }\n\n  /**\n   * @internal\n   * @param {import('./interface.ts').Listener} listener - The property path that was changed.\n   * @param {Scope | typeof Proxy<Scope> | undefined} target\n   */\n  #notifyListener(listener, target) {\n    const { originalTarget, listenerFn, watchFn } = listener;\n\n    try {\n      let newVal = watchFn(originalTarget);\n\n      if (isUndefined(newVal)) {\n        newVal = watchFn(target);\n      }\n\n      if (isFunction(newVal)) {\n        newVal = newVal(originalTarget);\n      }\n\n      if (isArray(newVal)) {\n        for (let i = 0, l = newVal.length; i < l; i++) {\n          if (isFunction(newVal[i])) {\n            newVal[i] = newVal[i](originalTarget);\n          }\n        }\n      }\n\n      listenerFn(newVal, originalTarget);\n\n      while ($postUpdateQueue.length) {\n        const fn = /** @type {Function} */ ($postUpdateQueue.shift());\n\n        fn();\n      }\n    } catch (err) {\n      $exceptionHandler(err);\n    }\n  }\n\n  /* @ignore */\n  $flushQueue() {\n    while ($postUpdateQueue.length) {\n      /** @type {Function} */ ($postUpdateQueue.shift())();\n    }\n  }\n\n  /**\n   * Searches the scope instance\n   *\n   * @param {string|number}id\n   * @returns {Scope|undefined}\n   */\n  $getById(id) {\n    if (isString(id)) {\n      id = parseInt(/** @type {string} */ (id), 10);\n    }\n\n    if (this.$id === id) {\n      return this;\n    } else {\n      let res = undefined;\n\n      for (const child of this._children) {\n        const found = child.$getById(id);\n\n        if (found) {\n          res = found;\n          break;\n        }\n      }\n\n      return res;\n    }\n  }\n\n  /**\n   * @param {string} name\n   * @returns {ng.Scope|undefined}\n   */\n  $searchByName(name) {\n    const stack = [this.$root];\n\n    while (stack.length) {\n      const scope = /** @type {Scope} */ (stack.pop());\n\n      if (scope.$scopename === name) {\n        return scope;\n      }\n\n      if (scope._children?.length) {\n        for (let i = scope._children.length - 1; i >= 0; i--) {\n          stack.push(scope._children[i]);\n        }\n      }\n    }\n\n    return undefined;\n  }\n}\n\n/*------------- Private helpers -------------*/\n\n/**\n * @param {Scope} model\n * @returns {number}\n */\nfunction calculateWatcherCount(model) {\n  const childIds = collectChildIds(model);\n\n  let count = 0;\n\n  for (const watchers of model._watchers.values()) {\n    for (let i = 0, l = watchers.length; i < l; i++) {\n      if (childIds.has(watchers[i].scopeId)) {\n        count++;\n      }\n    }\n  }\n\n  return count;\n}\n\n/**\n * @param {Scope} child\n * @returns {Set<number>}\n */\nfunction collectChildIds(child) {\n  const ids = new Set();\n\n  const stack = [child];\n\n  while (stack.length) {\n    const node = /** @type {Scope} */ (stack.pop());\n\n    if (!ids.has(node.$id)) {\n      ids.add(node.$id);\n\n      if (node._children) {\n        for (let i = 0, l = node._children.length; i < l; i++) {\n          stack.push(node._children[i]);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n","import { defaultHttpResponseTransform } from \"../http/http.js\";\nimport { extend, isArray } from \"../../shared/utils.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/**\n * Provider for the `$templateRequest` service.\n *\n * Fetches templates via HTTP and caches them in `$templateCache`.\n * Templates are assumed trusted.\n *\n * This provider allows configuring per-request `$http` options such as headers,\n * timeout, or transform functions via `httpOptions`.\n *\n * Option A:\n * - Provide a sensible default for template fetching (e.g. `Accept: text/html`)\n * - Keep `httpOptions` overridable during config phase\n */\nexport class TemplateRequestProvider {\n  /**\n   * Optional `$http.get()` config applied to every template request.\n   *\n   * This is merged on top of the default template request config:\n   * - `cache: $templateCache`\n   * - `transformResponse`: with `defaultHttpResponseTransform` removed\n   *\n   * Use this to set template-specific defaults such as custom headers,\n   * timeouts, credentials, etc.\n   *\n   * @type {ng.RequestShortcutConfig}\n   */\n  httpOptions;\n\n  constructor() {\n    /**\n     * Default options for template requests.\n     * Keeps behavior aligned with callers that previously used `$http` directly\n     * and set `Accept: text/html`.\n     *\n     * @type {ng.RequestShortcutConfig}\n     */\n    this.httpOptions = {\n      headers: {\n        Accept: \"text/html\",\n      },\n    };\n  }\n\n  $get = [\n    $injectTokens._templateCache,\n    $injectTokens._http,\n    /**\n     * @param {ng.TemplateCacheService} $templateCache\n     * @param {ng.HttpService} $http\n     * @returns {ng.TemplateRequestService}\n     */\n    ($templateCache, $http) => {\n      /**\n       * Fetch a template via HTTP and cache it.\n       *\n       * @param {string} templateUrl URL of the template\n       * @returns {Promise<string>} Resolves with template content\n       */\n      const fetchTemplate = (templateUrl) => {\n        // Filter out default transformResponse for template requests\n        let transformResponse = $http.defaults?.transformResponse ?? null;\n\n        if (isArray(transformResponse)) {\n          transformResponse = transformResponse.filter(\n            (x) => x !== defaultHttpResponseTransform,\n          );\n        } else if (transformResponse === defaultHttpResponseTransform) {\n          transformResponse = null;\n        }\n\n        /** @type {ng.RequestShortcutConfig} */\n        const config = extend(\n          {\n            cache: $templateCache,\n            transformResponse,\n          },\n          this.httpOptions || {},\n        );\n\n        return $http.get(templateUrl, config).then(\n          (response) => {\n            $templateCache.set(templateUrl, response.data);\n\n            return response.data;\n          },\n          (resp) => {\n            return Promise.reject(resp);\n          },\n        );\n      };\n\n      return fetchTemplate;\n    },\n  ];\n}\n","import { isDefined } from \"../../shared/utils.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/** @typedef {import('../../interface.ts').ServiceProvider} ServiceProvider */\n\n/**\n * Private service to sanitize uris for links and images. Used by $compile.\n * @extends {ServiceProvider}\n */\nexport class SanitizeUriProvider {\n  constructor() {\n    /**\n     * @private\n     * @type {RegExp}\n     */\n    this._aHrefSanitizationTrustedUrlList =\n      /^\\s*(https?|s?ftp|mailto|tel|file):/;\n\n    /**\n     * @private\n     * @type {RegExp}\n     */\n    this._imgSrcSanitizationTrustedUrlList =\n      /^\\s*((https?|ftp|file|blob):|data:image\\/)/;\n  }\n\n  /**\n   * Retrieves or overrides the regexp used to trust URLs for a[href] sanitization.\n   *\n   * @param {RegExp=} regexp New regexp to trust URLs with.\n   * @returns {RegExp|SanitizeUriProvider} Current regexp if no param, or self for chaining.\n   */\n  aHrefSanitizationTrustedUrlList(regexp) {\n    if (isDefined(regexp)) {\n      this._aHrefSanitizationTrustedUrlList = regexp;\n\n      return this;\n    }\n\n    return this._aHrefSanitizationTrustedUrlList;\n  }\n\n  /**\n   * Retrieves or overrides the regexp used to trust URLs for img[src] sanitization.\n   *\n   * @param {RegExp=} regexp New regexp to trust URLs with.\n   * @returns {RegExp|SanitizeUriProvider} Current regexp if no param, or self for chaining.\n   */\n  imgSrcSanitizationTrustedUrlList(regexp) {\n    if (isDefined(regexp)) {\n      this._imgSrcSanitizationTrustedUrlList = regexp;\n\n      return this;\n    }\n\n    return this._imgSrcSanitizationTrustedUrlList;\n  }\n\n  /**\n   * @returns {import(\"./interface.ts\").SanitizerFn}\n   */\n  $get = [\n    $injectTokens._window,\n    /** @param {ng.WindowService} $window */\n    ($window) => {\n      return /** @type {import(\"./interface.ts\").SanitizerFn} */ (\n        (uri, isMediaUrl) => {\n          if (!uri) return uri;\n\n          /** @type {RegExp} */\n          const regex = isMediaUrl\n            ? this._imgSrcSanitizationTrustedUrlList\n            : this._aHrefSanitizationTrustedUrlList;\n\n          const normalizedVal = new URL(uri.trim(), $window.location.href).href;\n\n          if (normalizedVal !== \"\" && !normalizedVal.match(regex)) {\n            return `unsafe:${normalizedVal}`;\n          }\n\n          return uri;\n        }\n      );\n    },\n  ];\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport {\n  entries,\n  hasOwn,\n  isArray,\n  isInstanceOf,\n  isString,\n} from \"../../shared/utils.js\";\n\nconst ACTIVE_CLASS = \"ng-active\";\n\nconst INACTIVE_CLASS = \"ng-inactive\";\n\nclass NgMessageCtrl {\n  /**\n   * @param {HTMLElement} $element\n   * @param {ng.Scope} $scope\n   * @param {ng.Attributes} $attrs\n   * @param {ng.AnimateService} $animate\n   */\n  constructor($element, $scope, $attrs, $animate) {\n    this._element = $element;\n    this._scope = $scope;\n    this._attrs = $attrs;\n    this._animate = $animate;\n\n    this._latestKey = 0;\n    this._nextAttachId = 0;\n    /** @type {Record<string, any>} */\n    this._messages = {};\n    this._renderLater = false;\n    this._cachedCollection = null;\n\n    this._head = undefined;\n    this._default = undefined;\n\n    this._scope.$watch(\n      this._attrs.ngMessages || this._attrs.for,\n      this._render.bind(this),\n    );\n  }\n\n  _getAttachId() {\n    return this._nextAttachId++;\n  }\n\n  _render(collection = {}) {\n    this._renderLater = false;\n    this._cachedCollection = collection;\n\n    const multiple =\n      isAttrTruthy(this._scope, this._attrs.ngMessagesMultiple) ||\n      isAttrTruthy(this._scope, this._attrs.multiple);\n\n    const unmatchedMessages = [];\n\n    /** @type {Record<string, boolean>} */\n    const matchedKeys = {};\n\n    let truthyKeys = 0;\n\n    let messageItem = this._head;\n\n    let messageFound = false;\n\n    let totalMessages = 0;\n\n    while (messageItem) {\n      totalMessages++;\n      const messageCtrl = messageItem.message;\n\n      let messageUsed = false;\n\n      if (!messageFound) {\n        entries(collection).forEach(([key, value]) => {\n          if (truthy(value) && !messageUsed) {\n            truthyKeys++;\n\n            if (messageCtrl.test(key)) {\n              if (matchedKeys[key]) return;\n              matchedKeys[key] = true;\n\n              messageUsed = true;\n              messageCtrl.attach();\n            }\n          }\n        });\n      }\n\n      if (messageUsed) {\n        messageFound = !multiple;\n      } else {\n        unmatchedMessages.push(messageCtrl);\n      }\n\n      messageItem = messageItem.next;\n    }\n\n    unmatchedMessages.forEach((messageCtrl) => {\n      messageCtrl.detach();\n    });\n\n    const messageMatched = unmatchedMessages.length !== totalMessages;\n\n    const attachDefault = this._default && !messageMatched && truthyKeys > 0;\n\n    if (attachDefault) {\n      this._default.attach();\n    } else if (this._default) {\n      this._default.detach();\n    }\n\n    if (messageMatched || attachDefault) {\n      this._animate.setClass(this._element, ACTIVE_CLASS, INACTIVE_CLASS);\n    } else {\n      this._animate.setClass(this._element, INACTIVE_CLASS, ACTIVE_CLASS);\n    }\n  }\n\n  reRender() {\n    if (!this._renderLater) {\n      this._renderLater = true;\n      Promise.resolve().then(() => {\n        if (this._renderLater && this._cachedCollection) {\n          this._render(this._cachedCollection);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {{ _ngMessageNode: string; }} comment\n   * @param {any} messageCtrl\n   * @param {any} isDefault\n   */\n  register(comment, messageCtrl, isDefault) {\n    if (isDefault) {\n      this._default = messageCtrl;\n    } else {\n      const nextKey = this._latestKey.toString();\n\n      this._messages[nextKey] = {\n        message: messageCtrl,\n      };\n      this.insertMessageNode(this._element, comment, nextKey);\n      comment._ngMessageNode = nextKey;\n      this._latestKey++;\n    }\n\n    this.reRender();\n  }\n\n  /**\n   * @param {{ _ngMessageNode: any; }} comment\n   * @param {any} isDefault\n   */\n  deregister(comment, isDefault) {\n    if (isDefault) {\n      delete this._default;\n    } else {\n      const key = comment._ngMessageNode;\n\n      delete comment._ngMessageNode;\n      this.removeMessageNode(this._element, comment, key);\n      delete this._messages[key];\n    }\n    this.reRender();\n  }\n\n  /**\n   * @param {any} parent\n   * @param {any} comment\n   */\n  findPreviousMessage(parent, comment) {\n    let prevNode = comment;\n\n    const parentLookup = [];\n\n    while (prevNode && prevNode !== parent) {\n      const prevKey = prevNode._ngMessageNode;\n\n      if (prevKey && prevKey.length) {\n        return this._messages[prevKey];\n      }\n\n      if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {\n        parentLookup.push(prevNode);\n        prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];\n      } else if (prevNode.previousSibling) {\n        prevNode = prevNode.previousSibling;\n      } else {\n        prevNode = prevNode.parentNode;\n        parentLookup.push(prevNode);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @param {HTMLElement} parent\n   * @param {{ _ngMessageNode: string; }} comment\n   * @param {string} key\n   */\n  insertMessageNode(parent, comment, key) {\n    const messageNode = this._messages[key];\n\n    if (!this._head) {\n      this._head = messageNode;\n    } else {\n      const match = this.findPreviousMessage(parent, comment);\n\n      if (match) {\n        messageNode.next = match.next;\n        match.next = messageNode;\n      } else {\n        messageNode.next = this._head;\n        this._head = messageNode;\n      }\n    }\n  }\n\n  /**\n   * @param {HTMLElement} parent\n   * @param {{ _ngMessageNode: any; }} comment\n   * @param {string | number} key\n   */\n  removeMessageNode(parent, comment, key) {\n    const messageNode = this._messages[key];\n\n    if (!messageNode) return;\n\n    const match = this.findPreviousMessage(parent, comment);\n\n    if (match) {\n      match.next = messageNode.next;\n    } else {\n      this._head = messageNode.next;\n    }\n  }\n}\n\nngMessagesDirective.$inject = [$injectTokens._animate];\n/**\n * @param {ng.AnimateService} $animate\n * @returns {ng.Directive<NgMessageCtrl>}\n */\nexport function ngMessagesDirective($animate) {\n  return {\n    require: \"ngMessages\",\n    restrict: \"AE\",\n    controller:\n      /**\n       * @param {HTMLElement} $element\n       * @param {ng.Scope} $scope\n       * @param {ng.Attributes} $attrs\n       * @returns {NgMessageCtrl}\n       */\n      ($element, $scope, $attrs) =>\n        new NgMessageCtrl($element, $scope, $attrs, $animate),\n  };\n}\n\n/**\n * @param {ng.Scope} scope\n * @param {string} attr\n */\nfunction isAttrTruthy(scope, attr) {\n  return (\n    (isString(attr) && attr.length === 0) || // empty attribute\n    truthy(attr && scope.$eval(attr))\n  );\n}\n\n/**\n * @param {unknown} val\n */\nfunction truthy(val) {\n  return isString(val) ? val.length : !!val;\n}\n\nngMessagesIncludeDirective.$inject = [\n  $injectTokens._templateRequest,\n  $injectTokens._compile,\n];\n\n/**\n * @param {ng.TemplateRequestService} $templateRequest\n * @param {ng.CompileService} $compile\n * @returns {ng.Directive}\n */\nexport function ngMessagesIncludeDirective($templateRequest, $compile) {\n  return {\n    restrict: \"AE\",\n    require: \"^^ngMessages\", // we only require this for validation sake\n    link($scope, element, attrs) {\n      const src = attrs.ngMessagesInclude || attrs.src;\n\n      $templateRequest(src).then((html) => {\n        if ($scope._destroyed) return;\n\n        if (isString(html) && !html.trim()) {\n          // Empty template - nothing to compile\n        } else {\n          // Non-empty template - compile and link\n          $compile(html)($scope, (contents) => {\n            isInstanceOf(contents, Node) && element.after(contents);\n          });\n        }\n      });\n    },\n  };\n}\n\nexport const ngMessageDirective = ngMessageDirectiveFactory(false);\nexport const ngMessageExpDirective = ngMessageDirectiveFactory(false);\nexport const ngMessageDefaultDirective = ngMessageDirectiveFactory(true);\n\n/**\n * @param {boolean} isDefault\n * @returns {($animate: ng.AnimateService) => ng.Directive}\n */\nfunction ngMessageDirectiveFactory(isDefault) {\n  ngMessageDirectiveFn.$inject = [$injectTokens._animate];\n  /**\n   * @param {ng.AnimateService} $animate\n   * @returns {ng.Directive}\n   */\n  function ngMessageDirectiveFn($animate) {\n    return {\n      restrict: \"AE\",\n      transclude: \"element\",\n      priority: 1, // must run before ngBind, otherwise the text is set on the comment\n      terminal: true,\n      require: \"^^ngMessages\",\n      link(scope, element, attrs, ngMessagesCtrl, $transclude) {\n        /**\n         * @type {HTMLElement}\n         */\n        let commentNode = element;\n\n        /**\n         * @type {any}\n         */\n        let records;\n\n        let staticExp;\n\n        let dynamicExp;\n\n        if (!isDefault) {\n          commentNode = element;\n          staticExp = attrs.ngMessage || attrs.when;\n          dynamicExp = attrs.ngMessageExp || attrs.whenExp;\n\n          const assignRecords = function (/** @type {string} */ items) {\n            records = items\n              ? isArray(items)\n                ? items\n                : items.split(/[\\s,]+/)\n              : null;\n            ngMessagesCtrl.reRender();\n          };\n\n          if (dynamicExp) {\n            assignRecords(scope.$eval(dynamicExp));\n            scope.$watch(dynamicExp, assignRecords);\n          } else {\n            assignRecords(staticExp);\n          }\n        }\n\n        /**\n         * @type {HTMLElement & { _attachId?: number } | undefined | null}\n         */\n        let currentElement;\n\n        /**\n         * @type {{ detach: any; test?: (name: any) => boolean | undefined; attach?: () => void; }}\n         */\n        let messageCtrl;\n\n        ngMessagesCtrl.register(\n          commentNode,\n          (messageCtrl = {\n            test(name) {\n              return contains(records, name);\n            },\n            attach() {\n              if (!currentElement) {\n                /** @type {ng.TranscludeFn} */ ($transclude)(\n                  (elm, newScope) => {\n                    $animate.enter(\n                      /** @type {HTMLElement} */ (elm),\n                      null,\n                      element,\n                    );\n                    currentElement =\n                      /** @type {HTMLElement & { _attachId?: number }} */ (elm);\n\n                    // Each time we attach this node to a message we get a new id that we can match\n                    // when we are destroying the node later.\n                    const attachId = (currentElement._attachId =\n                      ngMessagesCtrl._getAttachId());\n\n                    // in the event that the element or a parent element is destroyed\n                    // by another structural directive then it's time\n                    // to deregister the message from the controller\n                    currentElement.addEventListener(\"$destroy\", () => {\n                      // If the message element was removed via a call to `detach` then `currentElement` will be null\n                      // So this handler only handles cases where something else removed the message element.\n                      if (\n                        currentElement &&\n                        currentElement._attachId === attachId\n                      ) {\n                        ngMessagesCtrl.deregister(commentNode, isDefault);\n                        messageCtrl.detach();\n                      }\n                      /** @type {ng.Scope} */ (newScope).$destroy();\n                    });\n                  },\n                );\n              }\n            },\n            detach() {\n              if (currentElement) {\n                const elm = currentElement;\n\n                currentElement = null;\n                $animate.leave(/** @type {HTMLElement} */ (elm));\n              }\n            },\n          }),\n          isDefault,\n        );\n\n        // We need to ensure that this directive deregisters itself when it no longer exists\n        // Normally this is done when the attached element is destroyed; but if this directive\n        // gets removed before we attach the message to the DOM there is nothing to watch\n        // in which case we must deregister when the containing scope is destroyed.\n        scope.$on(\"$destroy\", () => {\n          ngMessagesCtrl.deregister(commentNode, isDefault);\n        });\n      },\n    };\n  }\n\n  return ngMessageDirectiveFn;\n}\n\n/**\n * @param {string | object | Array<any>} collection\n * @param {string | number | symbol} key\n */\nfunction contains(collection, key) {\n  if (collection) {\n    return isArray(collection)\n      ? collection.indexOf(key) >= 0\n      : hasOwn(/** @type {object} */ (collection), key);\n  }\n\n  return undefined;\n}\n","import { extend, hasOwn } from \"../../shared/utils.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\nconst ARIA_DISABLE_ATTR = \"ngAriaDisable\";\n\n/**\n * Internal Utilities\n */\nconst nativeAriaNodeNames = [\n  \"BUTTON\",\n  \"A\",\n  \"INPUT\",\n  \"TEXTAREA\",\n  \"SELECT\",\n  \"DETAILS\",\n  \"SUMMARY\",\n];\n\nconst isNodeOneOf = function (\n  /** @type {HTMLElement} */ elem,\n  /** @type {string | any[]} */ nodeTypeArray,\n) {\n  return nodeTypeArray.indexOf(elem.nodeName) !== -1;\n};\n\n/**\n * Used for configuring the ARIA attributes injected and managed by ngAria.\n *\n * ```js\n * angular.module('myApp', ['ngAria'], function config($ariaProvider) {\n *   $ariaProvider.config({\n *     ariaValue: true,\n *     tabindex: false\n *   });\n * });\n *```\n *\n * ## Dependencies\n * Requires the {@link ngAria} module to be installed.\n *\n */\nexport function AriaProvider() {\n  /** @type {Record<string, any>} */\n  let config = {\n    ariaHidden: true,\n    ariaChecked: true,\n    ariaReadonly: true,\n    ariaDisabled: true,\n    ariaRequired: true,\n    ariaInvalid: true,\n    ariaValue: true,\n    tabindex: true,\n    bindKeydown: true,\n    bindRoleForClick: true,\n  };\n\n  this.config = function (/** @type {Object} */ newConfig) {\n    config = extend(config, newConfig);\n  };\n\n  /**\n   * @param {string | number} attrName\n   * @param {any} ariaAttr\n   * @param {string | any[]} nativeAriaNodeNamesParam\n   * @param {any} negate\n   */\n  function watchExpr(attrName, ariaAttr, nativeAriaNodeNamesParam, negate) {\n    return function (\n      /** @type {ng.Scope} */ scope,\n      /** @type {HTMLElement} */ elem,\n      /** @type {ng.Attributes} */ attr,\n    ) {\n      if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;\n\n      const ariaCamelName = attr.$normalize(ariaAttr);\n\n      if (\n        config[ariaCamelName] &&\n        !isNodeOneOf(elem, nativeAriaNodeNamesParam) &&\n        !attr[ariaCamelName]\n      ) {\n        scope.$watch(attr[attrName], (boolVal) => {\n          // ensure boolean value\n          boolVal = negate ? !boolVal : !!boolVal;\n          elem.setAttribute(ariaAttr, boolVal);\n        });\n      }\n    };\n  }\n\n  this.$get = function () {\n    return {\n      /**\n       * @param {string | number} key\n       */\n      config(key) {\n        return config[key];\n      },\n      _watchExpr: watchExpr,\n    };\n  };\n}\n\nngDisabledAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n */\nexport function ngDisabledAriaDirective($aria) {\n  return $aria._watchExpr(\n    \"ngDisabled\",\n    \"aria-disabled\",\n    nativeAriaNodeNames,\n    false,\n  );\n}\n\nngShowAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n */\nexport function ngShowAriaDirective($aria) {\n  return $aria._watchExpr(\"ngShow\", \"aria-hidden\", [], true);\n}\n\n/**\n * @return {ng.Directive}\n */\nexport function ngMessagesAriaDirective() {\n  return {\n    restrict: \"A\",\n    require: \"?ngMessages\",\n    link(_scope, elem, attr) {\n      if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;\n\n      if (!elem.hasAttribute(\"aria-live\")) {\n        elem.setAttribute(\"aria-live\", \"assertive\");\n      }\n    },\n  };\n}\n\nngClickAriaDirective.$inject = [$injectTokens._aria, $injectTokens._parse];\n\n/**\n * @param {ng.AriaService} $aria\n * @param {ng.ParseService} $parse\n * @return {ng.Directive}\n */\nexport function ngClickAriaDirective($aria, $parse) {\n  return {\n    restrict: \"A\",\n    compile(_elem, attr) {\n      if (hasOwn(attr, ARIA_DISABLE_ATTR)) return undefined;\n\n      const fn = $parse(attr.ngClick);\n\n      return (scope, elem, attrParam) => {\n        if (!isNodeOneOf(elem, nativeAriaNodeNames)) {\n          if ($aria.config(\"bindRoleForClick\") && !elem.hasAttribute(\"role\")) {\n            elem.setAttribute(\"role\", \"button\");\n          }\n\n          if ($aria.config(\"tabindex\") && !elem.hasAttribute(\"tabindex\")) {\n            elem.setAttribute(\"tabindex\", \"0\");\n          }\n\n          if (\n            $aria.config(\"bindKeydown\") &&\n            !attrParam.ngKeydown &&\n            !attrParam.ngKeypress &&\n            !attrParam.ngKeyup\n          ) {\n            elem.addEventListener(\n              \"keydown\",\n              /** @param {KeyboardEvent} event */\n              (event) => {\n                const keyCode = parseInt(event.key, 10);\n\n                // eslint-disable-next-line no-magic-numbers\n                if (keyCode === 13 || keyCode === 32) {\n                  // If the event is triggered on a non-interactive element ...\n                  if (\n                    nativeAriaNodeNames.indexOf(\n                      /** @type {Node} */ (event.target).nodeName,\n                    ) === -1 &&\n                    !(\n                      /** @type {HTMLElement} */ (event.target)\n                        .isContentEditable\n                    )\n                  ) {\n                    // ... prevent the default browser behavior (e.g. scrolling when pressing spacebar)\n                    // See https://github.com/angular/angular.js/issues/16664\n                    event.preventDefault();\n                  }\n                  fn(scope, { $event: event });\n                }\n              },\n            );\n          }\n        }\n      };\n    },\n  };\n}\n\nngRequiredAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n */\nexport function ngRequiredAriaDirective($aria) {\n  return $aria._watchExpr(\n    \"ngRequired\",\n    \"aria-required\",\n    nativeAriaNodeNames,\n    false,\n  );\n}\n\nngCheckedAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n */\nexport function ngCheckedAriaDirective($aria) {\n  return $aria._watchExpr(\n    \"ngChecked\",\n    \"aria-checked\",\n    nativeAriaNodeNames,\n    false,\n  );\n}\n\nngValueAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n */\nexport function ngValueAriaDirective($aria) {\n  return $aria._watchExpr(\n    \"ngValue\",\n    \"aria-checked\",\n    nativeAriaNodeNames,\n    false,\n  );\n}\n\nngHideAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n */\nexport function ngHideAriaDirective($aria) {\n  return $aria._watchExpr(\"ngHide\", \"aria-hidden\", [], false);\n}\n\nngReadonlyAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n */\nexport function ngReadonlyAriaDirective($aria) {\n  return $aria._watchExpr(\n    \"ngReadonly\",\n    \"aria-readonly\",\n    nativeAriaNodeNames,\n    false,\n  );\n}\n\nngModelAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n * @returns {ng.Directive}\n */\nexport function ngModelAriaDirective($aria) {\n  /**\n   * @param {string} attr\n   * @param {string} normalizedAttr\n   * @param {HTMLElement} elem\n   * @param {boolean} allowNonAriaNodes\n   */\n  function shouldAttachAttr(attr, normalizedAttr, elem, allowNonAriaNodes) {\n    return (\n      $aria.config(normalizedAttr) &&\n      !elem.getAttribute(attr) &&\n      (allowNonAriaNodes || !isNodeOneOf(elem, nativeAriaNodeNames)) &&\n      (elem.getAttribute(\"type\") !== \"hidden\" || elem.nodeName !== \"INPUT\")\n    );\n  }\n\n  /**\n   * @param {string} role\n   * @param {HTMLElement} elem\n   */\n  function shouldAttachRole(role, elem) {\n    // if element does not have role attribute\n    // AND element type is equal to role (if custom element has a type equaling shape) <-- remove?\n    // AND element is not in nativeAriaNodeNames\n    return (\n      !elem.getAttribute(\"role\") &&\n      elem.getAttribute(\"type\") === role &&\n      !isNodeOneOf(elem, nativeAriaNodeNames)\n    );\n  }\n\n  /**\n   * @param {ng.Attributes} attr\n   * @returns {string}\n   */\n  function getShape(attr) {\n    const { type } = attr;\n\n    const { role } = attr;\n\n    return (type || role) === \"checkbox\" || role === \"menuitemcheckbox\"\n      ? \"checkbox\"\n      : (type || role) === \"radio\" || role === \"menuitemradio\"\n        ? \"radio\"\n        : type === \"range\" || role === \"progressbar\" || role === \"slider\"\n          ? \"range\"\n          : \"\";\n  }\n\n  return {\n    restrict: \"A\",\n    require: \"ngModel\",\n    priority: 200, // Make sure watches are fired after any other directives that affect the ngModel value\n    compile(_, attr) {\n      if (hasOwn(attr, ARIA_DISABLE_ATTR)) return undefined;\n\n      const shape = getShape(attr);\n\n      return {\n        // eslint-disable-next-line no-shadow\n        post(_, elem, attrPost, ngModel) {\n          const needsTabIndex = shouldAttachAttr(\n            \"tabindex\",\n            \"tabindex\",\n            elem,\n            false,\n          );\n\n          function getRadioReaction() {\n            // Strict comparison would cause a BC\n            elem.setAttribute(\n              \"aria-checked\",\n              // eslint-disable-next-line eqeqeq\n              (attrPost.value == ngModel.$viewValue).toString(),\n            );\n          }\n\n          function getCheckboxReaction() {\n            elem.setAttribute(\n              \"aria-checked\",\n              (!ngModel.$isEmpty(ngModel.$viewValue)).toString(),\n            );\n          }\n\n          switch (shape) {\n            case \"radio\":\n            case \"checkbox\":\n              if (shouldAttachRole(shape, elem)) {\n                elem.setAttribute(\"role\", shape);\n              }\n\n              if (\n                shouldAttachAttr(\"aria-checked\", \"ariaChecked\", elem, false)\n              ) {\n                ngModel.$watch(\n                  \"$modelValue\",\n                  shape === \"radio\" ? getRadioReaction : getCheckboxReaction,\n                );\n              }\n\n              if (needsTabIndex) {\n                elem.setAttribute(\"tabindex\", \"0\");\n              }\n              break;\n            case \"range\":\n              if (shouldAttachRole(shape, elem)) {\n                elem.setAttribute(\"role\", \"slider\");\n              }\n\n              if ($aria.config(\"ariaValue\")) {\n                const needsAriaValuemin =\n                  !elem.hasAttribute(\"aria-valuemin\") &&\n                  (hasOwn(attrPost, \"min\") || hasOwn(attrPost, \"ngMin\"));\n\n                const needsAriaValuemax =\n                  !elem.hasAttribute(\"aria-valuemax\") &&\n                  (hasOwn(attrPost, \"max\") || hasOwn(attrPost, \"ngMax\"));\n\n                const needsAriaValuenow = !elem.hasAttribute(\"aria-valuenow\");\n\n                if (needsAriaValuemin) {\n                  attrPost.$observe(\"min\", (newVal) => {\n                    elem.setAttribute(\"aria-valuemin\", newVal);\n                  });\n                }\n\n                if (needsAriaValuemax) {\n                  attrPost.$observe(\"max\", (newVal) => {\n                    elem.setAttribute(\"aria-valuemax\", newVal);\n                  });\n                }\n\n                if (needsAriaValuenow) {\n                  ngModel.$watch(\n                    \"$modelValue\",\n                    (/** @type {string} */ newVal) => {\n                      elem.setAttribute(\"aria-valuenow\", newVal);\n                    },\n                  );\n                }\n              }\n\n              if (needsTabIndex) {\n                elem.setAttribute(\"tabindex\", \"0\");\n              }\n              break;\n          }\n\n          if (\n            !hasOwn(attrPost, \"ngRequired\") &&\n            ngModel.$validators.required &&\n            shouldAttachAttr(\"aria-required\", \"ariaRequired\", elem, false)\n          ) {\n            // ngModel.$error.required is undefined on custom controls\n            attrPost.$observe(\"required\", () => {\n              elem.setAttribute(\n                \"aria-required\",\n                (!!attrPost.required).toString(),\n              );\n            });\n          }\n\n          if (shouldAttachAttr(\"aria-invalid\", \"ariaInvalid\", elem, true)) {\n            ngModel.$watch(\"$invalid\", (/** @type {any} */ newVal) => {\n              elem.setAttribute(\"aria-invalid\", (!!newVal).toString());\n            });\n          }\n        },\n      };\n    },\n  };\n}\n\nngDblclickAriaDirective.$inject = [$injectTokens._aria];\n/**\n * @param {ng.AriaService} $aria\n * @returns {import(\"../../interface.js\").DirectiveLinkFn<any>}\n */\nexport function ngDblclickAriaDirective($aria) {\n  return function (_scope, elem, attr) {\n    if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;\n\n    if (\n      $aria.config(\"tabindex\") &&\n      !elem.hasAttribute(\"tabindex\") &&\n      !isNodeOneOf(elem, nativeAriaNodeNames)\n    ) {\n      elem.setAttribute(\"tabindex\", \"0\");\n    }\n  };\n}\n","/**\n * Hybrid AnimateRunner\n * Supports both CSS animations (batched) and JS animations (per-Tick).\n *\n * The runner:\n *   - tracks completion state\n *   - supports done callbacks\n *   - exposes a host API (end, cancel, pause, resume)\n *   - can be awaited as a Promise\n *\n * It intentionally mirrors AngularJS 1.x $$AnimateRunner behavior.\n */\n\n/**\n * @typedef {import(\"../interface.ts\").AnimationHost} AnimationHost\n */\n\n/**\n * Internal runner states.\n * @internal\n * @enum {number}\n */\nconst RunnerState = {\n  /** Initial state before any completion logic started */\n  _INITIAL: 0,\n\n  /** Completion has been scheduled but not finished */\n  _PENDING: 1,\n\n  /** The runner is fully completed and callbacks fired */\n  _DONE: 2,\n};\n\n/**\n * Global queue used to batch CSS animation callbacks.\n * @type {Array<VoidFunction>}\n */\nlet queue = [];\n\n/** @type {boolean} */\nlet scheduled = false;\n\n/**\n * Flushes all queued callbacks in FIFO order.\n * @private\n */\nfunction flush() {\n  const tasks = queue;\n\n  queue = [];\n  scheduled = false;\n\n  for (let i = 0; i < tasks.length; i++) {\n    tasks[i]();\n  }\n}\n\n/**\n * Schedules a callback for next animation frame,\n * falling back to setTimeout(0) when RAF is unavailable.\n *\n * @param {VoidFunction} fn\n */\nfunction schedule(fn) {\n  queue.push(fn);\n\n  if (!scheduled) {\n    scheduled = true;\n\n    requestAnimationFrame(flush);\n  }\n}\n\nexport class AnimateRunner {\n  /**\n   * @param {AnimationHost} [host] - Optional animation host callbacks.\n   * @param {boolean} [jsAnimation=false]\n   *        If true: use RAF/timer ticks.\n   *        If false: use batched CSS animation ticks.\n   */\n  constructor(host = {}, jsAnimation = false) {\n    /** @type {AnimationHost} */\n    this._host = host;\n\n    /** @type {Array<(ok: boolean) => void>} */\n    this._doneCallbacks = [];\n\n    /** @type {RunnerState} */\n    this._state = RunnerState._INITIAL;\n\n    /**\n     * Deferred promise used by .then/.catch/.finally.\n     * @type {Promise<void>|null}\n     * @private\n     */\n    this._promise = null;\n\n    /**\n     * Internal tick scheduling function.\n     * - JS animations: immediate RAF or fallback timer\n     * - CSS animations: batched global queue\n     * @type {(fn: VoidFunction) => void}\n     * @private\n     */\n    if (jsAnimation) {\n      /** @type {(fn: VoidFunction) => void} */\n      const rafTick = (fn) => {\n        requestAnimationFrame(fn);\n      };\n\n      /** @type {(fn: VoidFunction) => void} */\n      const timeoutTick = (fn) => {\n        setTimeout(fn, 0);\n      };\n\n      /** @type {(fn: VoidFunction) => void} */\n      this._tick = (fn) => {\n        // When tab is hidden, requestAnimationFrame throttles heavily.\n        if (document.hidden) timeoutTick(fn);\n        else rafTick(fn);\n      };\n    } else {\n      this._tick = schedule;\n    }\n  }\n\n  /**\n   * Sets or replaces the current host.\n   * @param {AnimationHost} host\n   */\n  setHost(host) {\n    this._host = host || {};\n  }\n\n  /**\n   * Register a completion callback.\n   * Fires immediately if animation is already done.\n   *\n   * @param {(ok: boolean) => void} fn\n   */\n  done(fn) {\n    if (this._state === RunnerState._DONE) {\n      fn(true);\n    } else {\n      this._doneCallbacks.push(fn);\n    }\n  }\n\n  /**\n   * Reports progress to host.\n   * @param {...any} args\n   */\n  progress(...args) {\n    this._host.progress?.(...args);\n  }\n\n  /** Pause underlying animation (if supported). */\n  pause() {\n    this._host.pause?.();\n  }\n\n  /** Resume underlying animation (if supported). */\n  resume() {\n    this._host.resume?.();\n  }\n\n  /**\n   * Ends the animation successfully.\n   * Equivalent to user choosing to finish it immediately.\n   */\n  end() {\n    this._host.end?.();\n    this._finish(true);\n  }\n\n  /**\n   * Cancels the animation.\n   */\n  cancel() {\n    this._host.cancel?.();\n    this._finish(false);\n  }\n\n  /**\n   * Schedule animation completion.\n   *\n   * @param {boolean} [status=true]\n   */\n  complete(status = true) {\n    if (this._state === RunnerState._INITIAL) {\n      this._state = RunnerState._PENDING;\n      this._tick(() => this._finish(status));\n    }\n  }\n\n  /**\n   * Completes the animation and invokes all done callbacks.\n   * @param {boolean} status\n   * @private\n   */\n  _finish(status) {\n    if (this._state === RunnerState._DONE) return;\n\n    this._state = RunnerState._DONE;\n\n    const callbacks = this._doneCallbacks;\n\n    this._doneCallbacks = [];\n\n    for (let i = 0; i < callbacks.length; i++) {\n      callbacks[i] && callbacks[i](status);\n    }\n  }\n\n  /**\n   * Returns an internal promise that resolves on success,\n   * and rejects on cancel.\n   *\n   * @returns {Promise<void>}\n   */\n  getPromise() {\n    if (!this._promise) {\n      this._promise = new Promise((resolve, reject) => {\n        this.done((ok) => (ok === false ? reject() : resolve()));\n      });\n    }\n\n    return this._promise;\n  }\n\n  /**\n   * Standard \"thenable\" interface\n   * @template T\n   * @param {(value: void) => T|Promise<T>} onFulfilled\n   * @param {(reason: any) => any} [onRejected]\n   * @returns {Promise<T>}\n   */\n  then(onFulfilled, onRejected) {\n    return this.getPromise().then(onFulfilled, onRejected);\n  }\n\n  /**\n   * Standard promise catcher.\n   * @param {(reason: any) => any} onRejected\n   * @returns {Promise<void>}\n   */\n  catch(onRejected) {\n    return this.getPromise().catch(onRejected);\n  }\n\n  /**\n   * Standard promise finally.\n   * @param {() => any} onFinally\n   * @returns {Promise<void>}\n   */\n  finally(onFinally) {\n    return this.getPromise().finally(onFinally);\n  }\n\n  // ---------------------------------------------------------------------------\n  //  STATIC HELPERS\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Executes a list of runners sequentially.\n   * Each must complete before the next starts.\n   *\n   * @param {AnimateRunner[]} runners\n   * @param {(ok: boolean) => void} callback\n   */\n  static _chain(runners, callback) {\n    let i = 0;\n\n    const next = (ok = true) => {\n      if (!ok || i >= runners.length) {\n        callback(ok);\n\n        return;\n      }\n      runners[i++].done(next);\n    };\n\n    next();\n  }\n\n  /**\n   * Waits until all runners complete.\n   *\n   * @param {AnimateRunner[]} runners\n   * @param {(ok: boolean) => void} callback\n   */\n  static _all(runners, callback) {\n    let remaining = runners.length;\n\n    let status = true;\n\n    for (const i of runners) {\n      i.done((result) => {\n        if (result === false) status = false;\n\n        if (--remaining === 0) callback(status);\n      });\n    }\n  }\n}\n","const KEY = \"$animId\";\n\n/**\n * Animation cache responsible for:\n *  - Generating stable animation cache keys\n *  - Tracking cached animation results\n *  - Avoiding repeated animation work\n *\n * Cache keys are scoped per parent node to prevent collisions between\n * structurally identical nodes in different DOM subtrees.\n *\n * @internal\n */\nexport class AnimateCache {\n  /** @type {Map<string, import(\"./interface.ts\").CacheEntry>} */\n  #cache = new Map();\n\n  /**\n   * Monotonically increasing counter used to assign synthetic parent IDs.\n   * IDs are stored directly on parent nodes under `$animId`.\n   *\n   */\n  #parentCounter = 0;\n\n  /**\n   * Generates a stable cache key for an animation invocation.\n   *\n   * The key is derived from:\n   *  - The node's parent (used as a cache namespace)\n   *  - The animation method (e.g. enter, leave, addClass)\n   *  - The node's current CSS class state\n   *  - Any classes being added or removed\n   *\n   * If the node is not attached to the DOM, the node itself is used\n   * as the parent scope to avoid key collisions.\n   *\n   * @param {HTMLElement} node\n   *   Target element being animated.\n   * @param {string} method\n   *   Animation method name.\n   * @param {string} [addClass]\n   *   CSS class scheduled to be added during the animation.\n   * @param {string} [removeClass]\n   *   CSS class scheduled to be removed during the animation.\n   *\n   * @returns {string}\n   *   A unique, deterministic cache key.\n   */\n  _cacheKey(node, method, addClass, removeClass) {\n    const parent = /** @type {HTMLElement & Record<string, number>} */ (\n      node.parentNode ?? node\n    );\n\n    const parentID = parent[KEY] ?? (parent[KEY] = ++this.#parentCounter);\n\n    const parts = [parentID, method, node.getAttribute(\"class\")];\n\n    if (addClass) parts.push(addClass);\n\n    if (removeClass) parts.push(removeClass);\n\n    return parts.join(\" \");\n  }\n\n  /**\n   * Determines whether a cache entry exists but is marked as invalid.\n   *\n   * This is typically used to detect animations that were previously\n   * cached but resolved without a duration.\n   *\n   * @param {string} key\n   *   Cache key to test.\n   * @returns {boolean}\n   *   True if an invalid cache entry exists, false otherwise.\n   */\n  _containsCachedAnimationWithoutDuration(key) {\n    const entry = this.#cache.get(key);\n\n    return !!entry && !entry.isValid;\n  }\n\n  /**\n   * Clears all cached animation entries.\n   *\n   * Does not reset parent IDs.\n   *\n   * @returns {void}\n   */\n  _flush() {\n    this.#cache.clear();\n  }\n\n  /**\n   * Returns the number of times a cache entry has been used.\n   *\n   * @param {string} key\n   *   Cache key to query.\n   * @returns {number}\n   *   Usage count, or 0 if the entry does not exist.\n   */\n  _count(key) {\n    return this.#cache.get(key)?.total ?? 0;\n  }\n\n  /**\n   * Retrieves the cached value associated with a cache key.\n   *\n   * @param {string} key\n   *   Cache key to retrieve.\n   * @returns {any}\n   *   Cached value, or undefined if not present.\n   */\n  _get(key) {\n    return this.#cache.get(key)?.value;\n  }\n\n  /**\n   * Inserts or updates a cache entry.\n   *\n   * Existing entries will have their usage count incremented\n   * and their value replaced.\n   *\n   * @param {string} key\n   *   Cache key.\n   * @param {any} value\n   *   Value to cache.\n   * @param {boolean} isValid\n   *   Whether the cached value is considered valid.\n   *\n   * @returns {void}\n   */\n  _put(key, value, isValid) {\n    const entry = this.#cache.get(key);\n\n    if (entry) {\n      entry.total++;\n      entry.value = value;\n    } else {\n      this.#cache.set(key, { total: 1, value, isValid });\n    }\n  }\n}\n\nexport const animateCache = new AnimateCache();\n","/**\n * A requestAnimationFrame-based scheduler.\n */\nexport class RafScheduler {\n  constructor() {\n    /**\n     * Internal task queue, where each item is an array of functions to run.\n     * @type {Array<() => void>}\n     */\n    this._queue = [];\n\n    /**\n     * ID of the currently scheduled animation frame (if any).\n     * Used for cancellation and tracking.\n     * @type {number|null}\n     */\n    this._cancelFn = null;\n  }\n\n  /**\n   * Processes the next batch of tasks in the animation frame.\n   * Executes the first group of functions in the queue, then\n   * schedules the next frame if needed.\n   */\n  _nextTick() {\n    if (!this._queue.length) return;\n\n    while (this._queue.length) {\n      /** @type {() => void} */ (this._queue.shift())();\n    }\n\n    if (!this._cancelFn) {\n      this._cancelFn = window.requestAnimationFrame(() => {\n        this._cancelFn = null;\n        this._nextTick();\n      });\n    }\n  }\n\n  /**\n   * The main scheduler function.\n   * Accepts an array of functions and schedules them to run in the next available frame(s).\n   *\n   * @param {Array<() => void>} tasks\n   */\n  _schedule(tasks) {\n    this._queue.push(...tasks);\n    this._nextTick();\n  }\n\n  /**\n   * Cancels any pending frame and runs the given function once the frame is idle.\n   * Useful for debounced updates.\n   *\n   * @param {Function} fn - Function to run when the animation frame is quiet.\n   */\n  _waitUntilQuiet(fn) {\n    if (this._cancelFn !== null) {\n      window.cancelAnimationFrame(this._cancelFn);\n      this._cancelFn = null;\n    }\n\n    this._cancelFn = window.requestAnimationFrame(() => {\n      this._cancelFn = null;\n      fn();\n      this._nextTick();\n    });\n  }\n}\n\nexport const rafScheduler = new RafScheduler();\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport {\n  getCacheData,\n  removeElementData,\n  setCacheData,\n} from \"../../shared/dom.js\";\nimport {\n  entries,\n  isArray,\n  isDefined,\n  isNullOrUndefined,\n  isString,\n  keys,\n  nullObject,\n} from \"../../shared/utils.js\";\nimport { AnimateRunner } from \"../runner/animate-runner.js\";\nimport {\n  ACTIVE_CLASS_SUFFIX,\n  ADD_CLASS_SUFFIX,\n  EVENT_CLASS_PREFIX,\n  REMOVE_CLASS_SUFFIX,\n  applyAnimationClassesFactory,\n  applyAnimationFromStyles,\n  applyAnimationStyles,\n  applyAnimationToStyles,\n  applyInlineStyle,\n  _blockKeyframeAnimations,\n  packageStyles,\n  pendClasses,\n  prepareAnimationOptions,\n} from \"../shared.js\";\nimport { animateCache } from \"../cache/animate-cache.js\";\nimport { rafScheduler } from \"../raf/raf-scheduler.js\";\n\nconst ANIMATE_TIMER_KEY = $injectTokens._animateCss;\n\nconst ONE_SECOND = 1000;\n\nconst SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nconst ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\n\nconst CLOSING_TIME_BUFFER = 1.5;\n\nconst DETECT_CSS_PROPERTIES = {\n  transitionDuration: \"transitionDuration\",\n  transitionDelay: \"transitionDelay\",\n  transitionProperty: \"transitionProperty\",\n  animationDuration: \"animationDuration\",\n  animationDelay: \"animationDelay\",\n  animationIterationCount: \"animationIterationCount\",\n};\n\nconst DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration: \"transitionDuration\",\n  transitionDelay: \"transitionDelay\",\n  animationDuration: \"animationDuration\",\n  animationDelay: \"animationDelay\",\n};\n\n/**\n * @param {any} duration\n */\nfunction getCssKeyframeDurationStyle(duration) {\n  return [\"animationDuration\", `${duration}s`];\n}\n\n/**\n * @param {number | undefined} delay\n * @param {boolean | undefined} [isKeyframeAnimation]\n */\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  const prop = isKeyframeAnimation ? \"animationDelay\" : \"transitionDelay\";\n\n  return [prop, `${delay}s`];\n}\n\n/**\n * @param {Element} element\n * @param {{ [s: string]: string } | ArrayLike<string>} properties\n * @returns {{ [s: string]: number | null }}\n */\nfunction computeCssStyles(element, properties) {\n  const styles = nullObject();\n\n  const detectedStyles =\n    /** @type {CSSStyleDeclaration & import(\"../../shared/interface.ts\").Dict<string>} */\n    (window.getComputedStyle(element) || {});\n\n  entries(properties).forEach(([actualStyleName, formalStyleName]) => {\n    /** @type {string | number | null} */\n    let val = detectedStyles[formalStyleName];\n\n    if (val) {\n      if (isString(val) && /^[+-]?\\d/.test(val)) {\n        val = parseMaxTime(val); // number\n      }\n\n      if (val === 0) {\n        val = null;\n      }\n\n      styles[actualStyleName] = /** @type {number | null} */ (val);\n    }\n  });\n\n  return styles;\n}\n\n/**\n * Parse a CSS time value (or comma-separated list of values) and return the maximum duration.\n *\n * Accepts values expressed in seconds (`s`) or milliseconds (`ms`) as returned by `getComputedStyle()`,\n * e.g. `\"0.2s\"`, `\"150ms\"`, or `\"0.2s, 150ms\"`. Milliseconds are converted to seconds before comparison.\n *\n * Invalid tokens are ignored. If no valid numeric token is found, the result is `0`.\n *\n * @param {string} str A CSS time string (optionally comma-separated).\n * @returns {number} The maximum time value, expressed in **seconds**.\n */\nexport function parseMaxTime(str) {\n  let max = 0;\n\n  str.split(/\\s*,\\s*/).forEach((token) => {\n    if (!token) return;\n\n    // Computed styles usually return either \"Xs\" or \"Yms\"\n    // (but we accept plain numbers too).\n    let num;\n\n    if (token.endsWith(\"ms\")) {\n      num = parseFloat(token.slice(0, -2));\n\n      if (!isNaN(num)) num = num / 1000;\n    } else if (token.endsWith(\"s\")) {\n      num = parseFloat(token.slice(0, -1));\n    } else {\n      num = parseFloat(token);\n    }\n\n    if (!isNaN(num)) {\n      max = Math.max(max, num);\n    }\n  });\n\n  return max;\n}\n\n/**s\n * @param {unknown} val\n */\nfunction truthyTimingValue(val) {\n  return val === 0 || !isNullOrUndefined(val);\n}\n\n/**\n * @param {string | number | undefined} duration\n * @param {boolean} applyOnlyDuration\n * @return {import(\"../interface.ts\").InlineStyleEntry}\n */\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  let style = \"transition\";\n\n  let value = `${duration}s`;\n\n  if (applyOnlyDuration) {\n    style += \"Duration\";\n  } else {\n    value += \" linear all\";\n  }\n\n  return [style, value];\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\n/**\n * @param {{ [x: string]: any; }} backup\n * @param {HTMLElement} node\n * @param {any[]} properties\n */\nfunction registerRestorableStyles(backup, node, properties) {\n  properties.forEach((prop) => {\n    backup[prop] = isDefined(backup[prop])\n      ? backup[prop]\n      : node.style.getPropertyValue(prop);\n  });\n}\n\nexport function AnimateCssProvider() {\n  /**\n   * @type {string}\n   */\n  let activeClasses;\n\n  this.$get = [\n    /**\n     * @returns {ng.AnimateCssService}\n     */\n    () => {\n      const applyAnimationClasses = applyAnimationClassesFactory();\n\n      /**\n       * @param {any} node\n       * @param {string} cacheKey\n       * @param {any} allowNoDuration\n       * @param {{ transitionDuration: string; transitionDelay: string; transitionProperty: string; animationDuration: string; animationDelay: string; animationIterationCount: string; }} properties\n       */\n      function computeCachedCssStyles(\n        node,\n        cacheKey,\n        allowNoDuration,\n        properties,\n      ) {\n        let timings = animateCache._get(cacheKey);\n\n        if (!timings) {\n          timings = computeCssStyles(node, properties);\n\n          if (timings.animationIterationCount === \"infinite\") {\n            timings.animationIterationCount = 1;\n          }\n        }\n\n        // if a css animation has no duration we\n        // should mark that so that repeated addClass/removeClass calls are skipped\n        const hasDuration =\n          allowNoDuration ||\n          timings.transitionDuration > 0 ||\n          timings.animationDuration > 0;\n\n        // we keep putting this in multiple times even though the value and the cacheKey are the same\n        // because we're keeping an internal tally of how many duplicate animations are detected.\n        animateCache._put(cacheKey, timings, hasDuration);\n\n        return timings;\n      }\n\n      /**\n       * @param {Element} node\n       * @param {string | string[]} className\n       * @param {string} cacheKey\n       * @param {{ [s: string]: string; } | ArrayLike<string>} properties\n       */\n      function computeCachedCssStaggerStyles(\n        node,\n        className,\n        cacheKey,\n        properties,\n      ) {\n        let stagger;\n\n        const staggerCacheKey = `stagger-${cacheKey}`;\n\n        // if we have one or more existing matches of matching elements\n        // containing the same parent + CSS styles (which is how cacheKey works)\n        // then staggering is possible\n        if (animateCache._count(cacheKey) > 0) {\n          stagger = animateCache._get(staggerCacheKey);\n\n          if (!stagger) {\n            const staggerClassName = pendClasses(className, \"-stagger\");\n\n            node.className += ` ${staggerClassName}`;\n            stagger = computeCssStyles(node, properties);\n\n            // force the conversion of a null value to zero incase not set\n            stagger.animationDuration = Math.max(\n              stagger.animationDuration || 0,\n              0,\n            );\n            stagger.transitionDuration = Math.max(\n              stagger.transitionDuration || 0,\n              0,\n            );\n\n            node.classList.remove(staggerClassName);\n\n            animateCache._put(staggerCacheKey, stagger, true);\n          }\n        }\n\n        return stagger || {};\n      }\n\n      /** @type {Array<() => void>} */\n      const rafWaitQueue = [];\n\n      /**\n       * @param {() => void} callback\n       */\n      function waitUntilQuiet(callback) {\n        rafWaitQueue.push(callback);\n        rafScheduler._waitUntilQuiet(() => {\n          animateCache._flush();\n\n          // Forces synchronous style & layout flush.\n          // Required to commit animation prep state before activation.\n          document.documentElement.getBoundingClientRect();\n\n          // we use a for loop to ensure that if the queue is changed\n          // during this looping then it will consider new requests\n          for (let i = 0; i < rafWaitQueue.length; i++) {\n            rafWaitQueue[i]();\n          }\n          rafWaitQueue.length = 0;\n        });\n      }\n\n      /**\n       * @param {HTMLElement} node\n       * @param {string} cacheKey\n       * @param {boolean} allowNoDuration\n       */\n      function computeTimings(node, cacheKey, allowNoDuration) {\n        const timings = computeCachedCssStyles(\n          node,\n          cacheKey,\n          allowNoDuration,\n          DETECT_CSS_PROPERTIES,\n        );\n\n        const aD = timings.animationDelay;\n\n        const tD = timings.transitionDelay;\n\n        timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;\n        timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration,\n        );\n\n        return timings;\n      }\n\n      /**\n       * @param {HTMLElement} element\n       * @param {ng.AnimationOptions} [initialOptions]\n       * @return {{_willAnimate: boolean, start(): AnimateRunner, end: function(): void}}\n       */\n      function init(element, initialOptions) {\n        // all of the animation functions should create\n        // a copy of the options data, however, if a\n        // parent service has already created a copy then\n        let delayStyle;\n\n        // we should stick to using that\n        let options =\n          initialOptions ||\n          /** @type {ng.AnimationOptions} */ ({\n            _skipPreparationClasses: false,\n          });\n\n        if (!options._prepared) {\n          options = prepareAnimationOptions(structuredClone(options));\n        }\n\n        /** @type {Record<string, string | null | undefined>} */\n        const restoreStyles = {};\n\n        const node = /** @type {HTMLElement} */ (element);\n\n        // Note: this had an additional  !$$animateQueue.enabled() check\n        if (!node || !node.parentNode) {\n          return closeAndReturnNoopAnimator();\n        }\n\n        /** @type {Array<Array<string>>} */\n        const temporaryStyles = [];\n\n        const styles = packageStyles(options);\n\n        /**\n         * @type {boolean}\n         */\n        let animationClosed;\n\n        /**\n         * @type {boolean}\n         */\n        let animationPaused;\n\n        /**\n         * @type {boolean}\n         */\n        let animationCompleted;\n\n        /**\n         * @type {AnimateRunner}\n         */\n        let runner;\n\n        /** @type {import(\"../interface.ts\").AnimationHost} */\n        let runnerHost = {};\n\n        /**\n         * @type {number}\n         */\n        let maxDelay;\n\n        /**\n         * @type {number}\n         */\n        let maxDelayTime;\n\n        /**\n         * @type {number}\n         */\n        let maxDuration;\n\n        let maxDurationTime;\n\n        /**\n         * @type {number}\n         */\n        let startTime;\n\n        /** @type {string[]} */\n        const events = [];\n\n        if (options.duration === 0) {\n          return closeAndReturnNoopAnimator();\n        }\n\n        const method = /** @type {string} */ (\n          options.event && isArray(options.event)\n            ? options.event.join(\" \")\n            : options.event\n        );\n\n        const isStructural = method && options.structural;\n\n        let structuralClassName = \"\";\n\n        let addRemoveClassName = \"\";\n\n        if (isStructural) {\n          structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n        } else if (method) {\n          structuralClassName = method;\n        }\n\n        if (options.addClass) {\n          addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n        }\n\n        if (options.removeClass) {\n          if (addRemoveClassName.length) {\n            addRemoveClassName += \" \";\n          }\n          addRemoveClassName += pendClasses(\n            options.removeClass,\n            REMOVE_CLASS_SUFFIX,\n          );\n        }\n\n        // there may be a situation where a structural animation is combined together\n        // with CSS classes that need to resolve before the animation is computed.\n        // However this means that there is no explicit CSS code to block the animation\n        // from happening (by setting 0s none in the class name). If this is the case\n        // we need to apply the classes before the first rAF so we know to continue if\n        // there actually is a detected transition or keyframe animation\n        if (options.applyClassesEarly && addRemoveClassName.length) {\n          applyAnimationClasses(element, options);\n        }\n\n        let preparationClasses = [structuralClassName, addRemoveClassName]\n          .join(\" \")\n          .trim();\n\n        const hasToStyles = !!(styles.to && Object.keys(styles.to).length > 0);\n\n        const containsKeyframeAnimation =\n          (options.keyframeStyle || \"\").length > 0;\n\n        // there is no way we can trigger an animation if no styles and\n        // no classes are being applied which would then trigger a transition,\n        // unless there a is raw keyframe value that is applied to the element.\n        if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {\n          return closeAndReturnNoopAnimator();\n        }\n\n        /** @type {{ animationDelay: number; animationDuration: number; transitionDuration: number; transitionDelay: number; }} */\n        let stagger;\n\n        let cacheKey = animateCache._cacheKey(\n          node,\n          method,\n          options.addClass,\n          options.removeClass,\n        );\n\n        if (animateCache._containsCachedAnimationWithoutDuration(cacheKey)) {\n          preparationClasses = \"\";\n\n          return closeAndReturnNoopAnimator();\n        }\n\n        if (/** @type {number} */ (options.stagger) > 0) {\n          const staggerVal = parseFloat(\n            /** @type {string} */ (options.stagger),\n          );\n\n          stagger = {\n            transitionDelay: staggerVal,\n            animationDelay: staggerVal,\n            transitionDuration: 0,\n            animationDuration: 0,\n          };\n        } else {\n          stagger = computeCachedCssStaggerStyles(\n            node,\n            preparationClasses,\n            cacheKey,\n            DETECT_STAGGER_CSS_PROPERTIES,\n          );\n        }\n\n        if (!options._skipPreparationClasses) {\n          element.classList.add(\n            ...preparationClasses.split(\" \").filter((x) => x !== \"\"),\n          );\n        }\n\n        let applyOnlyDuration;\n\n        if (options.transitionStyle) {\n          const transitionStyle = [\"transition\", options.transitionStyle];\n\n          applyInlineStyle(node, transitionStyle);\n          temporaryStyles.push(transitionStyle);\n        }\n\n        if (/** @type {number} */ (options.duration) >= 0) {\n          applyOnlyDuration = node.style.transition.length > 0;\n          const durationStyle = getCssTransitionDurationStyle(\n            options.duration,\n            applyOnlyDuration,\n          );\n\n          // we set the duration so that it will be picked up by getComputedStyle later\n          applyInlineStyle(node, durationStyle);\n\n          temporaryStyles.push(durationStyle);\n        }\n\n        if (options.keyframeStyle) {\n          const keyframeStyle = [\"animation\", options.keyframeStyle];\n\n          applyInlineStyle(node, keyframeStyle);\n          temporaryStyles.push(keyframeStyle);\n        }\n\n        const staggerIndex = options.staggerIndex ?? 0;\n\n        const itemIndex = stagger\n          ? staggerIndex >= 0\n            ? staggerIndex\n            : animateCache._count(cacheKey)\n          : 0;\n\n        const isFirst = itemIndex === 0;\n\n        // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n        // without causing any combination of transitions to kick in. By adding a negative delay value\n        // it forces the setup class' transition to end immediately. We later then remove the negative\n        // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n        // that if there is no transition defined then nothing will happen and this will also allow\n        // other transitions to be stacked on top of each other without any chopping them out.\n        if (isFirst) {\n          blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n        }\n\n        let timings = computeTimings(node, cacheKey, !isStructural);\n\n        let relativeDelay = timings.maxDelay;\n\n        maxDelay = Math.max(relativeDelay, 0);\n        // eslint-disable-next-line prefer-destructuring\n        maxDuration = timings.maxDuration;\n\n        /** @type {{\n          _hasTransitions: boolean;\n          _hasAnimations: boolean;\n          _hasTransitionAll: boolean;\n          _applyTransitionDuration: boolean;\n          _applyAnimationDuration: boolean;\n          _applyTransitionDelay: boolean;\n          _applyAnimationDelay: boolean;\n          _recalculateTimingStyles: boolean;\n          _blockTransition: boolean;\n          _blockKeyframeAnimation: boolean;\n        }} */\n        const flags = {\n          _hasTransitions: timings.transitionDuration > 0,\n          _hasAnimations: timings.animationDuration > 0,\n          _hasTransitionAll: false,\n          _applyTransitionDuration: false,\n          _applyAnimationDuration: false,\n          _applyTransitionDelay: false,\n          _applyAnimationDelay: false,\n          _recalculateTimingStyles: addRemoveClassName.length > 0,\n          _blockTransition: false,\n          _blockKeyframeAnimation: false,\n        };\n\n        flags._hasTransitionAll =\n          flags._hasTransitions && timings.transitionProperty === \"all\";\n        flags._applyTransitionDuration =\n          hasToStyles &&\n          ((flags._hasTransitions && !flags._hasTransitionAll) ||\n            (flags._hasAnimations && !flags._hasTransitions));\n        flags._applyAnimationDuration =\n          !!options.duration && flags._hasAnimations;\n        flags._applyTransitionDelay =\n          truthyTimingValue(options.delay) &&\n          (flags._applyTransitionDuration || flags._hasTransitions);\n        flags._applyAnimationDelay =\n          truthyTimingValue(options.delay) && flags._hasAnimations;\n\n        if (flags._applyTransitionDuration || flags._applyAnimationDuration) {\n          maxDuration = options.duration\n            ? parseFloat(/** @type {string} */ (options.duration))\n            : maxDuration;\n\n          if (flags._applyTransitionDuration) {\n            flags._hasTransitions = true;\n            timings.transitionDuration = maxDuration;\n            applyOnlyDuration = node.style.transitionProperty.length > 0;\n            temporaryStyles.push(\n              getCssTransitionDurationStyle(maxDuration, applyOnlyDuration),\n            );\n          }\n\n          if (flags._applyAnimationDuration) {\n            flags._hasAnimations = true;\n            timings.animationDuration = maxDuration;\n            temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n          }\n        }\n\n        if (maxDuration === 0 && !flags._recalculateTimingStyles) {\n          return closeAndReturnNoopAnimator();\n        }\n\n        activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n\n        if (!isNullOrUndefined(options.delay)) {\n          if (typeof options.delay !== \"boolean\") {\n            delayStyle = parseFloat(options.delay);\n            // number in options.delay means we have to recalculate the delay for the closing timeout\n            maxDelay = Math.max(delayStyle, 0);\n          }\n\n          if (flags._applyTransitionDelay) {\n            temporaryStyles.push(getCssDelayStyle(delayStyle));\n          }\n\n          if (flags._applyAnimationDelay) {\n            temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n          }\n        }\n\n        // we need to recalculate the delay value since we used a pre-emptive negative\n        // delay value and the delay value is required for the final event checking. This\n        // property will ensure that this will happen after the RAF phase has passed.\n        if (\n          isNullOrUndefined(options.duration) &&\n          timings.transitionDuration > 0\n        ) {\n          flags._recalculateTimingStyles =\n            flags._recalculateTimingStyles || isFirst;\n        }\n\n        maxDelayTime = maxDelay * ONE_SECOND;\n        maxDurationTime = maxDuration * ONE_SECOND;\n\n        flags._blockTransition = timings.transitionDuration > 0;\n        flags._blockKeyframeAnimation =\n          timings.animationDuration > 0 &&\n          stagger.animationDelay > 0 &&\n          stagger.animationDuration === 0;\n\n        if (options.from) {\n          if (options.cleanupStyles) {\n            registerRestorableStyles(\n              restoreStyles,\n              node,\n              Object.keys(options.from),\n            );\n          }\n          applyAnimationFromStyles(element, options);\n        }\n\n        if (flags._blockTransition || flags._blockKeyframeAnimation) {\n          applyBlocking(maxDuration);\n        } else if (!options.skipBlocking) {\n          blockTransitions(node, 0);\n        }\n\n        // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n        return {\n          _willAnimate: true,\n          end: endFn,\n          start() {\n            if (animationClosed) {\n              const noopRunner = new AnimateRunner();\n\n              noopRunner.complete(true);\n\n              return noopRunner;\n            }\n\n            runnerHost = {\n              end: endFn,\n              cancel: cancelFn,\n              resume: undefined, // this will be set during the start() phase\n              pause: undefined,\n            };\n\n            runner = new AnimateRunner(runnerHost);\n\n            waitUntilQuiet(start);\n\n            // we don't have access to pause/resume the animation\n            // since it hasn't run yet. AnimateRunner will therefore\n            // set noop functions for resume and pause and they will\n            // later be overridden once the animation is triggered\n            return runner;\n          },\n        };\n\n        function endFn() {\n          close();\n        }\n\n        function cancelFn() {\n          close(true);\n        }\n\n        /**\n         * @param {boolean} [rejected]\n         */\n        function close(rejected) {\n          // if the promise has been called already then we shouldn't close\n          // the animation again\n          if (animationClosed || (animationCompleted && animationPaused))\n            return;\n          animationClosed = true;\n          animationPaused = false;\n\n          if (preparationClasses && !options._skipPreparationClasses) {\n            element.classList.remove(...preparationClasses.split(\" \"));\n          }\n          activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n\n          if (activeClasses) {\n            element.classList.remove(...activeClasses.split(\" \"));\n          }\n\n          _blockKeyframeAnimations(node, false);\n          blockTransitions(node, 0);\n\n          temporaryStyles.forEach((entry) => {\n            // There is only one way to remove inline style properties entirely from elements.\n            // By using `removeProperty` this works, but we need to convert camel-cased CSS\n            // styles down to hyphenated values.\n            node.style.removeProperty(entry[0]);\n          });\n\n          applyAnimationClasses(element, options);\n          applyAnimationStyles(element, options);\n\n          if (keys(restoreStyles).length) {\n            entries(restoreStyles).forEach(([prop, value]) => {\n              if (value) {\n                node.style.setProperty(prop, value);\n              } else {\n                node.style.removeProperty(prop);\n              }\n            });\n          }\n\n          // the reason why we have this option is to allow a synchronous closing callback\n          // that is fired as SOON as the animation ends (when the CSS is removed) or if\n          // the animation never takes off at all. A good example is a leave animation since\n          // the element must be removed just after the animation is over or else the element\n          // will appear on screen for one animation frame causing an overbearing flicker.\n          if (options.onDone) {\n            options.onDone();\n          }\n\n          if (events && events.length) {\n            // Remove the transitionend / animationend listener(s)\n            events.forEach((i) =>\n              element.removeEventListener(i, onAnimationProgress),\n            );\n          }\n\n          // Cancel the fallback closing timeout and remove the timer data\n          const animationTimerData = getCacheData(element, ANIMATE_TIMER_KEY);\n\n          if (animationTimerData) {\n            clearTimeout(animationTimerData[0].timer);\n            removeElementData(element, ANIMATE_TIMER_KEY);\n          }\n\n          // if the preparation function fails then the promise is not setup\n          if (runner) {\n            runner.complete(!rejected);\n          }\n        }\n\n        /**\n         * @param {number} duration\n         */\n        function applyBlocking(duration) {\n          if (flags._blockTransition) {\n            blockTransitions(node, duration);\n          }\n\n          if (flags._blockKeyframeAnimation) {\n            _blockKeyframeAnimations(node, !!duration);\n          }\n        }\n\n        function closeAndReturnNoopAnimator() {\n          runner = new AnimateRunner({\n            end: endFn,\n            cancel: cancelFn,\n          });\n\n          // should flush the cache animation\n          waitUntilQuiet(() => {\n            /* empty */\n          });\n          close();\n\n          return {\n            _willAnimate: false,\n            start() {\n              return runner;\n            },\n            end: endFn,\n          };\n        }\n\n        /**\n         * @param {Event & { originalEvent?: any }} event\n         */\n        function onAnimationProgress(event) {\n          event.stopPropagation();\n          const ev = event.originalEvent || event;\n\n          if (ev.target !== node) {\n            // Since TransitionEvent / AnimationEvent bubble up,\n            // we have to ignore events by finished child animations\n            return;\n          }\n\n          // we now always use `Date.now()` due to the recent changes with\n          // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n          const timeStamp = ev.$manualTimeStamp || Date.now();\n\n          /* Firefox (or possibly just Gecko) likes to not round values up\n           * when a ms measurement is used for the animation */\n          const elapsedTime = parseFloat(\n            ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES),\n          );\n\n          /* $manualTimeStamp is a mocked timeStamp value which is set\n           * within browserTrigger(). This is only here so that tests can\n           * mock animations properly. Real events fallback to event.timeStamp,\n           * or, if they don't, then a timeStamp is automatically created for them.\n           * We're checking to see if the timeStamp surpasses the expected delay,\n           * but we're using elapsedTime instead of the timeStamp on the 2nd\n           * pre-condition since animationPauseds sometimes close off early */\n          if (\n            Math.max(timeStamp - startTime, 0) >= maxDelayTime &&\n            elapsedTime >= maxDuration\n          ) {\n            // we set this flag to ensure that if the transition is paused then, when resumed,\n            // the animation will automatically close itself since transitions cannot be paused.\n            animationCompleted = true;\n            close();\n          }\n        }\n\n        function start() {\n          if (animationClosed) return;\n\n          if (!node.parentNode) {\n            close();\n\n            return;\n          }\n\n          // even though we only pause keyframe animations here the pause flag\n          // will still happen when transitions are used. Only the transition will\n          // not be paused since that is not possible. If the animation ends when\n          // paused then it will not complete until unpaused or cancelled.\n          const playPause = function (/** @type {boolean} */ playAnimation) {\n            if (!animationCompleted) {\n              animationPaused = !playAnimation;\n\n              if (timings.animationDuration) {\n                const value = _blockKeyframeAnimations(node, animationPaused);\n\n                if (animationPaused) {\n                  temporaryStyles.push(value);\n                } else {\n                  const index = temporaryStyles.indexOf(value);\n\n                  if (index !== -1) {\n                    temporaryStyles.splice(index, 1);\n                  }\n                }\n              }\n            } else if (animationPaused && playAnimation) {\n              animationPaused = false;\n              close();\n            }\n          };\n\n          // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n          // being inherited from the parent. If the transition duration is zero then we can safely\n          // rely that the delay value is an intentional stagger delay style.\n          const maxStagger =\n            itemIndex > 0 &&\n            ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n              (timings.animationDuration && stagger.animationDuration === 0)) &&\n            Math.max(stagger.animationDelay, stagger.transitionDelay);\n\n          if (maxStagger) {\n            setTimeout(\n              triggerAnimationStart,\n              Math.floor(maxStagger * itemIndex * ONE_SECOND),\n              false,\n            );\n          } else {\n            triggerAnimationStart();\n          }\n\n          // this will decorate the existing promise runner with pause/resume methods\n          runnerHost.resume = function () {\n            playPause(true);\n          };\n\n          runnerHost.pause = function () {\n            playPause(false);\n          };\n\n          function triggerAnimationStart() {\n            // just incase a stagger animation kicks in when the animation\n            // itself was cancelled entirely\n            if (animationClosed) return;\n\n            applyBlocking(0);\n\n            temporaryStyles.forEach((entry) => {\n              const key = entry[0];\n\n              node.style.setProperty(key, entry[1]);\n            });\n\n            applyAnimationClasses(element, options);\n            element.classList.add(\n              ...activeClasses.split(\" \").filter((x) => x !== \"\"),\n            );\n\n            if (flags._recalculateTimingStyles) {\n              cacheKey = animateCache._cacheKey(\n                node,\n                method,\n                options.addClass,\n                options.removeClass,\n              );\n\n              timings = computeTimings(node, cacheKey, false);\n              relativeDelay = timings.maxDelay;\n              maxDelay = Math.max(relativeDelay, 0);\n              // eslint-disable-next-line prefer-destructuring\n              maxDuration = timings.maxDuration;\n\n              if (maxDuration === 0) {\n                close();\n\n                return;\n              }\n\n              flags._hasTransitions = timings.transitionDuration > 0;\n              flags._hasAnimations = timings.animationDuration > 0;\n            }\n\n            if (flags._applyAnimationDelay) {\n              relativeDelay =\n                typeof options.delay !== \"boolean\" &&\n                truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n              maxDelay = Math.max(relativeDelay, 0);\n              timings.animationDelay = relativeDelay;\n              delayStyle = getCssDelayStyle(relativeDelay, true);\n              temporaryStyles.push(delayStyle);\n              node.style.setProperty(delayStyle[0], delayStyle[1]);\n            }\n\n            maxDelayTime = maxDelay * ONE_SECOND;\n            maxDurationTime = maxDuration * ONE_SECOND;\n\n            if (options.easing) {\n              let easeProp;\n\n              const easeVal = options.easing;\n\n              if (flags._hasTransitions) {\n                easeProp = \"transitionTimingFunction\";\n                temporaryStyles.push([easeProp, easeVal]);\n                node.style.setProperty(easeProp, easeVal);\n              }\n\n              if (flags._hasAnimations) {\n                easeProp = \"animationTimingFunction\";\n                temporaryStyles.push([easeProp, easeVal]);\n                node.style.setProperty(easeProp, easeVal);\n              }\n            }\n\n            if (timings.transitionDuration) {\n              events.push(\"transitionend\");\n            }\n\n            if (timings.animationDuration) {\n              events.push(\"animationend\");\n            }\n\n            startTime = Date.now();\n            const timerTime =\n              maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n\n            const endTime = startTime + timerTime;\n\n            const animationsData =\n              getCacheData(element, ANIMATE_TIMER_KEY) || [];\n\n            let setupFallbackTimer = true;\n\n            if (animationsData.length) {\n              const currentTimerData = animationsData[0];\n\n              setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n\n              if (setupFallbackTimer) {\n                clearTimeout(currentTimerData.timer);\n              } else {\n                animationsData.push(close);\n              }\n            }\n\n            if (setupFallbackTimer) {\n              const timer = setTimeout(onAnimationExpired, timerTime, false);\n\n              animationsData[0] = {\n                timer,\n                expectedEndTime: endTime,\n              };\n              animationsData.push(close);\n              setCacheData(element, ANIMATE_TIMER_KEY, animationsData);\n            }\n\n            if (events.length) {\n              events.forEach((x) => {\n                element.addEventListener(x, onAnimationProgress);\n              });\n            }\n\n            if (options.to) {\n              if (options.cleanupStyles) {\n                registerRestorableStyles(\n                  restoreStyles,\n                  node,\n                  Object.keys(options.to),\n                );\n              }\n              applyAnimationToStyles(element, options);\n            }\n          }\n\n          function onAnimationExpired() {\n            const animationsData = getCacheData(element, ANIMATE_TIMER_KEY);\n\n            // this will be false in the event that the element was\n            // removed from the DOM (via a leave animation or something\n            // similar)\n            if (animationsData) {\n              for (let i = 1; i < animationsData.length; i++) {\n                animationsData[i]();\n              }\n              removeElementData(element, ANIMATE_TIMER_KEY);\n            }\n          }\n        }\n      }\n\n      return init;\n    },\n  ];\n}\n\n/**\n * @param {HTMLElement} node\n * @param {number} duration\n * @returns {import(\"../interface.ts\").InlineStyleEntry}\n */\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  const value = duration ? `-${duration}s` : \"\";\n\n  applyInlineStyle(node, [\"transitionDelay\", value]);\n\n  return [\"transitionDelay\", value];\n}\n","import {\n  getOrSetCacheData,\n  extractElementNode,\n  setCacheData,\n} from \"../../shared/dom.js\";\nimport {\n  extend,\n  isArray,\n  isDefined,\n  isObject,\n  isString,\n  isUndefined,\n  nullObject,\n} from \"../../shared/utils.js\";\nimport {\n  NG_ANIMATE_CHILDREN_DATA,\n  applyAnimationClassesFactory,\n  applyAnimationStyles,\n  applyGeneratedPreparationClasses,\n  clearGeneratedClasses,\n  mergeAnimationDetails,\n  prepareAnimationOptions,\n  stripCommentsFromElement,\n} from \"../shared.js\";\nimport { $injectTokens as $t, provider } from \"../../injection-tokens.js\";\nimport { AnimateRunner } from \"../runner/animate-runner.js\";\nimport { NodeType } from \"../../shared/node.js\";\n\nconst NG_ANIMATE_ATTR_NAME = \"data-ng-animate\";\n\nconst NG_ANIMATE_PIN_DATA = \"$ngAnimatePin\";\n\nAnimateQueueProvider.$inject = provider([$t._animate]);\n\n/** @typedef {import(\"../interface.ts\").AnimationOptions} AnimationOptions */\n\n/**\n * @param {import(\"../animate.js\").AnimateProvider} $animateProvider\n * @constructor\n */\nexport function AnimateQueueProvider($animateProvider) {\n  const PRE_DIGEST_STATE = 1;\n\n  const RUNNING_STATE = 2;\n\n  const ONE_SPACE = \" \";\n\n  /** @type {import(\"../../shared/interface.ts\").Dict<any>} */\n  const rules = (this.rules = {\n    skip: [],\n    cancel: [],\n    join: [],\n  });\n\n  /**\n   * @param {AnimationOptions} options\n   * @return {import(\"../queue/interface.ts\").QueueAnimationData}\n   */\n  function getEventData(options) {\n    return {\n      addClass: options.addClass,\n      removeClass: options.removeClass,\n      from: options.from,\n      to: options.to,\n    };\n  }\n\n  /**\n   * @param {string} classString\n   * @return {Record<string, string>}\n   */\n  function makeTruthyCssClassMap(classString) {\n    const keys = classString.split(ONE_SPACE);\n\n    const map = nullObject();\n\n    keys.forEach((key) => {\n      map[key] = true;\n    });\n\n    return map;\n  }\n\n  /**\n   * @param {string} newClassString\n   * @param {string} currentClassString\n   */\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      const currentClassMap = makeTruthyCssClassMap(currentClassString);\n\n      return newClassString\n        .split(ONE_SPACE)\n        .some((className) => currentClassMap[className]);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * @param {string} ruleType\n   * @param {AnimationOptions} currentAnimation\n   * @param {any} previousAnimation\n   */\n  function isAllowed(ruleType, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(\n      (/** @type {(arg0: AnimationOptions, arg1: any) => any} */ fn) =>\n        fn(currentAnimation, previousAnimation),\n    );\n  }\n\n  /**\n   * @param {AnimationOptions} animation\n   * @param {boolean | undefined} [and]\n   */\n  function hasAnimationClasses(animation, and) {\n    const a = (animation.addClass || \"\").length > 0;\n\n    const b = (animation.removeClass || \"\").length > 0;\n\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(\n    (/** @type {AnimationOptions} */ newAnimation) =>\n      // if the new animation is class-based then we can just tack that on\n      !newAnimation.structural && hasAnimationClasses(newAnimation),\n  );\n\n  rules.skip.push(\n    (/** @type {AnimationOptions} */ newAnimation) =>\n      // there is no need to animate anything if no classes are being added and\n      // there is no structural animation that will be triggered\n      !newAnimation.structural && !hasAnimationClasses(newAnimation),\n  );\n\n  rules.skip.push(\n    (\n      /** @type {AnimationOptions} */ newAnimation,\n      /** @type {AnimationOptions} */ currentAnimation,\n    ) =>\n      // why should we trigger a new structural animation if the element will\n      // be removed from the DOM anyway?\n      currentAnimation.event === \"leave\" && newAnimation.structural,\n  );\n\n  rules.skip.push(\n    (\n      /** @type {AnimationOptions} */ newAnimation,\n      /** @type {AnimationOptions} */ currentAnimation,\n    ) =>\n      // if there is an ongoing current animation then don't even bother running the class-based animation\n      currentAnimation.structural &&\n      currentAnimation.state === RUNNING_STATE &&\n      !newAnimation.structural,\n  );\n\n  rules.cancel.push(\n    (\n      /** @type {AnimationOptions} */ newAnimation,\n      /** @type {AnimationOptions} */ currentAnimation,\n    ) =>\n      // there can never be two structural animations running at the same time\n      currentAnimation.structural && newAnimation.structural,\n  );\n\n  rules.cancel.push(\n    (\n      /** @type {AnimationOptions} */ newAnimation,\n      /** @type {AnimationOptions} */ currentAnimation,\n    ) =>\n      // if the previous animation is already running, but the new animation will\n      // be triggered, but the new animation is structural\n      currentAnimation.state === RUNNING_STATE && newAnimation.structural,\n  );\n\n  rules.cancel.push(\n    (\n      /** @type {AnimationOptions} */ newAnimation,\n      /** @type {AnimationOptions} */ currentAnimation,\n    ) => {\n      // cancel the animation if classes added / removed in both animation cancel each other out,\n      // but only if the current animation isn't structural\n\n      if (currentAnimation.structural) return false;\n\n      const nA = newAnimation.addClass;\n\n      const nR = newAnimation.removeClass;\n\n      const cA = currentAnimation.addClass;\n\n      const cR = currentAnimation.removeClass;\n\n      // early detection to save the global CPU shortage :)\n      if (\n        (isUndefined(nA) && isUndefined(nR)) ||\n        (isUndefined(cA) && isUndefined(cR))\n      ) {\n        return false;\n      } else {\n        return (\n          hasMatchingClasses(\n            /** @type {string} */ (nA),\n            /** @type {string} */ (cR),\n          ) ||\n          hasMatchingClasses(\n            /** @type {string} */ (nR),\n            /** @type {string} */ (cA),\n          )\n        );\n      }\n    },\n  );\n\n  this.$get = [\n    $t._rootScope,\n    $t._injector,\n    $t._animation,\n    /**\n     *\n     * @param {ng.RootScopeService} $rootScope\n     * @param {ng.InjectorService} $injector\n     * @param {import(\"../interface.ts\").AnimationService} $$animation\n     * @returns {import(\"../queue/interface.ts\").AnimateQueueService}\n     */\n    function ($rootScope, $injector, $$animation) {\n      const activeAnimationsLookup = new Map();\n\n      const disabledElementsLookup = new Map();\n\n      function postDigestTaskFactory() {\n        let postDigestCalled = false;\n\n        return function (/** @type {() => void} */ fn) {\n          // we only issue a call to postDigest before\n          // it has first passed. This prevents any callbacks\n          // from not firing once the animation has completed\n          // since it will be out of the digest cycle.\n          if (postDigestCalled) {\n            fn();\n          } else {\n            $rootScope.$postUpdate(() => {\n              postDigestCalled = true;\n              fn();\n            });\n          }\n        };\n      }\n\n      /** @type {import(\"../queue/interface.ts\").CallbackRegistry} */\n      const callbackRegistry = nullObject();\n\n      // remember that the `customFilter`/`classNameFilter` are set during the\n      // provider/config stage therefore we can optimize here and setup helper functions\n      const customFilter = $animateProvider.customFilter();\n\n      const classNameFilter = $animateProvider.classNameFilter();\n\n      const returnTrue = function () {\n        return true;\n      };\n\n      const isAnimatableByFilter = customFilter || returnTrue;\n\n      const isAnimatableClassName = !classNameFilter\n        ? returnTrue\n        : function (\n            /** @type {HTMLElement} */ node,\n            /** @type {import(\"../interface.ts\").AnimationOptions} */ options,\n          ) {\n            const className = [\n              node.getAttribute(\"class\"),\n              options.addClass,\n              options.removeClass,\n            ].join(\" \");\n\n            return classNameFilter.test(className);\n          };\n\n      const applyAnimationClasses = applyAnimationClassesFactory();\n\n      /**\n       * @param {HTMLElement} element\n       * @param {import(\"../interface.ts\").AnimationOptions} animation\n       */\n      function normalizeAnimationDetails(element, animation) {\n        return mergeAnimationDetails(element, animation, {});\n      }\n\n      /**\n       * @param {Node | null} targetParentNode\n       * @param {Node} targetNode\n       * @param {string} event\n       * @returns {import(\"../queue/interface.ts\").AnimateEventCallback[]}\n       */\n      function findCallbacks(targetParentNode, targetNode, event) {\n        /**\n         * @type {import(\"../queue/interface.ts\").AnimateEventCallback[]}\n         */\n        const matches = [];\n\n        const entries = callbackRegistry[event];\n\n        if (entries) {\n          entries.forEach((entry) => {\n            if (entry.node.contains(targetNode)) {\n              matches.push(entry.callback);\n            } else if (\n              event === \"leave\" &&\n              targetParentNode &&\n              entry.node.contains(targetParentNode)\n            ) {\n              matches.push(entry.callback);\n            }\n          });\n        }\n\n        return matches;\n      }\n\n      /**\n       * @param {any[]} list\n       * @param {Node | NodeList | undefined} matchContainer\n       * @param {Function | undefined} [matchCallback]\n       */\n      function filterFromRegistry(list, matchContainer, matchCallback) {\n        const containerNode = matchContainer\n          ? extractElementNode(matchContainer)\n          : undefined;\n\n        return list.filter((entry) => {\n          const isMatch =\n            entry.node === containerNode &&\n            (!matchCallback || entry.callback === matchCallback);\n\n          return !isMatch;\n        });\n      }\n\n      /**\n       * @param {string} phase\n       * @param {Element} node\n       */\n      function cleanupEventListeners(phase, node) {\n        if (phase === \"close\" && !node.parentNode) {\n          // If the element is not attached to a parentNode, it has been removed by\n          // the domOperation, and we can safely remove the event callbacks\n          $animate.off(node);\n        }\n      }\n\n      /** @type {import(\"../queue/interface.ts\").AnimateQueueService} */\n      const $animate = {\n        on(event, container, callback) {\n          const node = extractElementNode(container);\n\n          if (!node || !(node instanceof Element) || !callback) return;\n\n          callbackRegistry[event] = callbackRegistry[event] || [];\n          callbackRegistry[event].push({\n            node,\n            callback,\n          });\n\n          // Remove the callback when the element is removed from the DOM\n          container.addEventListener(\"$destroy\", () => {\n            const animationDetails = activeAnimationsLookup.get(node);\n\n            if (!animationDetails) {\n              // If there's an animation ongoing, the callback calling code will remove\n              // the event listeners. If we'd remove here, the callbacks would be removed\n              // before the animation ends\n              $animate.off(event, container, callback);\n            }\n          });\n        },\n\n        off(event, container, callback) {\n          if (arguments.length === 1 && !isString(arguments[0])) {\n            container = arguments[0];\n\n            for (const eventType in callbackRegistry) {\n              callbackRegistry[eventType] = filterFromRegistry(\n                callbackRegistry[eventType] || [],\n                container,\n              );\n            }\n\n            return;\n          }\n\n          if (!isString(event)) return;\n\n          const entries = callbackRegistry[event];\n\n          if (!entries) return;\n\n          callbackRegistry[event] =\n            arguments.length === 1\n              ? null\n              : filterFromRegistry(entries, container, callback);\n        },\n\n        pin(element, parentElement) {\n          setCacheData(element, NG_ANIMATE_PIN_DATA, parentElement);\n        },\n\n        push(element, event, options, domOperation) {\n          options = options || {};\n          options.domOperation = domOperation;\n\n          return queueAnimation(element, event, options);\n        },\n      };\n\n      return $animate;\n\n      /**\n       * @param {Element} originalElement\n       * @param {string} event\n       * @param {*} initialOptions\n       * @returns {AnimateRunner}\n       */\n      function queueAnimation(originalElement, event, initialOptions) {\n        // we always make a copy of the options since\n        // there should never be any side effects on\n        // the input data when running `$animateCss`.\n        let options = initialOptions;\n\n        // strip comments\n\n        let element = isArray(originalElement)\n          ? originalElement.filter((x) => x.nodeName !== \"#comment\")[0]\n          : originalElement;\n\n        const node = element;\n\n        const parentNode = node && node.parentNode;\n\n        options = prepareAnimationOptions(options);\n\n        // we create a fake runner with a working promise.\n        // These methods will become available after the digest has passed\n        const runner = new AnimateRunner();\n\n        // this is used to trigger callbacks in postDigest mode\n        const runInNextPostDigestOrNow = postDigestTaskFactory();\n\n        if (isArray(options.addClass)) {\n          options.addClass = options.addClass.join(\" \");\n        }\n\n        if (options.addClass && !isString(options.addClass)) {\n          options.addClass = null;\n        }\n\n        if (isArray(options.removeClass)) {\n          options.removeClass = options.removeClass.join(\" \");\n        }\n\n        if (options.removeClass && !isString(options.removeClass)) {\n          options.removeClass = null;\n        }\n\n        if (options.from && !isObject(options.from)) {\n          options.from = null;\n        }\n\n        if (options.to && !isObject(options.to)) {\n          options.to = null;\n        }\n\n        // If animations are hard-disabled for the whole application there is no need to continue.\n        // There are also situations where a directive issues an animation for a JQLite wrapper that\n        // contains only comment nodes. In this case, there is no way we can perform an animation.\n        if (\n          // !animationsEnabled ||\n          !node ||\n          !isAnimatableByFilter(node, event, initialOptions) ||\n          !isAnimatableClassName(node, options)\n        ) {\n          close();\n\n          return runner;\n        }\n        const isStructural = [\"enter\", \"move\", \"leave\"].indexOf(event) >= 0;\n\n        // This is a hard disable of all animations the element itself, therefore  there is no need to\n        // continue further past this point if not enabled\n        // Animations are also disabled if the document is currently hidden (page is not visible\n        // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n        let skipAnimations =\n          document.hidden || disabledElementsLookup.get(node);\n\n        const existingAnimation =\n          (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n\n        const hasExistingAnimation = !!existingAnimation.state;\n\n        // there is no point in traversing the same collection of parent ancestors if a followup\n        // animation will be run on the same element that already did all that checking work\n        if (\n          !skipAnimations &&\n          (!hasExistingAnimation ||\n            existingAnimation.state !== PRE_DIGEST_STATE)\n        ) {\n          skipAnimations = !areAnimationsAllowed(node, parentNode);\n        }\n\n        if (skipAnimations) {\n          // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n          if (document.hidden)\n            notifyProgress(runner, event, \"start\", getEventData(options));\n          close();\n\n          if (document.hidden)\n            notifyProgress(runner, event, \"close\", getEventData(options));\n\n          return runner;\n        }\n\n        if (isStructural) {\n          closeChildAnimations(node);\n        }\n\n        /** @type {AnimationOptions} */\n        const newAnimation = {\n          structural: isStructural,\n          element,\n          event,\n          addClass: options.addClass,\n          removeClass: options.removeClass,\n          close,\n          options,\n          runner,\n        };\n\n        if (hasExistingAnimation) {\n          const skipAnimationFlag = isAllowed(\n            \"skip\",\n            newAnimation,\n            existingAnimation,\n          );\n\n          if (skipAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              close();\n\n              return runner;\n            }\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n          const cancelAnimationFlag = isAllowed(\n            \"cancel\",\n            newAnimation,\n            existingAnimation,\n          );\n\n          if (cancelAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              // this will end the animation right away and it is safe\n              // to do so since the animation is already running and the\n              // runner callback code will run in async\n              existingAnimation.runner.end();\n            } else if (existingAnimation.structural) {\n              // this means that the animation is queued into a digest, but\n              // hasn't started yet. Therefore it is safe to run the close\n              // method which will call the runner methods in async.\n              existingAnimation.close();\n            } else {\n              // this will merge the new animation options into existing animation options\n              mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              return existingAnimation.runner;\n            }\n          } else {\n            // a joined animation means that this animation will take over the existing one\n            // so an example would involve a leave animation taking over an enter. Then when\n            // the postDigest kicks in the enter will be ignored.\n            const joinAnimationFlag = isAllowed(\n              \"join\",\n              newAnimation,\n              existingAnimation,\n            );\n\n            if (joinAnimationFlag) {\n              if (existingAnimation.state === RUNNING_STATE) {\n                normalizeAnimationDetails(element, newAnimation);\n              } else {\n                applyGeneratedPreparationClasses(\n                  element,\n                  isStructural ? event : null,\n                  options,\n                );\n\n                event = newAnimation.event = existingAnimation.event;\n                options = mergeAnimationDetails(\n                  element,\n                  existingAnimation,\n                  newAnimation,\n                );\n\n                // we return the same runner since only the option values of this animation will\n                // be fed into the `existingAnimation`.\n                return existingAnimation.runner;\n              }\n            }\n          }\n        } else {\n          // normalization in this case means that it removes redundant CSS classes that\n          // already exist (addClass) or do not exist (removeClass) on the element\n          normalizeAnimationDetails(element, newAnimation);\n        }\n\n        // when the options are merged and cleaned up we may end up not having to do\n        // an animation at all, therefore we should check this before issuing a post\n        // digest callback. Structural animations will always run no matter what.\n        let isValidAnimation = newAnimation.structural;\n\n        if (!isValidAnimation) {\n          // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n          isValidAnimation =\n            (newAnimation.event === \"animate\" &&\n              Object.keys(newAnimation.options?.to || {}).length > 0) ||\n            hasAnimationClasses(newAnimation);\n        }\n\n        if (!isValidAnimation) {\n          close();\n          clearElementAnimationState(node);\n\n          return runner;\n        }\n\n        // the counter keeps track of cancelled animations\n        const counter = (existingAnimation.counter || 0) + 1;\n\n        newAnimation.counter = counter;\n\n        markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);\n        $rootScope.$postUpdate(() => {\n          // It is possible that the DOM nodes inside `originalElement` have been replaced. This can\n          // happen if the animated element is a transcluded clone and also has a `templateUrl`\n          // directive on it. Therefore, we must recreate `element` in order to interact with the\n          // actual DOM nodes.\n          // Note: We still need to use the old `node` for certain things, such as looking up in\n          //       HashMaps where it was used as the key.\n\n          element = stripCommentsFromElement(originalElement);\n\n          let animationDetails = activeAnimationsLookup.get(node);\n\n          const animationCancelled = !animationDetails;\n\n          animationDetails = animationDetails || {};\n\n          // if addClass/removeClass is called before something like enter then the\n          // registered parent element may not be present. The code below will ensure\n          // that a final value for parent element is obtained\n          const parentElement = element.parentElement || null;\n\n          // animate/structural/class-based animations all have requirements. Otherwise there\n          // is no point in performing an animation. The parent node must also be set.\n          const isCurrentAnimationValid =\n            parentElement &&\n            (animationDetails.event === \"animate\" ||\n              animationDetails.structural ||\n              hasAnimationClasses(animationDetails));\n\n          // this means that the previous animation was cancelled\n          // even if the follow-up animation is the same event\n          if (\n            animationCancelled ||\n            animationDetails.counter !== counter ||\n            !isCurrentAnimationValid\n          ) {\n            // if another animation did not take over then we need\n            // to make sure that the domOperation and options are\n            // handled accordingly\n            if (animationCancelled) {\n              applyAnimationClasses(element, options);\n              applyAnimationStyles(element, options);\n            }\n\n            // if the event changed from something like enter to leave then we do\n            // it, otherwise if it's the same then the end result will be the same too\n            if (\n              animationCancelled ||\n              (isStructural && animationDetails.event !== event)\n            ) {\n              options.domOperation();\n              runner.end();\n            }\n\n            // in the event that the element animation was not cancelled or a follow-up animation\n            // isn't allowed to animate from here then we need to clear the state of the element\n            // so that any future animations won't read the expired animation data.\n            if (!isCurrentAnimationValid) {\n              clearElementAnimationState(node);\n            }\n\n            return;\n          }\n\n          // this combined multiple class to addClass / removeClass into a setClass event\n          // so long as a structural event did not take over the animation\n          event =\n            !animationDetails.structural &&\n            hasAnimationClasses(animationDetails, true)\n              ? \"setClass\"\n              : animationDetails.event;\n\n          markElementAnimationState(node, RUNNING_STATE);\n          const realRunner = $$animation(\n            element,\n            event,\n            animationDetails.options,\n          );\n\n          // this will update the runner's flow-control events based on\n          // the `realRunner` object.\n          runner.setHost(realRunner);\n          notifyProgress(runner, event, \"start\", getEventData(options));\n\n          realRunner.done((status) => {\n            close(!status);\n\n            if (activeAnimationsLookup.get(node)?.counter === counter) {\n              clearElementAnimationState(node);\n            }\n            notifyProgress(runner, event, \"close\", getEventData(options));\n          });\n        });\n\n        // Since we don't have digest any more - trigger queue here\n        setTimeout($rootScope.$flushQueue, 0);\n\n        return runner;\n\n        /**\n         * @param {AnimateRunner} runnerParam\n         * @param {string} eventParam\n         * @param {string} phase\n         * @param {import(\"../queue/interface.ts\").QueueAnimationData} data\n         */\n        function notifyProgress(runnerParam, eventParam, phase, data) {\n          runInNextPostDigestOrNow(() => {\n            const callbacks = findCallbacks(parentNode, node, eventParam);\n\n            if (callbacks.length) {\n              callbacks.forEach((callback) => {\n                callback(element, phase, data);\n              });\n              cleanupEventListeners(phase, node);\n            } else {\n              cleanupEventListeners(phase, node);\n            }\n          });\n          runnerParam.progress(eventParam, phase, data);\n        }\n\n        /**\n         * @param {boolean | undefined} [reject]\n         */\n        function close(reject) {\n          clearGeneratedClasses(element, options);\n          applyAnimationClasses(element, options);\n          applyAnimationStyles(element, options);\n          options.domOperation();\n          runner.complete(!reject);\n        }\n      }\n\n      /**\n       * Closes and cleans up any child animations found under the given node.\n       *\n       * Looks for elements that have the NG_ANIMATE_ATTR_NAME attribute, checks their\n       * animation state, ends running animations, and removes them from the\n       * activeAnimationsLookup if appropriate.\n       *\n       * @param {Element | ParentNode} node\n       *   The DOM node whose descendant animations should be closed.\n       *\n       * @returns {void}\n       */\n      function closeChildAnimations(node) {\n        const children = node.querySelectorAll(`[${NG_ANIMATE_ATTR_NAME}]`);\n\n        children.forEach((child) => {\n          const state = parseInt(\n            /** @type {string} */ (child.getAttribute(NG_ANIMATE_ATTR_NAME)),\n            10,\n          );\n\n          const animationDetails = activeAnimationsLookup.get(child);\n\n          if (animationDetails) {\n            switch (state) {\n              case RUNNING_STATE:\n                animationDetails.runner.end();\n                activeAnimationsLookup.delete(child);\n                break;\n              case PRE_DIGEST_STATE:\n                activeAnimationsLookup.delete(child);\n                break;\n            }\n          }\n        });\n      }\n\n      /**\n       * @param {Element} node\n       */\n      function clearElementAnimationState(node) {\n        node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n        activeAnimationsLookup.delete(node);\n      }\n\n      /**\n       * This fn returns false if any of the following is true:\n       * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n       * b) a parent element has an ongoing structural animation, and animateChildren is false\n       * c) the element is not a child of the body\n       * d) the element is not a child of the $rootElement\n       * @param {Element} node\n       * @param {Element} parentNode\n       */\n      function areAnimationsAllowed(node, parentNode) {\n        const bodyNode = document.body;\n\n        const rootNode = $injector.get(\"$rootElement\");\n\n        let bodyNodeDetected = node === bodyNode || node.nodeName === \"HTML\";\n\n        let rootNodeDetected = node === rootNode;\n\n        let parentAnimationDetected = false;\n\n        let elementDisabled = disabledElementsLookup.get(node);\n\n        let animateChildren;\n\n        let parentHost = getOrSetCacheData(node, NG_ANIMATE_PIN_DATA);\n\n        if (parentHost) {\n          parentNode = parentHost;\n        }\n\n        while (parentNode) {\n          if (!rootNodeDetected) {\n            // AngularTS doesn't want to attempt to animate elements outside of the application\n            // therefore we need to ensure that the rootElement is an ancestor of the current element\n            rootNodeDetected = parentNode === rootNode;\n          }\n\n          if (parentNode.nodeType !== NodeType._ELEMENT_NODE) {\n            // no point in inspecting the #document element\n            break;\n          }\n\n          const details = activeAnimationsLookup.get(parentNode) || {};\n\n          // either an enter, leave or move animation will commence\n          // therefore we can't allow any animations to take place\n          // but if a parent animation is class-based then that's ok\n          if (!parentAnimationDetected) {\n            const parentNodeDisabled = disabledElementsLookup.get(parentNode);\n\n            if (parentNodeDisabled === true && elementDisabled !== false) {\n              // disable animations if the user hasn't explicitly enabled animations on the\n              // current element\n              elementDisabled = true;\n              // element is disabled via parent element, no need to check anything else\n              break;\n            } else if (parentNodeDisabled === false) {\n              elementDisabled = false;\n            }\n            parentAnimationDetected = details.structural;\n          }\n\n          if (isUndefined(animateChildren) || animateChildren === true) {\n            const value = getOrSetCacheData(\n              parentNode,\n              NG_ANIMATE_CHILDREN_DATA,\n            );\n\n            if (isDefined(value)) {\n              animateChildren = value;\n            }\n          }\n\n          // there is no need to continue traversing at this point\n          if (parentAnimationDetected && animateChildren === false) break;\n\n          if (!bodyNodeDetected) {\n            // we also need to ensure that the element is or will be a part of the body element\n            // otherwise it is pointless to even issue an animation to be rendered\n            bodyNodeDetected = parentNode === bodyNode;\n          }\n\n          if (bodyNodeDetected && rootNodeDetected) {\n            // If both body and root have been found, any other checks are pointless,\n            // as no animation data should live outside the application\n            break;\n          }\n\n          if (!rootNodeDetected) {\n            // If `rootNode` is not detected, check if `parentNode` is pinned to another element\n            parentHost = getOrSetCacheData(parentNode, NG_ANIMATE_PIN_DATA);\n\n            if (parentHost) {\n              // The pin target element becomes the next parent element\n              parentNode = parentHost;\n              continue;\n            }\n          }\n\n          // eslint-disable-next-line prefer-destructuring\n          parentNode = /** @type {Element} */ (parentNode.parentNode);\n        }\n\n        const allowAnimation =\n          (!parentAnimationDetected || animateChildren) &&\n          elementDisabled !== true;\n\n        return allowAnimation && rootNodeDetected && bodyNodeDetected;\n      }\n\n      /**\n       * @param {Element} node\n       * @param {number} state\n       * @param {AnimationOptions} [details]\n       */\n      function markElementAnimationState(node, state, details) {\n        details = details || {};\n        details.state = state;\n\n        node.setAttribute(NG_ANIMATE_ATTR_NAME, state.toString());\n\n        const oldValue = activeAnimationsLookup.get(node);\n\n        const newValue = oldValue ? extend(oldValue, details) : details;\n\n        activeAnimationsLookup.set(node, newValue);\n      }\n    },\n  ];\n}\n","import { isArray, isFunction, isObject } from \"../shared/utils.js\";\nimport {\n  applyAnimationClassesFactory,\n  applyAnimationStyles,\n  prepareAnimationOptions,\n} from \"./shared.js\";\nimport { $injectTokens, provider } from \"../injection-tokens.js\";\nimport { AnimateRunner } from \"./runner/animate-runner.js\";\n\nAnimateJsProvider.$inject = provider([$injectTokens._animate]);\n\n/**\n * @param {import(\"./animate.js\").AnimateProvider} $animateProvider\n */\nexport function AnimateJsProvider($animateProvider) {\n  this.$get = [\n    $injectTokens._injector,\n    /**\n     * @param {ng.InjectorService} $injector\n     * @returns {import(\"./interface.ts\").AnimateJsFn}\n     */\n    ($injector) => {\n      const applyAnimationClasses = applyAnimationClassesFactory();\n\n      /**\n       * @param {HTMLElement} element\n       * @param {string} event\n       * @param {string | string[] | null | undefined} classes\n       * @param {ng.AnimationOptions | undefined} options\n       * @returns {import(\"./interface.ts\").Animator | undefined}\n       */\n      return function (element, event, classes, options) {\n        // Optional arguments\n        if (arguments.length === 3 && !isArray(classes) && isObject(classes)) {\n          options = /** @type {ng.AnimationOptions} */ (classes);\n          classes = null;\n        }\n\n        /** @type {ng.AnimationOptions} */\n        const animationOptions = prepareAnimationOptions(options);\n\n        if (!classes) {\n          classes = element.getAttribute(\"class\") || \"\";\n\n          if (animationOptions.addClass)\n            classes += ` ${animationOptions.addClass}`;\n\n          if (animationOptions.removeClass)\n            classes += ` ${animationOptions.removeClass}`;\n        }\n\n        const classesToAdd = animationOptions.addClass;\n\n        const classesToRemove = animationOptions.removeClass;\n\n        // Lookup animation objects\n        const animations = lookupAnimations(classes);\n\n        /**\n         * @type {((done: () => void) => void) | undefined}\n         */\n        let before;\n\n        /**\n         * @type {((done: () => void) => void) | undefined}\n         */\n        let after;\n\n        if (animations.length) {\n          let beforeFn, afterFn;\n\n          if (event === \"leave\") {\n            beforeFn = \"leave\";\n            afterFn = \"afterLeave\";\n          } else {\n            beforeFn = `before${event.charAt(0).toUpperCase()}${event.substring(1)}`;\n            afterFn = event;\n          }\n\n          if (event !== \"enter\" && event !== \"move\") {\n            before = packageAnimations(\n              element,\n              animationOptions,\n              animations,\n              beforeFn,\n              {\n                add: classesToAdd,\n                remove: classesToRemove,\n              },\n            );\n          }\n          after = packageAnimations(\n            element,\n            animationOptions,\n            animations,\n            afterFn,\n            {\n              add: classesToAdd,\n              remove: classesToRemove,\n            },\n          );\n        }\n\n        if (!before && !after) return undefined;\n\n        function applyOptions() {\n          animationOptions.domOperation?.();\n          applyAnimationClasses(element, animationOptions);\n        }\n\n        function close() {\n          applyOptions();\n          applyAnimationStyles(element, animationOptions);\n        }\n\n        /** @type {ng.AnimateRunner} */\n        let runner;\n\n        return /** @type {import(\"./interface.ts\").AnimateJsRunner} */ ({\n          _willAnimate: true,\n\n          start() {\n            if (runner) return runner;\n\n            runner = new AnimateRunner({\n              end: () => finish(true),\n              cancel: () => finish(false),\n            });\n\n            let finished = false;\n\n            let remaining = (before ? 1 : 0) + (after ? 1 : 0);\n\n            function partDone() {\n              if (finished) return;\n\n              if (--remaining === 0) finish(true);\n            }\n\n            /**\n             * @param {boolean | undefined} success\n             */\n            function finish(success) {\n              if (finished) return;\n              finished = true;\n              close();\n              runner.complete(success);\n            }\n\n            // Run before animations\n            if (before) before(partDone);\n            else applyOptions();\n\n            // Run after animations\n            if (after) after(partDone);\n\n            // If neither before nor after exist, nothing will call partDone()\n            if (remaining === 0) finish(true);\n\n            return runner;\n          },\n\n          end() {\n            if (runner) runner.end();\n            else {\n              close();\n              runner = new AnimateRunner();\n              runner.complete(true);\n            }\n\n            return runner;\n          },\n        });\n\n        // ---- helpers ----\n        /**\n         * @param {string | string[]} classList\n         */\n        function lookupAnimations(classList) {\n          const normalized = isArray(classList)\n            ? classList\n            : /** @type {string[]} */ (classList.split(\" \"));\n\n          /** @type {Array<Record<string, any>>} */\n          const matches = [];\n\n          /** @type {Record<string, boolean>} */\n          const flagMap = {};\n\n          for (let i = 0; i < normalized.length; i++) {\n            const klass = normalized[i];\n\n            const animationFactory =\n              $animateProvider._registeredAnimations[klass];\n\n            if (animationFactory && !flagMap[klass]) {\n              matches.push($injector.get(animationFactory));\n              flagMap[klass] = true;\n            }\n          }\n\n          return matches;\n        }\n\n        /**\n         * @param {HTMLElement} elementParam\n         * @param {ng.AnimationOptions} optionsParam\n         * @param {Array<Record<string, any>>} animationsParam\n         * @param {string} fnName\n         * @param {{ add?: string; remove?: string; }} classNames\n         */\n        function packageAnimations(\n          elementParam,\n          optionsParam,\n          animationsParam,\n          fnName,\n          classNames,\n        ) {\n          /** @type {Array<(done: () => void) => void>} */\n          const operations = [];\n\n          animationsParam.forEach((ani) => {\n            const animationFn = ani[fnName];\n\n            if (!animationFn) return;\n\n            operations.push((done) => {\n              if (isFunction(animationFn)) {\n                /** @type {any[]} */\n                let args;\n\n                switch (fnName) {\n                  case \"addClass\":\n                    args = [elementParam, classNames.add, done];\n                    break;\n                  case \"removeClass\":\n                    args = [elementParam, classNames.remove, done];\n                    break;\n                  case \"setClass\":\n                    args = [\n                      elementParam,\n                      classNames.add,\n                      classNames.remove,\n                      done,\n                    ];\n                    break;\n                  case \"animate\":\n                    args = [\n                      elementParam,\n                      optionsParam.from,\n                      optionsParam.to,\n                      done,\n                    ];\n                    break;\n                  default:\n                    args = [elementParam, done];\n                }\n\n                const value = animationFn.apply(ani, args);\n\n                if (value instanceof AnimateRunner) value.done(done);\n              } else done();\n            });\n          });\n\n          if (!operations.length) return undefined;\n\n          /**\n           * @param {() => void} done\n           */\n          return (done) => {\n            let completed = 0;\n\n            const total = operations.length;\n\n            operations.forEach((op) => {\n              op(() => {\n                if (++completed === total && isFunction(done)) done();\n              });\n            });\n          };\n        }\n      };\n    },\n  ];\n}\n","import {\n  deleteCacheData,\n  getCacheData,\n  removeElementData,\n  setCacheData,\n} from \"../shared/dom.js\";\nimport { mergeClasses } from \"../shared/utils.js\";\nimport {\n  NG_ANIMATE_CLASSNAME,\n  PREPARE_CLASS_SUFFIX,\n  applyAnimationClassesFactory,\n  applyAnimationStyles,\n  prepareAnimationOptions,\n} from \"./shared.js\";\nimport { $injectTokens as $t } from \"../injection-tokens.js\";\nimport { AnimateRunner } from \"./runner/animate-runner.js\";\nimport { animateCache } from \"./cache/animate-cache.js\";\nimport { rafScheduler } from \"./raf/raf-scheduler.js\";\n\n/** @typedef {import(\"./interface.ts\").SortedAnimationEntry} SortedAnimationEntry */\n/** @typedef {import(\"./interface.ts\").AnimationOptions} AnimationOptions */\n/** @typedef {import(\"./interface.ts\").AnimationDetails} AnimationDetails */\n/** @typedef {import(\"./interface.ts\").AnimationEntry} AnimationEntry */\n/** @typedef {import(\"./interface.ts\").AnchorRef} AnchorRef */\n/** @typedef {import(\"./interface.ts\").AnchorRefEntry} AnchorRefEntry */\n\nconst RUNNER_STORAGE_KEY = \"$$animationRunner\";\n\nconst PREPARE_CLASSES_KEY = \"$$animatePrepareClasses\";\n\nexport function AnimationProvider() {\n  const NG_ANIMATE_REF_ATTR = \"ng-animate-ref\";\n\n  /**\n   * @type {string[]}\n   */\n  const drivers = (this.drivers = []);\n\n  /**\n   * @param {Element | Node} element\n   * @param {AnimateRunner} runner\n   */\n  function setRunner(element, runner) {\n    setCacheData(element, RUNNER_STORAGE_KEY, runner);\n  }\n\n  /**\n   * @param {Element} element\n   */\n  function removeRunner(element) {\n    deleteCacheData(element, RUNNER_STORAGE_KEY);\n  }\n\n  /**\n   * @param {Element} element\n   */\n  function getRunner(element) {\n    return getCacheData(element, RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = [\n    $t._rootScope,\n    $t._injector,\n    /**\n     *\n     * @param {ng.RootScopeService} $rootScope\n     * @param {ng.InjectorService} $injector\n     * @return {import(\"./interface.ts\").AnimationService}\n     */\n    function ($rootScope, $injector) {\n      /** @type {AnimationEntry[]} */\n      const animationQueue = [];\n\n      const applyAnimationClasses = applyAnimationClassesFactory();\n\n      /**\n       * @param {SortedAnimationEntry[]} animations\n       */\n      function sortAnimations(animations) {\n        const tree = /** @type {Partial<SortedAnimationEntry>} */ ({\n          children: [],\n        });\n\n        let i;\n\n        const lookup = new Map();\n\n        // this is done first beforehand so that the map\n        // is filled with a list of the elements that will be animated\n\n        for (i = 0; i < animations.length; i++) {\n          const animation = animations[i];\n\n          lookup.set(\n            animation.domNode,\n            (animations[i] = {\n              domNode: animation.domNode,\n              element: animation.element,\n              fn: animation.fn,\n              children: [],\n            }),\n          );\n        }\n\n        for (i = 0; i < animations.length; i++) {\n          processNode(animations[i]);\n        }\n\n        return flatten(/** @type {SortedAnimationEntry} */ (tree));\n\n        /**\n         *\n         * @param {SortedAnimationEntry} entry\n         * @returns\n         */\n        function processNode(entry) {\n          if (entry.processed) return entry;\n          entry.processed = true;\n\n          const elementNode = entry.domNode;\n\n          let { parentNode } = elementNode;\n\n          lookup.set(elementNode, entry);\n\n          let parentEntry;\n\n          while (parentNode) {\n            parentEntry = lookup.get(parentNode);\n\n            if (parentEntry) {\n              if (!parentEntry.processed) {\n                parentEntry = processNode(parentEntry);\n              }\n              break;\n            }\n            // eslint-disable-next-line prefer-destructuring\n            parentNode = parentNode.parentNode;\n          }\n\n          (parentEntry || tree).children.push(entry);\n\n          return entry;\n        }\n\n        /**\n         * @param {SortedAnimationEntry} theeParam\n         * @returns\n         */\n        function flatten(theeParam) {\n          const result = [];\n\n          const queue = [];\n\n          for (i = 0; i < theeParam.children.length; i++) {\n            queue.push(theeParam.children[i]);\n          }\n\n          let remainingLevelEntries = queue.length;\n\n          let nextLevelEntries = 0;\n\n          let row = [];\n\n          for (let j = 0; j < queue.length; j++) {\n            const entry = queue[j];\n\n            if (remainingLevelEntries <= 0) {\n              remainingLevelEntries = nextLevelEntries;\n              nextLevelEntries = 0;\n              result.push(row);\n              row = [];\n            }\n            row.push(entry);\n            entry.children.forEach((childEntry) => {\n              nextLevelEntries++;\n              queue.push(childEntry);\n            });\n            remainingLevelEntries--;\n          }\n\n          if (row.length) {\n            result.push(row);\n          }\n\n          return result;\n        }\n      }\n\n      /**\n       * @param {HTMLElement} elementParam\n       * @param {string} event\n       * @param {AnimationOptions | undefined} optionsParam\n       * @returns {AnimateRunner}\n       */\n      return function (elementParam, event, optionsParam) {\n        /** @type {AnimationOptions & { domOperation: () => void }} */\n        const options =\n          /** @type {AnimationOptions & { domOperation: () => void }} */ (\n            prepareAnimationOptions(optionsParam)\n          );\n\n        const isStructural = [\"enter\", \"move\", \"leave\"].indexOf(event) >= 0;\n\n        // there is no animation at the current moment, however\n        // these runner methods will get later updated with the\n        // methods leading into the driver's end/cancel methods\n        // for now they just stop the animation from starting\n        const runner = new AnimateRunner({\n          end() {\n            close();\n          },\n          cancel() {\n            close(true);\n          },\n        });\n\n        if (!drivers.length) {\n          close();\n\n          return runner;\n        }\n\n        let classes = mergeClasses(\n          elementParam.getAttribute(\"class\"),\n          mergeClasses(options.addClass, options.removeClass),\n        );\n\n        let { tempClasses } = options;\n\n        if (tempClasses) {\n          classes += ` ${tempClasses}`;\n          options.tempClasses = undefined;\n        }\n\n        if (isStructural) {\n          setCacheData(\n            elementParam,\n            PREPARE_CLASSES_KEY,\n            `ng-${event}${PREPARE_CLASS_SUFFIX}`,\n          );\n        }\n\n        setRunner(elementParam, runner);\n\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        animationQueue.push({\n          element: elementParam,\n          classes,\n          event,\n          structural: isStructural,\n          options,\n          beforeStart,\n          close,\n        });\n\n        elementParam.addEventListener(\"$destroy\", handleDestroyedElement);\n\n        // we only want there to be one function called within the post digest\n        // block. This way we can group animations for all the animations that\n        // were apart of the same postDigest flush call.\n        if (animationQueue.length > 1) return runner;\n        $rootScope.$postUpdate(() => {\n          /** @type {AnimationEntry[]} */\n          const animations = [];\n\n          animationQueue.forEach((entry) => {\n            // the element was destroyed early on which removed the runner\n            // form its storage. This means we can't animate this element\n            // at all and it already has been closed due to destruction.\n            if (getRunner(/** @type {HTMLElement} */ (entry.element))) {\n              animations.push(entry);\n            } else {\n              /** @type {(reject?: boolean | undefined) => void} */ (\n                entry.close\n              )();\n            }\n          });\n\n          // now any future animations will be in another postDigest\n          animationQueue.length = 0;\n\n          const groupedAnimations = groupAnimations(animations);\n\n          /** @type {SortedAnimationEntry[]} */\n          const toBeSortedAnimations = [];\n\n          groupedAnimations.forEach((animationEntry) => {\n            const fromElement = animationEntry.from\n              ? animationEntry.from.element\n              : animationEntry.element;\n\n            let extraClasses = options.addClass;\n\n            extraClasses =\n              (extraClasses ? `${extraClasses} ` : \"\") + NG_ANIMATE_CLASSNAME;\n            const cacheKey = animateCache._cacheKey(\n              fromElement,\n              animationEntry.event,\n              extraClasses,\n              options.removeClass,\n            );\n\n            toBeSortedAnimations.push({\n              element: fromElement,\n              domNode: fromElement,\n              fn: function triggerAnimationStart() {\n                let startAnimationFn;\n\n                const closeFn = animationEntry.close;\n\n                // in the event that we've cached the animation status for this element\n                // and it's in fact an invalid animation (something that has duration = 0)\n                // then we should skip all the heavy work from here on\n                if (\n                  animateCache._containsCachedAnimationWithoutDuration(cacheKey)\n                ) {\n                  closeFn();\n\n                  return;\n                }\n\n                // it's important that we apply the `ng-animate` CSS class and the\n                // temporary classes before we do any driver invoking since these\n                // CSS classes may be required for proper CSS detection.\n                animationEntry.beforeStart();\n\n                // in the event that the element was removed before the digest runs or\n                // during the RAF sequencing then we should not trigger the animation.\n                const targetElement =\n                  animationEntry.anchors &&\n                  animationEntry.from &&\n                  animationEntry.to\n                    ? animationEntry.from.element || animationEntry.to.element\n                    : animationEntry.element;\n\n                if (getRunner(targetElement)) {\n                  const operation = invokeFirstDriver(animationEntry);\n\n                  if (operation) {\n                    startAnimationFn = operation.start;\n                  }\n                }\n\n                if (!startAnimationFn) {\n                  closeFn();\n                } else {\n                  const animationRunner = startAnimationFn();\n\n                  animationRunner.done((/** @type {any} */ status) => {\n                    closeFn(!status);\n                  });\n                  updateAnimationRunners(animationEntry, animationRunner);\n                }\n              },\n              children: [],\n            });\n          });\n\n          // we need to sort each of the animations in order of parent to child\n          // relationships. This ensures that the child classes are applied at the\n          // right time.\n          const finalAnimations = sortAnimations(toBeSortedAnimations);\n\n          /** @type {Array<() => void>} */\n          const flatFinalAnimations = [];\n\n          for (let i = 0; i < finalAnimations.length; i++) {\n            const innerArray = finalAnimations[i];\n\n            for (let j = 0; j < innerArray.length; j++) {\n              const entry = innerArray[j];\n\n              const { element } = entry;\n\n              // the RAFScheduler code only uses functions\n              flatFinalAnimations.push(entry.fn);\n\n              // the first row of elements shouldn't have a prepare-class added to them\n              // since the elements are at the top of the animation hierarchy and they\n              // will be applied without a RAF having to pass...\n              if (i === 0) {\n                removeElementData(element, PREPARE_CLASSES_KEY);\n                continue;\n              }\n\n              const prepareClassName = getCacheData(\n                element,\n                PREPARE_CLASSES_KEY,\n              );\n\n              if (prepareClassName) {\n                element.classList.add(prepareClassName);\n              }\n            }\n          }\n\n          rafScheduler._schedule(flatFinalAnimations);\n        });\n\n        return runner;\n\n        /**\n         * @param {HTMLElement} node\n         * @returns\n         */\n        function getAnchorNodes(node) {\n          const SELECTOR = `[${NG_ANIMATE_REF_ATTR}]`;\n\n          const items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n            ? [node]\n            : node.querySelectorAll(SELECTOR);\n\n          /**\n           * @type {(Element | HTMLElement)[]}\n           */\n          const anchors = [];\n\n          items.forEach((nodeItem) => {\n            const attr = nodeItem.getAttribute(NG_ANIMATE_REF_ATTR);\n\n            if (attr && attr.length) {\n              anchors.push(nodeItem);\n            }\n          });\n\n          return anchors;\n        }\n\n        /**\n         * @param {AnimationEntry[]} animations\n         * @returns {AnimationEntry[]}\n         */\n        function groupAnimations(animations) {\n          /** @type {AnimationEntry[]} */\n          const preparedAnimations = [];\n\n          /** @type {Record<string, AnchorRefEntry>} */\n          const refLookup = {};\n\n          animations.forEach((animation, index) => {\n            // eslint-disable-next-line no-shadow\n            const { element, event } = animation;\n\n            const node = element;\n\n            const enterOrMove = [\"enter\", \"move\"].indexOf(event) >= 0;\n\n            const anchorNodes = animation.structural\n              ? getAnchorNodes(node)\n              : [];\n\n            if (anchorNodes.length) {\n              const direction = enterOrMove ? \"to\" : \"from\";\n\n              anchorNodes.forEach((anchor) => {\n                const key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n\n                if (!key) return;\n\n                refLookup[key] = refLookup[key] || {};\n                refLookup[key][direction] = {\n                  animationID: index,\n                  element: anchor,\n                };\n              });\n            } else {\n              preparedAnimations.push(animation);\n            }\n          });\n\n          /** @type {Record<string, boolean>} */\n          const usedIndicesLookup = {};\n\n          /** @type {Record<string, AnimationEntry>} */\n          const anchorGroups = {};\n\n          Object.values(refLookup).forEach((operations) => {\n            const { from, to } = operations;\n\n            if (!from || !to) {\n              // only one of these is set therefore we can't have an\n              // anchor animation since all three pieces are required\n              const index = from\n                ? from.animationID\n                : to\n                  ? to.animationID\n                  : undefined;\n\n              if (index === undefined) return;\n\n              const indexKey = index.toString();\n\n              if (!usedIndicesLookup[indexKey]) {\n                usedIndicesLookup[indexKey] = true;\n                preparedAnimations.push(animations[index]);\n              }\n\n              return;\n            }\n\n            const fromAnimation = animations[from.animationID];\n\n            const toAnimation = animations[to.animationID];\n\n            const lookupKey = from.animationID.toString();\n\n            if (!anchorGroups[lookupKey]) {\n              const group = (anchorGroups[lookupKey] = {\n                structural: true,\n                element: /** @type {HTMLElement} */ (from.element),\n                event: fromAnimation.event,\n                options: fromAnimation.options,\n                beforeStart() {\n                  fromAnimation.beforeStart();\n                  toAnimation.beforeStart();\n                },\n                close() {\n                  fromAnimation.close();\n                  toAnimation.close();\n                },\n                classes: cssClassesIntersection(\n                  fromAnimation.classes,\n                  toAnimation.classes,\n                ),\n                from: fromAnimation,\n                to: toAnimation,\n                anchors: [], // TODO(matsko): change to reference nodes\n              });\n\n              // the anchor animations require that the from and to elements both have at least\n              // one shared CSS class which effectively marries the two elements together to use\n              // the same animation driver and to properly sequence the anchor animation.\n              if (group.classes.length) {\n                preparedAnimations.push(group);\n              } else {\n                preparedAnimations.push(fromAnimation);\n                preparedAnimations.push(toAnimation);\n              }\n            }\n\n            const group = anchorGroups[lookupKey];\n\n            if (group?.anchors) {\n              group.anchors.push({\n                out: /** @type {HTMLElement} */ (from.element),\n                in: /** @type {HTMLElement} */ (to.element),\n              });\n            }\n          });\n\n          return preparedAnimations;\n        }\n\n        /**\n         * @param {string | string[] | null | undefined} value\n         * @returns {string}\n         */\n        function normalizeClassValue(value) {\n          if (Array.isArray(value)) return value.join(\" \");\n\n          return value || \"\";\n        }\n\n        /**\n         * @param {string | string[] | null | undefined} a\n         * @param {string | string[] | null | undefined} b\n         * @returns {string}\n         */\n        function cssClassesIntersection(a, b) {\n          a = normalizeClassValue(a).split(\" \");\n          b = normalizeClassValue(b).split(\" \");\n          const matches = [];\n\n          for (let i = 0; i < a.length; i++) {\n            const aa = a[i];\n\n            if (aa.substring(0, 3) === \"ng-\") continue;\n\n            for (let j = 0; j < b.length; j++) {\n              if (aa === b[j]) {\n                matches.push(aa);\n                break;\n              }\n            }\n          }\n\n          return matches.join(\" \");\n        }\n\n        /**\n         * @param {import(\"./interface.ts\").AnimationDetails} animationDetails\n         */\n        function invokeFirstDriver(animationDetails) {\n          // we loop in reverse order since the more general drivers (like CSS and JS)\n          // may attempt more elements, but custom drivers are more particular\n          for (let i = drivers.length - 1; i >= 0; i--) {\n            const driverName = drivers[i];\n\n            const factory = $injector.get(driverName);\n\n            const driver = factory(animationDetails);\n\n            if (driver) {\n              return driver;\n            }\n          }\n\n          return undefined;\n        }\n\n        function beforeStart() {\n          tempClasses =\n            (tempClasses ? `${tempClasses} ` : \"\") + NG_ANIMATE_CLASSNAME;\n          elementParam.className += ` ${tempClasses}`;\n          let prepareClassName = getCacheData(\n            elementParam,\n            PREPARE_CLASSES_KEY,\n          );\n\n          if (prepareClassName) {\n            elementParam.classList.remove(prepareClassName);\n            prepareClassName = null;\n          }\n        }\n\n        /**\n         *\n         * @param {*} animation\n         * @param {*} newRunner\n         */\n        function updateAnimationRunners(animation, newRunner) {\n          if (animation.from && animation.to) {\n            update(animation.from.element);\n            update(animation.to.element);\n          } else {\n            update(animation.element);\n          }\n\n          /**\n           * @param {Element} el\n           */\n          function update(el) {\n            getRunner(el).setHost(newRunner);\n          }\n        }\n\n        function handleDestroyedElement() {\n          (event !== \"leave\" || !options._domOperationFired) &&\n            getRunner(elementParam)?.end();\n        }\n\n        /**\n         * @param {boolean | undefined} [rejected]\n         */\n        function close(rejected) {\n          removeRunner(elementParam);\n\n          applyAnimationClasses(elementParam, options);\n          applyAnimationStyles(elementParam, options);\n          options.domOperation();\n\n          if (tempClasses) {\n            const classList = Array.isArray(tempClasses)\n              ? tempClasses\n              : tempClasses.split(\" \");\n\n            classList.forEach((/** @type {string} */ cls) =>\n              elementParam.classList.remove(cls),\n            );\n          }\n\n          runner.complete(!rejected);\n        }\n      };\n    },\n  ];\n}\n","import { $injectTokens, provider } from \"../injection-tokens.js\";\nimport { NodeType } from \"../shared/node.js\";\nimport { isString } from \"../shared/utils.js\";\n\nimport { AnimateRunner } from \"./runner/animate-runner.js\";\nimport { concatWithSpace } from \"./shared.js\";\n\nconst NG_ANIMATE_SHIM_CLASS_NAME = \"ng-animate-shim\";\n\nconst NG_ANIMATE_ANCHOR_CLASS_NAME = \"ng-anchor\";\n\nconst NG_OUT_ANCHOR_CLASS_NAME = \"ng-anchor-out\";\n\nconst NG_IN_ANCHOR_CLASS_NAME = \"ng-anchor-in\";\n\nAnimateCssDriverProvider.$inject = provider([$injectTokens._animation]);\n\n/**\n * @param {import(\"./animation.js\").AnimationProvider} $$animationProvider\n */\nexport function AnimateCssDriverProvider($$animationProvider) {\n  $$animationProvider.drivers.push($injectTokens._animateCssDriver);\n\n  /**\n   * @param {Element} node\n   * @returns {boolean}\n   */\n  function isDocumentFragment(node) {\n    return node.parentNode?.nodeType === NodeType._DOCUMENT_FRAGMENT_NODE;\n  }\n\n  /**\n   * @returns {Function}\n   */\n  this.$get = [\n    $injectTokens._animateCss,\n    $injectTokens._rootElement,\n    /**\n     *\n     * @param {*} $animateCss\n     * @param {HTMLElement} $rootElement\n     * @returns\n     */\n    function ($animateCss, $rootElement) {\n      const bodyNode = document.body;\n\n      const rootNode = $rootElement;\n\n      const rootBodyElement =\n        // this is to avoid using something that exists outside of the body\n        // we also special case the doc fragment case because our unit test code\n        // appends the $rootElement to the body after the app has been bootstrapped\n        isDocumentFragment(rootNode) || bodyNode.contains(rootNode)\n          ? rootNode\n          : bodyNode;\n\n      return /** @param {import(\"./interface.ts\").AnimationDetails} animationDetails */ function initDriverFn(\n        animationDetails,\n      ) {\n        return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(\n              animationDetails.from,\n              animationDetails.to,\n              animationDetails.anchors || [],\n            )\n          : prepareRegularAnimation(animationDetails);\n      };\n\n      /**\n       * @param {HTMLElement} outAnchor\n       * @param {HTMLElement} inAnchor\n       * @returns {{ start(): AnimateRunner } | null}\n       */\n      function prepareAnchoredAnimation(outAnchor, inAnchor) {\n        const clone = /** @type {HTMLElement} */ (outAnchor.cloneNode(true));\n\n        const startingClasses = filterCssClasses(clone.getAttribute(\"class\"));\n\n        outAnchor.classList.add(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.classList.add(NG_ANIMATE_SHIM_CLASS_NAME);\n\n        clone.classList.add(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n        rootBodyElement.append(clone);\n\n        /** @type {ReturnType<typeof prepareInAnimation> | null} */\n        let animatorIn = null;\n\n        const animatorOut = prepareOutAnimation();\n\n        // the user may not end up using the `out` animation and\n        // only making use of the `in` animation or vice-versa.\n        // In either case we should allow this and not assume the\n        // animation is over unless both animations are not used.\n        if (!animatorOut) {\n          animatorIn = prepareInAnimation();\n\n          if (!animatorIn) {\n            end();\n\n            return null;\n          }\n        }\n\n        const startingAnimator = animatorOut || animatorIn;\n\n        if (!startingAnimator) {\n          end();\n\n          return null;\n        }\n\n        return {\n          start() {\n            const runner = new AnimateRunner({\n              end: endFn,\n              cancel: endFn,\n            });\n\n            let currentAnimation = startingAnimator.start();\n\n            currentAnimation.done(() => {\n              currentAnimation = null;\n\n              if (!animatorIn) {\n                animatorIn = prepareInAnimation();\n\n                if (animatorIn) {\n                  currentAnimation = animatorIn.start();\n                  currentAnimation.done(() => {\n                    currentAnimation = null;\n                    end();\n                    runner.complete();\n                  });\n\n                  return currentAnimation;\n                }\n              }\n              // in the event that there is no `in` animation\n              end();\n              runner.complete();\n\n              return undefined;\n            });\n\n            return runner;\n\n            function endFn() {\n              if (currentAnimation) {\n                currentAnimation.end();\n              }\n            }\n          },\n        };\n\n        /**\n         * @param {HTMLElement} anchor\n         */\n        function calculateAnchorStyles(anchor) {\n          /** @type {import(\"../shared/interface.ts\").Dict<string>} */\n          const styles = {};\n\n          const coords = anchor.getBoundingClientRect();\n\n          // we iterate directly since safari messes up and doesn't return\n          // all the keys for the coords object when iterated\n          /** @type {Array<\"width\" | \"height\" | \"top\" | \"left\">} */\n          const keys = [\"width\", \"height\", \"top\", \"left\"];\n\n          keys.forEach((key) => {\n            let value = coords[key];\n\n            switch (key) {\n              case \"top\":\n                value += bodyNode.scrollTop;\n                break;\n              case \"left\":\n                value += bodyNode.scrollLeft;\n                break;\n            }\n            styles[key] = `${Math.floor(value)}px`;\n          });\n\n          return styles;\n        }\n\n        function prepareOutAnimation() {\n          const animator = $animateCss(clone, {\n            addClass: NG_OUT_ANCHOR_CLASS_NAME,\n            delay: true,\n            from: calculateAnchorStyles(outAnchor),\n          });\n\n          // read the comment within `prepareRegularAnimation` to understand\n          // why this check is necessary\n          return animator._willAnimate ? animator : null;\n        }\n\n        function prepareInAnimation() {\n          const endingClasses = filterCssClasses(\n            inAnchor.getAttribute(\"class\"),\n          );\n\n          const toAdd = getUniqueValues(endingClasses, startingClasses);\n\n          const toRemove = getUniqueValues(startingClasses, endingClasses);\n\n          const animator = $animateCss(clone, {\n            to: calculateAnchorStyles(inAnchor),\n            addClass: `${NG_IN_ANCHOR_CLASS_NAME} ${toAdd}`,\n            removeClass: `${NG_OUT_ANCHOR_CLASS_NAME} ${toRemove}`,\n            delay: true,\n          });\n\n          // read the comment within `prepareRegularAnimation` to understand\n          // why this check is necessary\n          return animator._willAnimate ? animator : null;\n        }\n\n        function end() {\n          clone.remove();\n          outAnchor.classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);\n          inAnchor.classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);\n        }\n      }\n\n      /**\n       * @param {import(\"./interface.ts\").AnimationDetails} from\n       * @param {import(\"./interface.ts\").AnimationDetails} to\n       * @param {NonNullable<import(\"./interface.ts\").AnimationDetails[\"anchors\"]>} anchors\n       */\n      function prepareFromToAnchorAnimation(from, to, anchors) {\n        const fromAnimation = prepareRegularAnimation(from);\n\n        const toAnimation = prepareRegularAnimation(to);\n\n        /** @type {Array<{ start(): ng.AnimateRunner }>} */\n        const anchorAnimations = [];\n\n        anchors.forEach((anchor) => {\n          const outElement = anchor.out;\n\n          const inElement = anchor.in;\n\n          const animator = prepareAnchoredAnimation(outElement, inElement);\n\n          if (animator) {\n            anchorAnimations.push(animator);\n          }\n        });\n\n        // no point in doing anything when there are no elements to animate\n        if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)\n          return undefined;\n\n        return {\n          start() {\n            /**\n             * @type {ng.AnimateRunner[]}\n             */\n            const animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            anchorAnimations.forEach((animation) => {\n              animationRunners.push(animation.start());\n            });\n\n            const runner = new AnimateRunner({\n              end: endFn,\n              cancel: endFn, // CSS-driven animations cannot be cancelled, only ended\n            });\n\n            AnimateRunner._all(animationRunners, (status) => {\n              runner.complete(status);\n            });\n\n            return runner;\n\n            function endFn() {\n              animationRunners.forEach((runnerItem) => {\n                runnerItem.end();\n              });\n            }\n          },\n        };\n      }\n\n      /**\n       * @param {import(\"./interface.ts\").AnimationDetails} animationDetails\n       */\n      function prepareRegularAnimation(animationDetails) {\n        const options = animationDetails.options || {};\n\n        if (animationDetails.structural) {\n          options.event = animationDetails.event;\n          options.structural = true;\n          options.applyClassesEarly = true;\n\n          // we special case the leave animation since we want to ensure that\n          // the element is removed as soon as the animation is over. Otherwise\n          // a flicker might appear or the element may not be removed at all\n          if (animationDetails.event === \"leave\") {\n            options.onDone = options.domOperation;\n          }\n        }\n\n        // We assign the preparationClasses as the actual animation event since\n        // the internals of $animateCss will just suffix the event token values\n        // with `-active` to trigger the animation.\n        if (options.preparationClasses) {\n          options.event = concatWithSpace(\n            /** @type {string} */ (options.event),\n            options.preparationClasses,\n          );\n        }\n\n        const animator = $animateCss(animationDetails.element, options);\n\n        // the driver lookup code inside of $$animation attempts to spawn a\n        // driver one by one until a driver returns a._willAnimate animator object.\n        // $animateCss will always return an object, however, it will pass in\n        // a flag as a hint as to whether an animation was detected or not\n\n        return animator._willAnimate ? animator : null;\n      }\n    },\n  ];\n}\n\n/**\n * @param {string | null} classes\n * @return {string}\n */\nfunction filterCssClasses(classes) {\n  // remove all the `ng-` stuff\n  return classes ? classes.replace(/\\bng-\\S+\\b/g, \"\") : \"\";\n}\n\n/**\n * @param {string | string[]} a\n * @param {string | string[]} b\n */\nfunction getUniqueValues(a, b) {\n  if (isString(a)) a = a.split(\" \");\n\n  if (isString(b)) b = b.split(\" \");\n\n  return a.filter((/** @type {any} */ val) => b.indexOf(val) === -1).join(\" \");\n}\n","import { $injectTokens, provider } from \"../injection-tokens.js\";\nimport { AnimateRunner } from \"./runner/animate-runner.js\";\n\nAnimateJsDriverProvider.$inject = provider([$injectTokens._animation]);\n\n/**\n * @param {import(\"./animation.js\").AnimationProvider} $$animationProvider\n */\nexport function AnimateJsDriverProvider($$animationProvider) {\n  $$animationProvider.drivers.push($injectTokens._animateJsDriver);\n  this.$get = [\n    $injectTokens._animateJs,\n    /**\n     *\n     * @param {import(\"./interface.ts\").AnimateJsFn} $$animateJs\n     */\n    function ($$animateJs) {\n      /**\n       * @param {import(\"./interface.ts\").AnimationDetails} animationDetails\n       */\n      function initDriverFn(animationDetails) {\n        if (animationDetails.from && animationDetails.to) {\n          const fromAnimation = prepareAnimation(animationDetails.from);\n\n          const toAnimation = prepareAnimation(animationDetails.to);\n\n          if (!fromAnimation && !toAnimation) return undefined;\n\n          return {\n            start() {\n              /** @type {Array<ng.AnimateRunner>} */\n              const animationRunners = [];\n\n              if (fromAnimation) {\n                animationRunners.push(fromAnimation.start());\n              }\n\n              if (toAnimation) {\n                animationRunners.push(toAnimation.start());\n              }\n\n              AnimateRunner._all(animationRunners, done);\n\n              const runner = new AnimateRunner({\n                end: endFnFactory(),\n                cancel: endFnFactory(),\n              });\n\n              return runner;\n\n              function endFnFactory() {\n                return function () {\n                  animationRunners.forEach((x) => {\n                    // at this point we cannot cancel animations for groups just yet. 1.5+\n                    x.end();\n                  });\n                };\n              }\n\n              /**\n               * @param {boolean} status\n               */\n              function done(status) {\n                runner.complete(status);\n              }\n            },\n          };\n        }\n\n        return prepareAnimation(animationDetails);\n      }\n\n      /**\n       * @param {import(\"./interface.ts\").AnimationDetails} animationDetails\n       * @return {import(\"./interface.ts\").Animator | undefined}\n       */\n      function prepareAnimation(animationDetails) {\n        // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n        const { element, event, options, classes } = animationDetails;\n\n        return $$animateJs(element, event, classes, options);\n      }\n\n      return initDriverFn;\n    },\n  ];\n}\n","import { $injectTokens } from \"../injection-tokens.js\";\nngAnimateSwapDirective.$inject = [$injectTokens._animate];\n/**\n * @param {ng.AnimateService} $animate\n * @returns {ng.Directive}\n */\nexport function ngAnimateSwapDirective($animate) {\n  return {\n    restrict: \"A\",\n    transclude: \"element\",\n    terminal: true,\n    priority: 550, // We use 550 here to ensure that the directive is caught before others,\n    // but after `ngIf` (at priority 600).\n    link(scope, $element, attrs, _ctrl, $transclude) {\n      /**\n       * @type {HTMLElement | undefined}\n       */\n      let previousElement;\n\n      /**\n       * @type {ng.Scope | undefined | null}\n       */\n      let previousScope;\n\n      scope.$watch(attrs.ngAnimateSwap || attrs.for, (value) => {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n\n        if (value) {\n          /** @type {ng.TranscludeFn} */ ($transclude)((clone, childScope) => {\n            previousElement = /** @type {HTMLElement} */ (clone);\n            previousScope = childScope;\n            $animate.enter(/** @type {HTMLElement} */ (clone), null, $element);\n          });\n        }\n      });\n    },\n  };\n}\n","import { isString } from \"../shared/utils.js\";\nimport { NG_ANIMATE_CHILDREN_DATA } from \"./shared.js\";\nimport { setCacheData } from \"../shared/dom.js\";\nimport { $injectTokens as $t } from \"../injection-tokens.js\";\n\n$$AnimateChildrenDirective.$inject = [$t._interpolate];\n\n/**\n * @param {ng.InterpolateService} $interpolate\n * @returns {ng.Directive}\n */\nexport function $$AnimateChildrenDirective($interpolate) {\n  return {\n    link(scope, element, attrs) {\n      const val = /** @type {string} */ (attrs.ngAnimateChildren);\n\n      if (isString(val) && val.length === 0) {\n        // empty attribute\n        setCacheData(element, NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData(\n          /** @type {import(\"../core/interpolate/interface.ts\").InterpolationFunction} */ (\n            $interpolate(val)\n          )(scope),\n        );\n        attrs.$observe(\"ngAnimateChildren\", setData);\n      }\n\n      /**\n       * @param {string} [value]\n       */\n      function setData(value) {\n        const res = value === \"on\" || value === \"true\";\n\n        setCacheData(element, NG_ANIMATE_CHILDREN_DATA, res);\n      }\n    },\n  };\n}\n","import {\n  entries,\n  isArray,\n  isDate,\n  isFunction,\n  isRegExp,\n  isString,\n} from \"./utils.js\";\n\n/**\n * @param {unknown} o1\n * @param {unknown} o2\n */\nexport function equals(o1, o2) {\n  if (o1 === o2) return true;\n\n  if (o1 === null || o2 === null) return false;\n\n  if (Number.isNaN(o1) && Number.isNaN(o2)) return true; // NaN === NaN\n  const t1 = typeof o1,\n    t2 = typeof o2;\n\n  if (t1 !== t2 || t1 !== \"object\") return false;\n  const tup = [o1, o2];\n\n  if (tup.every(isArray))\n    return _arraysEq(\n      /** @type {Array<any>} */ (o1),\n      /** @type {Array<any>} */ (o2),\n    );\n\n  if (tup.every(isDate))\n    return (\n      /** @type {Date} */ (o1).getTime() === /** @type {Date} */ (o2).getTime()\n    );\n\n  if (tup.every(isRegExp))\n    return (\n      /** @type {RegExp} */ (o1).toString() ===\n      /** @type {RegExp} */ (o2).toString()\n    );\n\n  if (tup.every(isFunction)) return true; // meh\n\n  if ([isFunction, isArray, isDate, isRegExp].some((fn) => !!fn(tup))) {\n    return false;\n  }\n  /** @type {Record<string, any>} */\n  const keys = {};\n\n  for (const key in /** @type {Record<string, any>} */ (o1)) {\n    if (\n      !equals(\n        /** @type {Record<string, any>} */ (o1)[key],\n        /** @type {Record<string, any>} */ (o2)[key],\n      )\n    )\n      return false;\n    keys[key] = true;\n  }\n\n  for (const key in /** @type {Record<string, any>} */ (o2)) {\n    if (!keys[key]) return false;\n  }\n\n  return true;\n}\n\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\n\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it.\n *\n * @param {Object} parent - The object to be used as the prototype.\n * @param {Object} [extra] - The object containing additional properties to be copied.\n * @returns {Object} - A new object with `parent` as its prototype and properties from `extra`.\n */\nexport function inherit(parent, extra) {\n  const newObj = Object.create(parent);\n\n  if (extra) {\n    Object.assign(newObj, extra);\n  }\n\n  return newObj;\n}\n\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n * @param {Array<any>} array\n * @param {any} obj\n * @returns {Array<any>}\n */\nexport function removeFrom(array, obj) {\n  const i = array.indexOf(obj);\n\n  if (i !== -1) array.splice(i, 1);\n\n  return array;\n}\n\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n * @param {any} opts\n * @param {any} defaultsList\n */\nexport function defaults(opts, ...defaultsList) {\n  const defaultVals = Object.assign({}, ...defaultsList.reverse());\n\n  return Object.assign(defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n}\n\n/**\n * Return a copy of the object only containing the whitelisted properties.\n *\n * #### Example:\n * ```\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }\n * ```\n * @param {any} obj the source object\n * @param {string | any[]} propNames an Array of strings, which are the whitelisted property names\n */\nexport function pick(obj, propNames) {\n  /** @type {Record<string, any>} */\n  const objCopy = {};\n\n  for (const _prop in obj) {\n    if (propNames.indexOf(_prop) !== -1) {\n      objCopy[_prop] = obj[_prop];\n    }\n  }\n\n  return objCopy;\n}\n\n/**\n * Return a copy of the object omitting the blacklisted properties.\n * @example ```\n\nvar foo = { a: 1, b: 2, c: 3 };\nvar ab = omit(foo, ['a', 'b']); // { c: 3 }\n```\n * @param {{ [x: string]: any; }} obj the source object\n * @param {string | any[]} propNames an Array of strings, which are the blacklisted property names\n */\nexport function omit(obj, propNames) {\n  return Object.keys(obj)\n    .filter((x) => !propNames.includes(x))\n    .reduce(\n      /**\n       * @param {Record<string, any>} acc\n       * @param {string} key\n       * */ (acc, key) => ((acc[key] = obj[key]), acc),\n      {},\n    );\n}\n\n/**\n * Filters an Array or an Object's properties based on a predicate\n * @param {Record<string, any> | ArrayLike<any>} collection\n * @param {{ (x: any): boolean; (item: any): boolean; (val: any, key: any): boolean; (arg0: any, arg1: string): any; }} callback\n */\nexport function filter(collection, callback) {\n  const arr = isArray(collection);\n\n  /** @type {Record<string, any>} */\n  const result = arr ? [] : {};\n\n  const accept = arr\n    ? (/** @type {any} */ x) => result.push(x)\n    : (/** @type {any} */ x, /** @type {string | number} */ key) =>\n        (result[key] = x);\n\n  entries(collection).forEach(([i, item]) => {\n    if (callback(item, i)) accept(item, i);\n  });\n\n  return result;\n}\n\n/**\n * Finds an object from an array, or a property of an object, that matches a predicate\n * @param {{ [s: string]: any; } | ArrayLike<any>} collection\n * @param {function} callback\n */\nexport function find(collection, callback) {\n  /**\n   * @type {any}\n   */\n  let result;\n\n  entries(collection).forEach(([i, item]) => {\n    if (result) return;\n\n    if (callback(item, i)) result = item;\n  });\n\n  return result;\n}\n\n/**\n * Maps over an array or object and returns a new collection\n * with the same shape.\n *\n * @template T\n * @template R\n * @param {T[] | Record<string, T>} collection\n * @param {(value: T, key: string | number) => R} callback\n * @param {R[] | Record<string, R>} [target]\n * @returns {R[] | Record<string, R>}\n */\nexport function map(collection, callback, target) {\n  target = target || (isArray(collection) ? [] : {});\n\n  entries(collection).forEach(([i, item]) => {\n    if (isArray(target)) {\n      // Convert string key to number safely\n      const index = Number(i);\n\n      target[index] = callback(item, index);\n    } else {\n      target[i] = callback(item, i);\n    }\n  });\n\n  return target;\n}\n\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, \"hello world\"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexport const allTrueR = (/** @type {any} */ memo, /** @type {any} */ elem) =>\n  memo && elem;\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push(\"hello world\");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexport const anyTrueR = (/** @type {any} */ memo, /** @type {any} */ elem) =>\n  memo || elem;\n\n/**\n * Reduce function which un-nests a single level of arrays\n *\n * @param {any} memo\n * @param {any} elem\n * @returns {any}\n *\n * @example\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(unnestR, []) // [ \"a\", \"b\", \"c\", \"d\", [ \"double\", \"nested\" ] ]\n */\nexport const unnestR = (memo, elem) => memo.concat(elem);\n\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @template T\n * @param {T[]} memo\n * @param {any} elem\n * @returns {T[]}\n *\n * @example\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * input.reduce(flattenR, []) // [ \"a\", \"b\", \"c\", \"d\", \"double\", \"nested\" ]\n */\nexport const flattenR = (memo, elem) =>\n  Array.isArray(elem)\n    ? memo.concat(elem.reduce(flattenR, []))\n    : pushR(memo, elem);\n\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n * @param {any[]} arr\n * @param {unknown} obj\n */\nexport function pushR(arr, obj) {\n  arr.push(obj);\n\n  return arr;\n}\n\n/** Reduce function that filters out duplicates */\nexport const uniqR = (/** @type {any[]} */ acc, /** @type {any} */ token) =>\n  acc.includes(token) ? acc : pushR(acc, token);\n\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ \"a\", \"b\" ], [ \"c\", \"d\" ], [ [ \"double\", \"nested\" ] ] ];\n * unnest(input) // [ \"a\", \"b\", \"c\", \"d\", [ \"double, \"nested\" ] ]\n * ```\n */\nexport const unnest = (/** @type {any[]} */ arr) => arr.reduce(unnestR, []);\n\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === 'number';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, \"5\" ];\n * oneString.filter(assertPredicate(isNumber, \"Not all numbers\")); // throws Error(\"\"Not all numbers\"\");\n * ```\n */\nexport const assertPredicate = assertFn;\n\n/**\n * @param {(arg0: any) => any} predicateOrMap\n * @param {string} errMsg\n * @return {(obj:any) => any}\n */\nexport function assertFn(predicateOrMap, errMsg = \"assert failure\") {\n  return (obj) => {\n    const result = predicateOrMap(obj);\n\n    if (!result) {\n      throw new Error(errMsg);\n    }\n\n    return result;\n  };\n}\n\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n * @example ```\n\nlet foo = [ 0, 2, 4, 6 ];\nlet bar = [ 1, 3, 5, 7 ];\nlet baz = [ 10, 30, 50, 70 ];\narrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\narrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n```\n * @param {any[][]} args\n */\nexport function arrayTuples(...args) {\n  if (args.length === 0) return [];\n  const maxArrayLen = args.reduce(\n    (min, arr) => Math.min(arr.length, min),\n    Number.MAX_SAFE_INTEGER,\n  );\n\n  const result = [];\n\n  for (let i = 0; i < maxArrayLen; i++) {\n    // This is a hot function\n    // Unroll when there are 1-4 arguments\n    switch (args.length) {\n      case 1:\n        result.push([args[0][i]]);\n        break;\n      case 2:\n        result.push([args[0][i], args[1][i]]);\n        break;\n      case 3:\n        result.push([args[0][i], args[1][i], args[2][i]]);\n        break;\n      case 4:\n        result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n        break;\n      default:\n        result.push(args.map((array) => array[i]));\n        break;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n * @example ```\n\n    var pairs = [ [\"fookey\", \"fooval\"], [\"barkey\", \"barval\"] ]\n\n    var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n    // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n\n    // Or, more simply:\n    var pairsToObj = pairs.reduce(applyPairs, {})\n    // pairsToObj == { fookey: \"fooval\", barkey: \"barval\" }\n```\n * @param {{ [x: string]: any; }} memo\n * @param {any[]} keyValTuple\n */\nexport function applyPairs(memo, keyValTuple) {\n  let key, value;\n\n  if (isArray(keyValTuple)) [key, value] = keyValTuple;\n\n  if (!isString(key)) throw new Error(\"invalid parameters to applyPairs\");\n  memo[key] = value;\n\n  return memo;\n}\n\n/**\n * Returns the last element of an array, or undefined if the array is empty.\n * @template T\n * @param {any[]|string} arr - The input array.\n * @returns {T | undefined} The last element or undefined.\n */\nexport function tail(arr) {\n  return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * shallow copy from src to dest\n * @param {any} src\n * @param {any} dest\n */\nexport function copy(src, dest) {\n  if (dest) Object.keys(dest).forEach((key) => delete dest[key]);\n\n  if (!dest) dest = {};\n\n  return Object.assign(dest, src);\n}\n\n/**\n * @param {Array<any>} a1\n * @param {Array<any>} a2\n */\nfunction _arraysEq(a1, a2) {\n  if (a1.length !== a2.length) return false;\n\n  for (let i = 0; i < a1.length; i++) {\n    if (!equals(a1[i], a2[i])) return false;\n  }\n\n  return true;\n}\n","/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried \"copy\" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * @param {Function} fn\n * @returns {*|function(): (*|any)}\n */\nexport function curry(fn) {\n  const curried = (/** @type {any[]} */ ...args) => {\n    if (args.length >= fn.length) {\n      return fn(...args);\n    }\n\n    return (/** @type {any} */ ...nextArgs) => curried(...args, ...nextArgs);\n  };\n\n  return curried;\n}\n\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: \"blarg\" };\n * let getName = propEq(\"name\", \"blarg\");\n * getName(obj) === true\n */\nexport const propEq = curry(\n  (\n    /** @type {string | number} */ name,\n    /** @type {any} */ _val,\n    /** @type {{ [x: string]: any; }} */ obj,\n  ) => obj && obj[name] === _val,\n);\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: \"blarg\" }, };\n * let getName = prop(\"nestedObj.name\");\n * getName(obj) === \"blarg\"\n * let propNotFound = prop(\"this.property.doesnt.exist\");\n * propNotFound(obj) === undefined\n */\nexport const parse = (/** @type {string} */ path) => {\n  const parts = path.split(\".\");\n\n  return (/** @type {any} */ obj) =>\n    parts.reduce((acc, key) => acc && acc[key], obj);\n};\n\n/**\n * Given a class constructor, returns a predicate function that checks\n * whether a given object is an instance of that class.\n *\n * @param {new (...args: any[]) => any} ctor - The class constructor to check against.\n * @returns {(obj: any) => boolean} A predicate function that returns true if the object is of the given class.\n */\nexport function is(ctor) {\n  /**\n   * Checks if the provided object is an instance of the given constructor.\n   *\n   * @param {any} obj - The object to test.\n   * @returns {boolean} True if the object is an instance of the given class.\n   */\n  return function (obj) {\n    return (\n      (obj !== null && obj !== undefined && obj.constructor === ctor) ||\n      obj instanceof ctor\n    );\n  };\n}\n\n/**\n * Given a value, returns a function which returns that value.\n * @template T\n * @param {T} value - The value to wrap in a function.\n * @returns {() => T} A function that returns the given value.\n */\nexport const val = (value) => () => value;\n\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n * @example ```\n\n// Here's a 2-tuple where the first element is the isString predicate\n// and the second element is a function that returns a description of the input\nlet firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n\n// Second tuple: predicate \"isNumber\", mapfn returns a description\nlet secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];\n\nlet third = [ (input) => input === null,  (input) => `Oh, null...` ];\n\nlet fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n\nlet descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n\nconsole.log(descriptionOf(undefined)); // 'notdefined'\nconsole.log(descriptionOf(55)); // '(55) That's a number!'\nconsole.log(descriptionOf(\"foo\")); // 'Here's your string foo'\n```\n * @param {string | any[]} struct A 2D array.  Each element of the array should be an array, a 2-tuple,\nwith a Predicate and a mapping/output function\n * @returns {function(any):*}\n */\nexport function pattern(struct) {\n  return function (item) {\n    for (let i = 0; i < struct.length; i++) {\n      if (struct[i][0](item)) return struct[i][1](item);\n    }\n\n    return undefined;\n  };\n}\n","import { filter, map } from \"../../shared/common.js\";\nimport { isArray, isDefined } from \"../../shared/utils.js\";\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n */\nexport class ParamType {\n  /**\n     * @param {any} def A configuration object which contains the custom type definition.  The object's\n    properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     */\n  constructor(def) {\n    this.pattern = /.*/;\n    this.inherit = true;\n    Object.assign(this, def);\n    /** @type {string|undefined} */\n    this.name = undefined;\n  }\n  // consider these four methods to be \"abstract methods\" that should be overridden\n\n  /**\n   * @param {any} val\n   */\n  is(val) {\n    return !!val;\n  }\n\n  /**\n   * @param {any} val\n   */\n  encode(val) {\n    return val;\n  }\n\n  /**\n   * @param {any} val\n   */\n  decode(val) {\n    return val;\n  }\n\n  /**\n   * @param {any} a\n   * @param {any} b\n   */\n  equals(a, b) {\n    return a === b;\n  }\n\n  toString() {\n    return `{ParamType:${this.name}}`;\n  }\n\n  /**\n   * Given an encoded string, or a decoded object, returns a decoded object\n   * @param {any} val\n   */\n  $normalize(val) {\n    return this.is(val) ? val : this.decode(val);\n  }\n\n  /**\n   * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n   * e.g.:\n   * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n   * - url: \"/path?queryParam=1&queryParam=2\n   * - $stateParams.queryParam will be [1, 2]\n   * if `mode` is \"auto\", then\n   * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n   * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n   * @param {boolean |'auto'} mode\n   * @param {any} isSearch\n   */\n  $asArray(mode, isSearch) {\n    if (!mode) return this;\n\n    if (mode === \"auto\" && !isSearch)\n      throw new Error(\"'auto' array mode is for query parameters only\");\n\n    return new ArrayType(this, mode);\n  }\n}\n\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @this {Record<string, any>}\n * @param {ParamType & Record<string, any>} type\n * @param {boolean | 'auto'} mode\n */\nfunction ArrayType(type, mode) {\n  // Wrap non-array value as array\n  /**\n   * @param {any} val\n   */\n  function arrayWrap(val) {\n    return isArray(val) ? val : isDefined(val) ? [val] : [];\n  }\n  // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n  /**\n   * @param {any} val\n   */\n  function arrayUnwrap(val) {\n    switch (val.length) {\n      case 0:\n        return undefined;\n      case 1:\n        return mode === \"auto\" ? val[0] : val;\n      default:\n        return val;\n    }\n  }\n  // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n  /**\n   * @param {(value: any) => any} callback\n   * @param {boolean} [allTruthyMode]\n   */\n  function arrayHandler(callback, allTruthyMode) {\n    return function handleArray(/** @type {string | any[]} */ val) {\n      if (isArray(val) && val.length === 0) return val;\n      const arr = arrayWrap(val);\n\n      const result = map(arr, callback);\n\n      return allTruthyMode === true\n        ? filter(result, (x) => !x).length === 0\n        : arrayUnwrap(result);\n    };\n  }\n  // Wraps type (.equals) functions to operate on each value of an array\n  /**\n   * @param {(arg0: any, arg1: any) => any} callback\n   */\n  function arrayEqualsHandler(callback) {\n    return function handleArray(\n      /** @type {any} */ val1,\n      /** @type {any} */ val2,\n    ) {\n      const left = arrayWrap(val1),\n        right = arrayWrap(val2);\n\n      if (left.length !== right.length) return false;\n\n      for (let i = 0; i < left.length; i++) {\n        if (!callback(left[i], right[i])) return false;\n      }\n\n      return true;\n    };\n  }\n  [\"encode\", \"decode\", \"equals\", \"$normalize\"].forEach((name) => {\n    const paramTypeFn = type[name].bind(type);\n\n    const wrapperFn = name === \"equals\" ? arrayEqualsHandler : arrayHandler;\n\n    this[name] = wrapperFn(paramTypeFn);\n  });\n\n  Object.assign(this, {\n    dynamic: type.dynamic,\n    name: type.name,\n    pattern: type.pattern,\n    inherit: type.inherit,\n    raw: type.raw,\n    is: arrayHandler(type.is.bind(type), true),\n    $arrayMode: mode,\n  });\n}\n","import { equals, inherit, map, pick } from \"../../shared/common.js\";\nimport { hasOwn, isDefined, isNullOrUndefined } from \"../../shared/utils.js\";\nimport { is } from \"../../shared/hof.js\";\nimport { ParamType } from \"./param-type.js\";\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n *\n * To register custom parameter types, use [[UrlConfig.type]], i.e.,\n *\n * ```js\n * router.urlService.config.type(customType)\n * ```\n */\nexport class ParamTypes {\n  constructor() {\n    this.enqueue = true;\n    /**\n     * @type {{ name: any; def: any; }[]}\n     */\n    this.typeQueue = [];\n    this.defaultTypes = pick(ParamTypes.prototype, [\n      \"hash\",\n      \"string\",\n      \"query\",\n      \"path\",\n      \"int\",\n      \"bool\",\n      \"date\",\n      \"json\",\n      \"any\",\n    ]);\n    // Register default types. Store them in the prototype of this.types.\n    const makeType = (/** @type {any} */ definition, /** @type {any} */ name) =>\n      new ParamType(Object.assign({ name }, definition));\n\n    /**\n     * @type {Record<string, any>}\n     */\n    this.types = inherit(map(this.defaultTypes, makeType), {});\n  }\n\n  /**\n   * Registers a parameter type\n   *\n   * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n   * @param {string} name\n   * @param {import(\"./interface.ts\").ParamTypeDefinition} [definition]\n   * @param {() => import(\"../params/interface.ts\").ParamTypeDefinition} [definitionFn]\n   */\n  type(name, definition, definitionFn) {\n    if (!isDefined(definition)) return this.types[name];\n\n    if (hasOwn(this.types, name))\n      throw new Error(`A type named '${name}' has already been defined.`);\n    this.types[/** @type {string} */ (name)] = new ParamType(\n      Object.assign({ name }, definition),\n    );\n\n    if (definitionFn) {\n      this.typeQueue.push({ name, def: definitionFn });\n\n      if (!this.enqueue) this._flushTypeQueue();\n    }\n\n    return this;\n  }\n\n  _flushTypeQueue() {\n    while (this.typeQueue.length) {\n      const type = /** @type {any} */ (this.typeQueue.shift());\n\n      if (type.pattern)\n        throw new Error(\"You cannot override a type's .pattern at runtime.\");\n      Object.assign(\n        this.types[type.name],\n        window.angular.$injector.invoke(type.def),\n      );\n    }\n  }\n}\nfunction initDefaultTypes() {\n  const makeDefaultType = /** @param {any} def */ (def) => {\n    const valToString = (/** @type {any} */ val) =>\n      !isNullOrUndefined(val) ? val.toString() : val;\n\n    const defaultTypeBase = {\n      encode: valToString,\n      decode: valToString,\n      is: is(String),\n      pattern: /.*/,\n\n      equals: (/** @type {any} */ a, /** @type {any} */ b) => a === b, // allow coersion for null/undefined/\"\"\n    };\n\n    return Object.assign({}, defaultTypeBase, def);\n  };\n\n  // Default Parameter Type Definitions\n  Object.assign(ParamTypes.prototype, {\n    string: makeDefaultType({}),\n    path: makeDefaultType({\n      pattern: /[^/]*/,\n    }),\n    query: makeDefaultType({}),\n    hash: makeDefaultType({\n      inherit: false,\n    }),\n    int: makeDefaultType({\n      decode: (/** @type {string} */ val) => parseInt(val, 10),\n      /**\n       * @param {unknown} val\n       */\n      is(val) {\n        return !isNullOrUndefined(val) && this.decode(val.toString()) === val;\n      },\n      pattern: /-?\\d+/,\n    }),\n    bool: makeDefaultType({\n      encode: (/** @type {any} */ val) => (val && 1) || 0,\n      decode: (/** @type {string} */ val) => parseInt(val, 10) !== 0,\n      is: is(Boolean),\n      pattern: /[01]/,\n    }),\n    date: makeDefaultType({\n      /**\n       * @param {{ getFullYear: () => any; getMonth: () => number; getDate: () => any; }} val\n       */\n      encode(val) {\n        return !this.is(val)\n          ? undefined\n          : [\n              val.getFullYear(),\n              `0${val.getMonth() + 1}`.slice(-2),\n              `0${val.getDate()}`.slice(-2),\n            ].join(\"-\");\n      },\n      /**\n       * @param {any} val\n       */\n      decode(val) {\n        if (this.is(val)) return val;\n        const match = this.capture.exec(val);\n\n        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n      },\n      is: (/** @type {any} */ val) =>\n        val instanceof Date && !isNaN(val.valueOf()),\n      /**\n       * @param {{ [x: string]: () => any; }} left\n       * @param {{ [x: string]: () => any; }} right\n       */\n      equals(left, right) {\n        return [\"getFullYear\", \"getMonth\", \"getDate\"].reduce(\n          (acc, fn) => acc && left[fn]() === right[fn](),\n          true,\n        );\n      },\n      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,\n    }),\n    json: makeDefaultType({\n      encode: JSON.stringify,\n      decode: JSON.parse,\n      is: is(Object),\n      equals,\n      pattern: /[^/]*/,\n    }),\n    // does not encode/decode\n    any: makeDefaultType({\n      encode: (/** @type {any} */ x) => x,\n      decode: (/** @type {any} */ x) => x,\n      is: () => true,\n      equals,\n    }),\n  });\n}\ninitDefaultTypes();\n","import { ParamTypes } from \"../params/param-types\";\nimport { isDefined, isNullOrUndefined, isString } from \"../../shared/utils.js\";\n/**\n * An API to customize the URL behavior and retrieve URL configuration\n *\n * This API is used to customize the behavior of the URL.\n * This includes optional trailing slashes ([[strictMode]]), case sensitivity ([[caseInsensitive]]),\n * and custom parameter encoding (custom [[type]]).\n *\n * It also has information about the location (url) configuration such as [[port]] and [[baseHref]].\n * This information can be used to build absolute URLs, such as\n * `https://example.com:443/basepath/state/substate?param1=a#hashvalue`;\n *\n * This API is found at `router.urlService.config` (see: [[UIRouter.urlService]], [[URLService.config]])\n */\nexport class UrlConfigProvider {\n  constructor() {\n    /** @type {ParamTypes} */\n    this.paramTypes = new ParamTypes();\n    /** @type {boolean} */\n    this._isCaseInsensitive = false;\n    /** @type {boolean} */\n    this._isStrictMode = true;\n    /** @type {boolean | string} */\n    this._defaultSquashPolicy = false;\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     */\n    const pathType = this.type(\"path\");\n\n    pathType.encode = (/** @type {unknown} */ x) =>\n      !isNullOrUndefined(x)\n        ? x.toString().replace(/([~/])/g, (i) => (i === \"~\" ? \"~~\" : \"~2F\"))\n        : x;\n\n    pathType.decode = (/** @type {unknown} */ x) =>\n      !isNullOrUndefined(x)\n        ? x.toString().replace(/(~~|~2F)/g, (i) => (i === \"~~\" ? \"~\" : \"/\"))\n        : x;\n    this.paramTypes.enqueue = false;\n    this.paramTypes._flushTypeQueue();\n  }\n\n  $get = () => this;\n\n  /**\n   * Defines whether URL matching should be case sensitive (the default behavior), or not.\n   *\n   * #### Example:\n   * ```js\n   * // Allow case insensitive url matches\n   * urlService.config.caseInsensitive(true);\n   * ```\n   * @param {boolean} [value] `false` to match URL in a case sensitive manner; otherwise `true`;\n   * @returns {boolean} the current value of caseInsensitive\n   */\n  caseInsensitive(value) {\n    return (this._isCaseInsensitive = isDefined(value)\n      ? value\n      : this._isCaseInsensitive);\n  }\n\n  /**\n   * Sets the default behavior when generating or matching URLs with default parameter values.\n   *\n   * #### Example:\n   * ```js\n   * // Remove default parameter values from the url\n   * urlService.config.defaultSquashPolicy(true);\n   * ```\n   *\n   * @param {boolean | string} [value] A string that defines the default parameter URL squashing behavior.\n   *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL\n   *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the\n   *      parameter is surrounded by slashes, squash (remove) one slash from the URL\n   *    - any other string, e.g. \"~\": When generating an href with a default parameter value, squash (remove)\n   *      the parameter value from the URL and replace it with this string.\n   * @returns {boolean | string} the current value of defaultSquashPolicy\n   */\n  defaultSquashPolicy(value) {\n    if (\n      isDefined(value) &&\n      value !== true &&\n      value !== false &&\n      !isString(value)\n    )\n      throw new Error(\n        `Invalid squash policy: ${value}. Valid policies: false, true, arbitrary-string`,\n      );\n\n    return (this._defaultSquashPolicy = isDefined(value)\n      ? value\n      : this._defaultSquashPolicy);\n  }\n\n  /**\n   * Defines whether URLs should match trailing slashes, or not (the default behavior).\n   *\n   * #### Example:\n   * ```js\n   * // Allow optional trailing slashes\n   * urlService.config.strictMode(false);\n   * ```\n   *\n   * @param {boolean} value `false` to match trailing slashes in URLs, otherwise `true`.\n   * @returns {boolean} the current value of strictMode\n   */\n  strictMode(value) {\n    return (this._isStrictMode = isDefined(value) ? value : this._isStrictMode);\n  }\n\n  /**\n   * Creates and registers a custom [[ParamType]] object\n   *\n   * A custom parameter type can be used to generate URLs with typed parameters or custom encoding/decoding.\n   *\n   * #### Note: Register custom types *before using them* in a state definition.\n   *\n   * #### Example:\n   * ```js\n   * // Encode object parameter as JSON string\n   * urlService.config.type('myjson', {\n   *   encode: (obj) => JSON.stringify(obj),\n   *   decode: (str) => JSON.parse(str),\n   *   is: (val) => typeof(val) === 'object',\n   *   pattern: /[^/]+/,\n   *   equals: (a, b) => _.isEqual(a, b),\n   * });\n   * ```\n   *\n   * See [[ParamTypeDefinition]] for more examples\n   *\n   * @param {string} name The type name.\n   * @param {import(\"../params/interface.ts\").ParamTypeDefinition} [definition] The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n   * @param {() => import(\"../params/interface.ts\").ParamTypeDefinition} [definitionFn] A function that is injected before the app runtime starts.\n   *        The result of this function should be a [[ParamTypeDefinition]].\n   *        The result is merged into the existing `definition`.\n   *        See [[ParamType]] for information on the values accepted.\n   *\n   * @returns if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n   */\n  type(name, definition, definitionFn) {\n    const type = this.paramTypes.type(name, definition, definitionFn);\n\n    return !isDefined(definition) ? type : this;\n  }\n}\n","import { keys } from \"../../shared/utils.js\";\n\n/** @typedef {import(\"../state/state-object.js\").StateObject} StateObject */\n\nexport class StateParams {\n  constructor(params = {}) {\n    Object.assign(this, params);\n  }\n\n  /**\n   * Merges a set of parameters with all parameters inherited between the common parents of the\n   * current state and a given destination state.\n   *\n   * @param {Object} newParams The set of parameters which will be composited with inherited params.\n   * @param {StateObject} $current Internal definition of object representing the current state.\n   * @param {StateObject} $to Internal definition of object representing state to transition to.\n   */\n  $inherit(newParams, $current, $to) {\n    const parents = ancestors($current, $to);\n\n    /** @type {Record<string, any>} */\n    const inherited = {};\n\n    /** @type {string[]} */\n    const inheritList = [];\n\n    for (const parent of parents) {\n      if (!parent || !parent.params) continue;\n      /** @type {Record<string, any>} */\n      const parentParams = parent.params;\n\n      /** @type {string[]} */\n      const parentParamsKeys = keys(parentParams);\n\n      if (!parentParamsKeys.length) continue;\n\n      for (const key of parentParamsKeys) {\n        if (\n          parentParams[key].inherit === false ||\n          inheritList.indexOf(key) >= 0\n        ) {\n          continue;\n        }\n\n        inheritList.push(key);\n        inherited[key] = /** @type {Record<string, any>} */ (this)[key];\n      }\n    }\n\n    return Object.assign({}, inherited, newParams);\n  }\n}\n\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {StateObject} first The first state.\n * @param {StateObject} second The second state.\n * @return {Array<StateObject>} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n  /** @type {Array<StateObject>} */\n  const path = [];\n\n  const firstPath = first.path || [];\n\n  const secondPath = second.path || [];\n\n  const len = Math.min(firstPath.length, secondPath.length);\n\n  for (let i = 0; i < len; i++) {\n    if (firstPath[i] !== secondPath[i]) break;\n    path.push(firstPath[i]);\n  }\n\n  return path;\n}\n","import { isArray } from \"./utils.js\";\n\n/**\n * A simple bounded FIFO queue with optional eviction notifications.\n * @template T\n */\nexport class Queue {\n  /**\n   * @param {T[]} [items=[]] - Initial queue items.\n   * @param {number|null} [limit=null] - Maximum allowed items before eviction (null = unlimited).\n   */\n  constructor(items = [], limit = null) {\n    /** @type {T[]} */\n    this._items = isArray(items) ? [...items] : [];\n\n    /** @type {number|null} */\n    this._limit =\n      Number.isInteger(limit) && /** @type {number} */ (limit) > 0\n        ? limit\n        : null;\n\n    /** @type {Array<(item: T) => void>} */\n    this._evictListeners = [];\n  }\n\n  /**\n   * Register a listener that will be called with the evicted item.\n   * @param {(item: T) => void} listener\n   */\n  onEvict(listener) {\n    this._evictListeners.push(listener);\n  }\n\n  /**\n   * Adds an item to the end of the queue, evicting the head if over limit.\n   * @param {T} item\n   * @returns {T}\n   */\n  enqueue(item) {\n    this._items.push(item);\n\n    if (this._limit !== null && this._items.length > this._limit) {\n      this.evict();\n    }\n\n    return item;\n  }\n\n  /**\n   * Removes the head item and notifies eviction listeners.\n   * @returns {T|undefined}\n   */\n  evict() {\n    const item = this._items.shift();\n\n    if (item !== undefined) {\n      this._evictListeners.forEach((fn) => fn(item));\n    }\n\n    return item;\n  }\n\n  /**\n   * Removes and returns the first item in the queue.\n   * @returns {T|undefined}\n   */\n  dequeue() {\n    return this._items.length > 0 ? this._items.shift() : undefined;\n  }\n\n  /**\n   * Clears all items from the queue.\n   * @returns {T[]} The previously stored items.\n   */\n  clear() {\n    const cleared = [...this._items];\n\n    this._items.length = 0;\n\n    return cleared;\n  }\n\n  /**\n   * Returns the current number of items.\n   * @returns {number}\n   */\n  size() {\n    return this._items.length;\n  }\n\n  /**\n   * Removes a specific item from the queue.\n   * @param {T} item\n   * @returns {T|false} The removed item, or false if not found.\n   */\n  remove(item) {\n    const index = this._items.indexOf(item);\n\n    return index !== -1 ? this._items.splice(index, 1)[0] : false;\n  }\n\n  /**\n   * Returns the item at the tail (last).\n   * @returns {T|undefined}\n   */\n  peekTail() {\n    return this._items[this._items.length - 1];\n  }\n\n  /**\n   * Returns the item at the head (first).\n   * @returns {T|undefined}\n   */\n  peekHead() {\n    return this._items[0];\n  }\n}\n","import { StateParams } from \"./params/state-params.js\";\nimport { Queue } from \"../shared/queue.js\";\n\n/** @typedef {import('../interface.ts').ServiceProvider} ServiceProvider } */\n\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nexport class RouterProvider {\n  constructor() {\n    /**\n     * Current parameter values\n     *\n     * The parameter values from the latest successful transition\n     * @type {StateParams}\n     */\n    this.params = new StateParams();\n\n    /**\n     * @type {number}\n     */\n    this._lastStartedTransitionId = -1;\n\n    /**\n     * @type {Queue<ng.Transition>}\n     */\n    this._transitionHistory = new Queue(\n      /** @type {Array<ng.Transition>} */ ([]),\n      1,\n    );\n\n    /**\n     * @type {Queue<ng.Transition>}\n     */\n    this._successfulTransitions = new Queue(\n      /** @type {Array<ng.Transition>} */ ([]),\n      1,\n    );\n\n    /**\n     * @type {ng.StateDeclaration|undefined}\n     */\n    this.current = undefined;\n\n    /**\n     * @type {ng.StateObject|undefined}\n     */\n    this.$current = undefined;\n\n    /**\n     * @type {ng.Transition|undefined}\n     */\n    this.transition = undefined;\n  }\n\n  $get = () => this;\n}\n","import { pushR, tail } from \"./common.js\";\nimport { pattern, val } from \"./hof.js\";\nimport { isInjectable, isPromise } from \"./predicates.js\";\nimport {\n  isArray,\n  isFunction,\n  isNull,\n  isObject,\n  isString,\n  isUndefined,\n} from \"./utils.js\";\n\n/**\n * Functions that manipulate strings\n */\n\nconst DOTS = \"...\";\n\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param {number} max the maximum length of the string to return\n * @param {string} str the input string\n * @returns {string}\n */\nexport function maxLength(max, str) {\n  if (str.length <= max) return str;\n\n  return `${str.substring(0, max - DOTS.length)}${DOTS}`;\n}\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param {number} length the desired length of the string to return\n * @param {string} str the input string\n */\nexport function padString(length, str) {\n  while (str.length < length) str += \" \";\n\n  return str;\n}\n\n/**\n * @param {string} camelCase\n * @returns {string}\n */\nexport function kebobString(camelCase) {\n  return camelCase\n    .replace(/^([A-Z])/, ($1) => $1.toLowerCase()) // replace first char\n    .replace(/([A-Z])/g, ($1) => `-${$1.toLowerCase()}`); // replace rest\n}\n\nconst FN_LENGTH = 9;\n\n/**\n * @param {Function} fn\n * @returns {string}\n */\nexport function functionToString(fn) {\n  const fnStr = fnToString(fn);\n\n  const namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n\n  const toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n\n  const fnName = fn.name || \"\";\n\n  if (fnName && toStr.match(/function \\(/)) {\n    return `function ${fnName}${toStr.substring(FN_LENGTH)}`;\n  }\n\n  return toStr;\n}\n\n/**\n * @param {[]|Function} fn\n * @returns {string}\n */\nexport function fnToString(fn) {\n  const _fn = isArray(fn) ? fn.slice(-1)[0] : fn;\n\n  return (_fn && _fn.toString()) || \"undefined\";\n}\n\n/**\n * @param {any} value\n * @returns {string|*|string}\n */\nexport function stringify(value) {\n  /**\n   * @type {any[]}\n   */\n  const seen = [];\n\n  const isRejection = (/** @type {Promise<any>} */ obj) => {\n    return (\n      obj &&\n      typeof obj.then === \"function\" &&\n      obj.constructor.name === \"Rejection\"\n    );\n  };\n\n  const hasToString = (\n    /** @type {{ constructor: ObjectConstructor; toString: any; }} */ obj,\n  ) =>\n    isObject(obj) &&\n    !isArray(obj) &&\n    obj.constructor !== Object &&\n    isFunction(obj.toString);\n\n  const stringifyPattern = pattern([\n    [isUndefined, val(\"undefined\")],\n    [isNull, val(\"null\")],\n    [isPromise, val(\"[Promise]\")],\n    [\n      isRejection,\n      (\n        /** @type {{ _transitionRejection: { toString: () => any; }; }} */ reg,\n      ) => reg._transitionRejection.toString(),\n    ],\n    [\n      hasToString,\n      (/** @type {{ toString: () => any; }} */ str) => str.toString(),\n    ],\n    [isInjectable, functionToString],\n    [val(true), (/** @type {any} */ bool) => bool],\n  ]);\n\n  /**\n   * @param {any} item\n   */\n  function format(item) {\n    if (isObject(item)) {\n      if (seen.indexOf(item) !== -1) return \"[circular ref]\";\n      seen.push(item);\n    }\n\n    return stringifyPattern(item);\n  }\n\n  if (isUndefined(value)) {\n    // Workaround for IE & Edge Spec incompatibility where replacer function would not be called when JSON.stringify\n    // is given `undefined` as value. To work around that, we simply detect `undefined` and bail out early by\n    // manually stringifying it.\n    return format(value);\n  }\n\n  return JSON.stringify(value, (_key, item) => format(item)).replace(\n    /\\\\\"/g,\n    '\"',\n  );\n}\n\nexport const stripLastPathElement = (/** @type {string} */ str) =>\n  str.replace(/\\/[^/]*$/, \"\");\n\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n * @param {string} delim\n */\nexport function splitOnDelim(delim) {\n  const re = new RegExp(`(${delim})`, \"g\");\n\n  return (/** @type {string} */ str) => str.split(re).filter(Boolean);\n}\n\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n * @param {any[]} acc\n * @param {unknown} str\n */\nexport function joinNeighborsR(acc, str) {\n  if (isString(tail(acc)) && isString(str))\n    return acc.slice(0, -1).concat(tail(acc) + str);\n\n  return pushR(acc, str);\n}\n","/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from \"@uirouter/core/index\";\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require(\"@uirouter/core\").trace;\n * trace.enable(\"TRANSITION\", \"VIEWCONFIG\");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window[\"@uirouter/core\"].trace;\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @packageDocumentation\n */\nimport { parse } from \"../../shared/hof.js\";\nimport { isNumber, keys } from \"../../shared/utils.js\";\nimport {\n  functionToString,\n  maxLength,\n  padString,\n  stringify,\n} from \"../../shared/strings.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/** @typedef {import(\"../transition/interface.ts\").HookResult} HookResult */\n/** @typedef {import(\"../transition/transition-hook.js\").TransitionHook} TransitionHook */\n\nconst MAX_PAD_LENGTH = 30;\n\n/**\n * @param {import(\"../view/interface.ts\").ActiveUIView} ngView\n * @return {string}\n */\nfunction ngViewString(ngView) {\n  if (!ngView) return \"ng-view (defunct)\";\n  const state = ngView.creationContext\n    ? ngView.creationContext.name || \"(root)\"\n    : \"(none)\";\n\n  return `[ng-view#${ngView.id}:${ngView.fqn} (${ngView.name}@${state})]`;\n}\n\nconst viewConfigString =\n  /** @param {import(\"../view/view.js\").ViewConfig} viewConfig */ (\n    viewConfig,\n  ) => {\n    const view = viewConfig.viewDecl;\n\n    const state = view.$context?.name || \"(root)\";\n\n    return `[View#${viewConfig.$id} from '${state}' state]: target ng-view: '${view.$ngViewName}@${view.$ngViewContextAnchor}'`;\n  };\n\n/**\n * @param {Category | string} input\n * @return {string}\n */\nfunction normalizedCat(input) {\n  return isNumber(input)\n    ? Category[input]\n    : Category[Category[/** @type {string} */ (input)]];\n}\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable(\"TRANSITION\")`\n *\n * `trace.enable(1)`\n */\n\n/**\n * @type {Record<string, string>}\n */\nexport const Category = {\n  _RESOLVE: \"RESOLVE\",\n  _TRANSITION: \"TRANSITION\",\n  _HOOK: \"HOOK\",\n  _UIVIEW: \"UIVIEW\",\n  _VIEWCONFIG: \"VIEWCONFIG\",\n};\n\nconst _tid = parse(\"$id\");\n\nconst _rid = parse(\"router.$id\");\n\n/**\n * @param {ng.Transition} trans\n * @return {string}\n */\nfunction transLbl(trans) {\n  return `Transition #${_tid(trans)}-${_rid(trans)}`;\n}\n\n/**\n * Prints ng-router Transition trace information to the console.\n */\nexport class Trace {\n  constructor() {\n    /** @type {Record<string, boolean> } */\n    this._enabled = {};\n    this.approximateDigests = 0;\n    this.$logger = window.angular?.$injector?.get($injectTokens._log);\n  }\n\n  /**\n   * @param {boolean} enabled\n   * @param {string[]} categories\n   */\n  _set(enabled, categories) {\n    if (!categories.length) {\n      categories = keys(Category)\n        .map((k) => parseInt(k, 10))\n        .filter((k) => !isNaN(k))\n        .map((key) => Category[key]);\n    }\n    categories\n      .map(normalizedCat)\n      .forEach((category) => (this._enabled[category] = enabled));\n  }\n\n  /**\n   * @param {string[]} categories\n   */\n  enable(...categories) {\n    this._set(true, categories);\n  }\n\n  /**\n   * @param {string[]} categories\n   */\n  disable(...categories) {\n    this._set(false, categories);\n  }\n\n  /**\n   * Retrieves the enabled stateus of a [[Category]]\n   *\n   * ```js\n   * trace.enabled(\"VIEWCONFIG\"); // true or false\n   * ```\n   * @param {string} category\n   * @returns {boolean} true if the category is enabled\n   */\n  enabled(category) {\n    return !!this._enabled[normalizedCat(category)];\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {ng.Transition} trans\n   */\n  traceTransitionStart(trans) {\n    if (!this.enabled(Category._TRANSITION)) return;\n    this.$logger.log(`${transLbl(trans)}: Started  -> ${stringify(trans)}`);\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {ng.Transition} trans\n   */\n  traceTransitionIgnored(trans) {\n    if (!this.enabled(Category._TRANSITION)) return;\n    this.$logger.log(`${transLbl(trans)}: Ignored  <> ${stringify(trans)}`);\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {import(\"../transition/transition-hook.js\").TransitionHook} step\n   * @param {ng.Transition} trans\n   * @param {import(\"../transition/interface.ts\").TransitionHookOptions} options\n   */\n  traceHookInvocation(step, trans, options) {\n    if (!this.enabled(Category._HOOK)) return;\n    const event = parse(\"traceData.hookType\")(options) || \"internal\",\n      context =\n        parse(\"traceData.context.state.name\")(options) ||\n        parse(\"traceData.context\")(options) ||\n        \"unknown\",\n      name = functionToString(step.registeredHook.callback);\n\n    this.$logger.log(\n      `${transLbl(trans)}:   Hook -> ${event} context: ${context}, ${maxLength(200, name)}`,\n    );\n  }\n\n  /** @internal called by ng-router code */\n  /**\n   * @param {HookResult} hookResult\n   * @param {ng.Transition} trans\n   */\n  traceHookResult(hookResult, trans) {\n    if (!this.enabled(Category._HOOK)) return;\n    this.$logger.log(\n      `${transLbl(trans)}:   <- Hook returned: ${maxLength(200, stringify(hookResult))}`,\n    );\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {import(\"../path/path-node.js\").PathNode[]} path\n   * @param {import(\"../resolve/interface.ts\").PolicyWhen} when\n   * @param {ng.Transition} trans\n   */\n  traceResolvePath(path, when, trans) {\n    if (!this.enabled(Category._RESOLVE)) return;\n    this.$logger.log(`${transLbl(trans)}:         Resolving ${path} (${when})`);\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {import(\"../resolve/resolvable.js\").Resolvable} resolvable\n   * @param {ng.Transition} trans\n   */\n  traceResolvableResolved(resolvable, trans) {\n    if (!this.enabled(Category._RESOLVE)) return;\n    this.$logger.log(\n      `${transLbl(trans)}:               <- Resolved  ${resolvable} to: ${maxLength(200, stringify(resolvable.data))}`,\n    );\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {any} reason\n   * @param {ng.Transition} trans\n   */\n  traceError(reason, trans) {\n    if (!this.enabled(Category._TRANSITION)) return;\n    this.$logger.log(\n      `${transLbl(trans)}: <- Rejected ${stringify(trans)}, reason: ${reason}`,\n    );\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {import(\"../state/state-object.js\").StateObject} finalState\n   * @param {ng.Transition} trans\n   */\n  traceSuccess(finalState, trans) {\n    if (!this.enabled(Category._TRANSITION)) return;\n    this.$logger.log(\n      `${transLbl(trans)}: <- Success  ${stringify(trans)}, final state: ${finalState.name}`,\n    );\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {string} event\n   * @param {import(\"../view/interface.ts\").ActiveUIView} viewData\n   */\n  traceUIViewEvent(event, viewData, extra = \"\") {\n    if (!this.enabled(Category._UIVIEW)) return;\n    this.$logger.log(\n      `ng-view: ${padString(MAX_PAD_LENGTH, event)} ${ngViewString(viewData)}${extra}`,\n    );\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {import(\"../view/interface.ts\").ActiveUIView} viewData\n   * @param {import(\"../view/interface.ts\").ViewContext | undefined} context\n   */\n  traceUIViewConfigUpdated(viewData, context) {\n    if (!this.enabled(Category._UIVIEW)) return;\n    this.traceUIViewEvent(\n      \"Updating\",\n      viewData,\n      ` with ViewConfig from context='${context}'`,\n    );\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {import(\"../view/interface.ts\").ActiveUIView} viewData\n   * @param {string} html\n   */\n  traceUIViewFill(viewData, html) {\n    if (!this.enabled(Category._UIVIEW)) return;\n    this.traceUIViewEvent(\"Fill\", viewData, ` with: ${maxLength(200, html)}`);\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {import(\"../view/interface.ts\").ViewTuple[]} pairs\n   */\n  traceViewSync(pairs) {\n    if (!this.enabled(Category._VIEWCONFIG)) return;\n    const uivheader = \"uiview component fqn\";\n\n    const cfgheader = \"view config state (view name)\";\n\n    const mapping = pairs\n      .map(({ ngView, viewConfig }) => {\n        const uiv = ngView && ngView.fqn;\n\n        const cfg =\n          viewConfig &&\n          `${viewConfig.viewDecl.$context?.name}: (${viewConfig.viewDecl.$name})`;\n\n        return { [uivheader]: uiv, [cfgheader]: cfg };\n      })\n      .sort((a, b) => (a[uivheader] || \"\").localeCompare(b[uivheader] || \"\"));\n\n    this.$logger.table(mapping);\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {string} event\n   * @param {import(\"../view/view.js\").ViewConfig} viewConfig\n   */\n  traceViewServiceEvent(event, viewConfig) {\n    if (!this.enabled(Category._VIEWCONFIG)) return;\n    this.$logger.log(`VIEWCONFIG: ${event} ${viewConfigString(viewConfig)}`);\n  }\n\n  /**\n   * @internal called by ng-router code\n   * @param {string} event\n   * @param {import(\"../view/interface.ts\").ActiveUIView} viewData\n   */\n  traceViewServiceUIViewEvent(event, viewData) {\n    if (!this.enabled(Category._VIEWCONFIG)) return;\n    this.$logger.log(`VIEWCONFIG: ${event} ${ngViewString(viewData)}`);\n  }\n}\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from \"@uirouter/core/index\";\n * trace.enable(1, 5);\n * ```\n */\nexport const trace = new Trace();\n","import {\n  assert,\n  hasOwn,\n  isFunction,\n  isNullOrUndefined,\n  isObject,\n} from \"../../shared/utils.js\";\nimport { trace } from \"../common/trace.js\";\nimport { stringify } from \"../../shared/strings.js\";\n\n// TODO: explicitly make this user configurable\nexport const defaultResolvePolicy = {\n  when: \"LAZY\",\n  async: \"WAIT\",\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nexport class Resolvable {\n  /**\n   * @param {any} arg1\n   * @param {Function | undefined} [resolveFn]\n   * @param {any[]} [deps]\n   * @param {import(\"./interface.ts\").ResolvePolicy | undefined} [policy]\n   * @param {any} [data]\n   */\n  constructor(arg1, resolveFn, deps, policy, data) {\n    this.resolved = false;\n    this.promise = undefined;\n\n    if (arg1 instanceof Resolvable) {\n      Object.assign(this, arg1);\n    } else if (isFunction(resolveFn)) {\n      assert(!isNullOrUndefined(arg1), \"token argument is required\");\n      this.token = arg1;\n      this.policy = policy;\n      this.resolveFn = resolveFn;\n      this.deps = deps || [];\n      this.data = data;\n      this.resolved = data !== undefined;\n      this.promise = this.resolved ? Promise.resolve(this.data) : undefined;\n    } else if (\n      isObject(arg1) &&\n      arg1.token &&\n      (hasOwn(arg1, \"resolveFn\") || hasOwn(arg1, \"data\"))\n    ) {\n      this.token = arg1.token;\n      this.resolveFn = arg1.resolveFn;\n      this.deps = arg1.deps;\n      this.policy = arg1.policy;\n      this.data = arg1.data;\n    }\n  }\n\n  /**\n   * @param {ng.BuiltStateDeclaration} state\n   * @returns {import(\"./interface.ts\").ResolvePolicy}\n   */\n  getPolicy(state) {\n    const thisPolicy = this.policy || {};\n\n    const statePolicy = (state && state.resolvePolicy) || {};\n\n    return {\n      when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,\n      async:\n        thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,\n    };\n  }\n\n  /**\n   * Asynchronously resolve this Resolvable's data\n   *\n   * Given a ResolveContext that this Resolvable is found in:\n   * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n   * and update the Resolvable's state\n   * @param {import(\"./resolve-context.js\").ResolveContext} resolveContext\n   * @param {ng.Transition} [trans]\n   */\n  resolve(resolveContext, trans) {\n    // Gets all dependencies from ResolveContext and wait for them to be resolved\n    /** @type {() => Promise<any[]>} */\n    const getResolvableDependencies = () =>\n      Promise.all(\n        resolveContext.getDependencies(this).map((resolvable) => {\n          return resolvable.get(resolveContext, trans);\n        }),\n      );\n\n    // Invokes the resolve function passing the resolved dependencies as arguments\n    const invokeResolveFn = (/** @type {any[]} */ resolvedDeps) =>\n      this.resolveFn.apply(null, resolvedDeps);\n\n    const node = resolveContext.findNode(this);\n\n    const state = node && node.state;\n\n    const asyncPolicy = this.getPolicy(state).async;\n\n    const customAsyncPolicy = isFunction(asyncPolicy)\n      ? asyncPolicy\n      : (/** @type {any} */ x) => x;\n\n    // After the final value has been resolved, update the state of the Resolvable\n    const applyResolvedValue = (/** @type {any} */ resolvedValue) => {\n      this.data = resolvedValue;\n      this.resolved = true;\n      this.resolveFn = null;\n      trace.traceResolvableResolved(this, /** @type {ng.Transition} */ (trans));\n\n      return this.data;\n    };\n\n    // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n    this.promise = Promise.resolve()\n      .then(getResolvableDependencies)\n      .then(invokeResolveFn)\n      .then(customAsyncPolicy)\n      .then(applyResolvedValue);\n\n    return this.promise;\n  }\n\n  /**\n   * Gets a promise for this Resolvable's data.\n   *\n   * Fetches the data and returns a promise.\n   * Returns the existing promise if it has already been fetched once.\n   * @param {import(\"./resolve-context.js\").ResolveContext} resolveContext\n   * @param {ng.Transition | undefined} [trans]\n   * @return {Promise<any>}\n   */\n  get(resolveContext, trans) {\n    return this.promise || this.resolve(resolveContext, trans);\n  }\n\n  toString() {\n    return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;\n  }\n\n  clone() {\n    return new Resolvable(this);\n  }\n}\nResolvable.fromData = (/** @type {any} */ token, /** @type {any} */ data) =>\n  new Resolvable(token, () => data, undefined, undefined, data);\n","import { isObject, isString } from \"../../shared/utils.js\";\nimport { stringify } from \"../../shared/strings\";\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many ng-router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nexport class TargetState {\n  /**\n   * The TargetState constructor\n   *\n   * Note: Do not construct a `TargetState` manually.\n   * To create a `TargetState`, use the [[StateService.target]] factory method.\n   *\n   * @param {import(\"./state-service.js\").StateRegistryProvider} _stateRegistry The StateRegistry to use to look up the _definition\n   * @param {import(\"./interface.js\").StateOrName} _identifier An identifier for a state.\n   *    Either a fully-qualified state name, or the object used to define the state.\n   * @param {import(\"../params/interface.js\").RawParams} _params Parameters for the target state\n   * @param {import(\"../transition/interface.js\").TransitionOptions} _options Transition options.\n   *\n   * @internal\n   */\n  constructor(_stateRegistry, _identifier, _params, _options) {\n    this._stateRegistry = _stateRegistry;\n    this._identifier = _identifier;\n    this._identifier = _identifier;\n    this._params = Object.assign({}, _params || {});\n    this._options = Object.assign({}, _options || {});\n    this._definition = _stateRegistry.matcher.find(\n      _identifier,\n      this._options.relative,\n    );\n  }\n\n  /** The name of the state this object targets */\n  name() {\n    return (this._definition && this._definition.name) || this._identifier;\n  }\n\n  /** The identifier used when creating this TargetState */\n  identifier() {\n    return this._identifier;\n  }\n\n  /** The target parameter values */\n  params() {\n    return this._params;\n  }\n\n  /** The internal state object (if it was found) */\n  $state() {\n    return this._definition;\n  }\n\n  /** The internal state declaration (if it was found) */\n  state() {\n    return this._definition && this._definition.self;\n  }\n\n  /** The target options */\n  options() {\n    return this._options;\n  }\n\n  /** True if the target state was found */\n  exists() {\n    return !!(this._definition && this._definition.self);\n  }\n\n  /** True if the object is valid */\n  valid() {\n    return !this.error();\n  }\n\n  /** If the object is invalid, returns the reason why */\n  error() {\n    const base = /** @type {any} */ (this.options().relative);\n\n    if (!this._definition && !!base) {\n      const stateName = base.name ? base.name : base;\n\n      return `Could not resolve '${this.name()}' from state '${stateName}'`;\n    }\n\n    if (!this._definition) return `No such state '${this.name()}'`;\n\n    if (!this._definition.self)\n      return `State '${this.name()}' has an invalid definition`;\n\n    return undefined;\n  }\n\n  toString() {\n    return `'${this.name()}'${stringify(this.params())}`;\n  }\n\n  /**\n   * Returns a copy of this TargetState which targets a different state.\n   * The new TargetState has the same parameter values and transition options.\n   *\n   * @param {import(\"./interface.js\").StateOrName} state The new state that should be targeted\n   * @returns {TargetState} A new TargetState instance which targets the desired state\n   */\n  withState(state) {\n    return new TargetState(\n      this._stateRegistry,\n      state,\n      this._params,\n      this._options,\n    );\n  }\n\n  /**\n   * Returns a copy of this TargetState, using the specified parameter values.\n   *\n   * @param {import(\"../params/interface.js\").RawParams} params the new parameter values to use\n   * @param {boolean} replace When false (default) the new parameter values will be merged with the current values.\n   *                When true the parameter values will be used instead of the current values.\n   * @returns {TargetState} A new TargetState instance which targets the same state with the desired parameters\n   */\n  withParams(params, replace = false) {\n    const newParams = replace\n      ? params\n      : Object.assign({}, this._params, params);\n\n    return new TargetState(\n      this._stateRegistry,\n      this._identifier,\n      newParams,\n      this._options,\n    );\n  }\n\n  /**\n   * Returns a copy of this TargetState, using the specified Transition Options.\n   *\n   * @param {import(\"../transition/interface.js\").TransitionOptions} options the new options to use\n   * @param {boolean} replace When false (default) the new options will be merged with the current options.\n   *                When true the options will be used instead of the current options.\n   * @returns {TargetState} A new TargetState instance which targets the same state with the desired options\n   */\n  withOptions(options, replace = false) {\n    const newOpts = replace\n      ? options\n      : Object.assign({}, this._options, options);\n\n    return new TargetState(\n      this._stateRegistry,\n      this._identifier,\n      this._params,\n      newOpts,\n    );\n  }\n}\n/** Returns true if the object has a state property that might be a state or state name */\nTargetState.isDef = (/** @type {any} */ obj) => {\n  return (\n    obj &&\n    obj.state &&\n    (isString(obj.state) || (isObject(obj.state) && isString(obj.state.name)))\n  );\n};\n","import { allTrueR, filter, find, map } from \"../../shared/common.js\";\nimport { isInjectable } from \"../../shared/predicates.js\";\nimport {\n  isArray,\n  isDefined,\n  isNullOrUndefined,\n  isString,\n  isUndefined,\n} from \"../../shared/utils.js\";\nimport { ParamType } from \"./param-type.js\";\n\n/** @typedef {import(\"./interface.ts\").ParamDeclaration} ParamDeclaration */\n\nconst isShorthand = /** @param {ParamDeclaration} cfg */ (cfg) =>\n  [\"value\", \"type\", \"squash\", \"array\", \"dynamic\"].filter(\n    Object.prototype.hasOwnProperty.bind(cfg || {}),\n  ).length === 0;\n\n/**\n * @enum {number}\n */\nexport const DefType = {\n  _PATH: 0,\n  _SEARCH: 1,\n  _CONFIG: 2,\n};\n\n/**\n * @param {string} paramName\n * @param {DefType} location\n * @param {ng.StateDeclaration} state\n * @return {import(\"./interface.ts\").ParamDeclaration}\n */\nfunction getParamDeclaration(paramName, location, state) {\n  const noReloadOnSearch =\n    (state.reloadOnSearch === false && location === DefType._SEARCH) ||\n    undefined;\n\n  const dynamic = find([state.dynamic, noReloadOnSearch], isDefined);\n\n  const defaultConfig = isDefined(dynamic) ? { dynamic } : {};\n\n  const paramConfig = unwrapShorthand(\n    state && state.params && state.params[paramName],\n  );\n\n  return Object.assign(defaultConfig, paramConfig);\n}\n\n/**\n * @param {ParamDeclaration} cfg\n * @return {ParamDeclaration}\n */\nfunction unwrapShorthand(cfg) {\n  cfg = isShorthand(cfg) ? { value: cfg } : cfg;\n  getStaticDefaultValue._cacheable = true;\n  function getStaticDefaultValue() {\n    return cfg.value;\n  }\n  const _fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;\n\n  return Object.assign(cfg, { _fn });\n}\n\n/**\n * @param {ParamDeclaration} cfg\n * @param {ParamType | null} urlType\n * @param {DefType} location\n * @param {string} id\n * @param {import(\"./param-types.js\").ParamTypes} paramTypes\n */\nfunction getType(cfg, urlType, location, id, paramTypes) {\n  if (cfg.type && urlType && urlType.name !== \"string\")\n    throw new Error(`Param '${id}' has two type configurations.`);\n\n  if (\n    cfg.type &&\n    urlType &&\n    urlType.name === \"string\" &&\n    paramTypes.type(/** @type {string} */ (cfg.type))\n  )\n    return paramTypes.type(/** @type {string} */ (cfg.type));\n\n  if (urlType) return urlType;\n\n  if (!cfg.type) {\n    const type =\n      location === DefType._CONFIG\n        ? \"any\"\n        : location === DefType._PATH\n          ? \"path\"\n          : location === DefType._SEARCH\n            ? \"query\"\n            : \"string\";\n\n    return paramTypes.type(type);\n  }\n\n  return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n\n/**\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n * @param {ParamDeclaration} config\n * @param {boolean} isOptional\n * @param {boolean | string} defaultPolicy\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n  const { squash } = config;\n\n  if (!isOptional || squash === false) return false;\n\n  if (!isDefined(squash) || isNullOrUndefined(squash)) return defaultPolicy;\n\n  if (squash === true || isString(squash)) return squash;\n  throw new Error(\n    `Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`,\n  );\n}\n\n/**\n * @param {ParamDeclaration} config\n * @param {boolean} arrayMode\n * @param {boolean} isOptional\n * @param {string | boolean} squash\n */\nfunction getReplace(config, arrayMode, isOptional, squash) {\n  const defaultPolicy = [\n    { from: \"\", to: isOptional || arrayMode ? undefined : \"\" },\n    { from: null, to: isOptional || arrayMode ? undefined : \"\" },\n  ];\n\n  const replace = isArray(config.replace) ? config.replace : [];\n\n  if (isString(squash)) replace.push({ from: squash, to: undefined });\n\n  const configuredKeys = /** @type {string[]} */ (map(replace, (x) => x.from));\n\n  return filter(\n    defaultPolicy,\n    (item) => configuredKeys.indexOf(/** @type {string} */ (item.from)) === -1,\n  ).concat(replace);\n}\n\nexport class Param {\n  /**\n   *\n   * @param {string} id\n   * @param {ParamType | null} type\n   * @param {DefType} location\n   * @param {import(\"../url/url-config.js\").UrlConfigProvider} urlConfig\n   * @param {ng.StateDeclaration} state\n   */\n  constructor(id, type, location, urlConfig, state) {\n    const config = getParamDeclaration(id, location, state);\n\n    type = getType(config, type, location, id, urlConfig.paramTypes);\n    const arrayMode = getArrayMode();\n\n    type = /** @type {ParamType} */ (\n      arrayMode\n        ? type && type.$asArray(arrayMode, location === DefType._SEARCH)\n        : type\n    );\n    const isOptional =\n      config.value !== undefined || location === DefType._SEARCH;\n\n    const dynamic = !!config.dynamic;\n\n    const raw = !!config.raw;\n\n    const squash = getSquashPolicy(\n      config,\n      isOptional,\n      urlConfig.defaultSquashPolicy(),\n    );\n\n    const replace = getReplace(config, arrayMode, isOptional, squash);\n\n    const inherit = isDefined(config.inherit)\n      ? !!config.inherit\n      : !!type.inherit;\n\n    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n    function getArrayMode() {\n      const arrayDefaults = {\n        array: location === DefType._SEARCH ? \"auto\" : false,\n      };\n\n      const arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n\n      return Object.assign(arrayDefaults, arrayParamNomenclature, config).array;\n    }\n    this.isOptional = isOptional;\n    this.type = type;\n    this.location = location;\n    this.id = id;\n    this.dynamic = dynamic;\n    this.raw = raw;\n    this.squash = squash;\n    this.replace = replace;\n    this.inherit = inherit;\n    this.array = arrayMode;\n    this.config = config;\n    /** @type {import(\"./interface.ts\").RawParams | undefined} */\n    this.matchingKeys = undefined;\n  }\n\n  /**\n   * @param {any} value\n   */\n  isDefaultValue(value) {\n    return this.isOptional && this.type.equals(this.value(), value);\n  }\n\n  /**\n   * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n   * default value, which may be the result of an injectable function.\n   * @param {undefined} [value]\n   */\n  value(value) {\n    /**\n     * [Internal] Get the default value of a parameter, which may be an injectable function.\n     */\n    const getDefaultValue = () => {\n      if (this._defaultValueCache) return this._defaultValueCache.defaultValue;\n\n      if (!window.angular.$injector)\n        throw new Error(\n          \"Injectable functions cannot be called at configuration time\",\n        );\n      const defaultValue = window.angular.$injector.invoke(this.config._fn);\n\n      if (\n        defaultValue !== null &&\n        defaultValue !== undefined &&\n        !this.type.is(defaultValue)\n      )\n        throw new Error(\n          `Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`,\n        );\n\n      if (this.config._fn._cacheable) {\n        this._defaultValueCache = { defaultValue };\n      }\n\n      return defaultValue;\n    };\n\n    const replaceSpecialValues = (/** @type {any} */ val) => {\n      for (const tuple of this.replace) {\n        if (tuple.from === val) return tuple.to;\n      }\n\n      return val;\n    };\n\n    value = replaceSpecialValues(value);\n\n    return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n  }\n\n  isSearch() {\n    return this.location === DefType._SEARCH;\n  }\n\n  /**\n   * @param {null} value\n   */\n  validates(value) {\n    // There was no parameter value, but the param is optional\n    if ((isUndefined(value) || value === null) && this.isOptional) return true;\n    // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n    const normalized = this.type.$normalize(value);\n\n    if (!this.type.is(normalized)) return false;\n    // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n    const encoded = normalized; // this.type.encode(normalized);\n\n    return !(isString(encoded) && !this.type.pattern.exec(encoded));\n  }\n\n  toString() {\n    return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;\n  }\n\n  /**\n   * @param {Param[]} params\n   * @param {Record<string, any>} values\n   * @return {import(\"./interface.ts\").RawParams}\n   */\n  static values(params, values = {}) {\n    /** @type {import(\"./interface.ts\").RawParams} */\n    const paramValues = {};\n\n    for (const param of params) {\n      paramValues[param.id] = param.value(values[param.id]);\n    }\n\n    return paramValues;\n  }\n\n  /**\n   * Finds [[Param]] objects which have different param values\n   *\n   * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n   * @param {Param[]} params : The list of Param objects to filter\n   * @param {Record<string, any>} values1 : The first set of parameter values\n   * @param {Record<string, any>} values2 : the second set of parameter values\n   * @returns {Param[]} any Param objects whose values were different between values1 and values2\n   */\n  static changed(params, values1 = {}, values2 = {}) {\n    return params.filter(\n      (param) => !param.type.equals(values1[param.id], values2[param.id]),\n    );\n  }\n\n  /**\n   * Checks if two param value objects are equal (for a set of [[Param]] objects)\n   * @param {any[]} params The list of [[Param]] objects to check\n   * @param values1 The first set of param values\n   * @param values2 The second set of param values\n   * @returns true if the param values in values1 and values2 are equal\n   */\n  static equals(params, values1 = {}, values2 = {}) {\n    return Param.changed(params, values1, values2).length === 0;\n  }\n\n  /**\n   * Returns true if a the parameter values are valid, according to the Param definitions\n   * @param {any[]} params\n   * @param {Record<string, any>} values\n   * @return {boolean}\n   */\n  static validates(params, values = {}) {\n    return params\n      .map((param) => param.validates(values[param.id]))\n      .reduce(allTrueR, true);\n  }\n}\n","import { applyPairs, find } from \"../../shared/common.js\";\nimport { propEq } from \"../../shared/hof.js\";\nimport { Param } from \"../params/param.js\";\n\n/**\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nexport class PathNode {\n  /**\n   * @param {PathNode | ng.StateObject | undefined} stateOrNode\n   */\n  constructor(stateOrNode) {\n    if (stateOrNode instanceof PathNode) {\n      const node = stateOrNode;\n\n      /** @type {ng.StateObject} */\n      this.state = node.state;\n      this.paramSchema = node.paramSchema.slice();\n      this.paramValues = Object.assign({}, node.paramValues);\n      this.resolvables = node.resolvables.slice();\n      this.views = node.views && node.views.slice();\n    } else {\n      const state = stateOrNode;\n\n      this.state = /** @type {ng.StateObject} */ (state);\n      this.paramSchema = /** @type {ng.StateObject} */ (state).parameters({\n        inherit: false,\n      });\n      this.paramValues = {};\n\n      this.resolvables = /** @type {ng.StateObject} */ (state).resolvables?.map(\n        (res) => res.clone(),\n      );\n    }\n  }\n\n  clone() {\n    return new PathNode(this);\n  }\n\n  /**\n   * Sets [[paramValues]] for the node, from the values of an object hash\n   * @param {import(\"../params/interface.js\").RawParams} params\n   * @returns {PathNode}\n   */\n  applyRawParams(params) {\n    const getParamVal = (/** @type {Param} */ paramDef) => [\n      paramDef.id,\n      paramDef.value(params[paramDef.id]),\n    ];\n\n    this.paramValues = this.paramSchema.reduce(\n      (/** @type {{ [x: string]: any; }} */ memo, /** @type {Param} */ pDef) =>\n        applyPairs(memo, getParamVal(pDef)),\n      {},\n    );\n\n    return this;\n  }\n\n  /**\n   * Gets a specific [[Param]] metadata that belongs to the node\n   * @param {string} name\n   * @returns {Param | undefined}\n   */\n  parameter(name) {\n    return find(this.paramSchema, propEq(\"id\", name));\n  }\n\n  /**\n   * @param {PathNode} node\n   * @param {import(\"./interface.js\").GetParamsFn} paramsFn\n   * @returns {boolean} true if the state and parameter values for another PathNode are\n  equal to the state and param values for this PathNode\n   */\n  equals(node, paramsFn) {\n    const diff = this.diff(node, paramsFn);\n\n    return diff && diff.length === 0;\n  }\n\n  /**\n   * Finds Params with different parameter values on another PathNode.\n   *\n   * Given another node (of the same state), finds the parameter values which differ.\n   * Returns the [[Param]] (schema objects) whose parameter values differ.\n   *\n   * Given another node for a different state, returns `false`\n   * @param {PathNode} node The node to compare to\n   * @param {import(\"./interface.js\").GetParamsFn} paramsFn A function that returns which parameters should be compared.\n   * @returns { Param[] | false} The [[Param]]s which differ, or null if the two nodes are for different states\n   */\n  diff(node, paramsFn) {\n    if (this.state !== node.state) return false;\n    const params = paramsFn ? paramsFn(this) : this.paramSchema;\n\n    return Param.changed(params, this.paramValues, node.paramValues);\n  }\n}\n","import { arrayTuples, find, omit, pick, unnestR } from \"../../shared/common.js\";\nimport { propEq } from \"../../shared/hof.js\";\nimport { TargetState } from \"../state/target-state.js\";\nimport { PathNode } from \"./path-node.js\";\n\n/** @typedef {import(\"../params/param.js\").Param} Param */\n/** @typedef {import(\"./interface.ts\").GetParamsFn} GetParamsFn */\n/** @typedef {import(\"../state/state-object.js\").StateObject} StateObject */\n/** @typedef {import(\"../params/interface.ts\").RawParams} RawParams */\n\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nexport class PathUtils {\n  /**\n   * @param {TargetState} targetState\n   */\n  static buildPath(targetState) {\n    const toParams = targetState.params();\n\n    const stateObject = /** @type {ng.StateObject} */ (targetState.$state());\n\n    return stateObject.path?.map((state) =>\n      new PathNode(state).applyRawParams(toParams),\n    );\n  }\n\n  /**\n   * Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[]\n   * @param {PathNode[]} fromPath\n   * @param {TargetState} targetState\n   */\n  static buildToPath(fromPath, targetState) {\n    const toPath = PathUtils.buildPath(targetState);\n\n    if (targetState.options().inherit) {\n      return PathUtils.inheritParams(\n        fromPath,\n        /** @type {PathNode[]} */ (toPath),\n        Object.keys(targetState.params()),\n      );\n    }\n\n    return toPath;\n  }\n\n  /**\n   * Creates ViewConfig objects and adds to nodes.\n   *\n   * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n   * @param {ng.ViewService} $view\n   * @param {PathNode[]} path\n   * @param {StateObject[]} states\n   */\n  static applyViewConfigs($view, path, states) {\n    // Only apply the viewConfigs to the nodes for the given states\n    path\n      .filter((node) => states.includes(node.state))\n      .forEach((node) => {\n        const viewDecls = Object.values(node.state.views || {});\n\n        const subPath = PathUtils.subPath(path, (x) => x === node);\n\n        const viewConfigs = viewDecls.map((view) => {\n          return $view._createViewConfig(\n            /** @type {PathNode[]} */ (subPath),\n            view,\n          );\n        });\n\n        node.views = viewConfigs.reduce(unnestR, []);\n      });\n  }\n\n  /**\n   * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n   *\n   * For a parameter in a node to be inherited from the from path:\n   * - The toPath's node must have a matching node in the fromPath (by state).\n   * - The parameter name must not be found in the toKeys parameter array.\n   *\n   * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n   * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n   * it is not inherited from the fromPath.\n   * @param {PathNode[]} fromPath\n   * @param {PathNode[]} toPath\n   * @param {string[]} [toKeys]\n   * @returns {PathNode[]}\n   */\n  static inheritParams(fromPath, toPath, toKeys = []) {\n    /**\n     * @param {PathNode[]} path\n     * @param {StateObject} state\n     * @returns {RawParams}\n     */\n    function nodeParamVals(path, state) {\n      /** @type {PathNode} */\n      const node = find(path, propEq(\"state\", state));\n\n      return Object.assign({}, node && node.paramValues);\n    }\n    const noInherit = fromPath\n      .map((node) => node.paramSchema)\n      .reduce(unnestR, [])\n      .filter((/** @type {RawParams} */ param) => !param.inherit)\n      .map((/** @type {RawParams} */ x) => x.id);\n\n    /**\n     * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n     * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n     * @param {PathNode} toNode\n     * @return {PathNode}\n     */\n    function makeInheritedParamsNode(toNode) {\n      // All param values for the node (may include default key/vals, when key was not found in toParams)\n      let toParamVals = Object.assign({}, toNode && toNode.paramValues);\n\n      // limited to only those keys found in toParams\n      const incomingParamVals = pick(toParamVals, toKeys);\n\n      toParamVals = omit(toParamVals, toKeys);\n      const fromParamVals = omit(\n        nodeParamVals(fromPath, toNode.state) || {},\n        noInherit,\n      );\n\n      // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n      const ownParamVals = Object.assign(\n        toParamVals,\n        fromParamVals,\n        incomingParamVals,\n      );\n\n      return new PathNode(toNode.state).applyRawParams(ownParamVals);\n    }\n\n    // The param keys specified by the incoming toParams\n    return toPath.map(makeInheritedParamsNode);\n  }\n\n  /**\n   * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n   * @param {PathNode[]} fromPath\n   * @param {PathNode[]} toPath\n   * @param {StateObject} reloadState\n   * @returns {import(\"../transition/interface.ts\").TreeChanges}\n   */\n  static treeChanges(fromPath, toPath, reloadState) {\n    const max = Math.min(fromPath.length, toPath.length);\n\n    let keep = 0;\n\n    const nodesMatch = (\n      /** @type {PathNode} */ node1,\n      /** @type {PathNode} */ node2,\n    ) => node1.equals(node2, PathUtils.nonDynamicParams);\n\n    while (\n      keep < max &&\n      fromPath[keep].state !== reloadState &&\n      nodesMatch(fromPath[keep], toPath[keep])\n    ) {\n      keep++;\n    }\n\n    /**\n     * Given a retained node, return a new node which uses the to node's param values\n     * @param {PathNode} retainedNode\n     * @param {number} idx\n     */\n    function applyToParams(retainedNode, idx) {\n      const cloned = retainedNode.clone();\n\n      cloned.paramValues = toPath[idx].paramValues;\n\n      return cloned;\n    }\n\n    const from = fromPath;\n\n    const retained = from.slice(0, keep);\n\n    const exiting = from.slice(keep);\n\n    // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped\n    const retainedWithToParams = retained.map(applyToParams);\n\n    const entering = toPath.slice(keep);\n\n    const to = retainedWithToParams.concat(entering);\n\n    return { from, to, retained, retainedWithToParams, exiting, entering };\n  }\n\n  /**\n   * Returns a new path which is: the subpath of the first path which matches the second path.\n   *\n   * The new path starts from root and contains any nodes that match the nodes in the second path.\n   * It stops before the first non-matching node.\n   *\n   * Nodes are compared using their state property and their parameter values.\n   * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n   *\n   * @param {PathNode[]} pathA the first path\n   * @param {PathNode[]} pathB the second path\n   * @param {GetParamsFn} [paramsFn] a function which returns the parameters to consider when comparing\n   *\n   * @returns {PathNode[]} an array of PathNodes from the first path which match the nodes in the second path\n   */\n  static matching(pathA, pathB, paramsFn) {\n    let done = false;\n\n    const tuples = arrayTuples(pathA, pathB);\n\n    return tuples.reduce((matching, [nodeA, nodeB]) => {\n      done = done || !nodeA.equals(nodeB, paramsFn);\n\n      return done ? matching : matching.concat(nodeA);\n    }, []);\n  }\n\n  /**\n   * Returns true if two paths are identical.\n   *\n   * @param {PathNode[]} pathA\n   * @param {PathNode[]} pathB\n   * @param {GetParamsFn} [paramsFn] a function which returns the parameters to consider when comparing\n   * @returns true if the the states and parameter values for both paths are identical\n   */\n  static equals(pathA, pathB, paramsFn) {\n    return (\n      pathA.length === pathB.length &&\n      PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length\n    );\n  }\n\n  /**\n   * Return a subpath of a path, which stops at the first matching node\n   *\n   * Given an array of nodes, returns a subset of the array starting from the first node,\n   * stopping when the first node matches the predicate.\n   * @param {PathNode[]} path a path of [[PathNode]]s\n   * @param {import(\"../../shared/interface.ts\").Predicate<PathNode>} predicate a [[Predicate]] fn that matches [[PathNode]]s\n   * @returns {PathNode[] | undefined} a subpath up to the matching node, or undefined if no match is found\n   */\n  static subPath(path, predicate) {\n    const node = find(path, predicate);\n\n    const elementIdx = path.indexOf(node);\n\n    return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n  }\n\n  /**\n   * @param {PathNode} node\n   * @return {Param[]}\n   */\n  static nonDynamicParams(node) {\n    return node.state\n      .parameters({ inherit: false })\n      .filter((param) => !param.dynamic);\n  }\n\n  /**\n   * Gets the raw parameter values from a path\n   * @param {PathNode[]} path\n   */\n  static paramValues(path) {\n    return path.reduce((acc, node) => Object.assign(acc, node.paramValues), {});\n  }\n}\n\n/** Given a PathNode[], create an TargetState\n * @param {import(\"../state/state-registry.js\").StateRegistryProvider} registry\n * @param {Array<PathNode>} path\n * @returns {TargetState}\n */\nexport function makeTargetState(registry, path) {\n  return new TargetState(\n    registry,\n    /** @type {PathNode} */ (path.at(-1)).state,\n    path\n      .map((x) => x.paramValues)\n      .reduce((acc, obj) => ({ ...acc, ...obj }), {}),\n    {},\n  );\n}\n","import { find, tail, uniqR, unnestR } from \"../../shared/common.js\";\nimport { propEq } from \"../../shared/hof.js\";\nimport { trace } from \"../common/trace.js\";\nimport { Resolvable } from \"./resolvable.js\";\nimport { PathUtils } from \"../path/path-utils.js\";\nimport { stringify } from \"../../shared/strings.js\";\nimport { isUndefined } from \"../../shared/utils.js\";\n\n/** @typedef {import(\"../path/path-node.js\").PathNode} PathNode */\n\nexport const resolvePolicies = {\n  when: {\n    LAZY: \"LAZY\",\n    EAGER: \"EAGER\",\n  },\n  async: {\n    WAIT: \"WAIT\",\n    NOWAIT: \"NOWAIT\",\n  },\n};\n\nconst ALL_WHENS = [resolvePolicies.when.EAGER, resolvePolicies.when.LAZY];\n\nconst EAGER_WHENS = [resolvePolicies.when.EAGER];\n\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * ng-router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nexport class ResolveContext {\n  /**\n   * @param {import(\"../resolve/resolve-context.js\").PathNode[]} _path\n   */\n  constructor(_path) {\n    this._path = _path;\n  }\n\n  /** Gets all the tokens found in the resolve context, de-duplicated */\n  getTokens() {\n    return this._path\n      .reduce(\n        (acc, node) =>\n          acc.concat(\n            node.resolvables.map(\n              (/** @type {Resolvable} */ resolve) => resolve.token,\n            ),\n          ),\n        [],\n      )\n      .reduce(uniqR, []);\n  }\n\n  /**\n   * Gets the Resolvable that matches the token\n   *\n   * Gets the last Resolvable that matches the token in this context, or undefined.\n   * Throws an error if it doesn't exist in the ResolveContext\n   * @param {string} token\n   * @return {Resolvable}\n   */\n  getResolvable(token) {\n    const matching = this._path\n      .map((node) => node.resolvables)\n      .reduce(unnestR, [])\n      .filter((/** @type {Resolvable} */ resolve) => resolve.token === token);\n\n    return /** @type {Resolvable} */ (tail(matching));\n  }\n\n  /**\n   * Returns the [[ResolvePolicy]] for the given [[Resolvable]]\n   * @param {Resolvable} resolvable\n   * @return {import(\"./interface.ts\").ResolvePolicy}\n   */\n  getPolicy(resolvable) {\n    const node = this.findNode(resolvable);\n\n    return resolvable.getPolicy(node);\n  }\n\n  /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     * @example `let ABCD = new ResolveContext([A, B, C, D]);`\n\n    Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n    When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n    However, `B` should only be able to access resolvables from `A`, `B`.\n\n    When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n    `let AB = ABCD.subcontext(a)`\n     * @param {ng.BuiltStateDeclaration} state\n     */\n  subContext(state) {\n    return new ResolveContext(\n      /** @type {PathNode[]} */ (\n        PathUtils.subPath(\n          /** @type {PathNode[]} */ (this._path),\n          (node) => /** @type {PathNode} */ (node).state === state,\n        )\n      ),\n    );\n  }\n\n  /**\n   * Adds Resolvables to the node that matches the state\n   *\n   * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n   * The resolvable is added to the node matching the `state` parameter.\n   *\n   * These new resolvables are not automatically fetched.\n   * The calling code should either fetch them, fetch something that depends on them,\n   * or rely on [[resolvePath]] being called when some state is being entered.\n   *\n   * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n   *\n   * @param {Resolvable[] | import(\"./interface.ts\").ResolvableLiteral[]} newResolvables the new Resolvables\n   * @param {ng.StateObject} state Used to find the node to put the resolvable on\n   */\n  addResolvables(newResolvables, state) {\n    /** @type {import('../path/path-node').PathNode} */\n    const node = find(this._path, propEq(\"state\", state));\n\n    const keys = newResolvables.map((resolve) => resolve.token);\n\n    node.resolvables = node.resolvables\n      .filter(\n        (/** @type {Resolvable} */ resolve) =>\n          keys.indexOf(resolve.token) === -1,\n      )\n      .concat(newResolvables);\n  }\n\n  /**\n   * Returns a promise for an array of resolved path Element promises\n   *\n   * @param {import(\"./interface.ts\").PolicyWhen} when\n   * @param {ng.Transition} trans\n   * @returns {Promise<any>|any}\n   */\n  resolvePath(when = \"LAZY\", trans) {\n    // This option determines which 'when' policy Resolvables we are about to fetch.\n    const whenOption = ALL_WHENS.includes(when) ? when : \"LAZY\";\n\n    // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n    // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n    const matchedWhens =\n      whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n\n    // get the subpath to the state argument, if provided\n    trace.traceResolvePath(this._path, when, trans);\n    const matchesPolicy =\n      (\n        /** @type {string | any[]} */ acceptedVals,\n        /** @type {string} */ whenOrAsync,\n      ) =>\n      (/** @type {Resolvable} */ resolvable) =>\n        acceptedVals.includes(\n          /** @type {Record<string, any>} */ (this.getPolicy(resolvable))[\n            whenOrAsync\n          ],\n        );\n\n    // Trigger all the (matching) Resolvables in the path\n    // Reduce all the \"WAIT\" Resolvables into an array\n    /**\n     * @type {any[]}\n     */\n    const promises = this._path.reduce((acc, node) => {\n      const nodeResolvables = node.resolvables.filter(\n        matchesPolicy(matchedWhens, \"when\"),\n      );\n\n      const nowait = nodeResolvables.filter(matchesPolicy([\"NOWAIT\"], \"async\"));\n\n      const wait = nodeResolvables.filter(\n        (/** @type {Resolvable} */ x) => !matchesPolicy([\"NOWAIT\"], \"async\")(x),\n      );\n\n      // For the matching Resolvables, start their async fetch process.\n      const subContext = this.subContext(\n        /** @type {ng.BuiltStateDeclaration} */ (node.state),\n      );\n\n      const getResult = (\n        /** @type {{ get: (arg0: ResolveContext, arg1: ng.Transition) => Promise<any>; token: any; }} */ resolve,\n      ) =>\n        resolve\n          .get(subContext, trans)\n          // Return a tuple that includes the Resolvable's token\n          .then((value) => ({ token: resolve.token, value }));\n\n      nowait.forEach(getResult);\n\n      return acc.concat(wait.map(getResult));\n    }, []);\n\n    // Wait for all the \"WAIT\" resolvables\n    return Promise.all(promises);\n  }\n\n  /**\n   * @param {Resolvable} resolvable\n   */\n  findNode(resolvable) {\n    return find(this._path, (/** @type {PathNode} */ node) =>\n      node.resolvables.includes(resolvable),\n    );\n  }\n\n  /**\n   * Gets the async dependencies of a Resolvable\n   *\n   * Given a Resolvable, returns its dependencies as a Resolvable[]\n   * @param {Resolvable} resolvable\n   * @returns {Resolvable[]}\n   */\n  getDependencies(resolvable) {\n    const node = this.findNode(resolvable);\n\n    // Find which other resolvables are \"visible\" to the `resolvable` argument\n    // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n    const subPath =\n      PathUtils.subPath(this._path, (/** @type {any} */ x) => x === node) ||\n      this._path;\n\n    const availableResolvables = /** @type {Resolvable[]} */ (\n      subPath.reduce(\n        (\n          /** @type {string | any[]} */ acc,\n          /** @type {{ resolvables: any; }} */ _node,\n        ) => acc.concat(_node.resolvables),\n        [],\n      ) // all of subpath's resolvables\n    ).filter((/** @type {Resolvable} */ res) => res !== resolvable); // filter out the `resolvable` argument\n\n    return resolvable.deps.map((/** @type {string} */ token) => {\n      const matching = availableResolvables.filter(\n        (/** @type {{ token: string; }} */ resolve) => resolve.token === token,\n      );\n\n      if (matching.length) return tail(matching);\n      const fromInjector = window.angular.$injector.get(token);\n\n      if (isUndefined(fromInjector)) {\n        throw new Error(\n          `Could not find Dependency Injection token: ${stringify(token)}`,\n        );\n      }\n\n      return new Resolvable(token, () => fromInjector, [], fromInjector);\n    });\n  }\n}\n","import { pick, tail } from \"../../shared/common.js\";\nimport { entries, isArray, isDefined, isString } from \"../../shared/utils.js\";\nimport { isInjectable } from \"../../shared/predicates.js\";\nimport { trace } from \"../common/trace.js\";\nimport { ResolveContext } from \"../resolve/resolve-context.js\";\nimport { Resolvable } from \"../resolve/resolvable.js\";\nimport { annotate } from \"../../core/di/di.js\";\n\n/**\n * @return {(path: import(\"../path/path-node.js\").PathNode[], view: import(\"./interface.ts\").ViewDeclaration) => ViewConfig}\n */\nexport function getViewConfigFactory() {\n  /**\n   * @type {import(\"../template-factory.js\").TemplateFactoryProvider | null}\n   */\n  let templateFactory = null;\n\n  return (\n    /** @type {import(\"../path/path-node.js\").PathNode[]} */ path,\n    /** @type {import(\"./interface.ts\").ViewDeclaration} */ view,\n  ) => {\n    templateFactory =\n      templateFactory || window.angular.$injector.get(\"$templateFactory\"); // TODO: remove static injector\n\n    return new ViewConfig(\n      path,\n      view,\n      /** @type {import(\"../template-factory.js\").TemplateFactoryProvider} */ (\n        templateFactory\n      ),\n    );\n  };\n}\n\nconst hasAnyKey = (\n  /** @type {any[]} */ keys,\n  /** @type {import(\"./state-object.js\").StateObject & Record<string, any>} */ obj,\n) => keys.reduce((acc, key) => acc || isDefined(obj[key]), false);\n\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n * @param {ng.StateObject & Record<string, any>} state\n */\nexport function ng1ViewsBuilder(state) {\n  // Do not process root state\n  if (!state.parent) return {};\n  const tplKeys = [\n      \"templateProvider\",\n      \"templateUrl\",\n      \"template\",\n      \"notify\",\n      \"async\",\n    ],\n    ctrlKeys = [\n      \"controller\",\n      \"controllerProvider\",\n      \"controllerAs\",\n      \"resolveAs\",\n    ],\n    compKeys = [\"component\", \"bindings\", \"componentProvider\"],\n    nonCompKeys = tplKeys.concat(ctrlKeys),\n    allViewKeys = compKeys.concat(nonCompKeys);\n\n  // Do not allow a state to have both state-level props and also a `views: {}` property.\n  // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n  // However, the `$default` approach should not be mixed with a separate `views: ` block.\n  if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n    throw new Error(\n      `State '${state.name}' has a 'views' object. ` +\n        `It cannot also have \"view properties\" at the state level.  ` +\n        `Move the following properties into a view (in the 'views' object): ` +\n        ` ${allViewKeys.filter((key) => isDefined(state[key])).join(\", \")}`,\n    );\n  }\n  const views = /** @type {Record<string, any>} */ ({});\n\n  const viewsObject = state.views || { $default: pick(state, allViewKeys) };\n\n  entries(viewsObject).forEach(([name, config]) => {\n    // Account for views: { \"\": { template... } }\n    name = name || \"$default\";\n\n    // Account for views: { header: \"headerComponent\" }\n    if (isString(config)) config = { component: config };\n    // Make a shallow copy of the urlConfig object\n    config = Object.assign({}, config);\n\n    // Do not allow a view to mix props for component-style view with props for template/controller-style view\n    if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n      throw new Error(\n        `Cannot combine: ${compKeys.join(\"|\")} with: ${nonCompKeys.join(\"|\")} in stateview: '${name}@${state.name}'`,\n      );\n    }\n    config.resolveAs = config.resolveAs || \"$resolve\";\n    config.$context = state;\n    config.$name = name;\n    const normalized = ViewConfig.normalizeUIViewTarget(\n      config.$context,\n      config.$name,\n    );\n\n    config.$ngViewName = normalized.ngViewName;\n    config.$ngViewContextAnchor = normalized.ngViewContextAnchor;\n    views[name] = config;\n  });\n\n  return views;\n}\n\n/**\n * @type {Number}\n */\nlet id = 0;\n\nexport class ViewConfig {\n  /**\n   * @param {Array<import('../path/path-node.js').PathNode>} path\n   * @param {import(\"./interface.ts\").ViewDeclaration} viewDecl\n   * @param {import('../template-factory.js').TemplateFactoryProvider} factory\n   */\n  constructor(path, viewDecl, factory) {\n    this.$id = -1;\n    /**\n     * @type {Array<import('../path/path-node.js').PathNode>}\n     */\n    this.path = path;\n\n    /**\n     * @type {import(\"./interface.ts\").ViewDeclaration}\n     */\n    this.viewDecl = viewDecl;\n    /**\n     * @type {import('../template-factory.js').TemplateFactoryProvider}\n     */\n    this.factory = factory;\n    /**\n     * @type {string | undefined}\n     */\n    this.component = undefined;\n    /**\n     * @type {string | undefined}\n     */\n    this.template = undefined;\n\n    /** @type {Number} */\n    this.$id = id++;\n\n    /** @type {boolean} */\n    this.loaded = false;\n    this.getTemplate = (\n      /** @type {any} */ ngView,\n      /** @type {ResolveContext} */ context,\n    ) =>\n      this.component\n        ? this.factory.makeComponentTemplate(\n            ngView,\n            context,\n            this.component,\n            this.viewDecl.bindings,\n          )\n        : this.template;\n  }\n\n  /**\n   *\n   * @returns {Promise<ViewConfig>}\n   */\n  async load() {\n    const context = new ResolveContext(this.path);\n\n    const params = this.path.reduce(\n      (acc, node) => Object.assign(acc, node.paramValues),\n      {},\n    );\n\n    const promises = [\n      Promise.resolve(this.factory.fromConfig(this.viewDecl, params, context)),\n      Promise.resolve(this.getController(context)),\n    ];\n\n    const results = await Promise.all(promises);\n\n    trace.traceViewServiceEvent(\"Loaded\", this);\n    this.controller = results[1];\n    Object.assign(this, results[0]); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n\n    return this;\n  }\n\n  /**\n   * Gets the controller for a view configuration.\n   * @returns {Function | Promise<Function>} Returns a controller, or a promise that resolves to a controller.\n   * @param {ResolveContext} context\n   */\n  getController(context) {\n    const provider = this.viewDecl.controllerProvider;\n\n    if (!isInjectable(provider)) return this.viewDecl.controller;\n    const deps = annotate(provider);\n\n    const providerFn = isArray(provider) ? tail(provider) : provider;\n\n    const resolvable = new Resolvable(\"\", providerFn, deps);\n\n    return resolvable.get(context);\n  }\n\n  /**\n   * Normalizes a view's name from a state.views configuration block.\n   *\n   * This calculates the values for\n   * [[_ViewDeclaration.$ngViewName]] and [[_ViewDeclaration.$ngViewContextAnchor]].\n   *\n   * @param {import(\"./state-service.js\").StateObject} context the context object (state declaration) that the view belongs to\n   * @param {string} rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n   *\n   * @returns the normalized ngViewName and ngViewContextAnchor that the view targets\n   */\n  static normalizeUIViewTarget(context, rawViewName = \"\") {\n    // TODO: Validate incoming view name with a regexp to allow:\n    // ex: \"view.name@foo.bar\" , \"^.^.view.name\" , \"view.name@^.^\" , \"\" ,\n    // \"@\" , \"$default@^\" , \"!$default.$default\" , \"!foo.bar\"\n    const viewAtContext = rawViewName.split(\"@\");\n\n    let ngViewName = viewAtContext[0] || \"$default\"; // default to unnamed view\n\n    let ngViewContextAnchor = isString(viewAtContext[1])\n      ? viewAtContext[1]\n      : \"^\"; // default to parent context\n\n    // Handle relative view-name sugar syntax.\n    // Matches rawViewName \"^.^.^.foo.bar\" into array: [\"^.^.^.foo.bar\", \"^.^.^\", \"foo.bar\"],\n    const relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(ngViewName);\n\n    if (relativeViewNameSugar) {\n      // Clobbers existing contextAnchor (rawViewName validation will fix this)\n      ngViewContextAnchor = relativeViewNameSugar[1]; // set anchor to \"^.^.^\"\n      ngViewName = relativeViewNameSugar[2]; // set view-name to \"foo.bar\"\n    }\n\n    if (ngViewName.charAt(0) === \"!\") {\n      ngViewName = ngViewName.substring(1);\n      ngViewContextAnchor = \"\"; // target absolutely from root\n    }\n    // handle parent relative targeting \"^.^.^\"\n    const relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n\n    if (relativeMatch.exec(ngViewContextAnchor)) {\n      /** @type {import(\"./state-service.js\").StateObject | undefined} */\n      let anchorState = context;\n\n      // \"^.^.^\" -> [\"^\", \"^\", \"^\"] (count how many times we go up)\n      const hops = ngViewContextAnchor.split(\".\").filter(Boolean).length;\n\n      for (let i = 0; i < hops; i++) {\n        anchorState = anchorState && anchorState.parent;\n      }\n\n      // If the anchor goes past the root, fall back to the root-most known state\n      // (or keep `context` if you prefer different behavior).\n      if (!anchorState) {\n        anchorState = context;\n\n        while (anchorState.parent) anchorState = anchorState.parent;\n      }\n\n      ngViewContextAnchor = anchorState.name;\n    } else if (ngViewContextAnchor === \".\") {\n      ngViewContextAnchor = context.name;\n    }\n\n    return { ngViewName, ngViewContextAnchor };\n  }\n}\n","import { applyPairs, equals, removeFrom } from \"../../shared/common.js\";\nimport { curry } from \"../../shared/hof.js\";\nimport { trace } from \"../common/trace.js\";\nimport { getViewConfigFactory } from \"../state/views.js\";\n\n/** @typedef {import(\"./interface.ts\").ActiveUIView} ActiveUIView */\n/** @typedef {import(\"../state/views.js\").ViewConfig} ViewConfig */\n\n/**\n * The View service\n *\n * This service pairs existing `ng-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ng-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ng-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\n\nconst FQN_MULTIPLIER = 10_000;\n\nexport class ViewService {\n  constructor() {\n    /**\n     * @type {any[]}\n     */\n    this._ngViews = [];\n    /**\n     * @type {any[]}\n     */\n    this._viewConfigs = [];\n    /**\n     * @type {any[]}\n     */\n    this._listeners = [];\n    this._viewConfigFactory = getViewConfigFactory();\n  }\n\n  $get = () => this;\n\n  /**\n   * @param {?import('../state/state-object.js').StateObject} [context]\n   * @return {?import('../state/state-object.js').StateObject}\n   */\n  rootViewContext(context) {\n    return (this._rootContext = context || this._rootContext);\n  }\n\n  /**\n   * @param {import(\"../path/path-node.js\").PathNode[]} path\n   * @param {import(\"../state/interface.ts\").ViewDeclaration} decl\n   * @return {import(\"../state/views.js\").ViewConfig}\n   */\n  _createViewConfig(path, decl) {\n    /** @type {function(any, any): any} */\n    const cfgFactory = this._viewConfigFactory;\n\n    if (!cfgFactory)\n      throw new Error(\"ViewService: No view config factory registered\");\n\n    return cfgFactory(path, decl);\n  }\n\n  /**\n   * Deactivates a ViewConfig.\n   *\n   * This function deactivates a `ViewConfig`.\n   * After calling [[sync]], it will un-pair from any `ng-view` with which it is currently paired.\n   *\n   * @param {ViewConfig} viewConfig The ViewConfig view to deregister.\n   */\n  deactivateViewConfig(viewConfig) {\n    trace.traceViewServiceEvent(\"<- Removing\", viewConfig);\n    removeFrom(this._viewConfigs, viewConfig);\n  }\n\n  /**\n   * @param {ViewConfig} viewConfig\n   */\n  activateViewConfig(viewConfig) {\n    trace.traceViewServiceEvent(\"-> Registering\", viewConfig);\n    this._viewConfigs.push(viewConfig);\n  }\n\n  sync() {\n    /** @type {import(\"../../shared/interface.ts\").Dict<import(\"./interface.ts\").ActiveUIView>} */\n    const ngViewsByFqn = this._ngViews\n      .map((uiv) => [uiv.fqn, uiv])\n      .reduce(applyPairs, {});\n\n    // Return a weighted depth value for a ngView.\n    // The depth is the nesting depth of ng-views (based on FQN; times 10,000)\n    // plus the depth of the state that is populating the ngView\n    /**\n     * @param {import(\"./interface.ts\").ActiveUIView} ngView\n     */\n    function ngViewDepth(ngView) {\n      /** @type {(context: import(\"./interface.ts\").ViewContext) => number} */\n      const stateDepth =\n        /** @param {import(\"./interface.ts\").ViewContext} context */ (\n          context,\n        ) => (context && context.parent ? stateDepth(context.parent) + 1 : 1);\n\n      return (\n        ngView.fqn.split(\".\").length * FQN_MULTIPLIER +\n        stateDepth(ngView.creationContext)\n      );\n    }\n    // Return the ViewConfig's context's depth in the context tree.\n    /**\n     * @param {ViewConfig} config\n     */\n    function viewConfigDepth(config) {\n      let context = /** @type {import(\"./interface.ts\").ViewContext} */ (\n          config.viewDecl.$context\n        ),\n        count = 0;\n\n      while (++count && context.parent) context = context.parent;\n\n      return count;\n    }\n    // Given a depth function, returns a compare function which can return either ascending or descending order\n    const depthCompare = curry(\n      (\n        /** @type {(arg0: any) => number} */ depthFn,\n        /** @type {number} */ posNeg,\n        /** @type {any} */ left,\n        /** @type {any} */ right,\n      ) => posNeg * (depthFn(left) - depthFn(right)),\n    );\n\n    const matchingConfigPair = (\n      /** @type {import(\"./interface.ts\").ActiveUIView} */ ngView,\n    ) => {\n      const matchingConfigs = this._viewConfigs.filter(\n        ViewService.matches(ngViewsByFqn, ngView),\n      );\n\n      if (matchingConfigs.length > 1) {\n        // This is OK.  Child states can target a ng-view that the parent state also targets (the child wins)\n        // Sort by depth and return the match from the deepest child\n        // console.log(`Multiple matching view configs for ${ngView.fqn}`, matchingConfigs);\n        matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n      }\n\n      return { ngView, viewConfig: matchingConfigs[0] };\n    };\n\n    const configureUIView = (\n      /** @type {import(\"./interface.ts\").ViewTuple} */ tuple,\n    ) => {\n      // If a parent ng-view is reconfigured, it could destroy child ng-views.\n      // Before configuring a child ng-view, make sure it's still in the active ngViews array.\n      if (this._ngViews.indexOf(tuple.ngView) !== -1) {\n        tuple.ngView?.configUpdated(tuple.viewConfig);\n      }\n    };\n\n    // Sort views by FQN and state depth. Process uiviews nearest the root first.\n    /** @type {import(\"./interface.ts\").ViewTuple[]} */\n    const ngViewTuples = this._ngViews\n      .sort(depthCompare(ngViewDepth, 1))\n      .map(matchingConfigPair);\n\n    /** @type {ViewConfig[]} */\n    const matchedViewConfigs = ngViewTuples.map((tuple) => tuple.viewConfig);\n\n    /** @type {import(\"./interface.ts\").ViewTuple[]} */\n    const unmatchedConfigTuples = this._viewConfigs\n      .filter((config) => !matchedViewConfigs.includes(config))\n      .map((viewConfig) => ({ ngView: undefined, viewConfig }));\n\n    ngViewTuples.forEach((tuple) => {\n      configureUIView(tuple);\n    });\n    /** @type {import(\"./interface.ts\").ViewTuple[]} */\n    const allTuples = ngViewTuples.concat(unmatchedConfigTuples);\n\n    this._listeners.forEach((cb) => cb(allTuples));\n    trace.traceViewSync(allTuples);\n  }\n\n  /**\n   * Registers a `ng-view` component\n   *\n   * When a `ng-view` component is created, it uses this method to register itself.\n   * After registration the [[sync]] method is used to ensure all `ng-view` are configured with the proper [[ViewConfig]].\n   *\n   * Note: the `ng-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ng-view`,\n   * and what the view's state context is.\n   *\n   * Note: There is no corresponding `deregisterUIView`.\n   *       A `ng-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n   * @param {import(\"./interface.ts\").ActiveUIView} ngView The metadata for a UIView\n   * @return {() => void} a de-registration function used when the view is destroyed.\n   */\n  registerUIView(ngView) {\n    trace.traceViewServiceUIViewEvent(\"-> Registering\", ngView);\n    const ngViews = this._ngViews;\n\n    const fqnAndTypeMatches = /** @param {ActiveUIView} uiv */ (uiv) =>\n      uiv.fqn === ngView.fqn;\n\n    if (ngViews.filter(fqnAndTypeMatches).length)\n      trace.traceViewServiceUIViewEvent(\"!!!! duplicate ngView named:\", ngView);\n    ngViews.push(ngView);\n    this.sync();\n\n    return () => {\n      const idx = ngViews.indexOf(ngView);\n\n      if (idx === -1) {\n        trace.traceViewServiceUIViewEvent(\n          \"Tried removing non-registered ngView\",\n          ngView,\n        );\n\n        return;\n      }\n      trace.traceViewServiceUIViewEvent(\"<- Deregistering\", ngView);\n      removeFrom(ngViews, ngView);\n    };\n  }\n\n  /**\n   * Returns the list of views currently available on the page, by fully-qualified name.\n   *\n   * @return {Array<string>} Returns an array of fully-qualified view names.\n   */\n  available() {\n    return this._ngViews.map((view) => view.fqn);\n  }\n\n  /**\n   * Returns the list of views on the page containing loaded content.\n   *\n   * @return {Array<string>} Returns an array of fully-qualified view names.\n   */\n  active() {\n    return this._ngViews\n      .filter((view) => view.$config)\n      .map((view) => view.name);\n  }\n}\n/**\n * Given a ng-view and a ViewConfig, determines if they \"match\".\n *\n * A ng-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n * the DOM, describing its nesting relationship to any parent ng-view tags it is nested inside of.\n *\n * A ViewConfig has a target ng-view name and a context anchor.  The ng-view name can be a simple name, or\n * can be a segmented ng-view path, describing a portion of a ng-view fqn.\n *\n * If the ViewConfig's target ng-view name is a simple name (no dots), then a ng-view matches if:\n * - the ng-view's name matches the ViewConfig's target name\n * - the ng-view's context matches the ViewConfig's anchor\n *\n * If the ViewConfig's target ng-view name is a segmented name (with dots), then a ng-view matches if:\n * - There exists a parent ng-view where:\n *    - the parent ng-view's name matches the first segment (index 0) of the ViewConfig's target name\n *    - the parent ng-view's context matches the ViewConfig's anchor\n * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ng-view's fqn\n *\n * Example:\n *\n * DOM:\n * <ng-view>                        <!-- created in the root context (name: \"\") -->\n *   <ng-view name=\"foo\">                <!-- created in the context named: \"A\"      -->\n *     <ng-view>                    <!-- created in the context named: \"A.B\"    -->\n *       <ng-view name=\"bar\">            <!-- created in the context named: \"A.B.C\"  -->\n *       </ng-view>\n *     </ng-view>\n *   </ng-view>\n * </ng-view>\n *\n * ngViews: [\n *  { fqn: \"$default\",                  creationContext: { name: \"\" } },\n *  { fqn: \"$default.foo\",              creationContext: { name: \"A\" } },\n *  { fqn: \"$default.foo.$default\",     creationContext: { name: \"A.B\" } }\n *  { fqn: \"$default.foo.$default.bar\", creationContext: { name: \"A.B.C\" } }\n * ]\n *\n * These four view configs all match the ng-view with the fqn: \"$default.foo.$default.bar\":\n *\n * - ViewConfig1: { ngViewName: \"bar\",                       ngViewContextAnchor: \"A.B.C\" }\n * - ViewConfig2: { ngViewName: \"$default.bar\",              ngViewContextAnchor: \"A.B\" }\n * - ViewConfig3: { ngViewName: \"foo.$default.bar\",          ngViewContextAnchor: \"A\" }\n * - ViewConfig4: { ngViewName: \"$default.foo.$default.bar\", ngViewContextAnchor: \"\" }\n *\n * Using ViewConfig3 as an example, it matches the ng-view with fqn \"$default.foo.$default.bar\" because:\n * - The ViewConfig's segmented target name is: [ \"foo\", \"$default\", \"bar\" ]\n * - There exists a parent ng-view (which has fqn: \"$default.foo\") where:\n *    - the parent ng-view's name \"foo\" matches the first segment \"foo\" of the ViewConfig's target name\n *    - the parent ng-view's context \"A\" matches the ViewConfig's anchor context \"A\"\n * - And the remaining segments [ \"$default\", \"bar\" ].join(\".\"_ of the ViewConfig's target name match\n *   the tail of the ng-view's fqn \"default.bar\"\n *\n * @internal\n */\nViewService.matches =\n  (\n    /** @type {import(\"../../shared/interface.ts\").Dict<ActiveUIView>} */ ngViewsByFqn,\n    /** @type {ActiveUIView} */ ngView,\n  ) =>\n  (/** @type {ViewConfig} */ viewConfig) => {\n    // Split names apart from both viewConfig and ngView into segments\n    const vc = viewConfig.viewDecl;\n\n    const vcSegments = /** @type {string[]} */ (vc.$ngViewName?.split(\".\"));\n\n    const uivSegments = ngView.fqn.split(\".\");\n\n    // Check if the tails of the segment arrays match. ex, these arrays' tails match:\n    // vc: [\"foo\", \"bar\"], uiv fqn: [\"$default\", \"foo\", \"bar\"]\n    if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n      return false;\n    // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n    // [\"$default\", \"foo\"].join(\".\") == \"$default.foo\", does the ng-view $default.foo context match?\n    const negOffset = 1 - vcSegments.length || undefined;\n\n    const fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\".\");\n\n    const ngViewContext = ngViewsByFqn[fqnToFirstSegment].creationContext;\n\n    return vc.$ngViewContextAnchor === (ngViewContext && ngViewContext.name);\n  };\n","import { stringify } from \"../../shared/strings.js\";\nimport { is } from \"../../shared/hof.js\";\n\n/**\n * An object for Transition Rejection reasons.\n * @internal\n * @enum {number}\n */\nexport const RejectType = {\n  /**\n   * A new transition superseded this one.\n   *\n   * While this transition was running, a new transition started.\n   * This transition is cancelled because it was superseded by a new transition.\n   * @type {number}\n   */\n  _SUPERSEDED: 2,\n\n  /**\n   * The transition was aborted.\n   *\n   * The transition was aborted by a hook which returned `false`.\n   * @type {number}\n   */\n  _ABORTED: 3,\n\n  /**\n   * The transition was invalid.\n   *\n   * The transition was never started because it was invalid.\n   * @type {number}\n   */\n  _INVALID: 4,\n\n  /**\n   * The transition was ignored.\n   *\n   * The transition was ignored because it would have no effect.\n   * Either:\n   * - The transition is targeting the current state and parameter values.\n   * - The transition is targeting the same state and parameter values as the currently running transition.\n   * @type {number}\n   */\n  _IGNORED: 5,\n\n  /**\n   * The transition errored.\n   *\n   * This generally means a hook threw an error or returned a rejected promise.\n   * @type {number}\n   */\n  _ERROR: 6,\n};\n\nlet id = 0;\n\nexport class Rejection {\n  /**\n   * @param {number} type\n   * @param {string} message\n   * @param {any} [detail]\n   */\n  constructor(type, message, detail) {\n    /** @type {number} */\n    this.$id = id++;\n    /** @type {number} */\n    this.type = type;\n    /** @type {string} */\n    this.message = message;\n    /** @type {any} */\n    this.detail = detail;\n    /** @type {boolean} */\n    this.redirected = false;\n  }\n\n  /**\n   * Returns a Rejection due to transition superseded\n   *\n   * @param {any} [detail]\n   * @param {{ redirected?: boolean } | undefined} [options]\n   * @returns {Rejection}\n   */\n  static superseded(detail, options) {\n    const message =\n      \"The transition has been superseded by a different transition\";\n\n    const rejection = new Rejection(RejectType._SUPERSEDED, message, detail);\n\n    if (options && options.redirected) {\n      rejection.redirected = true;\n    }\n\n    return rejection;\n  }\n\n  /**\n   * Returns a Rejection due to redirected transition\n   *\n   * @param {any} [detail]\n   * @returns {Rejection}\n   */\n  static redirected(detail) {\n    return Rejection.superseded(detail, { redirected: true });\n  }\n\n  /**\n   * Returns a Rejection due to invalid transition\n   *\n   * @param {any} detail\n   * @returns {Rejection}\n   */\n  static invalid(detail) {\n    const message = \"This transition is invalid\";\n\n    return new Rejection(RejectType._INVALID, message, detail);\n  }\n\n  /**\n   * Returns a Rejection due to ignored transition\n   *\n   * @param {any} [detail]\n   * @returns {Rejection}\n   */\n  static ignored(detail) {\n    const message = \"The transition was ignored\";\n\n    return new Rejection(RejectType._IGNORED, message, detail);\n  }\n\n  /**\n   * Returns a Rejection due to aborted transition\n   *\n   * @param {any} [detail]\n   * @returns {Rejection}\n   */\n  static aborted(detail) {\n    const message = \"The transition has been aborted\";\n\n    return new Rejection(RejectType._ABORTED, message, detail);\n  }\n\n  /**\n   * Returns a Rejection due to errored transition\n   *\n   * @param {any} [detail]\n   * @returns {Rejection}\n   */\n  static errored(detail) {\n    const message = \"The transition errored\";\n\n    return new Rejection(RejectType._ERROR, message, detail);\n  }\n\n  /**\n   * Returns a Rejection\n   *\n   * Normalizes a value as a Rejection.\n   * If the value is already a Rejection, returns it.\n   * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n   *\n   * @param {any} detail\n   * @returns {Rejection} `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n   */\n  static normalize(detail) {\n    return is(Rejection)(detail) ? detail : Rejection.errored(detail);\n  }\n\n  /**\n   * @returns {string}\n   */\n  toString() {\n    /**\n     * @param {any} data\n     * @returns {string}\n     */\n    const detailString = (data) =>\n      data && data.toString !== Object.prototype.toString\n        ? data.toString()\n        : stringify(data);\n\n    const detail = detailString(this.detail);\n\n    const { $id, type, message } = this;\n\n    return `Transition Rejection($id: ${$id} type: ${type}, message: ${message}, detail: ${detail})`;\n  }\n\n  /**\n   * Returns a rejected Promise annotated with `_transitionRejection` for identification.\n   *\n   * @returns {Promise<any> & { _transitionRejection: Rejection }}\n   */\n  toPromise() {\n    return Object.assign(((x) => (x.catch(() => 0), x))(Promise.reject(this)), {\n      _transitionRejection: this,\n    });\n  }\n}\n","import { defaults } from \"../../shared/common.js\";\nimport { fnToString, maxLength } from \"../../shared/strings.js\";\nimport { isPromise } from \"../../shared/predicates.js\";\nimport { parse } from \"../../shared/hof.js\";\nimport { trace } from \"../common/trace.js\";\nimport { Rejection } from \"./reject-factory.js\";\nimport { TargetState } from \"../state/target-state.js\";\n\n/** @typedef {import(\"./interface.ts\").TransitionHookOptions} TransitionHookOptions */\n/** @typedef {import(\"./interface.ts\").HookResult} HookResult */\n/** @typedef {import(\"./transition.js\").Transition} Transition */\n/** @typedef {import(\"./hook-registry.js\").RegisteredHook} RegisteredHook */\n\n/**\n * Default options for TransitionHook\n * @type {Partial<TransitionHookOptions>}\n */\nconst defaultOptions = {\n  current: () => {\n    /* empty */\n  },\n  transition: null,\n  traceData: {},\n  bind: null,\n};\n\n/**\n * Enum representing the different phases of a transition hook.\n * @internal\n * @enum {number}\n */\nexport const TransitionHookPhase = {\n  _CREATE: 0,\n  _BEFORE: 1,\n  _RUN: 2,\n  _SUCCESS: 3,\n  _ERROR: 4,\n};\n\n/**\n * Enum representing the scope in which a transition hook operates.\n * @enum {number}\n */\nexport const TransitionHookScope = {\n  _TRANSITION: 0,\n  _STATE: 1,\n};\n\nexport class TransitionHook {\n  /**\n   * Chains together an array of TransitionHooks.\n   *\n   * Given a list of [[TransitionHook]] objects, chains them together.\n   * Each hook is invoked after the previous one completes.\n   *\n   * #### Example:\n   * ```js\n   * var hooks: TransitionHook[] = getHooks();\n   * let promise: Promise<any> = TransitionHook.chain(hooks);\n   *\n   * promise.then(handleSuccess, handleError);\n   * ```\n   *\n   * @param {TransitionHook[]} hooks the list of hooks to chain together\n   * @param {Promise<any>} [waitFor] if provided, the chain is `.then()`'ed off this promise\n   * @returns a `Promise` for sequentially invoking the hooks (in order)\n   */\n  static chain(hooks, waitFor) {\n    // Chain the next hook off the previous\n    const createHookChainR = (\n      /** @type {Promise<any>} */ prev,\n      /** @type {TransitionHook} */ nextHook,\n    ) => prev.then(() => nextHook.invokeHook());\n\n    return hooks.reduce(createHookChainR, waitFor || Promise.resolve());\n  }\n\n  /**\n   * Invokes all the provided TransitionHooks, in order.\n   * Each hook's return value is checked.\n   * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n   * If no hook returns a promise, then all hooks are processed synchronously.\n   *\n   * @param {TransitionHook[]} hooks the list of TransitionHooks to invoke\n   * @param {() => Promise<any>} doneCallback a callback that is invoked after all the hooks have successfully completed\n   *\n   * @returns {Promise<any>} a promise for the async result, or the result of the callback\n   */\n  static invokeHooks(hooks, doneCallback) {\n    for (let idx = 0; idx < hooks.length; idx++) {\n      const hookResult = hooks[idx].invokeHook();\n\n      if (isPromise(hookResult)) {\n        const remainingHooks = hooks.slice(idx + 1);\n\n        return TransitionHook.chain(remainingHooks, hookResult).then(() => {\n          doneCallback();\n        });\n      }\n    }\n\n    return doneCallback();\n  }\n\n  /**\n   * Run all TransitionHooks, ignoring their return value.\n   * @param {TransitionHook[]} hooks\n   */\n  static runAllHooks(hooks) {\n    hooks.forEach((hook) => hook.invokeHook());\n  }\n\n  /**\n   *\n   * @param {Transition} transition\n   * @param {import(\"../state/interface.ts\").StateDeclaration | null} stateContext\n   * @param {RegisteredHook} registeredHook\n   * @param {TransitionHookOptions} options\n   * @param {ng.ExceptionHandlerService} exceptionHandler\n   */\n  constructor(\n    transition,\n    stateContext,\n    registeredHook,\n    options,\n    exceptionHandler,\n  ) {\n    this.transition = transition;\n    this.stateContext = stateContext;\n    this.registeredHook = registeredHook;\n    /** @type {TransitionHookOptions} */\n    this.options = /** @type {TransitionHookOptions} */ (\n      defaults(options, defaultOptions)\n    );\n\n    this.type = registeredHook.eventType;\n\n    this.isSuperseded = () =>\n      this.type.hookPhase === TransitionHookPhase._RUN &&\n      !this.options.transition?.isActive();\n\n    /** @type {ng.ExceptionHandlerService} */\n    this._exceptionHandler = exceptionHandler;\n  }\n\n  /**\n   * @param {unknown} err\n   */\n  logError(err) {\n    this._exceptionHandler(err);\n  }\n\n  invokeHook() {\n    const hook = this.registeredHook;\n\n    if (hook._deregistered) return undefined;\n    const notCurrent = this.getNotCurrentRejection();\n\n    if (notCurrent) return notCurrent;\n    const { options } = this;\n\n    trace.traceHookInvocation(this, this.transition, options);\n    const invokeCallback = () =>\n      hook.callback.call(\n        options.bind,\n        this.transition,\n        /** @type {ng.StateDeclaration} */ (this.stateContext),\n      );\n\n    const normalizeErr = (/** @type {any} */ err) =>\n      Rejection.normalize(err).toPromise();\n\n    const handleError = (/** @type {Rejection} */ err) =>\n      hook.eventType.getErrorHandler()(err);\n\n    const handleResult = (/** @type {any} */ result) =>\n      hook.eventType.getResultHandler(this)(result);\n\n    try {\n      const result = invokeCallback();\n\n      if (!this.type.synchronous && isPromise(result)) {\n        return /** @type Promise<any>} */ (result)\n          .catch(normalizeErr)\n          .then(handleResult, handleError);\n      } else {\n        return handleResult(result);\n      }\n    } catch (err) {\n      // If callback throws (synchronously)\n      return handleError(Rejection.normalize(err));\n    } finally {\n      if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n        hook.deregister();\n      }\n    }\n  }\n\n  /**\n   * This method handles the return value of a Transition Hook.\n   *\n   * A hook can return false (cancel), a TargetState (redirect),\n   * or a promise (which may later resolve to false or a redirect)\n   *\n   * This also handles \"transition superseded\" -- when a new transition\n   * was started while the hook was still running\n   * @param {HookResult} result\n   * @returns {Promise<any> | undefined}\n   */\n  handleHookResult(result) {\n    const notCurrent = this.getNotCurrentRejection();\n\n    if (notCurrent) return notCurrent;\n\n    // Hook returned a promise\n    if (isPromise(result)) {\n      // Wait for the promise, then reprocess with the resulting value\n      return /** @type {Promise<any>} */ (result).then((val) =>\n        this.handleHookResult(val),\n      );\n    }\n    trace.traceHookResult(result, this.transition);\n\n    // Hook returned false\n    if (result === false) {\n      // Abort this Transition\n      return Rejection.aborted(\"Hook aborted transition\").toPromise();\n    }\n\n    // hook returned a TargetState\n    if (result instanceof TargetState) {\n      // Halt the current Transition and redirect (a new Transition) to the TargetState.\n      return Rejection.redirected(result).toPromise();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Return a Rejection promise if the transition is no longer current due\n   * a new transition has started and superseded this one.\n   */\n  getNotCurrentRejection() {\n    if (this.transition._aborted) {\n      return Rejection.aborted().toPromise();\n    }\n\n    // This transition is no longer current.\n    // Another transition started while this hook was still running.\n    if (this.isSuperseded()) {\n      return Rejection.superseded(\n        /** @type {TransitionHookOptions} */ (this.options).current(),\n      ).toPromise();\n    }\n\n    return undefined;\n  }\n\n  toString() {\n    const { options, registeredHook } = this;\n\n    const event = parse(\"traceData.hookType\")(options) || \"internal\",\n      context =\n        parse(\"traceData.context.state.name\")(options) ||\n        parse(\"traceData.context\")(options) ||\n        \"unknown\",\n      name = fnToString(registeredHook.callback);\n\n    return `${event} context: ${context}, ${maxLength(200, name)}`;\n  }\n}\n/**\n * These GetResultHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.HANDLE_RESULT =\n  (/** @type {TransitionHook} */ hook) => (/** @type {HookResult} */ result) =>\n    hook.handleHookResult(result);\n/**\n * If the result is a promise rejection, log it.\n * Otherwise, ignore the result.\n */\nTransitionHook.LOG_REJECTED_RESULT =\n  (/** @type {{ logError: (arg0: Rejection) => any; }} */ hook) =>\n  (/** @type {HookResult} */ result) => {\n    if (isPromise(result)) {\n      /** @type {Promise<any>} */ (result).catch((/** @type {any} */ err) =>\n        hook.logError(Rejection.normalize(err)),\n      );\n    }\n\n    return undefined;\n  };\n/**\n * These GetErrorHandler(s) are used by [[invokeHook]] below\n * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n */\nTransitionHook.LOG_ERROR =\n  /** @param {{ logError: (arg0: any) => any; }} [hook] */ (hook) =>\n    (/** @type {any} */ error) =>\n      hook?.logError(error);\nTransitionHook.REJECT_ERROR = () => (/** @type {any} */ error) =>\n  ((x) => (x.catch(() => 0), x))(Promise.reject(error));\nTransitionHook.THROW_ERROR = () => (/** @type {any} */ error) => {\n  throw error;\n};\n","/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nexport class Glob {\n  /** Returns a glob from the string, or null if the string isn't Glob-like\n   * @param {string} text\n   * @returns {?Glob}\n   */\n  static fromString(text) {\n    return hasGlobs(text) ? new Glob(text) : null;\n  }\n\n  /**\n   * @param {string} text\n   */\n  constructor(text) {\n    /**\n     * @type {string}\n     */\n    this._text = text;\n\n    const regexpString = this._text\n      .split(\".\")\n      .map((seg) => {\n        if (seg === \"**\") return \"(?:|(?:\\\\.[^.]*)*)\";\n\n        if (seg === \"*\") return \"\\\\.[^.]*\";\n\n        return `\\\\.${seg}`;\n      })\n      .join(\"\");\n\n    /**\n     * @type {RegExp}\n     */\n    this._regexp = new RegExp(`^${regexpString}$`);\n  }\n\n  /**\n   * @param {string} name\n   * @return {boolean}\n   */\n  matches(name) {\n    return this._regexp.test(`.${name}`);\n  }\n}\n\n/** Returns true if the string has glob-like characters in it\n *  @param {string} text\n *  @returns {boolean}\n */\nexport function hasGlobs(text) {\n  return !!/[!,*]+/.exec(text);\n}\n","import { map, removeFrom, tail } from \"../../shared/common.js\";\nimport { isFunction, isString } from \"../../shared/utils.js\";\nimport { Glob } from \"../glob/glob.js\";\nimport { TransitionHookScope } from \"./transition-hook.js\";\n\n/**\n * Determines if the given state matches the matchCriteria\n * @internal\n * @param {import(\"../state/state-object.js\").StateObject} state a State Object to test against\n * @param {import(\"./interface.ts\").HookMatchCriterion} criterion - If a string, matchState uses the string as a glob-matcher against the state name\n- If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n  and returns a positive match if any of the globs match.\n- If a function, matchState calls the function with the state and returns true if the function's result is truthy.\n * @param {ng.Transition} transition\n * @returns {boolean}\n */\nexport function matchState(state, criterion, transition) {\n  const toMatch = isString(criterion) ? [criterion] : criterion;\n\n  /**\n   * @param {ng.BuiltStateDeclaration} _state\n   */\n  function matchGlobs(_state) {\n    const globStrings = /** @type {string[]}*/ (toMatch);\n\n    for (let i = 0; i < globStrings.length; i++) {\n      const glob = new Glob(globStrings[i]);\n\n      if (\n        (glob && glob.matches(_state.name)) ||\n        (!glob && globStrings[i] === _state.name)\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  const matchFn = /** @type {any} */ (\n    isFunction(toMatch) ? toMatch : matchGlobs\n  );\n\n  return !!matchFn(state, transition);\n}\n/**\n * The registration data for a registered transition hook\n */\nexport class RegisteredHook {\n  /**\n   * @param {ng.TransitionService} tranSvc\n   * @param {import(\"./transition-event-type.js\").TransitionEventType} eventType\n   * @param {import(\"./interface.ts\").HookFn} callback\n   * @param {import(\"./interface.ts\").HookMatchCriteria} matchCriteria\n   * @param {(hook: RegisteredHook) => void} removeHookFromRegistry\n   * @param {import(\"./interface.ts\").HookRegOptions} options\n   */\n  constructor(\n    tranSvc,\n    eventType,\n    callback,\n    matchCriteria,\n    removeHookFromRegistry,\n    options = {},\n  ) {\n    this.tranSvc = tranSvc;\n    this.eventType = eventType;\n    this.callback = callback;\n    this.matchCriteria = matchCriteria;\n    this.removeHookFromRegistry = removeHookFromRegistry;\n    this.invokeCount = 0;\n    this._deregistered = false;\n    this.priority = options.priority || 0;\n    this.bind = options.bind || null;\n    this.invokeLimit = options.invokeLimit;\n  }\n\n  /**\n   * Gets the matching [[PathNode]]s\n   *\n   * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n   * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n   *\n   * Returning `null` is significant to distinguish between the default\n   * \"match-all criterion value\" of `true` compared to a `() => true` function,\n   * when the nodes is an empty array.\n   *\n   * This is useful to allow a transition match criteria of `entering: true`\n   * to still match a transition, even when `entering === []`.  Contrast that\n   * with `entering: (state) => true` which only matches when a state is actually\n   * being entered.\n   * @param {import(\"../resolve/resolve-context.js\").PathNode[]} nodes\n   * @param {import(\"./interface.ts\").HookMatchCriterion} criterion\n   * @param {ng.Transition} transition\n   * @return {import(\"../resolve/resolve-context.js\").PathNode[] | null}\n   */\n  _matchingNodes(nodes, criterion, transition) {\n    if (criterion === true) return nodes;\n    const matching = nodes.filter((node) =>\n      matchState(node.state, criterion, transition),\n    );\n\n    return matching.length ? matching : null;\n  }\n\n  /**\n   * Gets the default match criteria (all `true`)\n   *\n   * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n   *\n   * ```js\n   * {\n   *   to: true,\n   *   from: true,\n   *   entering: true,\n   *   exiting: true,\n   *   retained: true,\n   * }\n   * @returns {import(\"./interface.ts\").HookMatchCriteria}\n   */\n  _getDefaultMatchCriteria() {\n    return /** @type {import(\"./interface.ts\").HookMatchCriteria} */ (\n      map(this.tranSvc._getPathTypes(), () => true)\n    );\n  }\n\n  /**\n   * Gets matching nodes as [[IMatchingNodes]]\n   *\n   * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n   *\n   * ```js\n   * let matches: IMatchingNodes = {\n   *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n   *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n   *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n   *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n   *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n   * };\n   * ```\n   * @param {import(\"./interface.ts\").TreeChanges} treeChanges\n   * @param {ng.Transition} transition\n   * @returns {{}}\n   */\n  _getMatchingNodes(treeChanges, transition) {\n    const criteria = Object.assign(\n      this._getDefaultMatchCriteria(),\n      this.matchCriteria,\n    );\n\n    const paths = Object.values(this.tranSvc._getPathTypes());\n\n    return paths.reduce((mn, pathtype) => {\n      // STATE scope criteria matches against every node in the path.\n      // TRANSITION scope criteria matches against only the last node in the path\n      const isStateHook = pathtype.scope === TransitionHookScope._STATE;\n\n      const path = treeChanges[pathtype.name] || [];\n\n      const nodes = isStateHook ? path : [tail(path)];\n\n      /** @type {Record<string, any>} */ (mn)[pathtype.name] =\n        this._matchingNodes(\n          nodes,\n          /** @type {import(\"./interface.ts\").HookMatchCriterion} */ (\n            criteria[pathtype.name]\n          ),\n          transition,\n        );\n\n      return mn;\n    }, {});\n  }\n\n  /**\n   * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]\n   * @param {import(\"./interface.ts\").TreeChanges} treeChanges\n   * @param {ng.Transition} transition\n   * @returns {import(\"./interface.ts\").IMatchingNodes | null} an IMatchingNodes object, or null. If an IMatchingNodes object is returned,\n   * its values are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n   */\n  matches(treeChanges, transition) {\n    const matches = this._getMatchingNodes(treeChanges, transition);\n\n    // Check if all the criteria matched the TreeChanges object\n    const allMatched = Object.values(matches).every((x) => x);\n\n    return allMatched\n      ? /** @type {import(\"./interface.ts\").IMatchingNodes } */ (matches)\n      : null;\n  }\n\n  deregister() {\n    this.removeHookFromRegistry(this);\n    this._deregistered = true;\n  }\n}\n/**\n * Register a transition hook without mutating the hookSource surface.\n * @param {ng.TransitionProvider| import(\"./transition.js\").Transition} hookSource\n * @param {ng.TransitionProvider} transitionService\n * @param {import(\"./transition-event-type.js\").TransitionEventType} eventType\n * @param {import(\"./interface.ts\").HookMatchCriteria} matchCriteria\n * @param {import(\"./interface.ts\").HookFn} callback\n * @param {import(\"./interface.ts\").HookRegOptions} options\n * @returns {import(\"./interface.ts\").DeregisterFn}\n */\nexport function registerHook(\n  hookSource,\n  transitionService,\n  eventType,\n  matchCriteria,\n  callback,\n  options = {},\n) {\n  // Create the object which holds the registered transition hooks.\n  /** @type {{ [x: string]: RegisteredHook[] } & Record<string, any>} */\n  const _registeredHooks = (hookSource._registeredHooks =\n    hookSource._registeredHooks || {});\n\n  const hooks = (_registeredHooks[eventType.name] =\n    _registeredHooks[eventType.name] || []);\n\n  const removeHookFn = (/** @type {RegisteredHook} */ hook) =>\n    removeFrom(hooks, hook);\n\n  const registeredHook = new RegisteredHook(\n    transitionService,\n    eventType,\n    callback,\n    matchCriteria,\n    removeHookFn,\n    options,\n  );\n\n  hooks.push(registeredHook);\n\n  return registeredHook.deregister.bind(registeredHook);\n}\n/**\n * Return a registration function of the requested type.\n * @param {ng.TransitionProvider| import(\"./transition.js\").Transition} hookSource\n * @param {ng.TransitionService} transitionService\n * @param {import(\"./transition-event-type.js\").TransitionEventType} eventType\n * @returns {function(import(\"./interface.ts\").HookMatchCriteria, import(\"./interface.ts\").HookFn, {}=): (function(): void)|*}\n */\nexport function makeEvent(hookSource, transitionService, eventType) {\n  // Create the object which holds the registered transition hooks.\n  /** @type {{ [x: string]: RegisteredHook[] } & Record<string, any>} */\n  const _registeredHooks = (hookSource._registeredHooks =\n    hookSource._registeredHooks || {});\n\n  /**\n   * @type {any[]}\n   */\n  const hooks = (_registeredHooks[eventType.name] = []);\n\n  const removeHookFn = (/** @type {any} */ x) => removeFrom(hooks, x);\n\n  // Create hook registration function on the HookRegistry for the event\n  /** @type Record<string, any> */ (hookSource)[eventType.name] =\n    hookRegistrationFn;\n\n  /**\n   * @param {import(\"./interface.ts\").HookMatchCriteria} matchObject\n   * @param {import(\"./interface.ts\").HookFn} callback\n   */\n  function hookRegistrationFn(matchObject, callback, options = {}) {\n    const registeredHook = new RegisteredHook(\n      transitionService,\n      eventType,\n      callback,\n      matchObject,\n      removeHookFn,\n      options,\n    );\n\n    hooks.push(registeredHook);\n\n    return registeredHook.deregister.bind(registeredHook);\n  }\n\n  return hookRegistrationFn;\n}\n","import { assertPredicate, unnestR } from \"../../shared/common.js\";\nimport { isArray } from \"../../shared/utils.js\";\nimport {\n  TransitionHook,\n  TransitionHookPhase,\n  TransitionHookScope,\n} from \"./transition-hook.js\";\n\n/** @typedef {import(\"./transition-event-type.js\").TransitionEventType} TransitionEventType */\n\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n */\nexport class HookBuilder {\n  /**\n   * @param {import(\"./transition.js\").Transition} transition\n   */\n  constructor(transition) {\n    this.transition = transition;\n  }\n\n  /**\n   * @param {TransitionHookPhase} phase\n   * @returns {TransitionHook[]}\n   */\n  buildHooksForPhase(phase) {\n    return this.transition._transitionService\n      ._getEvents(phase)\n      .map((type) => this.buildHooks(type))\n      .reduce(unnestR, [])\n      .filter(Boolean);\n  }\n\n  /**\n   * Returns an array of newly built TransitionHook objects.\n   *\n   * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n   * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n   * - For each of the [[PathNode]]s, creates a TransitionHook\n   *\n   * @param {TransitionEventType} hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n   * @returns {TransitionHook[]} an array of TransitionHook objects\n   */\n  buildHooks(hookType) {\n    const { transition } = this;\n\n    const treeChanges = /** @type {import(\"./interface.ts\").TreeChanges} */ (\n      transition.treeChanges()\n    );\n\n    // Find all the matching registered hooks for a given hook type\n    const matchingHooks = this.getMatchingHooks(\n      hookType,\n      treeChanges,\n      transition,\n    );\n\n    if (!matchingHooks) return [];\n    const baseHookOptions = {\n      transition,\n      current: transition.options().current,\n    };\n\n    const makeTransitionHooks = (\n      /** @type {import(\"./hook-registry.js\").RegisteredHook} */ hook,\n    ) => {\n      // Fetch the Nodes that caused this hook to match.\n      const matches = hook.matches(\n        /** @type {import(\"./interface.ts\").TreeChanges} */ (treeChanges),\n        transition,\n      );\n\n      // Select the PathNode[] that will be used as TransitionHook context objects\n      const matchingNodes =\n        /** @type {import(\"./interface.ts\").IMatchingNodes} */ (matches)[\n          hookType.criteriaMatchPath.name\n        ];\n\n      // Return an array of HookTuples\n      return matchingNodes.map((node) => {\n        const _options = Object.assign(\n          {\n            bind: hook.bind,\n            traceData: { hookType: hookType.name, context: node },\n          },\n          baseHookOptions,\n        );\n\n        /** @type {import(\"../state/interface.ts\").StateDeclaration | null} */\n        const state =\n          hookType.criteriaMatchPath.scope === TransitionHookScope._STATE\n            ? node.state.self\n            : null;\n\n        const transitionHook = new TransitionHook(\n          transition,\n          state,\n          hook,\n          /** @type {import(\"./transition-hook.js\").TransitionHookOptions} */ (\n            _options\n          ),\n          this.transition._transitionService._exceptionHandler,\n        );\n\n        return { hook, node, transitionHook };\n      });\n    };\n\n    return matchingHooks\n      .map(makeTransitionHooks)\n      .reduce(unnestR, [])\n      .sort(tupleSort(hookType.reverseSort))\n      .map(\n        (/** @type {{ transitionHook: any; }} */ tuple) => tuple.transitionHook,\n      );\n  }\n\n  /**\n   * Finds all RegisteredHooks from:\n   * - The Transition object instance hook registry\n   * - The TransitionService ($transitions) global hook registry\n   *\n   * which matched:\n   * - the eventType\n   * - the matchCriteria (to, from, exiting, retained, entering)\n   * @returns an array of matched [[RegisteredHook]]s\n   * @param {import(\"./transition-event-type.js\").TransitionEventType} hookType\n   * @param {import(\"./interface.ts\").TreeChanges} treeChanges\n   * @param {import(\"./transition.js\").Transition} transition\n   */\n  getMatchingHooks(hookType, treeChanges, transition) {\n    const isCreate = hookType.hookPhase === TransitionHookPhase._CREATE;\n\n    // Instance and Global hook registries\n    const $transitions = this.transition._transitionService;\n\n    const registries = isCreate\n      ? [$transitions]\n      : [this.transition, $transitions];\n\n    return registries\n      .map((reg) => reg.getHooks(hookType.name)) // Get named hooks from registries\n      .filter(assertPredicate(isArray, `broken event named: ${hookType.name}`)) // Sanity check\n      .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n      .filter(\n        (\n          /** @type {{ matches: (arg0: import(\"./interface.ts\").TreeChanges, arg1: ng.Transition) => any; }} */ hook,\n        ) => hook.matches(treeChanges, transition),\n      ); // Only those satisfying matchCriteria\n  }\n}\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort = false) {\n  return function nodeDepthThenPriority(\n    /** @type {import(\"./interface.ts\").HookTuple} */ left,\n    /** @type {import(\"./interface.ts\").HookTuple} */ right,\n  ) {\n    const factor = reverseDepthSort ? -1 : 1;\n\n    const leftPath = /** @type {ng.StateObject[]} */ (left.node.state.path);\n\n    const rightPath = /** @type {ng.StateObject[]} */ (right.node.state.path);\n\n    const depthDelta = (leftPath.length - rightPath.length) * factor;\n\n    return depthDelta !== 0\n      ? depthDelta\n      : right.hook.priority - left.hook.priority;\n  };\n}\n","import { trace } from \"../common/trace.js\";\nimport { stringify } from \"../../shared/strings.js\";\nimport {\n  anyTrueR,\n  arrayTuples,\n  find,\n  map,\n  omit,\n  tail,\n  unnestR,\n} from \"../../shared/common.js\";\nimport {\n  assert,\n  isNullOrUndefined,\n  isObject,\n  isUndefined,\n} from \"../../shared/utils.js\";\nimport { is, propEq, val } from \"../../shared/hof.js\";\nimport { TransitionHook, TransitionHookPhase } from \"./transition-hook.js\";\nimport { registerHook } from \"./hook-registry.js\";\nimport { HookBuilder } from \"./hook-builder.js\";\nimport { PathUtils } from \"../path/path-utils.js\";\nimport { Param } from \"../params/param.js\";\nimport { Resolvable } from \"../resolve/resolvable.js\";\nimport { ResolveContext } from \"../resolve/resolve-context.js\";\nimport { Rejection } from \"./reject-factory.js\";\n\n/** @typedef {import('./interface.ts').DeregisterFn} DeregisterFn */\n/** @typedef {import('./interface.ts').HookFn} HookFn */\n/** @typedef {import('./interface.ts').HookMatchCriteria} HookMatchCriteria */\n/** @typedef {import('./interface.ts').HookRegOptions} HookRegOptions */\n/** @typedef {import(\"../state/interface.ts\").BuiltStateDeclaration} BuiltStateDeclaration */\n/** @typedef {import(\"./interface.ts\").RegisteredHooks} RegisteredHooks */\n/** @typedef {import(\"./hook-registry.js\").RegisteredHook} RegisteredHook */\n/** @typedef {import('../state/target-state.js').TargetState} TargetState */\n/** @typedef {import(\"../transition/interface.ts\").TreeChanges} TreeChanges */\n/** @typedef {import(\"../path/path-node.js\").PathNode} PathNode */\n/** @typedef {import(\"../state/state-object.js\").StateObject} StateObject */\n/** @typedef {import(\"../state/interface.ts\").StateDeclaration} StateDeclaration */\n\nconst REDIRECT_MAX = 20;\n\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nexport class Transition {\n  /**\n   * Creates a new Transition object.\n   *\n   * If the target state is not valid, an error is thrown.\n   *\n   * @param {Array<PathNode>} fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n   *        encapsulates the \"from state\".\n   * @param {TargetState} targetState The target state and parameters being transitioned to (also, the transition options)\n   * @param {import(\"./transition-service.js\").TransitionProvider} transitionService\n   * @param {ng.RouterService} globals\n   */\n  constructor(fromPath, targetState, transitionService, globals) {\n    /**\n     * @type {import('../router.js').RouterProvider}\n     */\n    this._globals = globals;\n\n    this._transitionService = transitionService;\n\n    /** @type {PromiseWithResolvers<any>} */\n    this._deferred = Promise.withResolvers();\n\n    /**\n     * This promise is resolved or rejected based on the outcome of the Transition.\n     *\n     * When the transition is successful, the promise is resolved\n     * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n     */\n    this.promise = this._deferred.promise;\n    /** @type {RegisteredHooks} Holds the hook registration functions such as those passed to Transition.onStart() */\n    this._registeredHooks = {};\n\n    /** @type {HookBuilder} */\n    this._hookBuilder = new HookBuilder(this);\n\n    /** Checks if this transition is currently active/running. */\n    /** @type {() => boolean} */\n    this.isActive = () => this._globals.transition === this;\n\n    this._targetState = targetState;\n\n    if (!targetState.valid()) {\n      throw new Error(targetState.error());\n    }\n    // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n    this._options = Object.assign(\n      { current: val(this) },\n      targetState.options(),\n    );\n    this.$id = transitionService._transitionCount++;\n    const toPath = PathUtils.buildToPath(fromPath, targetState);\n\n    /** @type {TreeChanges} */\n    this._treeChanges = PathUtils.treeChanges(\n      fromPath,\n      /** @type {PathNode[]} */ (toPath),\n      this._options.reloadState,\n    );\n    const onCreateHooks = this._hookBuilder.buildHooksForPhase(\n      TransitionHookPhase._CREATE,\n    );\n\n    TransitionHook.invokeHooks(onCreateHooks, () => Promise.resolve());\n    this.applyViewConfigs();\n  }\n\n  /**\n   * @param {string} hookName\n   * @returns {RegisteredHook[]}\n   */\n  getHooks(hookName) {\n    return this._registeredHooks[hookName] || [];\n  }\n\n  /**\n   * Registers a hook by event name.\n   * @param {string} eventName\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  on(eventName, matchCriteria, callback, options) {\n    const eventType = this._getEventType(eventName);\n\n    if (eventType.hookPhase === TransitionHookPhase._CREATE) {\n      throw new Error(\"onCreate hooks can only be registered on the service\");\n    }\n\n    return registerHook(\n      this,\n      this._transitionService,\n      eventType,\n      matchCriteria,\n      callback,\n      options,\n    );\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onBefore(matchCriteria, callback, options) {\n    return this.on(\"onBefore\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onStart(matchCriteria, callback, options) {\n    return this.on(\"onStart\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onEnter(matchCriteria, callback, options) {\n    return this.on(\"onEnter\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onRetain(matchCriteria, callback, options) {\n    return this.on(\"onRetain\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onExit(matchCriteria, callback, options) {\n    return this.on(\"onExit\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onFinish(matchCriteria, callback, options) {\n    return this.on(\"onFinish\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onSuccess(matchCriteria, callback, options) {\n    return this.on(\"onSuccess\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onError(matchCriteria, callback, options) {\n    return this.on(\"onError\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {string} eventName\n   * @returns {import(\"./transition-event-type.js\").TransitionEventType}\n   */\n  _getEventType(eventName) {\n    const eventType = this._transitionService\n      ._getEvents()\n      .find((type) => type.name === eventName);\n\n    if (!eventType) {\n      throw new Error(`Unknown Transition hook event: ${eventName}`);\n    }\n\n    return eventType;\n  }\n\n  applyViewConfigs() {\n    const enteringStates = this._treeChanges.entering.map((node) => node.state);\n\n    PathUtils.applyViewConfigs(\n      this._transitionService.$view,\n      this._treeChanges.to,\n      enteringStates,\n    );\n  }\n\n  /**\n   * @returns {StateObject} the internal from [State] object\n   */\n  $from() {\n    return tail(this._treeChanges.from).state;\n  }\n\n  /**\n   * @returns {StateObject} the internal to [State] object\n   */\n  $to() {\n    return tail(this._treeChanges.to).state;\n  }\n\n  /**\n   * Returns the \"from state\"\n   *\n   * Returns the state that the transition is coming *from*.\n   *\n   * @returns {StateDeclaration} The state declaration object for the Transition's (\"from state\").\n   */\n  from() {\n    return this.$from().self;\n  }\n\n  /**\n   * Returns the \"to state\"\n   *\n   * Returns the state that the transition is going *to*.\n   *\n   * @returns {StateDeclaration} The state declaration object for the Transition's target state (\"to state\").\n   */\n  to() {\n    return this.$to().self;\n  }\n\n  /**\n   * Gets the Target State\n   *\n   * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n   *\n   * @returns {TargetState} the [[TargetState]] of this Transition\n   */\n  targetState() {\n    return this._targetState;\n  }\n\n  /**\n   * @param {string} pathname\n   * @returns {any}\n   */\n  params(pathname = \"to\") {\n    return Object.freeze(\n      /** @type {PathNode[]} */ (this._treeChanges[pathname])\n        .map((x) => x.paramValues)\n        .reduce((acc, obj) => ({ ...acc, ...obj }), {}),\n    );\n  }\n\n  /**\n   * Gets all available resolve tokens (keys)\n   *\n   * This method can be used in conjunction with [[injector]] to inspect the resolve values\n   * available to the Transition.\n   *\n   * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n   * in the Transition's [[TreeChanges.to]] path.\n   *\n   * #### Example:\n   * This example logs all resolve values\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n   * ```\n   *\n   * #### Example:\n   * This example creates promises for each resolve value.\n   * This triggers fetches of resolves (if any have not yet been fetched).\n   * When all promises have all settled, it logs the resolve values.\n   * ```js\n   * let tokens = trans.getResolveTokens();\n   * let promise = tokens.map(token => trans.injector().getAsync(token));\n   * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n   * ```\n   *\n   * Note: Angular 1 users whould use `$q.all()`\n   *\n   * @param pathname resolve context's path name (e.g., `to` or `from`)\n   *\n   * @returns an array of resolve tokens (keys)\n   */\n  getResolveTokens(pathname = \"to\") {\n    return new ResolveContext(\n      /** @type {PathNode[]} */ (this._treeChanges[pathname]),\n    ).getTokens();\n  }\n\n  /**\n   * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n   *\n   * Allows a transition hook to dynamically add a Resolvable to this Transition.\n   *\n   * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).\n   *\n   * If a `state` argument is provided, the Resolvable is processed when that state is being entered.\n   * If no `state` is provided then the root state is used.\n   * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.\n   * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.\n   *\n   * The `state` argument also scopes the resolved data.\n   * The resolved data is available from the injector for that `state` and any children states.\n   *\n   * #### Example:\n   * ```js\n   * transitionService.onBefore({}, transition => {\n   *   transition.addResolvable({\n   *     token: 'myResolve',\n   *     deps: ['MyService'],\n   *     resolveFn: myService => myService.getData()\n   *   });\n   * });\n   * ```\n   *\n   * @param {Resolvable | import(\"../resolve/interface.ts\").ResolvableLiteral} resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n   * @param {import(\"../state/interface.ts\").StateOrName} state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n   */\n  addResolvable(resolvable, state) {\n    if (state === void 0) {\n      state = \"\";\n    }\n    resolvable = is(Resolvable)(resolvable)\n      ? resolvable\n      : new Resolvable(resolvable);\n    const stateName = typeof state === \"string\" ? state : state.name;\n\n    const topath = this._treeChanges.to;\n\n    const targetNode = find(topath, (/** @type {PathNode} */ node) => {\n      return node.state.name === stateName;\n    });\n\n    assert(!!targetNode, `targetNode not found ${stateName}`);\n    const resolveContext = new ResolveContext(topath);\n\n    resolveContext.addResolvables(\n      [resolvable],\n      /** @type {PathNode} */ (targetNode).state,\n    );\n  }\n\n  /**\n   * Gets the transition from which this transition was redirected.\n   *\n   * If the current transition is a redirect, this method returns the transition that was redirected.\n   *\n   * #### Example:\n   * ```js\n   * let transitionA = $state.go('A').transition\n   * transitionA.onStart({}, () => $state.target('B'));\n   * $transitions.onSuccess({ to: 'B' }, (trans) => {\n   *   trans.to().name === 'B'; // true\n   *   trans.redirectedFrom() === transitionA; // true\n   * });\n   * ```\n   *\n   * @returns {Transition} The previous Transition, or null if this Transition is not the result of a redirection\n   */\n  redirectedFrom() {\n    return this._options.redirectedFrom || null;\n  }\n\n  /**\n   * Gets the original transition in a redirect chain\n   *\n   * A transition might belong to a long chain of multiple redirects.\n   * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n   *\n   * #### Example:\n   * ```js\n   * // states\n   * registry.register({ name: 'A', redirectTo: 'B' });\n   * registry.register({ name: 'B', redirectTo: 'C' });\n   * registry.register({ name: 'C', redirectTo: 'D' });\n   * registry.register({ name: 'D' });\n   *\n   * let transitionA = $state.go('A').transition\n   *\n   * $transitions.onSuccess({ to: 'D' }, (trans) => {\n   *   trans.to().name === 'D'; // true\n   *   trans.redirectedFrom().to().name === 'C'; // true\n   *   trans.originalTransition() === transitionA; // true\n   *   trans.originalTransition().to().name === 'A'; // true\n   * });\n   * ```\n   *\n   * @returns {Transition} The original Transition that started a redirect chain\n   */\n  originalTransition() {\n    const rf = this.redirectedFrom();\n\n    return (rf && rf.originalTransition()) || this;\n  }\n\n  /**\n   * Get the transition options\n   *\n   * @returns {import(\"./interface.ts\").TransitionOptions} the options for this Transition.\n   */\n  options() {\n    return this._options;\n  }\n\n  /**\n   * Gets the states being entered.\n   *\n   * @returns an array of states that will be entered during this transition.\n   */\n  entering() {\n    const states = /** @type {ng.StateObject[]} */ (\n      map(this._treeChanges.entering, (x) => x.state)\n    );\n\n    return states.map((x) => x.self);\n  }\n\n  /**\n   * Gets the states being exited.\n   *\n   * @returns {import(\"../state/interface.ts\").StateDeclaration[]} an array of states that will be exited during this transition.\n   */\n  exiting() {\n    const states = /** @type {ng.StateObject[]} */ (\n      map(this._treeChanges.exiting, (x) => x.state)\n    );\n\n    return states.map((x) => x.self).reverse();\n  }\n\n  /**\n   * Gets the states being retained.\n   *\n   * @returns {import(\"../state/interface.ts\").StateDeclaration[]} an array of states that are already entered from a previous Transition, that will not be\n   *    exited during this Transition\n   */\n  retained() {\n    const states = /** @type {ng.StateObject[]} */ (\n      map(this._treeChanges.retained, (x) => x.state)\n    );\n\n    return states.map((x) => x.self);\n  }\n\n  /**\n   * Get the [[ViewConfig]]s associated with this Transition\n   *\n   * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n   * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n   *\n   * @param pathname the name of the path to fetch views for:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @param {ng.StateObject} [state] If provided, only returns the `ViewConfig`s for a single state in the path\n   *\n   * @returns {import(\"../state/views.js\").ViewConfig[]} a list of ViewConfig objects for the given path.\n   */\n  views(pathname = \"entering\", state) {\n    let path = this._treeChanges[pathname];\n\n    path = !state\n      ? path\n      : /** @type {import('../path/path-node.js').PathNode[]} */ (path).filter(\n          propEq(\"state\", state),\n        );\n\n    return /** @type {import('../path/path-node.js').PathNode[]} */ (path)\n      .map((x) => x.views)\n      .reduce(unnestR, []);\n  }\n\n  /**\n   * Return the transition's tree changes\n   *\n   * A transition goes from one state/parameters to another state/parameters.\n   * During a transition, states are entered and/or exited.\n   *\n   * This function returns various branches (paths) which represent the changes to the\n   * active state tree that are caused by the transition.\n   *\n   * @param {string} [pathname] The name of the tree changes path to get:\n   *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n   * @returns {import('../path/path-node.js').PathNode[] | import(\"./interface.ts\").TreeChanges}\n   */\n  treeChanges(pathname) {\n    return pathname\n      ? /** @type {import('../path/path-node.js').PathNode[]} */ (\n          this._treeChanges[pathname]\n        )\n      : this._treeChanges;\n  }\n\n  /**\n   * Creates a new transition that is a redirection of the current one.\n   *\n   * This transition can be returned from a [[TransitionService]] hook to\n   * redirect a transition to a new state and/or set of parameters.\n   *\n   * @param {TargetState} targetState the new target state for the redirected transition\n   *\n   * @returns {Transition} Returns a new [[Transition]] instance.\n   */\n  redirect(targetState) {\n    let redirects = 1,\n      trans = /** @type {Transition} */ (this);\n\n    while (!isNullOrUndefined((trans = trans.redirectedFrom()))) {\n      if (++redirects > REDIRECT_MAX)\n        throw new Error(`Too many consecutive Transition redirects (20+)`);\n    }\n    const redirectOpts =\n      /** @type {import(\"./interface.ts\").TransitionOptions} */ ({\n        redirectedFrom: this,\n        source: \"redirect\",\n      });\n\n    // If the original transition was caused by URL sync, then use { location: 'replace' }\n    // on the new transition (unless the target state explicitly specifies location: false).\n    // This causes the original url to be replaced with the url for the redirect target\n    // so the original url disappears from the browser history.\n    if (\n      this.options().source === \"url\" &&\n      targetState.options().location !== false\n    ) {\n      redirectOpts.location = \"replace\";\n    }\n    const newOptions = Object.assign(\n      {},\n      this.options(),\n      targetState.options(),\n      redirectOpts,\n    );\n\n    targetState = targetState.withOptions(newOptions, true);\n    const newTransition = this._transitionService.create(\n      this._treeChanges.from,\n      targetState,\n    );\n\n    const originalEnteringNodes = this._treeChanges.entering;\n\n    const redirectEnteringNodes = newTransition._treeChanges.entering;\n\n    // --- Re-use resolve data from original transition ---\n    // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n    // (because of the redirect), the resolves fetched by the original transition are still valid in the\n    // redirected transition.\n    //\n    // This allows you to define a redirect on a parent state which depends on an async resolve value.\n    // You can wait for the resolve, then redirect to a child state based on the result.\n    // The redirected transition does not have to re-fetch the resolve.\n    // ---------------------------------------------------------\n    const nodeIsReloading =\n      (/** @type {ng.StateObject} */ reloadState) =>\n      (/** @type {PathNode} */ node) => {\n        return reloadState && node.state.includes[reloadState.name];\n      };\n\n    const params = /** @type {PathNode[]} */ (\n      PathUtils.matching(\n        redirectEnteringNodes,\n        originalEnteringNodes,\n        PathUtils.nonDynamicParams,\n      )\n    );\n\n    // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n    const matchingEnteringNodes = params.filter(\n      (x) =>\n        !nodeIsReloading(\n          /** @type {ng.StateObject} */ (targetState.options().reloadState),\n        )(x),\n    );\n\n    // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n    matchingEnteringNodes.forEach((node, idx) => {\n      node.resolvables = originalEnteringNodes[idx].resolvables;\n    });\n\n    return newTransition;\n  }\n\n  /** @internal If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n  _changedParams() {\n    const tc = this._treeChanges;\n\n    /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n    // If user explicitly wants a reload\n    if (this._options.reload) return undefined;\n\n    // If any states are exiting or entering\n    if (tc.exiting.length || tc.entering.length) return undefined;\n\n    // If to/from path lengths differ\n    if (tc.to.length !== tc.from.length) return undefined;\n    // If the to/from paths are different\n    const pathsDiffer = arrayTuples(tc.to, tc.from)\n      .map((tuple) => tuple[0].state !== tuple[1].state)\n      .reduce(anyTrueR, false);\n\n    if (pathsDiffer) return undefined;\n    // Find any parameter values that differ\n    const nodeSchemas = tc.to.map((node) => node.paramSchema);\n\n    const [toValues, fromValues] = [tc.to, tc.from].map((path) =>\n      path.map((x) => x.paramValues),\n    );\n\n    const tuples = arrayTuples(nodeSchemas, toValues, fromValues);\n\n    return tuples\n      .map(([schema, toVals, fromVals]) =>\n        Param.changed(schema, toVals, fromVals),\n      )\n      .reduce(unnestR, []);\n  }\n\n  /**\n   * Returns true if the transition is dynamic.\n   *\n   * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n   *\n   * @returns {boolean} true if the Transition is dynamic\n   */\n  dynamic() {\n    const changes = this._changedParams();\n\n    return !changes\n      ? false\n      : changes\n          .map((/** @type {Param} */ x) => x.dynamic)\n          .reduce(anyTrueR, false);\n  }\n\n  /**\n   * Returns true if the transition is ignored.\n   *\n   * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n   *\n   * @returns true if the Transition is ignored.\n   */\n  ignored() {\n    return !!this._ignoredReason();\n  }\n\n  _ignoredReason() {\n    const pending = this._globals.transition;\n\n    const { reloadState } = this._options;\n\n    const same = (\n      /** @type {PathNode[]} */ pathA,\n      /** @type {PathNode[]} */ pathB,\n    ) => {\n      if (pathA.length !== pathB.length) return false;\n      const matching = PathUtils.matching(pathA, pathB);\n\n      return (\n        pathA.length ===\n        /** @type {PathNode[]} */ (matching).filter(\n          (node) => !reloadState || !node.state.includes[reloadState.name],\n        ).length\n      );\n    };\n\n    const newTC = this._treeChanges;\n\n    const pendTC = pending && pending._treeChanges;\n\n    if (\n      pendTC &&\n      same(pendTC.to, newTC.to) &&\n      same(pendTC.exiting, newTC.exiting)\n    )\n      return \"SameAsPending\";\n\n    if (\n      newTC.exiting.length === 0 &&\n      newTC.entering.length === 0 &&\n      same(newTC.from, newTC.to)\n    )\n      return \"SameAsCurrent\";\n\n    return undefined;\n  }\n\n  /**\n   * Runs the transition\n   *\n   * This method is generally called from the [[StateService.transitionTo]]\n   *\n   * @internal\n   *\n   * @returns {Promise<any>} a promise for a successful transition.\n   */\n  run() {\n    // Gets transition hooks array for the given phase\n    const getHooksFor = (/** @type {TransitionHookPhase} */ phase) =>\n      this._hookBuilder.buildHooksForPhase(phase);\n\n    // When the chain is complete, then resolve or reject the deferred\n    const transitionSuccess = () => {\n      trace.traceSuccess(this.$to(), this);\n      this.success = true;\n      this._deferred.resolve(this.to());\n      const hooks = this._hookBuilder.buildHooksForPhase(\n        TransitionHookPhase._SUCCESS,\n      );\n\n      hooks.forEach((hook) => {\n        hook.invokeHook();\n      });\n    };\n\n    const transitionError = (/** @type {Rejection} */ reason) => {\n      trace.traceError(reason, this);\n      this.success = false;\n      this._deferred.reject(reason);\n      this._error = reason;\n      const hooks = getHooksFor(TransitionHookPhase._ERROR);\n\n      hooks.forEach((hook) => hook.invokeHook());\n    };\n\n    const runTransition = () => {\n      // Wait to build the RUN hook chain until the BEFORE hooks are done\n      // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n      const allRunHooks = getHooksFor(TransitionHookPhase._RUN);\n\n      const resolved = Promise.resolve();\n\n      return TransitionHook.invokeHooks(allRunHooks, () => resolved);\n    };\n\n    const startTransition = () => {\n      const { _globals } = this;\n\n      _globals._lastStartedTransitionId = this.$id;\n      _globals.transition = this;\n      _globals._transitionHistory.enqueue(this);\n      trace.traceTransitionStart(this);\n\n      return Promise.resolve();\n    };\n\n    const allBeforeHooks = getHooksFor(TransitionHookPhase._BEFORE);\n\n    TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n      .then(runTransition)\n      .then(transitionSuccess, transitionError);\n\n    return this.promise;\n  }\n\n  /**\n   * Checks if the Transition is valid\n   *\n   * @returns true if the Transition is valid\n   */\n  valid() {\n    return !this.error() || this.success !== undefined;\n  }\n\n  /**\n   * Aborts this transition\n   *\n   * Imperative API to abort a Transition.\n   * This only applies to Transitions that are not yet complete.\n   */\n  abort() {\n    // Do not set flag if the transition is already complete\n    if (isUndefined(this.success)) {\n      this._aborted = true;\n    }\n  }\n\n  /**\n   * The Transition error reason.\n   *\n   * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n   * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n   *\n   * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.\n   */\n  error() {\n    const state = this.$to();\n\n    if (state.self.abstract) {\n      return Rejection.invalid(\n        `Cannot transition to abstract state '${state.name}'`,\n      );\n    }\n    const paramDefs = state.parameters();\n\n    const values = this.params();\n\n    const invalidParams = paramDefs.filter(\n      (param) => !param.validates(values[param.id]),\n    );\n\n    if (invalidParams.length) {\n      const invalidValues = invalidParams\n        .map((param) => `[${param.id}:${stringify(values[param.id])}]`)\n        .join(\", \");\n\n      const detail = `The following parameter values are not valid for state '${state.name}': ${invalidValues}`;\n\n      return Rejection.invalid(detail);\n    }\n\n    if (this.success === false) return this._error;\n\n    return undefined;\n  }\n\n  /**\n   * A string representation of the Transition\n   *\n   * @returns A string representation of the Transition\n   */\n  toString() {\n    const fromStateOrName = this.from();\n\n    const toStateOrName = this.to();\n\n    const avoidEmptyHash = (\n      /** @type {import(\"../params/interface.ts\").RawParams} */ params,\n    ) =>\n      params[\"#\"] !== null && params[\"#\"] !== undefined\n        ? params\n        : omit(params, [\"#\"]);\n\n    // (X) means the to state is invalid.\n    const id = this.$id,\n      from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,\n      fromParams = stringify(\n        avoidEmptyHash(\n          this._treeChanges.from\n            .map((x) => x.paramValues)\n            .reduce((acc, obj) => ({ ...acc, ...obj }), {}),\n        ),\n      ),\n      toValid = this.valid() ? \"\" : \"(X) \",\n      to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,\n      toParams = stringify(avoidEmptyHash(this.params()));\n\n    return `Transition#${id}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;\n  }\n}\n\nTransition.diToken = Transition;\n","import { Transition } from \"../transition/transition.js\";\nimport { Resolvable } from \"../resolve/resolvable.js\";\nimport { uniqR, unnestR } from \"../../shared/common.js\";\n\n/**\n * @param {ng.TransitionService} transitionService\n */\nexport function registerAddCoreResolvables(transitionService) {\n  return transitionService.onCreate({}, function addCoreResolvables(trans) {\n    trans.addResolvable(Resolvable.fromData(Transition, trans), \"\");\n    trans.addResolvable(Resolvable.fromData(\"$transition$\", trans), \"\");\n    trans.addResolvable(\n      Resolvable.fromData(\"$stateParams\", trans.params()),\n      \"\",\n    );\n    trans.entering().forEach((/** @type {ng.StateDeclaration} */ state) => {\n      trans.addResolvable(Resolvable.fromData(\"$state$\", state), state);\n    });\n  });\n}\n\nconst TRANSITION_TOKENS = [\"$transition$\", Transition];\n\n// References to Transition in the treeChanges pathnodes makes all\n// previous Transitions reachable in memory, causing a memory leak\n// This function removes resolves for '$transition$' and `Transition` from the treeChanges.\n// Do not use this on current transitions, only on old ones.\n/**\n *\n * @param {ng.Transition} trans\n */\nexport function treeChangesCleanup(trans) {\n  const nodes = Object.values(trans.treeChanges())\n    .reduce(unnestR, [])\n    .reduce(uniqR, []);\n\n  // If the resolvable is a Transition, return a new resolvable with null data\n  const replaceTransitionWithNull = (/** @type {Resolvable} */ resolve) => {\n    return TRANSITION_TOKENS.includes(resolve.token)\n      ? Resolvable.fromData(resolve.token, null)\n      : resolve;\n  };\n\n  nodes.forEach((/** @type {{ resolvables: Resolvable[]; }} */ node) => {\n    node.resolvables = node.resolvables.map(replaceTransitionWithNull);\n  });\n}\n","/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n * @param {string} hookName\n * @return {import(\"../transition/interface\").TransitionStateHookFn}\n */\nfunction makeEnterExitRetainHook(hookName) {\n  return (transition, state) => {\n    const _state = /** @type Record<string, any> */ (\n      state._state && state._state()\n    );\n\n    const hookFn = _state[hookName];\n\n    return hookFn(transition, state);\n  };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[HookRegistry.onExit]]\n */\nconst onExitHook = makeEnterExitRetainHook(\"onExit\");\n\nexport const registerOnExitHook = (\n  /** @type {ng.TransitionService} */ transitionService,\n) =>\n  transitionService.onExit(\n    {\n      exiting: (state) =>\n        !!(/** @type {ng.BuiltStateDeclaration} */ (state).onExit),\n    },\n    onExitHook,\n  );\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[HookRegistry.onRetain]]\n */\nconst onRetainHook = makeEnterExitRetainHook(\"onRetain\");\n\nexport const registerOnRetainHook = (\n  /** @type {ng.TransitionService} */ transitionService,\n) =>\n  transitionService.onRetain(\n    {\n      retained: (state) =>\n        !!(/** @type {ng.BuiltStateDeclaration} */ (state).onRetain),\n    },\n    onRetainHook,\n  );\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[HookRegistry.onEnter]]\n */\nconst onEnterHook = makeEnterExitRetainHook(\"onEnter\");\n\nexport const registerOnEnterHook = (\n  /** @type {ng.TransitionService} */ transitionService,\n) =>\n  transitionService.onEnter(\n    {\n      entering: (state) =>\n        !!(/** @type {ng.BuiltStateDeclaration} */ (state).onEnter),\n    },\n    onEnterHook,\n  );\n","import { ResolveContext } from \"../resolve/resolve-context.js\";\nimport { val } from \"../../shared/hof.js\";\n\n/** @typedef  {import(\"../transition/interface.ts\").TreeChanges} TreeChanges */\n\nexport const RESOLVE_HOOK_PRIORITY = 1000;\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nconst eagerResolvePath = (/** @type {ng.Transition} */ trans) =>\n  new ResolveContext(/** @type {TreeChanges} */ (trans.treeChanges()).to)\n    .resolvePath(\"EAGER\", trans)\n    .then(() => {\n      /* empty */\n    });\n\nexport const registerEagerResolvePath = (\n  /** @type {ng.TransitionService} */ transitionService,\n) =>\n  transitionService.onStart({}, eagerResolvePath, {\n    priority: RESOLVE_HOOK_PRIORITY,\n  });\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nconst lazyResolveState = (\n  /** @type {ng.Transition} */ trans,\n  /** @type {ng.StateDeclaration} */ state,\n) =>\n  new ResolveContext(/** @type {TreeChanges} */ (trans.treeChanges()).to)\n    .subContext(/** @type {Function}*/ (state._state)())\n    .resolvePath(\"LAZY\", trans)\n    .then(() => {\n      /* empty */\n    });\n\nexport const registerLazyResolveState = (\n  /** @type {ng.TransitionService} */ transitionService,\n) =>\n  transitionService.onEnter({ entering: val(true) }, lazyResolveState, {\n    priority: RESOLVE_HOOK_PRIORITY,\n  });\n/**\n * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.\n *\n * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`\n *\n * After all entering states have been entered, this hook resolves any remaining Resolvables.\n * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].\n *\n * See [[StateDeclaration.resolve]]\n */\nconst resolveRemaining = (/** @type {ng.Transition} */ trans) =>\n  new ResolveContext(/** @type {TreeChanges} */ (trans.treeChanges()).to)\n    .resolvePath(\"LAZY\", trans)\n    .then(() => {\n      /* empty */\n    });\n\nexport const registerResolveRemaining = (\n  /** @type {ng.TransitionService} */ transitionService,\n) =>\n  transitionService.onFinish({}, resolveRemaining, {\n    priority: RESOLVE_HOOK_PRIORITY,\n  });\n","/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nconst loadEnteringViews = (/** @type {ng.Transition} */ transition) => {\n  const enteringViews = transition.views(\"entering\");\n\n  if (!enteringViews.length) return undefined;\n\n  return Promise.all(\n    enteringViews.map((view) => Promise.resolve(view.load())),\n  ).then(() => {\n    /* empty */\n  });\n};\n\nexport const registerLoadEnteringViews = (\n  /** @type {ng.TransitionService} */ transitionService,\n) => transitionService.onFinish({}, loadEnteringViews);\n\nexport const registerActivateViews = (\n  /** @type {ng.TransitionService} */ transitionService,\n  /** @type {ng.ViewService} */ viewService,\n) => {\n  /**\n   * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n   *\n   * Registered using `transitionService.onSuccess({}, activateViews);`\n   *\n   * After a transition is complete, this hook deactivates the old views from the previous state,\n   * and activates the new views from the destination state.\n   *\n   * See [[ViewService]]\n   */\n  const activateViews = (/** @type {ng.Transition} */ transition) => {\n    const enteringViews = transition.views(\"entering\");\n\n    const exitingViews = transition.views(\"exiting\");\n\n    if (!enteringViews.length && !exitingViews.length) return;\n    exitingViews.forEach((vc) => viewService.deactivateViewConfig(vc));\n    enteringViews.forEach((vc) => {\n      viewService.activateViewConfig(vc);\n    });\n    viewService.sync();\n  };\n\n  return transitionService.onSuccess({}, activateViews);\n};\n","import { isArray } from \"../../shared/utils.js\";\n\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n * @param {ng.TransitionService} transitionService\n * @param {ng.StateService} [stateService]\n * @param {ng.UrlService} [urlService]\n * @param {ng.StateRegistryService | undefined} [stateRegistry]\n */\nexport function registerLazyLoadHook(\n  transitionService,\n  stateService,\n  urlService,\n  stateRegistry,\n) {\n  return transitionService.onBefore(\n    {\n      entering: (state) => {\n        return !!(/** @type {ng.BuiltStateDeclaration} */ (state).lazyLoad);\n      },\n    },\n    /** @param {ng.Transition} transition */ (transition) => {\n      function retryTransition() {\n        if (transition.originalTransition().options().source !== \"url\") {\n          // The original transition was not triggered via url sync\n          // The lazy state should be loaded now, so re-try the original transition\n\n          const orig = transition.targetState();\n          // TODO invesigate why this is present if its not passed in transition service\n\n          return /** @type {ng.StateService} */ (stateService).target(\n            orig.identifier(),\n            orig.params(),\n            orig.options(),\n          );\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        const result = urlService?.match(urlService.parts());\n\n        const rule = result && result.rule;\n\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === \"STATE\") {\n          const { state } = rule;\n\n          const params = result.match;\n\n          return stateService?.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        urlService?.sync();\n\n        return undefined;\n      }\n      const promises = transition\n        .entering()\n        .filter(\n          (/** @type {ng.StateDeclaration} */ state) =>\n            state._state && !!state._state().lazyLoad,\n        )\n        .map(\n          (\n            /** @type {import(\"../state/interface.ts\").StateDeclaration} */ state,\n          ) => lazyLoadState(transition, state, stateRegistry),\n        );\n\n      return Promise.all(promises).then(retryTransition);\n    },\n  );\n}\n\nconst lazyLoadPromiseCache = new WeakMap(); // WeakMap<Function, Promise<any>>\n\n/**\n * Invokes a state's lazy load function\n * @param {ng.Transition} transition a Transition context\n * @param {import(\"../state/interface.ts\").StateDeclaration} state the state to lazy load\n * @param {ng.StateRegistryService | undefined} [stateRegistry]\n * @return {Promise<import(\"../state/interface.ts\").LazyLoadResult | undefined>} a promise for the lazy load result\n */\nexport function lazyLoadState(transition, state, stateRegistry) {\n  const lazyLoadFn = /** @type {import(\"../state/interface.ts\").LazyLoadFn} */ (\n    state._state && state._state().lazyLoad\n  );\n\n  let promise = lazyLoadPromiseCache.get(lazyLoadFn);\n\n  if (!promise) {\n    const success = (/** @type {any} */ result) => {\n      delete state.lazyLoad;\n      state._state && delete state._state().lazyLoad;\n      lazyLoadPromiseCache.delete(lazyLoadFn);\n\n      return result;\n    };\n\n    const error = (/** @type {any} */ err) => {\n      lazyLoadPromiseCache.delete(lazyLoadFn);\n\n      return Promise.reject(err);\n    };\n\n    promise = Promise.resolve(lazyLoadFn(transition, state))\n      .then(updateStateRegistry)\n      .then(success, error);\n\n    lazyLoadPromiseCache.set(lazyLoadFn, promise);\n  }\n\n  /**\n   * @param {import(\"../state/interface.ts\").LazyLoadResult} result\n   */\n  function updateStateRegistry(result) {\n    if (result && isArray(result.states)) {\n      result.states.forEach(\n        (_state) => stateRegistry && stateRegistry.register(_state),\n      );\n    }\n\n    return result;\n  }\n\n  return promise;\n}\n","import { TransitionHook } from \"./transition-hook.js\";\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n */\nexport class TransitionEventType {\n  /**\n   * @param {string} name\n   * @param {number} hookPhase\n   * @param {number} hookOrder\n   * @param {any} criteriaMatchPath\n   */\n  constructor(\n    name,\n    hookPhase,\n    hookOrder,\n    criteriaMatchPath,\n    reverseSort = false,\n    getResultHandler = TransitionHook.HANDLE_RESULT,\n    getErrorHandler = TransitionHook.REJECT_ERROR,\n    synchronous = false,\n  ) {\n    this.name = name;\n    this.hookPhase = hookPhase;\n    this.hookOrder = hookOrder;\n    this.criteriaMatchPath = criteriaMatchPath;\n    this.reverseSort = reverseSort;\n    this.getResultHandler = getResultHandler;\n    this.getErrorHandler = getErrorHandler;\n    this.synchronous = synchronous;\n  }\n}\n","import { trace } from \"../common/trace.js\";\nimport { Rejection } from \"../transition/reject-factory.js\";\n/**\n * A [[TransitionHookFn]] that skips a transition if it should be ignored\n *\n * This hook is invoked at the end of the onBefore phase.\n *\n * If the transition should be ignored (because no parameter or states changed)\n * then the transition is ignored and not processed.\n * @param {ng.Transition} trans\n */\nfunction ignoredHook(trans) {\n  const ignoredReason = trans._ignoredReason();\n\n  if (!ignoredReason) return undefined;\n  trace.traceTransitionIgnored(trans);\n  const pending = trans._globals.transition;\n\n  // The user clicked a link going back to the *current state* ('A')\n  // However, there is also a pending transition in flight (to 'B')\n  // Abort the transition to 'B' because the user now wants to be back at 'A'.\n  if (ignoredReason === \"SameAsCurrent\" && pending) {\n    pending.abort();\n  }\n\n  return Rejection.ignored().toPromise();\n}\nexport const registerIgnoredTransitionHook = (\n  /** @type {ng.TransitionService} */ transitionService,\n) => transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n","/**\n * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n *\n * This hook is invoked at the end of the onBefore phase.\n * If the transition is invalid (for example, param values do not validate)\n * then the transition is rejected.\n * @param {ng.Transition} trans\n */\nfunction invalidTransitionHook(trans) {\n  if (!trans.valid()) {\n    throw new Error(trans.error()?.toString());\n  }\n}\nexport const registerInvalidTransitionHook = (\n  /** @type {ng.TransitionService} */ transitionService,\n) =>\n  transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n","import { Transition } from \"./transition.js\";\nimport { makeEvent, registerHook } from \"./hook-registry.js\";\nimport {\n  registerAddCoreResolvables,\n  treeChangesCleanup,\n} from \"../hooks/core-resolvables.js\";\nimport {\n  registerOnEnterHook,\n  registerOnExitHook,\n  registerOnRetainHook,\n} from \"../hooks/on-enter-exit-retain.js\";\nimport {\n  registerEagerResolvePath,\n  registerLazyResolveState,\n  registerResolveRemaining,\n} from \"../hooks/resolve.js\";\nimport {\n  registerActivateViews,\n  registerLoadEnteringViews,\n} from \"../hooks/views.js\";\nimport { registerLazyLoadHook } from \"../hooks/lazy-load.js\";\nimport { TransitionEventType } from \"./transition-event-type.js\";\nimport {\n  TransitionHook,\n  TransitionHookPhase,\n  TransitionHookScope,\n} from \"./transition-hook.js\";\nimport { isDefined } from \"../../shared/utils.js\";\nimport { registerIgnoredTransitionHook } from \"../hooks/ignored-transition.js\";\nimport { registerInvalidTransitionHook } from \"../hooks/invalid-transition.js\";\nimport { registerRedirectToHook } from \"../hooks/redirect-to.js\";\nimport { $injectTokens as $t, provider } from \"../../injection-tokens.js\";\nimport { copy } from \"../../shared/common.js\";\n/** @typedef {import(\"./interface.ts\").DeregisterFn} DeregisterFn */\n/** @typedef {import(\"./interface.ts\").HookFn} HookFn */\n/** @typedef {import(\"./interface.ts\").HookMatchCriteria} HookMatchCriteria */\n/** @typedef {import(\"./interface.ts\").HookRegOptions} HookRegOptions */\n/** @typedef {import(\"./interface.ts\").PathTypes} PathTypes */\n/** @typedef {import(\"./interface.ts\").RegisteredHooks} RegisteredHooks */\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n * @type {import(\"./interface.ts\").TransitionOptions}\n */\nexport const defaultTransOpts = {\n  location: true,\n  relative: undefined,\n  inherit: false,\n  notify: true,\n  reload: false,\n  supercede: true,\n  custom: {},\n  current: () => null,\n  source: \"unknown\",\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n *\n * This API is located at `router.transitionService` ([[UIRouter.transitionService]])\n */\nexport class TransitionProvider {\n  /* @ignore */ static $inject = provider([\n    $t._router,\n    $t._view,\n    $t._exceptionHandler,\n  ]);\n\n  /**\n   * @param {ng.RouterService} globals\n   * @param {ng.ViewService} viewService\n   * @param {ng.ExceptionHandlerProvider} $exceptionHandler\n   */\n  constructor(globals, viewService, $exceptionHandler) {\n    this._transitionCount = 0;\n    /**\n     * The transition hook types, such as `onEnter`, `onStart`, etc\n     * @type {TransitionEventType[]}\n     */\n    this._eventTypes = [];\n    /** @internal The registered transition hooks */\n    /** @type {RegisteredHooks} */\n    this._registeredHooks = {};\n    /** The  paths on a criteria object */\n    /** @type {PathTypes} */\n    this._criteriaPaths = /** @type {PathTypes} */ ({});\n    this.globals = globals;\n    this.$view = viewService;\n    /** @type {Record<string, DeregisterFn | undefined>} */\n    this._deregisterHookFns = {};\n    this._defineCorePaths();\n    this._defineCoreEvents();\n    this._registerCoreTransitionHooks();\n\n    /** @type {ng.ExceptionHandlerService} */\n    this._exceptionHandler = $exceptionHandler.handler;\n    globals._successfulTransitions.onEvict(treeChangesCleanup);\n  }\n\n  $get = [\n    $t._state,\n    $t._url,\n    $t._stateRegistry,\n    $t._view,\n    /**\n     * @param {ng.StateService} stateService\n     * @param {ng.UrlService} urlService\n     * @param {ng.StateRegistryService} stateRegistry\n     * @param {ng.ViewService} viewService\n     * @returns {TransitionProvider}\n     */\n    (stateService, urlService, stateRegistry, viewService) => {\n      // Lazy load state trees\n      this._deregisterHookFns.lazyLoad = registerLazyLoadHook(\n        this,\n        stateService,\n        urlService,\n        stateRegistry,\n      );\n\n      // After globals.current is updated at priority: 10000\n      this._deregisterHookFns.updateUrl = registerUpdateUrl(\n        this,\n        stateService,\n        urlService,\n      );\n\n      // Wire up redirectTo hook\n      this._deregisterHookFns.redirectTo = registerRedirectToHook(\n        this,\n        stateService,\n      );\n\n      this._deregisterHookFns.activateViews = registerActivateViews(\n        this,\n        viewService,\n      );\n\n      return this;\n    },\n  ];\n  /**\n   * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n   *\n   * Registers a transition lifecycle hook, which is invoked during transition construction.\n   *\n   * This low level hook should only be used by plugins.\n   * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n   * The Sticky States plugin uses this hook to modify the treechanges.\n   *\n   * ### Lifecycle\n   *\n   * `onCreate` hooks are invoked *while a transition is being constructed*.\n   *\n   * ### Return value\n   *\n   * The hook's return value is ignored\n   *\n   * @internal\n   * @param criteria defines which Transitions the Hook should be invoked for.\n   * @param callback the hook function which will be invoked.\n   * @param options the registration options\n   * @returns a function which deregisters the hook.\n   */\n\n  /**\n   * Creates a new [[Transition]] object\n   *\n   * This is a factory function for creating new Transition objects.\n   * It is used internally by the [[StateService]] and should generally not be called by application code.\n   *\n   * @internal\n   * @param fromPath the path to the current state (the from state)\n   * @param targetState the target state (destination)\n   * @returns a Transition\n   */\n  /**\n   * @param {import(\"../path/path-node.js\").PathNode[]} fromPath\n   * @param {import(\"../state/target-state.js\").TargetState} targetState\n   */\n  create(fromPath, targetState) {\n    return new Transition(fromPath, targetState, this, this.globals);\n  }\n\n  _defineCoreEvents() {\n    const TH = TransitionHook;\n\n    const paths = this._criteriaPaths;\n\n    const NORMAL_SORT = false,\n      REVERSE_SORT = true;\n\n    const SYNCHRONOUS = true;\n\n    this._defineEvent(\n      \"onCreate\",\n      TransitionHookPhase._CREATE,\n      0,\n      paths.to,\n      NORMAL_SORT,\n      TH.LOG_REJECTED_RESULT,\n      TH.THROW_ERROR,\n      SYNCHRONOUS,\n    );\n    this._defineEvent(\"onBefore\", TransitionHookPhase._BEFORE, 0, paths.to);\n    this._defineEvent(\"onStart\", TransitionHookPhase._RUN, 0, paths.to);\n    this._defineEvent(\n      \"onExit\",\n      TransitionHookPhase._RUN,\n      100,\n      paths.exiting,\n      REVERSE_SORT,\n    );\n    this._defineEvent(\n      \"onRetain\",\n      TransitionHookPhase._RUN,\n      200,\n      paths.retained,\n    );\n    this._defineEvent(\"onEnter\", TransitionHookPhase._RUN, 300, paths.entering);\n    this._defineEvent(\"onFinish\", TransitionHookPhase._RUN, 400, paths.to);\n    this._defineEvent(\n      \"onSuccess\",\n      TransitionHookPhase._SUCCESS,\n      0,\n      paths.to,\n      NORMAL_SORT,\n      TH.LOG_REJECTED_RESULT,\n      TH.LOG_ERROR,\n      SYNCHRONOUS,\n    );\n    this._defineEvent(\n      \"onError\",\n      TransitionHookPhase._ERROR,\n      0,\n      paths.to,\n      NORMAL_SORT,\n      TH.LOG_REJECTED_RESULT,\n      TH.LOG_ERROR,\n      SYNCHRONOUS,\n    );\n  }\n\n  _defineCorePaths() {\n    const { _STATE: STATE, _TRANSITION: TRANSITION } = TransitionHookScope;\n\n    this._definePathType(\"to\", TRANSITION);\n    this._definePathType(\"from\", TRANSITION);\n    this._definePathType(\"exiting\", STATE);\n    this._definePathType(\"retained\", STATE);\n    this._definePathType(\"entering\", STATE);\n  }\n\n  /**\n   * @param {string} name\n   * @param {number} hookPhase\n   * @param {number} hookOrder\n   * @param {any} criteriaMatchPath\n   */\n  _defineEvent(\n    name,\n    hookPhase,\n    hookOrder,\n    criteriaMatchPath,\n    reverseSort = false,\n    getResultHandler = TransitionHook.HANDLE_RESULT,\n    getErrorHandler = TransitionHook.REJECT_ERROR,\n    synchronous = false,\n  ) {\n    const eventType = new TransitionEventType(\n      name,\n      hookPhase,\n      hookOrder,\n      criteriaMatchPath,\n      reverseSort,\n      getResultHandler,\n      getErrorHandler,\n      synchronous,\n    );\n\n    this._eventTypes.push(eventType);\n    makeEvent(this, this, eventType);\n  }\n\n  /**\n   * @param {TransitionHookPhase} [phase]\n   * @return {any[]}\n   */\n  _getEvents(phase) {\n    const transitionHookTypes = isDefined(phase)\n      ? this._eventTypes.filter((type) => type.hookPhase === phase)\n      : this._eventTypes.slice();\n\n    return transitionHookTypes.sort((left, right) => {\n      const cmpByPhase = left.hookPhase - right.hookPhase;\n\n      return cmpByPhase === 0 ? left.hookOrder - right.hookOrder : cmpByPhase;\n    });\n  }\n\n  /**\n   * Adds a Path to be used as a criterion against a TreeChanges path\n   *\n   * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n   * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n   * Each state in the exiting path is checked against the criteria and returned as part of the match.\n   *\n   * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n   * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n   * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n   * @internal\n   * @param {string} name\n   * @param {number} hookScope\n   */\n  _definePathType(name, hookScope) {\n    this._criteriaPaths[name] = { name, scope: hookScope };\n  }\n\n  _getPathTypes() {\n    return this._criteriaPaths;\n  }\n\n  /**\n   * @param {string} hookName\n   * @returns {import(\"./hook-registry.js\").RegisteredHook[]}\n   */\n  getHooks(hookName) {\n    return this._registeredHooks[hookName] || [];\n  }\n\n  /**\n   * Registers a hook by event name.\n   * @param {string} eventName\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  on(eventName, matchCriteria, callback, options) {\n    const eventType = this._getEventType(eventName);\n\n    return registerHook(\n      this,\n      this,\n      eventType,\n      matchCriteria,\n      callback,\n      options,\n    );\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onCreate(matchCriteria, callback, options) {\n    return this.on(\"onCreate\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onBefore(matchCriteria, callback, options) {\n    return this.on(\"onBefore\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onStart(matchCriteria, callback, options) {\n    return this.on(\"onStart\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onEnter(matchCriteria, callback, options) {\n    return this.on(\"onEnter\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onRetain(matchCriteria, callback, options) {\n    return this.on(\"onRetain\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onExit(matchCriteria, callback, options) {\n    return this.on(\"onExit\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onFinish(matchCriteria, callback, options) {\n    return this.on(\"onFinish\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onSuccess(matchCriteria, callback, options) {\n    return this.on(\"onSuccess\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {HookMatchCriteria} matchCriteria\n   * @param {HookFn} callback\n   * @param {HookRegOptions} [options]\n   * @returns {DeregisterFn}\n   */\n  onError(matchCriteria, callback, options) {\n    return this.on(\"onError\", matchCriteria, callback, options);\n  }\n\n  /**\n   * @param {string} eventName\n   * @returns {TransitionEventType}\n   */\n  _getEventType(eventName) {\n    const eventType = this._eventTypes.find((type) => type.name === eventName);\n\n    if (!eventType) {\n      throw new Error(`Unknown Transition hook event: ${eventName}`);\n    }\n\n    return eventType;\n  }\n\n  _registerCoreTransitionHooks() {\n    const fns = this._deregisterHookFns;\n\n    fns.addCoreResolves = registerAddCoreResolvables(this);\n    fns.ignored = registerIgnoredTransitionHook(this);\n    fns.invalid = registerInvalidTransitionHook(this);\n\n    // Wire up onExit/Retain/Enter state hooks\n    fns.onExit = registerOnExitHook(this);\n    fns.onRetain = registerOnRetainHook(this);\n    fns.onEnter = registerOnEnterHook(this);\n    // Wire up Resolve hooks\n    fns.eagerResolve = registerEagerResolvePath(this);\n    fns.lazyResolve = registerLazyResolveState(this);\n    fns.resolveAll = registerResolveRemaining(this);\n    // Wire up the View management hooks\n    fns.loadViews = registerLoadEnteringViews(this);\n\n    // Updates global state after a transition\n    fns.updateGlobals = registerUpdateGlobalState(this);\n    // Lazy load state trees\n    fns.lazyLoad = registerLazyLoadHook(this);\n  }\n}\n\n/**\n * @param {ng.TransitionService} transitionService\n * @param {ng.StateService} stateService\n * @param {ng.UrlService} urlService\n */\nfunction registerUpdateUrl(transitionService, stateService, urlService) {\n  /**\n   * A [[TransitionHookFn]] which updates the URL after a successful transition\n   *\n   * Registered using `transitionService.onSuccess({}, updateUrl);`\n   */\n  const updateUrl = (/** @type {ng.Transition}} */ transition) => {\n    const options = transition.options();\n\n    const $state = stateService;\n\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (\n      options.source !== \"url\" &&\n      options.location &&\n      $state.$current?.navigable\n    ) {\n      const urlOptions = /** @type {any} */ ({\n        replace: options.location === \"replace\",\n      });\n\n      urlService.push(\n        $state.$current.navigable.url,\n        $state.globals.params,\n        urlOptions,\n      );\n    }\n    urlService.update(true);\n  };\n\n  return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n}\n\n/**\n * Registers a hook that keeps global router state in sync with transitions.\n *\n * - Sets the current transition before it runs\n * - Updates current state and params on success\n * - Clears the current transition when finished\n * @param {ng.TransitionService} transitionService\n */\nfunction registerUpdateGlobalState(transitionService) {\n  return transitionService.onCreate({}, (trans) => {\n    const globals = trans._globals;\n\n    const transitionSuccessful = () => {\n      globals._successfulTransitions.enqueue(trans);\n      globals.$current = trans.$to();\n      globals.current = globals.$current.self;\n      copy(trans.params(), globals.params);\n    };\n\n    const clearCurrentTransition = () => {\n      // Only clear if this transition is still the active one\n      if (globals.transition === trans) {\n        globals.transition = undefined;\n      }\n    };\n\n    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n  });\n}\n","import { isFunction, isString } from \"../../shared/utils.js\";\nimport { TargetState } from \"../state/target-state\";\n\nexport const registerRedirectToHook = (\n  /** @type {ng.TransitionService} */ transitionService,\n  /** @type {ng.StateService} */ stateService,\n) => {\n  /**\n   * A [[TransitionHookFn]] that redirects to a different state or params\n   *\n   * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n   *\n   * See [[StateDeclaration.redirectTo]]\n   */\n  const redirectToHook = (/** @type {ng.Transition} */ trans) => {\n    const redirect = trans.to().redirectTo;\n\n    if (!redirect) return undefined;\n    const $state = stateService;\n\n    /**\n     * @param {any} result\n     */\n    function handleResult(result) {\n      if (!result) return undefined;\n\n      if (result instanceof TargetState) {\n        return result;\n      }\n\n      if (isString(result)) {\n        return $state.target(result, trans.params(), trans.options());\n      }\n\n      if (/** @type {any} */ (result).state || result.params) {\n        return $state.target(\n          /** @type {any} */ (result).state || trans.to(),\n          result.params || trans.params(),\n          trans.options(),\n        );\n      }\n\n      return undefined;\n    }\n\n    if (isFunction(redirect)) {\n      return Promise.resolve(redirect(trans)).then(handleResult);\n    }\n\n    return handleResult(redirect);\n  };\n\n  return transitionService.onStart(\n    {\n      to: (state) =>\n        !!(/** @type {ng.BuiltStateDeclaration} */ (state).redirectTo),\n    },\n    redirectToHook,\n  );\n};\n","import { defaults, removeFrom } from \"../../shared/common.js\";\nimport { isDefined, isObject, isString, minErr } from \"../../shared/utils.js\";\nimport { Queue } from \"../../shared/queue.js\";\nimport { makeTargetState } from \"../path/path-utils.js\";\nimport { PathNode } from \"../path/path-node.js\";\nimport { defaultTransOpts } from \"../transition/transition-service.js\";\nimport { RejectType, Rejection } from \"../transition/reject-factory.js\";\nimport { TargetState } from \"./target-state.js\";\nimport { Param } from \"../params/param.js\";\nimport { Glob } from \"../glob/glob.js\";\nimport { lazyLoadState } from \"../hooks/lazy-load.js\";\nimport { $injectTokens, provider } from \"../../injection-tokens.js\";\n\n/** @typedef {import(\"./state-registry.js\").StateRegistryProvider} StateRegistryProvider */\n/** @typedef {import(\"./interface.ts\").StateDeclaration} StateDeclaration */\n/** @typedef {import(\"./state-object.js\").StateObject} StateObject */\n/** @typedef {import(\"./state-matcher.js\").StateOrName} StateOrName */\n/** @typedef {import(\"../transition/transition.js\").Transition} Transition */\n/** @typedef {import(\"./interface.ts\").TransitionPromise} TransitionPromise */\n/** @typedef {import(\"../transition/interface.ts\").TransitionOptions} TransitionOptions */\n/** @typedef {import(\"../params/interface.ts\").RawParams} RawParams */\n/** @typedef {import(\"./interface.ts\").OnInvalidCallback} OnInvalidCallback */\n/** @typedef {import(\"../transition/transition-hook.js\").HookResult} HookResult */\n\nconst stdErr = minErr(\"$stateProvider\");\n\n/**\n * Attaches a catch handler to silence unhandled rejection warnings,\n * while preserving the original promise.\n *\n * @template T\n * @param {Promise<T>} promise\n * @returns {Promise<T>}\n */\nconst silenceUncaughtInPromise = (promise) => {\n  promise.catch(() => undefined);\n\n  return promise;\n};\n\n/**\n * Creates a rejected promise whose rejection is intentionally silenced.\n *\n * @template [E=unknown]\n * @param {E} error\n * @returns {Promise<never>}\n */\nexport const silentRejection = (error) =>\n  silenceUncaughtInPromise(Promise.reject(error));\n\n/**\n * Provides services related to ng-router states.\n *\n * This API is located at `router.stateService` ([[UIRouter.stateService]])\n */\nexport class StateProvider {\n  /**\n   * The latest successful state parameters\n   *\n   * @deprecated This is a passthrough through to [[Router.params]]\n   */\n  get params() {\n    return this.globals.params;\n  }\n\n  /**\n   * The current [[StateDeclaration]]\n   */\n  get current() {\n    return this.globals.current;\n  }\n\n  /**\n   * The current [[StateObject]] (an internal API)\n   */\n  get $current() {\n    return this.globals.$current;\n  }\n\n  /* @ignore */ static $inject = provider([\n    $injectTokens._router,\n    $injectTokens._transitions,\n    $injectTokens._exceptionHandler,\n  ]);\n\n  /**\n   *\n   * @param {ng.RouterProvider} globals\n   * @param {ng.TransitionProvider} transitionService\n   * @param {ng.ExceptionHandlerProvider} exceptionHandlerProvider\n   */\n  constructor(globals, transitionService, exceptionHandlerProvider) {\n    /**\n     * @type {ng.RouterProvider}\n     */\n    this.globals = globals;\n    /**\n     * @type {ng.TransitionProvider}\n     */\n    this.transitionService = transitionService;\n\n    /**\n     * @type {StateRegistryProvider | undefined}\n     */\n    this.stateRegistry = undefined;\n\n    /** @type {ng.UrlService | undefined } */\n    this.urlService = undefined;\n    /** @type {ng.InjectorService | undefined } */\n    this.$injector = undefined;\n\n    /**\n     * @type {import(\"./interface.ts\").OnInvalidCallback[]}\n     */\n    this.invalidCallbacks = [];\n\n    /** @type {ng.ExceptionHandlerService} */\n    this._defaultErrorHandler = exceptionHandlerProvider.handler;\n  }\n\n  $get = [\n    $injectTokens._injector,\n    $injectTokens._url,\n    /**\n     * @param {ng.InjectorService} $injector\n     * @param {ng.UrlService} $url\n     * @returns {StateProvider}\n     */\n    ($injector, $url) => {\n      this.urlService = $url;\n      this.$injector = $injector;\n\n      return this;\n    },\n  ];\n\n  /**\n   * Decorates states when they are registered\n   *\n   * Allows you to extend (carefully) or override (at your own peril) the\n   * `stateBuilder` object used internally by [[StateRegistry]].\n   * This can be used to add custom functionality to ng-router,\n   * for example inferring templateUrl based on the state name.\n   *\n   * When passing only a name, it returns the current (original or decorated) builder\n   * function that matches `name`.\n   *\n   * The builder functions that can be decorated are listed below. Though not all\n   * necessarily have a good use case for decoration, that is up to you to decide.\n   *\n   * In addition, users can attach custom decorators, which will generate new\n   * properties within the state's internal definition. There is currently no clear\n   * use-case for this beyond accessing internal states (i.e. $state.$current),\n   * however, expect this to become increasingly relevant as we introduce additional\n   * meta-programming features.\n   *\n   * **Warning**: Decorators should not be interdependent because the order of\n   * execution of the builder functions in non-deterministic. Builder functions\n   * should only be dependent on the state definition object and super function.\n   *\n   *\n   * Existing builder functions and current return values:\n   *\n   * - **parent** `{object}` - returns the parent state object.\n   * - **data** `{object}` - returns state data, including any inherited data that is not\n   *   overridden by own values (if any).\n   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n   *   or `null`.\n   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n   *   navigable).\n   * - **params** `{object}` - returns an array of state params that are ensured to\n   *   be a super-set of parent's params.\n   * - **views** `{object}` - returns a views object where each key is an absolute view\n   *   name (i.e. \"viewName@stateName\") and each value is the urlConfig object\n   *   (template, controller) for the view. Even when you don't use the views object\n   *   explicitly on a state urlConfig, one is still created for you internally.\n   *   So by decorating this builder function you have access to decorating template\n   *   and controller properties.\n   * - **ownParams** `{object}` - returns an array of params that belong to the state,\n   *   not including any params defined by ancestor states.\n   * - **path** `{string}` - returns the full path from the root down to this state.\n   *   Needed for state activation.\n   * - **includes** `{object}` - returns an object that includes every state that\n   *   would pass a `$state.includes()` test.\n   *\n   * #### Example:\n   * Override the internal 'views' builder with a function that takes the state\n   * definition, and a reference to the internal function being overridden:\n   * ```js\n   * $stateProvider.decorator('views', function (state, parent) {\n   *   let result = {},\n   *       views = parent(state);\n   *\n   *   angular.forEach(views, function (urlConfig, name) {\n   *     let autoName = (state.name + '.' + name).replace('.', '/');\n   *     urlConfig.templateUrl = urlConfig.templateUrl || '/partials/' + autoName + '.html';\n   *     result[name] = urlConfig;\n   *   });\n   *   return result;\n   * });\n   *\n   * $stateProvider.state('home', {\n   *   views: {\n   *     'contact.list': { controller: 'ListController' },\n   *     'contact.item': { controller: 'ItemController' }\n   *   }\n   * });\n   * ```\n   *\n   *\n   * ```js\n   * // Auto-populates list and item views with /partials/home/contact/list.html,\n   * // and /partials/home/contact/item.html, respectively.\n   * $state.go('home');\n   * ```\n   *\n   * @param {string} name The name of the builder function to decorate.\n   * @param {import(\"./interface.ts\").BuilderFunction} func A function that is responsible for decorating the original\n   * builder function. The function receives two parameters:\n   *\n   *   - `{object}` - state - The state urlConfig object.\n   *   - `{object}` - super - The original builder function.\n   *\n   * @return {object} $stateProvider - $stateProvider instance\n   */\n  decorator(name, func) {\n    return (\n      /** @type {StateRegistryProvider} */ (this.stateRegistry).decorator(\n        name,\n        func,\n      ) || this\n    );\n  }\n\n  /**\n   *\n   * @param {import(\"./interface.ts\").StateDeclaration} definition\n   */\n  state(definition) {\n    if (!definition.name) {\n      throw stdErr(\"stateinvalid\", `'name' required`);\n    }\n\n    try {\n      /** @type {StateRegistryProvider} */ (this.stateRegistry).register(\n        definition,\n      );\n    } catch (err) {\n      throw stdErr(\"stateinvalid\", /** @type {Error} */ (err).message);\n    }\n\n    return this;\n  }\n\n  /**\n   * Handler for when [[transitionTo]] is called with an invalid state.\n   *\n   * Invokes the [[onInvalid]] callbacks, in natural order.\n   * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n   * The results of the callbacks are wrapped in Promise.resolve(), so the callbacks may return promises.\n   *\n   * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n   * @internal\n   * @param {PathNode[]} fromPath\n   * @param {TargetState} toState\n   */\n  _handleInvalidTargetState(fromPath, toState) {\n    const fromState = makeTargetState(\n      /** @type {StateRegistryProvider} */ (this.stateRegistry),\n      fromPath,\n    );\n\n    const { globals } = this;\n\n    const latestThing = () => globals._transitionHistory.peekTail();\n\n    const latest = latestThing();\n\n    /** @type {Queue<import(\"./interface.ts\").OnInvalidCallback>} */\n    const callbackQueue = new Queue(this.invalidCallbacks.slice());\n\n    const injector = this.$injector;\n\n    const checkForRedirect = (/** @type {HookResult} */ result) => {\n      if (!(result instanceof TargetState)) {\n        return undefined;\n      }\n      let target = result;\n\n      // Recreate the TargetState, in case the state is now defined.\n      target = this.target(\n        target.identifier(),\n        target.params(),\n        target.options(),\n      );\n\n      if (!target.valid()) {\n        return Rejection.invalid(target.error()).toPromise();\n      }\n\n      if (latestThing() !== latest) {\n        return Rejection.superseded().toPromise();\n      }\n\n      return this.transitionTo(\n        target.identifier(),\n        target.params(),\n        target.options(),\n      );\n    };\n\n    /**\n     * @returns {Promise<any>}\n     */\n    function invokeNextCallback() {\n      const nextCallback = callbackQueue.dequeue();\n\n      if (nextCallback === undefined)\n        return Rejection.invalid(toState.error()).toPromise();\n      const callbackResult = Promise.resolve(\n        nextCallback(toState, fromState, injector),\n      );\n\n      return callbackResult\n        .then(checkForRedirect)\n        .then((result) => result || invokeNextCallback());\n    }\n\n    return invokeNextCallback();\n  }\n\n  /**\n   * Registers an Invalid State handler\n   *\n   * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n   * has been called with an invalid state reference parameter\n   *\n   * Example:\n   * ```js\n   * stateService.onInvalid(function(to, from, injector) {\n   *   if (to.name() === 'foo') {\n   *     let lazyLoader = injector.get('LazyLoadService');\n   *     return lazyLoader.load('foo')\n   *         .then(() => stateService.target('foo'));\n   *   }\n   * });\n   * ```\n   *\n   * @param {import(\"./interface.ts\").OnInvalidCallback} callback invoked when the toState is invalid\n   *   This function receives the (invalid) toState, the fromState, and an injector.\n   *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n   *   If one is returned, it is treated as a redirect.\n   *\n   * @returns a function which deregisters the callback\n   */\n  onInvalid(callback) {\n    this.invalidCallbacks.push(callback);\n\n    return () => {\n      removeFrom(this.invalidCallbacks, callback);\n    };\n  }\n\n  /**\n   * Reloads the current state\n   *\n   * A method that force reloads the current state, or a partial state hierarchy.\n   * All resolves are re-resolved, and components reinstantiated.\n   *\n   * #### Example:\n   * ```js\n   * let app angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.reload = function(){\n   *     $state.reload();\n   *   }\n   * });\n   * ```\n   *\n   * Note: `reload()` is just an alias for:\n   *\n   * ```js\n   * $state.transitionTo($state.current, $state.params, {\n   *   reload: true, inherit: false\n   * });\n   * ```\n   *\n   * @param {string | StateDeclaration | StateObject} [reloadState] A state name or a state object.\n   *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n   *\n   * #### Example:\n   * ```js\n   * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n   * //and current state is 'contacts.detail.item'\n   * let app angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.reload = function(){\n   *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n   *     $state.reload('contact.detail');\n   *   }\n   * });\n   * ```\n   *\n   * @returns A promise representing the state of the new transition. See [[StateService.go]]\n   */\n  reload(reloadState) {\n    return this.transitionTo(\n      /** @type {StateDeclaration} */ (this.globals.current),\n      this.globals.params,\n      {\n        reload: isDefined(reloadState) ? reloadState : true,\n        inherit: false,\n        notify: false,\n      },\n    );\n  }\n\n  /**\n   * Transition to a different state and/or parameters\n   *\n   * Convenience method for transitioning to a new state.\n   *\n   * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n   * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n   * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n   * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n   * inherit from the current parameter values (because of `inherit: true`).\n   *\n   * #### Example:\n   * ```js\n   * let app = angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.changeState = function () {\n   *     $state.go('contact.detail');\n   *   };\n   * });\n   * ```\n   *\n   * @param {StateOrName} to Absolute state name, state object, or relative state path (relative to current state).\n   *\n   * Some examples:\n   *\n   * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n   * - `$state.go('^')` - will go to the parent state\n   * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n   * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n   *\n   * @param {*} [params] A map of the parameters that will be sent to the state, will populate $stateParams.\n   *\n   *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n   *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n   *\n   * @param {*} [options] Transition options\n   *\n   * @returns {Promise<any>} A promise representing the state of the new transition.\n   */\n  go(to, params, options) {\n    const defautGoOpts = { relative: this.$current, inherit: true };\n\n    const transOpts = defaults(options, defautGoOpts, defaultTransOpts);\n\n    return this.transitionTo(to, params, transOpts);\n  }\n\n  /**\n   * Creates a [[TargetState]]\n   *\n   * This is a factory method for creating a TargetState\n   *\n   * This may be returned from a Transition Hook to redirect a transition, for example.\n   * @param {string | import(\"./interface.ts\").StateDeclaration | import(\"./state-object.js\").StateObject} identifier\n   * @param {{}} params\n   * @param {any} [options]\n   */\n  target(identifier, params, options = {}) {\n    // If we're reloading, find the state object to reload from\n    if (isObject(options.reload) && !options.reload.name)\n      throw new Error(\"Invalid reload state object\");\n    const reg = /** @type {ng.StateRegistryService} */ (this.stateRegistry);\n\n    options.reloadState =\n      options.reload === true\n        ? reg.root()\n        : reg.matcher.find(options.reload, options.relative);\n\n    if (options.reload && !options.reloadState)\n      throw new Error(\n        `No such reload state '${isString(options.reload) ? options.reload : options.reload.name}'`,\n      );\n\n    return new TargetState(\n      /** @type {StateRegistryProvider} */ (this.stateRegistry),\n      identifier,\n      params,\n      options,\n    );\n  }\n\n  getCurrentPath() {\n    const { globals } = this;\n\n    const latestSuccess = globals._successfulTransitions.peekTail();\n\n    const rootPath = () => [\n      new PathNode(\n        /** @type {ng.StateRegistryService} */ (this.stateRegistry).root(),\n      ),\n    ];\n\n    return latestSuccess ? latestSuccess._treeChanges.to : rootPath();\n  }\n\n  /**\n   * Low-level method for transitioning to a new state.\n   *\n   * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n   *\n   * #### Example:\n   * ```js\n   * let app = angular.module('app', ['ui.router']);\n   *\n   * app.controller('ctrl', function ($scope, $state) {\n   *   $scope.changeState = function () {\n   *     $state.transitionTo('contact.detail');\n   *   };\n   * });\n   * ```\n   *\n   * @param {StateOrName} to State name or state object.\n   * @param {RawParams} toParams A map of the parameters that will be sent to the state,\n   *      will populate $stateParams.\n   * @param {TransitionOptions} options Transition options\n   *\n   * @returns {TransitionPromise | Promise<any>} A promise representing the state of the new transition. See [[go]]\n   */\n  transitionTo(to, toParams = {}, options = {}) {\n    options = defaults(options, defaultTransOpts);\n    const getCurrent = () => this.globals.transition;\n\n    options = Object.assign(options, { current: getCurrent });\n    const ref = this.target(to, toParams, options);\n\n    const currentPath = this.getCurrentPath();\n\n    if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);\n\n    if (!ref.valid()) return silentRejection(ref.error());\n\n    if (options.supercede === false && getCurrent()) {\n      return Rejection.ignored(\n        \"Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.\",\n      ).toPromise();\n    }\n    /**\n     * Special handling for Ignored, Aborted, and Redirected transitions\n     *\n     * The semantics for the transition.run() promise and the StateService.transitionTo()\n     * promise differ. For instance, the run() promise may be rejected because it was\n     * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n     * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n     * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n     */\n    /** @typedef {(error: any) => Promise<any>} RejectionHandler */\n    /** @typedef {(trans: Transition) => RejectionHandler} RejectedTransitionHandler */\n\n    /** @type {RejectedTransitionHandler} */\n    const rejectedTransitionHandler =\n      (/** @type {Transition} */ trans) => (error) => {\n        if (error instanceof Rejection) {\n          const isLatest = this.globals._lastStartedTransitionId <= trans.$id;\n\n          if (error.type === RejectType._IGNORED) {\n            isLatest && /** @type {ng.UrlService} */ (this.urlService).update();\n\n            // Consider ignored `Transition.run()` as a successful `transitionTo`\n            return Promise.resolve(this.globals.current);\n          }\n          const { detail } = error;\n\n          if (\n            error.type === RejectType._SUPERSEDED &&\n            error.redirected &&\n            detail instanceof TargetState\n          ) {\n            // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n            // by returning the promise for the new (redirect) `Transition.run()`.\n            const redirect = trans.redirect(detail);\n\n            return redirect.run().catch(rejectedTransitionHandler(redirect));\n          }\n\n          if (error.type === RejectType._ABORTED) {\n            isLatest && /** @type {ng.UrlService} */ (this.urlService).update();\n\n            return Promise.reject(error);\n          }\n        }\n        const errorHandler = this.defaultErrorHandler();\n\n        errorHandler(error);\n\n        return Promise.reject(error);\n      };\n\n    const transition = this.transitionService.create(currentPath, ref);\n\n    const transitionToPromise = transition\n      .run()\n      .catch(rejectedTransitionHandler(transition));\n\n    silenceUncaughtInPromise(transitionToPromise); // issue #2676\n\n    // Return a promise for the transition, which also has the transition object on it.\n    return Object.assign(transitionToPromise, { transition });\n  }\n\n  /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     * @param {import(\"./state-matcher.js\").StateOrName} stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param {import(\"../params/interface.ts\").RawParams} [params] A param object, e.g. `{sectionId: section.id}`, that you'd like\n    to test against the current active state.\n     * @param {{ relative: import(\"./state-matcher.js\").StateOrName | undefined; } | undefined} [options] An options object. The options are:\n    - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n    test relative to `options.relative` state (or name).\n     * @returns {boolean | undefined} Returns true if it is the state.\n     */\n  is(stateOrName, params, options) {\n    options = defaults(options, { relative: this.$current });\n    const state = this.stateRegistry?.matcher.find(\n      stateOrName,\n      options?.relative,\n    );\n\n    if (!isDefined(state)) return undefined;\n\n    if (this.$current !== state) return false;\n\n    if (!params) return true;\n    const schema = state.parameters({ inherit: true, matchingKeys: params });\n\n    return Param.equals(\n      schema,\n      Param.values(schema, params),\n      this.globals.params,\n    );\n  }\n\n  /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     * @param {StateOrName} stateOrName A partial name, relative name, glob pattern,\n    or state object to be searched for within the current state name.\n     * @param {RawParams} [params] A param object, e.g. `{sectionId: section.id}`,\n    that you'd like to test against the current active state.\n     * @param {TransitionOptions} [options] An options object. The options are:\n    - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n    test relative to `options.relative` state (or name).\n     * @returns {boolean | undefined} Returns true if it does include the state\n     */\n  includes(stateOrName, params, options) {\n    options = defaults(options, { relative: this.$current });\n    const glob = isString(stateOrName) && Glob.fromString(stateOrName);\n\n    if (glob) {\n      if (!glob.matches(/** @type {string} */ (this.$current?.name)))\n        return false;\n      stateOrName = /** @type {string} */ (this.$current?.name);\n    }\n    const state = this.stateRegistry?.matcher.find(\n      stateOrName,\n      options?.relative,\n    );\n\n    const include = this.$current?.includes;\n\n    if (!isDefined(state)) return undefined;\n\n    if (!isDefined(include[state.name])) return false;\n\n    if (!params) return true;\n    const schema = /** @type {ng.StateObject} */ (state).parameters({\n      inherit: true,\n      matchingKeys: params,\n    });\n\n    return Param.equals(\n      schema,\n      Param.values(schema, params),\n      this.globals.params,\n    );\n  }\n\n  /**\n   * Generates a URL for a state and parameters\n   *\n   * Returns the url for the given state populated with the given params.\n   *\n   * #### Example:\n   * ```js\n   * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n   * ```\n   * @param {import(\"./state-matcher.js\").StateOrName} stateOrName The state name or state object you'd like to generate a url from.\n   * @param {import(\"../params/interface.ts\").RawParams} params An object of parameter values to fill the state's required parameters.\n   * @param {import(\"./interface.ts\").HrefOptions} [options] Options object. The options are:\n   * @returns {string | null} compiled state url\n   */\n  href(stateOrName, params, options) {\n    const defaultHrefOpts = {\n      lossy: true,\n      inherit: true,\n      absolute: false,\n      relative: this.$current,\n    };\n\n    options = defaults(options, defaultHrefOpts);\n    params = params || {};\n    const state = this.stateRegistry?.matcher.find(\n      stateOrName,\n      options?.relative,\n    );\n\n    if (!isDefined(state)) return null;\n\n    if (options?.inherit)\n      params = this.globals.params.$inherit(\n        params,\n        /** @type {StateObject} */ (this.$current),\n        state,\n      );\n    const nav = state && options?.lossy ? state.navigable : state;\n\n    if (!nav || nav.url === undefined || nav.url === null) {\n      return null;\n    }\n\n    return /** @type {ng.UrlService} */ (this.urlService).href(\n      nav.url,\n      params,\n      {\n        absolute: options?.absolute,\n      },\n    );\n  }\n\n  /**\n   * Sets or gets the default [[transitionTo]] error handler.\n   *\n   * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n   * This includes errors caused by resolves and transition hooks.\n   *\n   * Note:\n   * This handler does not receive certain Transition rejections.\n   * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n   *\n   * The built-in default error handler logs the error to the console.\n   *\n   * You can provide your own custom handler.\n   *\n   * #### Example:\n   * ```js\n   * stateService.defaultErrorHandler(function() {\n   *   // Do not log transitionTo errors\n   * });\n   * ```\n   * @param {import(\"../../docs.ts\").ExceptionHandler | undefined} [handler] a global error handler function\n   * @returns the current global error handler\n   */\n  defaultErrorHandler(handler) {\n    return (this._defaultErrorHandler = handler || this._defaultErrorHandler);\n  }\n\n  /**\n   * @param {import(\"./interface.ts\").StateOrName} stateOrName\n   * @param {undefined} [base]\n   */\n  get(stateOrName, base) {\n    const reg = this.stateRegistry;\n\n    if (arguments.length === 0) return reg?.get();\n\n    return reg?.get(stateOrName, base || this.$current);\n  }\n\n  /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     * @param {import(\"./interface.ts\").StateOrName} stateOrName the state that should be lazy loaded\n     * @param {ng.Transition} transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n    Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n    This noop transition is not actually run.\n     * @returns a promise to lazy load\n     */\n  lazyLoad(stateOrName, transition) {\n    const state = /** @type {ng.StateDeclaration} */ (this.get(stateOrName));\n\n    if (!state || !state.lazyLoad)\n      throw new Error(`Can not lazy load ${stateOrName}`);\n    const currentPath = this.getCurrentPath();\n\n    const target = makeTargetState(\n      /** @type {StateRegistryProvider} */ (this.stateRegistry),\n      currentPath,\n    );\n\n    transition =\n      transition || this.transitionService.create(currentPath, target);\n\n    return lazyLoadState(transition, state);\n  }\n}\n","import {\n  isArray,\n  isDefined,\n  isFunction,\n  isNullOrUndefined,\n  isObject,\n} from \"../shared/utils.js\";\nimport { tail, unnestR } from \"../shared/common.js\";\nimport { Resolvable } from \"./resolve/resolvable.js\";\nimport { kebobString } from \"../shared/strings.js\";\nimport { annotate } from \"../core/di/di.js\";\nimport { DirectiveSuffix } from \"../core/compile/compile.js\";\nimport { $injectTokens as $t } from \"../injection-tokens.js\";\n\n/**\n * @typedef BindingTuple\n * @property {string} name\n * @property {string} type\n */\n\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nexport class TemplateFactoryProvider {\n  $get = [\n    $t._http,\n    $t._templateCache,\n    $t._templateRequest,\n    $t._injector,\n    /**\n     * @param {ng.HttpService} $http\n     * @param {ng.TemplateCacheService} $templateCache\n     * @param {ng.TemplateRequestService} $templateRequest\n     * @param {ng.InjectorService} $injector\n     * @returns {TemplateFactoryProvider}\n     */\n    ($http, $templateCache, $templateRequest, $injector) => {\n      this.$templateRequest = $templateRequest;\n      this.$http = $http;\n      this.$templateCache = $templateCache;\n      this.$injector = $injector;\n\n      return this;\n    },\n  ];\n\n  /**\n   * Creates a template from a configuration object.\n   *\n   * @param config Configuration object for which to load a template.\n   * The following properties are search in the specified order, and the first one\n   * that is defined is used to create the template:\n   *\n   * @param {any} config\n   * @param {any} params  Parameters to pass to the template function.\n   * @param {import(\"./resolve/resolve-context.js\").ResolveContext} context The resolve context associated with the template's view\n   *\n   * @return {string|object}  The template html as a string, or a promise for\n   * that string,or `null` if no template is configured.\n   */\n  fromConfig(config, params, context) {\n    const defaultTemplate = \"<ng-view></ng-view>\";\n\n    /**\n     * @param {string | Promise<string>} result\n     * @returns {Promise<{ template: string }>}\n     */\n    const asTemplate = (result) =>\n      Promise.resolve(result).then((str) => ({ template: str }));\n\n    /**\n     * @param {string | Promise<string>} result\n     * @returns {Promise<{ component: string }>}\n     */\n    const asComponent = (result) =>\n      Promise.resolve(result).then((str) => ({ component: str }));\n\n    /**\n     * @param {any} configParam\n     * @returns {\"template\"|\"templateUrl\"|\"templateProvider\"|\"component\"|\"componentProvider\"|\"default\"}\n     */\n    const getConfigType = (configParam) => {\n      if (isDefined(configParam.template)) return \"template\";\n\n      if (isDefined(configParam.templateUrl)) return \"templateUrl\";\n\n      if (isDefined(configParam.templateProvider)) return \"templateProvider\";\n\n      if (isDefined(configParam.component)) return \"component\";\n\n      if (isDefined(configParam.componentProvider)) return \"componentProvider\";\n\n      return \"default\";\n    };\n\n    switch (getConfigType(config)) {\n      case \"template\":\n        return asTemplate(\n          /** @type {string} */ (this.fromString(config.template, params)),\n        );\n      case \"templateUrl\":\n        return asTemplate(\n          /** @type {Promise<any>} */ (\n            this.fromUrl(config.templateUrl, params)\n          ),\n        );\n      case \"templateProvider\":\n        return asTemplate(\n          this.fromProvider(config.templateProvider, params, context),\n        );\n      case \"component\":\n        return asComponent(config.component);\n      case \"componentProvider\":\n        return asComponent(\n          this.fromComponentProvider(config.componentProvider, context),\n        );\n      default:\n        return asTemplate(defaultTemplate);\n    }\n  }\n\n  /**\n   * Creates a template from a string or a function returning a string.\n   *\n   * @param {string | Function} template html template as a string or function that returns an html template as a string.\n   * @param {any} [params] Parameters to pass to the template function.\n   *\n   * @return {string|object} The template html as a string, or a promise for that\n   * string.\n   */\n  fromString(template, params) {\n    return isFunction(template)\n      ? /** @type {Function} */ (template)(params)\n      : template;\n  }\n\n  /**\n   * Loads a template from the a URL via `$http` and `$templateCache`.\n   *\n   * @param {string|Function} url url of the template to load, or a function\n   * that returns a url.\n   * @param {Object} params Parameters to pass to the url function.\n   * @return {Promise<string> | null}\n   */\n  fromUrl(url, params) {\n    if (isFunction(url)) url = /** @type {Function} */ (url)(params);\n\n    if (isNullOrUndefined(url)) return null;\n\n    return /** @type {ng.TemplateRequestService} */ (this.$templateRequest)(\n      /** @type {string} */ (url),\n    );\n  }\n\n  /**\n   * Creates a template by invoking an injectable provider function.\n   *\n   * @param {import('../interface.ts').Injectable<any>} provider Function to invoke via `locals`\n   * @param {Function} params a function used to invoke the template provider\n   * @param {import(\"./resolve/resolve-context.js\").ResolveContext} context\n   * @return {string|Promise.<string>} The template html as a string, or a promise\n   * for that string.\n   */\n  fromProvider(provider, params, context) {\n    const deps = annotate(provider);\n\n    const providerFn = isArray(provider)\n      ? /** @type {Function} */ (tail(provider))\n      : provider;\n\n    const resolvable = new Resolvable(\"\", providerFn, deps);\n\n    return resolvable.get(context);\n  }\n\n  /**\n   * Creates a component's template by invoking an injectable provider function.\n   * @param {import('../interface.ts').Injectable<any>} provider Function to invoke via `locals`\n   * @param {import(\"./resolve/resolve-context.js\").ResolveContext} context\n   * @return {Promise<any>} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n   */\n  fromComponentProvider(provider, context) {\n    const deps = annotate(provider);\n\n    const providerFn = isArray(provider) ? tail(provider) : provider;\n\n    const resolvable = new Resolvable(\"\", providerFn, deps);\n\n    return resolvable.get(context); // https://github.com/angular-ui/ui-router/pull/3165/files\n  }\n\n  /**\n   * Creates a template from a component's name\n   *\n   * This implements route-to-component.\n   * It works by retrieving the component (directive) metadata from the injector.\n   * It analyses the component's bindings, then constructs a template that instantiates the component.\n   * The template wires input and output bindings to resolves or from the parent component.\n   *\n   * @param {any} ngView {object} The parent ng-view (for binding outputs to callbacks)\n   * @param {import(\"./resolve/resolve-context.js\").ResolveContext} context The ResolveContext (for binding outputs to callbacks returned from resolves)\n   * @param {string} component {string} Component's name in camel case.\n   * @param {any} [bindings] An object defining the component's bindings: {foo: '<'}\n   * @return {string} The template as a string: \"<component-name input1='$resolve.foo'></component-name>\".\n   */\n  makeComponentTemplate(ngView, context, component, bindings) {\n    bindings = bindings || {};\n    // Bind once prefix\n    // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n    const kebob = (/** @type {string} */ camelCase) => {\n      const kebobed = kebobString(camelCase);\n\n      return /^(x|data)-/.exec(kebobed) ? `x-${kebobed}` : kebobed;\n    };\n\n    const attributeTpl = /** @param {BindingTuple} input*/ (input) => {\n      const { name, type } = input;\n\n      const attrName = kebob(name);\n\n      // If the ng-view has an attribute which matches a binding on the routed component\n      // then pass that attribute through to the routed component template.\n      // Prefer ng-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n      if (ngView.getAttribute(attrName) && !bindings[name])\n        return `${attrName}='${ngView.getAttribute(attrName)}'`;\n      const resolveName = bindings[name] || name;\n\n      // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n      // some-attr=\"{{$resolve.someResolveName }}\"\n      if (type === \"@\") return `${attrName}='{{s$resolve.${resolveName}}}'`;\n\n      // Wire \"&\" callbacks to resolves that return a callback function\n      // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n      // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n      if (type === \"&\") {\n        const res = context.getResolvable(resolveName);\n\n        const fn = res && res.data;\n\n        const args = (fn && annotate(fn)) || [];\n\n        // account for array style injection, i.e., ['foo', function(foo) {}]\n        const arrayIdxStr = isArray(fn) ? `[${fn.length - 1}]` : \"\";\n\n        return `${attrName}='$resolve.${resolveName}${arrayIdxStr}(${args.join(\",\")})'`;\n      }\n\n      // some-attr=\"::$resolve.someResolveName\"\n      return `${attrName}='$resolve.${resolveName}'`;\n    };\n\n    const attrs = getComponentBindings(this.$injector, component)\n      .map(attributeTpl)\n      .join(\" \");\n\n    const kebobName = kebob(component);\n\n    return `<${kebobName} ${attrs}></${kebobName}>`;\n  }\n}\n\n/**\n * Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\n * @param {ng.InjectorService | undefined} $injector\n * @param {string} name\n */\nfunction getComponentBindings($injector, name) {\n  const cmpDefs = $injector?.get(name + DirectiveSuffix); // could be multiple\n\n  if (!cmpDefs || !cmpDefs.length)\n    throw new Error(`Unable to find component named '${name}'`);\n\n  return cmpDefs.map(getBindings).reduce(unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nconst getBindings = (/** @type {ng.Directive} */ def) => {\n  if (isObject(def.bindToController))\n    return scopeBindings(def.bindToController);\n\n  return scopeBindings(/** @type {Record<string, string>} */ (def.scope));\n};\n\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nconst scopeBindings = (/** @type {Record<string, string>} */ bindingsObj) => {\n  /** @type {Array<[string, RegExpExecArray | null]>} */\n  const tuples = Object.keys(bindingsObj || {}).map((key) => {\n    const match = /^([=<@&])[?]?(.*)/.exec(bindingsObj[key] || \"\");\n\n    return [key, match];\n  });\n\n  /** @type {(x: [string, RegExpExecArray | null]) => x is [string, RegExpExecArray]} */\n  const hasMatch = (x) => x[1] !== null;\n\n  return tuples\n    .filter(hasMatch)\n    .map(([key, match]) => ({ name: match[2] || key, type: match[1] }));\n};\n","import {\n  allTrueR,\n  arrayTuples,\n  defaults,\n  find,\n  inherit,\n  map,\n  tail,\n  unnest,\n  unnestR,\n} from \"../../shared/common.js\";\nimport { propEq } from \"../../shared/hof.js\";\nimport {\n  hasOwn,\n  isArray,\n  isDefined,\n  isNullOrUndefined,\n  isString,\n} from \"../../shared/utils.js\";\nimport { DefType, Param } from \"../params/param.js\";\nimport { joinNeighborsR, splitOnDelim } from \"../../shared/strings.js\";\n\n/** @typedef {import(\"./interface.js\").UrlMatcherCache} UrlMatcherCache */\n/** @typedef {import(\"./interface.ts\").ParamDetails} ParamDetails */\n\n/**\n * @param {any} str\n * @param {any} [param]\n */\nfunction quoteRegExp(str, param) {\n  let surroundPattern = [\"\", \"\"];\n\n  let result = str.replace(/[\\\\[\\]^$*+?.()|{}]/g, \"\\\\$&\");\n\n  if (!param) return result;\n  switch (param.squash) {\n    case false:\n      surroundPattern = [\"(\", `)${param.isOptional ? \"?\" : \"\"}`];\n      break;\n    case true:\n      result = result.replace(/\\/$/, \"\");\n      surroundPattern = [\"(?:/(\", \")|/)?\"];\n      break;\n    default:\n      surroundPattern = [`(${param.squash}|`, \")?\"];\n      break;\n  }\n\n  return (\n    result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1]\n  );\n}\n\nconst memoizeTo = (\n  /** @type {{ [x: string]: any; path?: UrlMatcher[]; }} */ obj,\n  /** @type {string} */ _prop,\n  /** @type {{ (): RegExp; (): any; }} */ fn,\n) => (obj[_prop] = obj[_prop] || fn());\n\nconst splitOnSlash = splitOnDelim(\"/\");\n\nconst defaultConfig = {\n  state: { params: {} },\n  strict: true,\n  caseInsensitive: true,\n};\n\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nexport class UrlMatcher {\n  /**\n   * @internal Given a matcher, return an array with the matcher's path segments and path params, in order\n   * @param {UrlMatcher} matcher\n   */\n  static pathSegmentsAndParams(matcher) {\n    const staticSegments = matcher._segments;\n\n    const pathParams = matcher._params.filter(\n      (path) => path.location === DefType._PATH,\n    );\n\n    return arrayTuples(staticSegments, [...pathParams, undefined])\n      .reduce(unnestR, [])\n      .filter((/** @type {string} */ x) => x !== \"\" && isDefined(x));\n  }\n\n  /**\n   * @internal Given a matcher, return an array with the matcher's query params\n   * @param {UrlMatcher} matcher\n   * @returns {Param[]}\n   */\n  static queryParams(matcher) {\n    return matcher._params.filter((path) => path.location === DefType._SEARCH);\n  }\n\n  /**\n   * Compare two UrlMatchers\n   *\n   * This comparison function converts a UrlMatcher into static and dynamic path segments.\n   * Each static path segment is a static string between a path separator (slash character).\n   * Each dynamic segment is a path parameter.\n   *\n   * The comparison function sorts static segments before dynamic ones.\n   * @param {UrlMatcher} a\n   * @param {UrlMatcher} b\n   */\n  static compare(a, b) {\n    /**\n     * Converts a UrlMatcher and all its parent matchers into a flat array of segments.\n     *\n     * Each segment is one of:\n     *  - A slash literal `'/'`\n     *  - A string literal (path segment)\n     *  - A `Param` object representing a URL parameter\n     *\n     * Example:\n     * ```js\n     * // Matches strings like \"/foo/:param/tail\"\n     * var matcher = $umf.compile(\"/foo\")\n     *                  .append($umf.compile(\"/:param\"))\n     *                  .append($umf.compile(\"/\"))\n     *                  .append($umf.compile(\"tail\"));\n     *\n     * var result = segments(matcher);\n     * // result: [ '/', 'foo', '/', Param, '/', 'tail' ]\n     * ```\n     *\n     * The computed segments are cached in `matcher._cache.segments` for faster future access.\n     *\n     * @param {UrlMatcher} matcher The matcher object to convert into segments. Must have `_cache.path`.\n     * @returns {(string | Param)[]} An array of segments representing the URL pattern.\n     */\n    const segments = (matcher) =>\n      (matcher._cache.segments =\n        matcher._cache.segments ||\n        matcher._cache.path\n          ?.map(UrlMatcher.pathSegmentsAndParams)\n          .reduce(unnestR, [])\n          .reduce(joinNeighborsR, [])\n          .map((/** @type {unknown} */ x) =>\n            isString(x) ? splitOnSlash(x) : x,\n          )\n          .reduce(unnestR, []));\n\n    /**\n     * Gets the sort weight for each segment of a UrlMatcher\n     *\n     * Caches the result as `matcher._cache.weights`\n     */\n    const weights = (/** @type {UrlMatcher} */ matcher) =>\n      (matcher._cache.weights =\n        matcher._cache.weights ||\n        segments(matcher).map((segment) => {\n          // Sort slashes first, then static strings, the Params\n          if (segment === \"/\") return 1;\n\n          if (isString(segment)) return 2;\n\n          if (segment instanceof Param) return 3;\n\n          return undefined;\n        }));\n\n    /**\n     * Pads shorter array in-place (mutates)\n     */\n    const padArrays = (\n      /** @type {any[]} */ left,\n      /** @type {any[]} */ right,\n      /** @type {number} */ padVal,\n    ) => {\n      const len = Math.max(left.length, right.length);\n\n      while (left.length < len) left.push(padVal);\n\n      while (right.length < len) right.push(padVal);\n    };\n\n    const weightsA = weights(a),\n      weightsB = weights(b);\n\n    padArrays(weightsA, weightsB, 0);\n    const _pairs = arrayTuples(weightsA, weightsB);\n\n    let cmp;\n\n    for (let i = 0, l = _pairs.length; i < l; i++) {\n      cmp = _pairs[i][0] - _pairs[i][1];\n\n      if (cmp !== 0) return cmp;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {string} pattern The pattern to compile into a matcher.\n   * @param {import(\"../params/param-types.js\").ParamTypes} paramTypes The [[ParamTypes]] registry\n   * @param {import(\"../params/param-factory.js\").ParamFactory} paramFactory A [[ParamFactory]] object\n   * @param {import(\"./interface.js\").UrlMatcherCompileConfig} config A [[UrlMatcherCompileConfig]] configuration object\n   */\n  constructor(pattern, paramTypes, paramFactory, config) {\n    this._cache = /** @type {UrlMatcherCache} */ ({\n      path: [/** @type {UrlMatcher} */ (this)],\n    });\n\n    /**\n     * @type {any[]}\n     */\n    this._children = [];\n\n    this._params = [];\n\n    this._segments = [];\n\n    /**\n     * @type {any[]}\n     */\n    this._compiled = [];\n    this.config = config = defaults(config, defaultConfig);\n    this.pattern = pattern;\n    // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n    //   '*' name\n    //   ':' name\n    //   '{' name '}'\n    //   '{' name ':' regexp '}'\n    // The regular expression is somewhat complicated due to the need to allow curly braces\n    // inside the regular expression. The placeholder regexp breaks down as follows:\n    //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n    //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n    //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n    //    [^{}\\\\]+                       - anything other than curly braces or backslash\n    //    \\\\.                            - a backslash escape\n    //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n\n    const MAX_REGEX_LENGTH = 200; // or any safe limit\n\n    const placeholder = new RegExp(\n      `([:*])([\\\\w[\\\\]]+)|\\\\{([\\\\w[\\\\]]+)(?::\\\\s*((?:[^{}\\\\\\\\]{1,${\n        MAX_REGEX_LENGTH\n      }}|\\\\\\\\.|\\\\{(?:[^{}\\\\\\\\]{1,${MAX_REGEX_LENGTH}}|\\\\\\\\.)*\\\\})+))?\\\\}`,\n      \"g\",\n    );\n\n    const searchPlaceholder = new RegExp(\n      `([:]?)([\\\\w[\\\\].-]+)|\\\\{([\\\\w[\\\\].-]+)(?::\\\\s*((?:[^{}\\\\\\\\]{1,${\n        MAX_REGEX_LENGTH\n      }}|\\\\\\\\.|\\\\{(?:[^{}\\\\\\\\]{1,${MAX_REGEX_LENGTH}}|\\\\\\\\.)*\\\\})+))?\\\\}`,\n      \"g\",\n    );\n\n    const patterns = [];\n\n    let last = 0;\n\n    let matchArray;\n\n    const checkParamErrors = (/** @type {string} */ id) => {\n      if (!UrlMatcher.nameValidator.test(id))\n        throw new Error(\n          `Invalid parameter name '${id}' in pattern '${pattern}'`,\n        );\n\n      if (find(this._params, propEq(\"id\", id)))\n        throw new Error(\n          `Duplicate parameter name '${id}' in pattern '${pattern}'`,\n        );\n    };\n\n    // Split into static segments separated by path parameter placeholders.\n    // The number of segments is always 1 more than the number of parameters.\n    const matchDetails = (\n      /** @type {RegExpExecArray} */ match,\n      /** @type {boolean} */ isSearch,\n    ) => {\n      // IE[78] returns '' for unmatched groups instead of null\n      const id = match[2] || match[3];\n\n      const regexp = isSearch\n        ? match[4]\n        : match[4] || (match[1] === \"*\" ? \"[\\\\s\\\\S]*\" : null);\n\n      const makeRegexpType = (/** @type {string | RegExp} */ str) =>\n        inherit(paramTypes.type(isSearch ? \"query\" : \"path\"), {\n          pattern: new RegExp(\n            str,\n            this.config.caseInsensitive ? \"i\" : undefined,\n          ),\n        });\n\n      return {\n        id,\n        regexp,\n        segment: pattern.substring(last, match.index),\n        type: !regexp\n          ? null\n          : paramTypes.type(regexp) || makeRegexpType(regexp),\n      };\n    };\n\n    let details;\n\n    let segment;\n\n    while ((matchArray = placeholder.exec(pattern))) {\n      details = matchDetails(matchArray, false);\n\n      if (details.segment.indexOf(\"?\") >= 0) break; // we're into the search part\n      checkParamErrors(details.id);\n      this._params.push(\n        paramFactory.fromPath(\n          details.id,\n          details.type,\n          /** @type {ng.StateDeclaration} */ (config.state),\n        ),\n      );\n      this._segments.push(details.segment);\n      patterns.push([details.segment, tail(this._params)]);\n      last = placeholder.lastIndex;\n    }\n    segment = pattern.substring(last);\n    // Find any search parameter names and remove them from the last segment\n    const i = segment.indexOf(\"?\");\n\n    if (i >= 0) {\n      const search = segment.substring(i);\n\n      segment = segment.substring(0, i);\n\n      if (search.length > 0) {\n        last = 0;\n\n        while ((matchArray = searchPlaceholder.exec(search))) {\n          details = matchDetails(matchArray, true);\n          checkParamErrors(details.id);\n          this._params.push(\n            paramFactory.fromSearch(\n              details.id,\n              details.type,\n              /** @type {ng.StateDeclaration} */ (config.state),\n            ),\n          );\n          last = placeholder.lastIndex;\n          // check if ?&\n        }\n      }\n    }\n    this._segments.push(segment);\n    this._compiled = patterns\n      .map((_pattern) => quoteRegExp.apply(null, /** @type {any} */ (_pattern)))\n      .concat(quoteRegExp(segment));\n  }\n\n  /**\n   * Creates a new concatenated UrlMatcher\n   *\n   * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n   *\n   * @param {UrlMatcher} url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n   * @returns {UrlMatcher} A new `UrlMatcher` instance representing the concatenation of this `UrlMatcher` and the provided `url` matcher.\n   */\n  append(url) {\n    this._children.push(url);\n    url._cache = {\n      path: this._cache.path?.concat(url),\n      parent: this,\n      pattern: null,\n    };\n\n    return url;\n  }\n\n  isRoot() {\n    return /** @type {UrlMatcher[]} */ (this._cache.path)[0] === this;\n  }\n\n  /** Returns the input pattern string */\n  toString() {\n    return this.pattern;\n  }\n\n  /**\n   * @param {any} value\n   * @param {Param} param\n   * @returns {any}\n   */\n  _getDecodedParamValue(value, param) {\n    return param.value(value);\n  }\n\n  /**\n   * Tests the specified url/path against this matcher.\n   *\n   * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n   * parameter values.  Returns null if the path does not match.\n   *\n   * The returned object contains the values\n   * of any search parameters that are mentioned in the pattern, but their value may be null if\n   * they are not present in `search`. This means that search parameters are always treated\n   * as optional.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n   *   x: '1', q: 'hello'\n   * });\n   * // returns { id: 'bob', q: 'hello', r: null }\n   * ```\n   * @param {string} path The URL path to match, e.g. `$location.getPath()`.\n   * @param {any} search URL search parameters, e.g. `$location.getSearch()`.\n   * @param {string} hash URL hash e.g. `$location.getHash()`.\n   * @returns {import(\"../params/interface.js\").RawParams | null} The captured parameter values.\n   */\n  exec(path, search = {}, hash) {\n    const match = memoizeTo(this._cache, \"pattern\", () => {\n      return new RegExp(\n        [\n          \"^\",\n          unnest(\n            /** @type {UrlMatcher[]} */ (this._cache.path).map(\n              (x) => x._compiled,\n            ),\n          ).join(\"\"),\n          this.config.strict === false ? \"/?\" : \"\",\n          \"$\",\n        ].join(\"\"),\n        this.config.caseInsensitive ? \"i\" : undefined,\n      );\n    }).exec(path);\n\n    if (!match) return null;\n    // options = defaults(options, { isolate: false });\n    const allParams = this.parameters(),\n      pathParams = allParams.filter((param) => !param.isSearch()),\n      searchParams = allParams.filter((param) => param.isSearch()),\n      nPathSegments = /** @type {UrlMatcher[]} */ (this._cache.path)\n        .map((urlm) => urlm._segments.length - 1)\n        .reduce((a, x) => a + x),\n      values = /** @type {Record<string, any>} */ ({});\n\n    if (nPathSegments !== match.length - 1)\n      throw new Error(`Unbalanced capture group in route '${this.pattern}'`);\n    /**\n     * @param {any} paramVal\n     */\n    function decodePathArray(paramVal) {\n      const reverseString = (/** @type {string} */ str) =>\n        str.split(\"\").reverse().join(\"\");\n\n      const unquoteDashes = (/** @type {string} */ str) =>\n        str.replace(/\\\\-/g, \"-\");\n\n      const split = reverseString(paramVal).split(/-(?!\\\\)/);\n\n      const allReversed = map(split, reverseString);\n\n      return /** @type {string[]} */ (\n        map(allReversed, unquoteDashes)\n      ).reverse();\n    }\n\n    for (let i = 0; i < nPathSegments; i++) {\n      const param = pathParams[i];\n\n      let value = match[i + 1];\n\n      // if the param value matches a pre-replace pair, replace the value before decoding.\n      for (let j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n\n      if (value && param.array === true) value = decodePathArray(value);\n      values[param.id] = this._getDecodedParamValue(value, param);\n    }\n    searchParams.forEach((param) => {\n      let value = search[param.id];\n\n      for (let j = 0; j < param.replace.length; j++) {\n        if (param.replace[j].from === value) value = param.replace[j].to;\n      }\n      values[param.id] = this._getDecodedParamValue(value, param);\n    });\n\n    if (hash) values[\"#\"] = hash;\n\n    return values;\n  }\n\n  /**\n   * @internal\n   * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n   *\n   * @param {any} [opts]\n   * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n   *    pattern has no parameters, an empty array is returned.\n   */\n  parameters(opts = {}) {\n    if (opts.inherit === false) return this._params;\n\n    return unnest(\n      /** @type {UrlMatcher[]} */ (this._cache.path).map(\n        (matcher) => matcher._params,\n      ),\n    );\n  }\n\n  /**\n   * @internal Returns a single parameter from this UrlMatcher by id\n   * @param {string} id\n   * @param {any} opts\n   * @returns {Param | any | boolean | UrlMatcher | null}\n   */\n  parameter(id, opts = {}) {\n    const findParam = () => {\n      for (const param of this._params) {\n        if (param.id === id) return param;\n      }\n\n      return undefined;\n    };\n\n    const { parent } = this._cache;\n\n    return (\n      findParam() ||\n      (opts.inherit !== false && parent && parent.parameter(id, opts)) ||\n      null\n    );\n  }\n\n  /**\n   * Validates the input parameter values against this UrlMatcher\n   *\n   * Checks an object hash of parameters to validate their correctness according to the parameter\n   * types of this `UrlMatcher`.\n   * @param {import(\"../params/interface.js\").RawParams} params The object hash of parameters to validate.\n   * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.\n   */\n  validates(params) {\n    const validParamVal = (\n      /** @type {Param} */ param,\n      /** @type {any} */ val,\n    ) => !param || param.validates(val);\n\n    params = params || {};\n    // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n    const paramSchema = this.parameters().filter((paramDef) =>\n      hasOwn(params, paramDef.id),\n    );\n\n    return paramSchema\n      .map((paramDef) => validParamVal(paramDef, params[paramDef.id]))\n      .reduce(allTrueR, true);\n  }\n\n  /**\n   * Given a set of parameter values, creates a URL from this UrlMatcher.\n   *\n   * Creates a URL that matches this pattern by substituting the specified values\n   * for the path and search parameters.\n   *\n   * #### Example:\n   * ```js\n   * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n   * // returns '/user/bob?q=yes'\n   * ```\n   *\n   * @param {import(\"../params/interface.js\").RawParams} values  the values to substitute for the parameters in this pattern.\n   * @returns the formatted URL (path and optionally search part).\n   */\n  format(values = {}) {\n    // Build the full path of UrlMatchers (including all parent UrlMatchers)\n    const urlMatchers = this._cache.path;\n\n    // Extract all the static segments and Params (processed as ParamDetails)\n    // into an ordered array\n    const pathSegmentsAndParams = /** @type {UrlMatcher[]} */ (urlMatchers)\n      .map(UrlMatcher.pathSegmentsAndParams)\n      .reduce(unnestR, [])\n      .map((/** @type {string | Param} */ x) =>\n        isString(x) ? x : getDetails(/** @type {Param} */ (x)),\n      );\n\n    // Extract the query params into a separate array\n    const queryParams = /** @type {UrlMatcher[]} */ (urlMatchers)\n      .map(UrlMatcher.queryParams)\n      .reduce(unnestR, [])\n      .map(getDetails);\n\n    const isInvalid = (/** @type {any} */ param) => param.isValid === false;\n\n    if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n      return null;\n    }\n    /**\n     * Given a Param, applies the parameter value, then returns detailed information about it\n     * @param {Param} param\n     * @returns {import(\"./interface.js\").ParamDetails}\n     */\n    function getDetails(param) {\n      // Normalize to typed value\n      const value = param.value(values[param.id]);\n\n      const isValid = param.validates(value);\n\n      const isDefaultValue = param.isDefaultValue(value);\n\n      // Check if we're in squash mode for the parameter\n      const squash = isDefaultValue ? param.squash : false;\n\n      // Allow the Parameter's Type to encode the value\n      const encoded = param.type.encode(value);\n\n      return { param, value, isValid, isDefaultValue, squash, encoded };\n    }\n    // Build up the path-portion from the list of static segments and parameters\n    /** @type {string} */\n    const pathString = /** @type {string} */ (\n      pathSegmentsAndParams.reduce(\n        /** @param {string} acc */ (acc, /** @type {ParamDetails} */ x) => {\n          // The element is a static segment (a raw string); just append it\n          if (isString(x)) return acc + x;\n          // Otherwise, it's a ParamDetails.\n          const { squash, encoded, param } = x;\n\n          // If squash is === true, try to remove a slash from the path\n          if (squash === true) return acc.match(/\\/$/) ? acc.slice(0, -1) : acc;\n\n          // If squash is a string, use the string for the param value\n          if (isString(squash)) return acc + squash;\n\n          if (squash !== false) return acc; // ?\n\n          if (isNullOrUndefined(encoded)) return acc;\n\n          // If this parameter value is an array, encode the value using encodeDashes\n          if (isArray(encoded))\n            return (\n              acc +\n              /** @type {string[]} */ (map(encoded, encodeDashes)).join(\"-\")\n            );\n\n          // If the parameter type is \"raw\", then do not encodeURIComponent\n          if (param.raw) {\n            return acc + encoded;\n          }\n\n          // Encode the value\n          return acc + encodeURIComponent(encoded);\n        },\n        \"\",\n      )\n    );\n\n    // Build the query string by applying parameter values (array or regular)\n    // then mapping to key=value, then flattening and joining using \"&\"\n    const queryString = queryParams\n      .map((/** @type {ParamDetails} */ paramDetails) => {\n        const { param, squash, isDefaultValue } = paramDetails;\n\n        let { encoded } = paramDetails;\n\n        if (isNullOrUndefined(encoded) || (isDefaultValue && squash !== false))\n          return undefined;\n\n        if (!isArray(encoded)) encoded = [encoded];\n\n        if (encoded.length === 0) return undefined;\n\n        if (!param.raw)\n          encoded = /** @type {string |string[]} */ (\n            map(encoded, encodeURIComponent)\n          );\n\n        return /** @type {any} */ (encoded).map(\n          (/** @type {any} */ val) => `${param.id}=${val}`,\n        );\n      })\n      .reduce(unnestR, [])\n      .join(\"&\");\n\n    // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n    return (\n      pathString +\n      (queryString ? `?${queryString}` : \"\") +\n      (values[\"#\"] ? `#${values[\"#\"]}` : \"\")\n    );\n  }\n}\n\nUrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n\n/**\n * @param {string | number | boolean} str\n */\nfunction encodeDashes(str) {\n  // Replace dashes with encoded \"\\-\"\n  return encodeURIComponent(str).replace(\n    /-/g,\n    (char) => `%5C%${char.charCodeAt(0).toString(16).toUpperCase()}`,\n  );\n}\n","import { defaults, find } from \"../../shared/common.js\";\nimport { propEq } from \"../../shared/hof.js\";\nimport { Glob } from \"../glob/glob.js\";\nimport { hasOwn, isFunction, isObject } from \"../../shared/utils.js\";\n\n/** @typedef {import(\"../params/param.js\").Param} Param */\n/** @typedef {import(\"../resolve/resolvable.js\").Resolvable} Resolvable */\n\n/**\n * Internal representation of a ng-router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration._state]]) which returns the corresponding [[StateObject]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n * @extends {ng.StateDeclaration}\n */\nexport class StateObject {\n  /**\n   * @type {string}\n   */\n  name;\n  /**\n   * @type {{ url: any; } | undefined | null}\n   */\n  navigable;\n\n  /** @type {StateObject | undefined} */\n  parent;\n\n  /**\n   * @type {ArrayLike<Param> | undefined}\n   */\n  params;\n\n  /**\n   * @type {{ parameter: (arg0: any, arg1: {}) => any; } | undefined}\n   */\n  url;\n\n  /**\n   * @type {any}\n   */\n  includes;\n  /**\n   * @type {StateObject[] | undefined}\n   */\n  path;\n\n  /**\n   * @type {any}\n   */\n  views;\n\n  /**\n   * A list of [[Resolvable]] objects.  The internal representation of [[resolve]].\n   * @type {Resolvable[] | undefined}\n   */\n  resolvables;\n\n  /**\n   * @param {import('./interface.ts').StateDeclaration} config\n   */\n  constructor(config) {\n    Object.assign(this, config);\n\n    /**\n     * @type {ng.StateDeclaration}\n     */\n    this.self = config;\n\n    this.name = config.name;\n\n    /**\n     * @type {?Glob}\n     */\n    const nameGlob = this.name ? Glob.fromString(this.name) : null;\n\n    this._stateObjectCache = { nameGlob };\n  }\n\n  /** @returns {StateObject} */\n  _state() {\n    return this;\n  }\n\n  /**\n   * Returns true if the provided parameter is the same state.\n   *\n   * Compares the identity of the state against the passed value, which is either an object\n   * reference to the actual `State` instance, the original definition object passed to\n   * `$stateProvider.state()`, or the fully-qualified name.\n   *\n   * @param {any} ref Can be one of (a) a `State` instance, (b) an object that was passed\n   *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n   * @returns Returns `true` if `ref` matches the current `State` instance.\n   */\n  is(ref) {\n    return this === ref || this.self === ref || this.fqn() === ref;\n  }\n\n  /**\n   * @deprecated this does not properly handle dot notation\n   * @returns {string} Returns a dot-separated name of the state.\n   */\n  fqn() {\n    if (!this.parent || !(this.parent instanceof this.constructor))\n      return this.name;\n    const name = this.parent.fqn();\n\n    return name ? `${name}.${this.name}` : this.name;\n  }\n\n  /**\n   * Returns the root node of this state's tree.\n   *\n   * @returns {StateObject} The root of this state's tree.\n   */\n  root() {\n    return (this.parent && this.parent.root()) || this;\n  }\n\n  /**\n   * Gets the state's `Param` objects\n   *\n   * Gets the list of [[Param]] objects owned by the state.\n   * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n   * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n   *\n   * @param {Partial<Param>} [opts] options\n   * @returns {Param[]} the list of [[Param]] objects\n   */\n  parameters(opts) {\n    const params = /** @type {Param} */ (\n      defaults(opts, { inherit: true, matchingKeys: null })\n    );\n\n    const inherited =\n      (params.inherit && this.parent && this.parent.parameters()) || [];\n\n    return inherited\n      .concat(Object.values(/** @type {ArrayLike<Param>} */ (this.params)))\n      .filter(\n        (param) =>\n          !params.matchingKeys || hasOwn(params.matchingKeys, param.id),\n      );\n  }\n\n  /**\n   * Returns a single [[Param]] that is owned by the state\n   *\n   * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n   * @param {string} id the name of the [[Param]] to return\n   * @param {Param} [opts] options\n   * @returns {Param | undefined} the [[Param]] object, or undefined if it does not exist\n   */\n  parameter(id, opts = /** @type {Param} */ ({})) {\n    return (\n      (this.url && this.url.parameter(id, opts)) ||\n      find(\n        Object.values(/** @type {ArrayLike<Param>} */ (this.params)),\n        propEq(\"id\", id),\n      ) ||\n      (opts.inherit && this.parent && this.parent.parameter(id))\n    );\n  }\n\n  toString() {\n    return this.fqn();\n  }\n}\n/** Predicate which returns true if the object is a [[StateDeclaration]] object */\nStateObject.isStateDeclaration = (\n  /** @type {StateObject | import(\"../state/interface.js\").StateDeclaration} */ obj,\n) => isFunction(obj._state);\n\n/** Predicate which returns true if the object is an internal [[StateObject]] object */\nStateObject.isState = (/** @type {any} */ obj) =>\n  isObject(obj._stateObjectCache);\n","import { UrlMatcher } from \"./url-matcher.js\";\nimport {\n  assert,\n  isDefined,\n  isFunction,\n  isString,\n  isUndefined,\n} from \"../../shared/utils.js\";\nimport { is, pattern } from \"../../shared/hof.js\";\nimport { StateObject } from \"../state/state-object.js\";\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n */\n\nconst LOWEST = 0.000001;\n\nexport class UrlRuleFactory {\n  /**\n   * @param {ng.UrlService} urlService\n   * @param {ng.StateService} stateService\n   * @param {ng.RouterService} routerGlobals\n   */\n  constructor(urlService, stateService, routerGlobals) {\n    /** @type {ng.UrlService} */\n    this.urlService = urlService;\n\n    /** @type {ng.StateService} */\n    this.stateService = stateService;\n\n    /** @type {ng.RouterService} */\n    this.routerGlobals = routerGlobals;\n  }\n\n  /**\n   *\n   * @param {StateObject} what\n   * @param {*} [handler]\n   * @returns {import(\"./url-rules.js\").UrlRule}\n   */\n  create(what, handler) {\n    const { isState, isStateDeclaration } = StateObject;\n\n    const makeRule = pattern([\n      [\n        isString,\n        (/** @type {string} */ _what) =>\n          makeRule(this.urlService.compile(_what)),\n      ],\n      [\n        is(UrlMatcher),\n        (/** @type {any} */ _what) => this.fromUrlMatcher(_what, handler),\n      ],\n      [\n        (/** @type {any} */ _what) =>\n          isState(_what) || isStateDeclaration(_what),\n        (/** @type {any} */ _what) =>\n          this.fromState(_what, this.stateService, this.routerGlobals),\n      ],\n      [\n        is(RegExp),\n        (/** @type {any} */ _what) => this.fromRegExp(_what, handler),\n      ],\n      [\n        isFunction,\n        (/** @type {import(\"./interface.js\").UrlRuleMatchFn} */ _what) =>\n          new BaseUrlRule(_what, handler),\n      ],\n    ]);\n\n    const rule = makeRule(what);\n\n    if (!rule) throw new Error(\"invalid 'what' in when()\");\n\n    return rule;\n  }\n\n  /**\n   * A UrlRule which matches based on a UrlMatcher\n   *\n   * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   *\n   * ## Handler as UrlMatcher\n   *\n   * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n   * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n   * The url is replaced with the result.\n   *\n   * #### Example:\n   * ```js\n   * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n   * var handler = $umf.compile(\"/home/:fooId/:barId\");\n   * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match); // '/home/123/456'\n   * ```\n   * @param {UrlMatcher} urlMatcher\n   * @param {string | UrlMatcher | import(\"./interface.js\").UrlRuleHandlerFn} handler\n   * @returns {import(\"./interface.js\").MatcherUrlRule}\n   */\n  fromUrlMatcher(urlMatcher, handler) {\n    let _handler = handler;\n\n    if (isString(handler)) handler = this.urlService.compile(handler);\n\n    if (is(UrlMatcher)(handler)) {\n      const matcher = /** @type {UrlMatcher} */ (handler);\n\n      _handler = (match) => {\n        const url = matcher.format(match); // string | null\n\n        return url === null ? undefined : url; // string | void\n      };\n    }\n    /**\n     * @param {import(\"./interface.js\").UrlParts} url\n     * @returns {import(\"../params/interface.js\").RawParams | boolean | null}\n     */\n    function matchUrlParamters(url) {\n      const params = urlMatcher.exec(\n        url.path,\n        url.search,\n        /** @type {string} */ (url.hash),\n      );\n\n      return (\n        urlMatcher.validates(\n          /** @type {import(\"../params/interface.js\").RawParams} */ (params),\n        ) && params\n      );\n    }\n    // Prioritize URLs, lowest to highest:\n    // - Some optional URL parameters, but none matched\n    // - No optional parameters in URL\n    // - Some optional parameters, some matched\n    // - Some optional parameters, all matched\n    /**\n     * @param {import(\"../params/interface.js\").RawParams} params\n     * @returns {number}\n     */\n    function matchPriority(params) {\n      const optional = urlMatcher\n        .parameters()\n        .filter((param) => param.isOptional);\n\n      if (!optional.length) return LOWEST;\n      const matched = optional.filter((param) => params[param.id]);\n\n      return matched.length / optional.length;\n    }\n    /** @type {{ urlMatcher: UrlMatcher; matchPriority: (params: import(\"../params/interface.js\").RawParams) => number; type: \"URLMATCHER\" }} */\n    const details = { urlMatcher, matchPriority, type: \"URLMATCHER\" };\n\n    return /** @type {import(\"./interface.js\").MatcherUrlRule} */ (\n      Object.assign(\n        new BaseUrlRule(\n          matchUrlParamters,\n          /** @type {import(\"./interface.js\").UrlRuleHandlerFn} */ (_handler),\n        ),\n        details,\n      )\n    );\n  }\n\n  /**\n   * A UrlRule which matches a state by its url\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromState($state.get('foo'), router);\n   * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n   * var result = rule.handler(match);\n   * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n   * ```\n   * @param {StateObject | import(\"../state/interface.js\").StateDeclaration} stateOrDecl\n   * @param {import(\"../state/state-service.js\").StateProvider} stateService\n   * @param {import(\"../router.js\").RouterProvider} globals\n   * @returns {import(\"./interface.js\").StateRule}\n   */\n  fromState(stateOrDecl, stateService, globals) {\n    const state = StateObject.isStateDeclaration(stateOrDecl)\n      ? /** @type {StateObject} */ (stateOrDecl)?._state()\n      : stateOrDecl;\n\n    /**\n     * Handles match by transitioning to matched state\n     *\n     * First checks if the router should start a new transition.\n     * A new transition is not required if the current state's URL\n     * and the new URL are already identical\n     */\n    const handler = (\n      /** @type {import(\"../params/interface.js\").RawParams} */ match,\n    ) => {\n      const $state = stateService;\n\n      if (\n        $state.href(state, match) !==\n        $state.href(\n          /** @type {import(\"../state/interface.js\").StateDeclaration} */ (\n            globals.current\n          ),\n          globals.params,\n        )\n      ) {\n        $state.transitionTo(state, match, { inherit: true, source: \"url\" });\n      }\n    };\n\n    const details = { state, type: \"STATE\" };\n\n    return /** @type {import(\"./interface.js\").StateRule} */ (\n      Object.assign(\n        this.fromUrlMatcher(/** @type {UrlMatcher} */ (state.url), handler),\n        details,\n      )\n    );\n  }\n\n  /**\n   * A UrlRule which matches based on a regular expression\n   *\n   * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n   *\n   * ## Handler as a function\n   *\n   * If `handler` is a function, the function is invoked with:\n   *\n   * - regexp match array (from `regexp`)\n   * - url: the current Url ([[UrlParts]])\n   * - router: the router object ([[UIRouter]])\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   *\n   * ## Handler as string\n   *\n   * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n   * The string is first interpolated using `string.replace()` style pattern.\n   *\n   * #### Example:\n   * ```js\n   * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n   * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n   * var result = rule.handler(match); // '/home/bar'\n   * ```\n   * @param {RegExp} regexp\n   * @param {string | import(\"./interface.js\").UrlRuleHandlerFn} handler\n   * @returns {import(\"./interface.js\").RegExpRule}\n   */\n  fromRegExp(regexp, handler) {\n    if (regexp.global || regexp.sticky)\n      throw new Error(\"Rule RegExp must not be global or sticky\");\n    /**\n     * If handler is a string, the url will be replaced by the string.\n     * If the string has any String.replace() style variables in it (like `$2`),\n     * they will be replaced by the captures from [[match]]\n     */\n    const redirectUrlTo = (/** @type {RegExpExecArray} */ match) =>\n      // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n      /** @type {string} */ (handler).replace(\n        /\\$(\\$|\\d{1,2})/,\n        (_, what) => match[what === \"$\" ? 0 : Number(what)],\n      );\n\n    const _handler = isString(handler) ? redirectUrlTo : handler;\n\n    const matchParamsFromRegexp = (\n      /** @type {import(\"./interface.js\").UrlParts} */ url,\n    ) => regexp.exec(url.path);\n\n    const details = { regexp, type: \"REGEXP\" };\n\n    return /** @type {import(\"./interface.js\").RegExpRule} */ (\n      Object.assign(\n        new BaseUrlRule(\n          /** @type  {import(\"./interface.js\").UrlRuleMatchFn} */ (\n            matchParamsFromRegexp\n          ),\n          _handler,\n        ),\n        details,\n      )\n    );\n  }\n}\n\nUrlRuleFactory.isUrlRule = (/** @type {{ [x: string]: any; }} */ obj) =>\n  obj && [\"type\", \"match\", \"handler\"].every((key) => isDefined(obj[key]));\n\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n */\nexport class BaseUrlRule {\n  /**\n   * @param {import(\"./interface.js\").UrlRuleMatchFn} match\n   * @param {import(\"./interface.js\").UrlRuleHandlerFn} handler\n   */\n  constructor(match, handler) {\n    /**\n     * @type {import(\"./interface.js\").UrlRuleMatchFn}\n     */\n    this.match = match;\n\n    /**\n     * @type {import(\"./interface.js\").UrlRuleType}\n     */\n    this.type = \"RAW\";\n\n    /**\n     * @type {number}\n     */\n    this.$id = -1;\n\n    /**\n     * @type {number | undefined}\n     */\n    this._group = undefined;\n\n    /**\n     * @type {import(\"./interface.js\").UrlRuleHandlerFn}\n     */\n    this.handler = handler || ((x) => x);\n\n    /**\n     * @type {number | undefined}\n     */\n    this.priority = undefined;\n  }\n\n  /**\n   * This function should be overridden\n   * @param {*} [params]\n   * @returns {number}\n   */\n  matchPriority(params) {\n    assert(isUndefined(params));\n\n    return 0 - this.$id;\n  }\n}\n","import { UrlMatcher } from \"./url-matcher.js\";\nimport { isDefined } from \"../../shared/utils.js\";\nimport { removeFrom } from \"../../shared/common.js\";\nimport { UrlRuleFactory } from \"./url-rule.js\";\n\n/** @typedef {import(\"./interface.ts\").UrlRule} UrlRule */\n/** @typedef {import(\"./interface.ts\").MatcherUrlRule} MatcherUrlRule */\n/** @typedef {import(\"./url-rule.js\").BaseUrlRule} BaseUrlRule */\n\n/**\n * @param {{ priority: any; }} a\n * @param {{ priority: any; }} b\n */\nfunction prioritySort(a, b) {\n  return (b.priority || 0) - (a.priority || 0);\n}\n\nconst typeSort = (\n  /** @type {{ type: string | number; }} */ a,\n  /** @type {{ type: string | number; }} */ b,\n) => {\n  const weights = /** @type {Record<string, any>} */ ({\n    STATE: 4,\n    URLMATCHER: 4,\n    REGEXP: 3,\n    RAW: 2,\n    OTHER: 1,\n  });\n\n  return (weights[a.type] || 0) - (weights[b.type] || 0);\n};\n\nconst urlMatcherSort = (\n  /** @type {MatcherUrlRule} */ a,\n  /** @type {MatcherUrlRule} */ b,\n) =>\n  !a.urlMatcher || !b.urlMatcher\n    ? 0\n    : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);\n\nconst idSort = (\n  /** @type {{ type: string | number; $id: any; }} */ a,\n  /** @type {{ type: string | number; $id: any; }} */ b,\n) => {\n  // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL\n  const useMatchPriority = /** @type {Record<string, any>} */ ({\n    STATE: true,\n    URLMATCHER: true,\n  });\n\n  const equal = useMatchPriority[a.type] && useMatchPriority[b.type];\n\n  return equal ? 0 : (a.$id || 0) - (b.$id || 0);\n};\n\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRules.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Rule registration order (for rule types other than STATE and URLMATCHER)\n *   - Equally sorted State and UrlMatcher rules will each match the URL.\n *     Then, the *best* match is chosen based on how many parameter values were matched.\n * @param {UrlRule} a\n * @param {UrlRule} b\n */\nfunction defaultRuleSortFn(a, b) {\n  let cmp = prioritySort(a, b);\n\n  if (cmp !== 0) return cmp;\n  cmp = typeSort(a, b);\n\n  if (cmp !== 0) return cmp;\n  cmp = urlMatcherSort(\n    /** @type {MatcherUrlRule} */ (a),\n    /** @type {MatcherUrlRule} */ (b),\n  );\n\n  if (cmp !== 0) return cmp;\n\n  return idSort(a, b);\n}\n\n/**\n * API for managing URL rules\n *\n * This API is used to create and manage URL rules.\n * URL rules are a mechanism to respond to specific URL patterns.\n *\n * The most commonly used methods are [[otherwise]] and [[when]].\n *\n * This API is found at `$url.rules` (see: [[UIRouter.urlService]], [[URLService.rules]])\n */\nexport class UrlRules {\n  /** @param {UrlRuleFactory} urlRuleFactory */\n  constructor(urlRuleFactory) {\n    this._sortFn = defaultRuleSortFn;\n    /**\n     * @type {UrlRule[]}\n     */\n    this._rules = [];\n    this._id = 0;\n    this._urlRuleFactory = urlRuleFactory;\n  }\n\n  /**\n   * Remove a rule previously registered\n   * @param {UrlRule} rule the matcher rule that was previously registered using [[rule]]\n   */\n  removeRule(rule) {\n    removeFrom(this._rules, rule);\n  }\n\n  /**\n   * Manually adds a URL Rule.\n   *\n   * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n   * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n   * Rules can be created using [[urlRuleFactory]], or created manually as simple objects.\n   *\n   * A rule should have a `match` function which returns truthy if the rule matched.\n   * It should also have a `handler` function which is invoked if the rule is the best match.\n   *\n   * @param {UrlRule} rule the rule to register\n   * @returns {() => void } a function that deregisters the rule\n   */\n  rule(rule) {\n    if (!UrlRuleFactory.isUrlRule(rule)) throw new Error(\"invalid rule\");\n    rule.$id = this._id++;\n    rule.priority = rule.priority || 0;\n    this._rules.push(rule);\n    this._sorted = false;\n\n    return () => this.removeRule(rule);\n  }\n\n  /**\n   * Gets all registered rules\n   *\n   * @returns {import(\"./interface.ts\").UrlRule[]} an array of all the registered rules\n   */\n  rules() {\n    this.ensureSorted();\n\n    return this._rules;\n  }\n\n  /**\n   * Defines URL Rule priorities\n   *\n   * More than one rule ([[UrlRule]]) might match a given URL.\n   * This `compareFn` is used to sort the rules by priority.\n   * Higher priority rules should sort earlier.\n   *\n   * The [[defaultRuleSortFn]] is used by default.\n   *\n   * You only need to call this function once.\n   * The `compareFn` will be used to sort the rules as each is registered.\n   *\n   * If called without any parameter, it will re-sort the rules.\n   *\n   * ---\n   *\n   * Url rules may come from multiple sources: states's urls ([[StateDeclaration.url]]), [[when]], and [[rule]].\n   * Each rule has a (user-provided) [[UrlRule.priority]], a [[UrlRule.type]], and a [[UrlRule.$id]]\n   * The `$id` is is the order in which the rule was registered.\n   *\n   * The sort function should use these data, or data found on a specific type\n   * of [[UrlRule]] (such as [[StateRule.state]]), to order the rules as desired.\n   *\n   * #### Example:\n   * This compare function prioritizes rules by the order in which the rules were registered.\n   * A rule registered earlier has higher priority.\n   *\n   * ```js\n   * function compareFn(a, b) {\n   *   return a.$id - b.$id;\n   * }\n   * ```\n   * @param {((a: UrlRule, b: UrlRule) => number) | undefined} [compareFn] a function that compares to [[UrlRule]] objects.\n   * The `compareFn` should abide by the `Array.sort` compare function rules.\n   * Given two rules, `a` and `b`, return a negative number if `a` should be higher priority.\n   * Return a positive number if `b` should be higher priority.\n   * Return `0` if the rules are identical.\n   * See the [mozilla reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description)\n   * for details.\n   */\n  sort(compareFn) {\n    const sorted = this.stableSort(\n      this._rules,\n      (this._sortFn = compareFn || this._sortFn),\n    );\n\n    // precompute _sortGroup values and apply to each rule\n    let group = 0;\n\n    for (let i = 0; i < sorted.length; i++) {\n      sorted[i]._group = group;\n\n      if (\n        i < sorted.length - 1 &&\n        this._sortFn(sorted[i], sorted[i + 1]) !== 0\n      ) {\n        group++;\n      }\n    }\n    this._rules = sorted;\n    this._sorted = true;\n  }\n\n  ensureSorted() {\n    this._sorted || this.sort();\n  }\n\n  /**\n   * @param {any[]} arr\n   * @param {(arg0: any, arg1: any) => any} compareFn\n   */\n  stableSort(arr, compareFn) {\n    const arrOfWrapper = arr.map((elem, idx) => ({ elem, idx }));\n\n    arrOfWrapper.sort((wrapperA, wrapperB) => {\n      const cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);\n\n      return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;\n    });\n\n    return arrOfWrapper.map((wrapper) => wrapper.elem);\n  }\n\n  /**\n   * Registers a `matcher` and `handler` for custom URLs handling.\n   *\n   * The `matcher` can be:\n   *\n   * - a [[UrlMatcher]]: See: [[UrlMatcherFactory.compile]]\n   * - a `string`: The string is compiled to a [[UrlMatcher]]\n   * - a `RegExp`: The regexp is used to match the url.\n   *\n   * The `handler` can be:\n   *\n   * - a string: The url is redirected to the value of the string.\n   * - a function: The url is redirected to the return value of the function.\n   *\n   * ---\n   *\n   * When the `handler` is a `string` and the `matcher` is a `UrlMatcher` (or string), the redirect\n   * string is interpolated with parameter values.\n   *\n   * #### Example:\n   * When the URL is `/foo/123` the rule will redirect to `/bar/123`.\n   * ```js\n   * .when(\"/foo/:param1\", \"/bar/:param1\")\n   * ```\n   *\n   * ---\n   *\n   * When the `handler` is a string and the `matcher` is a `RegExp`, the redirect string is\n   * interpolated with capture groups from the RegExp.\n   *\n   * #### Example:\n   * When the URL is `/foo/123` the rule will redirect to `/bar/123`.\n   * ```js\n   * .when(new RegExp(\"^/foo/(.*)$\"), \"/bar/$1\");\n   * ```\n   *\n   * ---\n   *\n   * When the handler is a function, it receives the matched value, the current URL, and the `UIRouter` object (See [[UrlRuleHandlerFn]]).\n   * The \"matched value\" differs based on the `matcher`.\n   * For [[UrlMatcher]]s, it will be the matched state params.\n   * For `RegExp`, it will be the match array from `regexp.exec()`.\n   *\n   * If the handler returns a string, the URL is redirected to the string.\n   *\n   * #### Example:\n   * When the URL is `/foo/123` the rule will redirect to `/bar/123`.\n   * ```js\n   * .when(new RegExp(\"^/foo/(.*)$\"), match => \"/bar/\" + match[1]);\n   * ```\n   *\n   * Note: the `handler` may also invoke arbitrary code, such as `$state.go()`\n   * @param {import(\"../state/state-object.js\").StateObject} matcher A pattern `string` to match, compiled as a [[UrlMatcher]], or a `RegExp`.\n   * @param {any} handler The path to redirect to, or a function that returns the path.\n   * @param {{ priority: any; }} options `{ priority: number }`\n   * @return {UrlRule} the registered [[UrlRule]]\n   */\n  when(matcher, handler, options) {\n    const rule = this._urlRuleFactory.create(matcher, handler);\n\n    if (isDefined(options && options.priority))\n      rule.priority = options.priority;\n    this.rule(rule);\n\n    return rule;\n  }\n}\n","import { DefType, Param } from \"./param.js\";\n\n/** @typedef {import(\"./param-type.js\").ParamType} ParamType */\n\nexport class ParamFactory {\n  /**\n   * @param {import(\"../url/url-config.js\").UrlConfigProvider} urlServiceConfig\n   */\n  constructor(urlServiceConfig) {\n    /**\n     * @type {import(\"../url/url-config.js\").UrlConfigProvider}\n     */\n    this.urlServiceConfig = urlServiceConfig;\n  }\n\n  /**\n   * @param {string} id\n   * @param {ParamType | null} type\n   * @param {ng.StateDeclaration} state\n   */\n  fromConfig(id, type, state) {\n    return new Param(id, type, DefType._CONFIG, this.urlServiceConfig, state);\n  }\n\n  /**\n   * @param {string} id\n   * @param {ParamType} type\n   * @param {ng.StateDeclaration} state\n   */\n  fromPath(id, type, state) {\n    return new Param(id, type, DefType._PATH, this.urlServiceConfig, state);\n  }\n\n  /**\n   * @param {string} id\n   * @param {ParamType} type\n   * @param {ng.StateDeclaration} state\n   */\n  fromSearch(id, type, state) {\n    return new Param(id, type, DefType._SEARCH, this.urlServiceConfig, state);\n  }\n}\n","import {\n  entries,\n  isDefined,\n  isFunction,\n  isNull,\n  isObject,\n  isString,\n} from \"../../shared/utils.js\";\nimport { is, pattern } from \"../../shared/hof.js\";\nimport { UrlRules } from \"./url-rules.js\";\nimport { TargetState } from \"../state/target-state.js\";\nimport { removeFrom } from \"../../shared/common.js\";\nimport { stripLastPathElement } from \"../../shared/strings.js\";\nimport { UrlMatcher } from \"./url-matcher.js\";\nimport { ParamFactory } from \"../params/param-factory.js\";\nimport { UrlRuleFactory } from \"./url-rule.js\";\nimport { getBaseHref } from \"../../shared/dom.js\";\nimport { $injectTokens as $t, provider } from \"../../injection-tokens.js\";\n\n/**\n * API for URL management\n */\nexport class UrlService {\n  /* @ignore */ static $inject = provider([\n    $t._location,\n    $t._state,\n    $t._router,\n    $t._urlConfig,\n  ]);\n\n  /** @type {ng.LocationService | undefined} */\n  $location;\n\n  /**\n   * @param {ng.LocationProvider} $locationProvider\n   * @param {import(\"../../router/state/state-service.js\").StateProvider} stateProvider\n   * @param {import(\"../router.js\").RouterProvider} globals\n   * @param {import(\"../../router/url/url-config.js\").UrlConfigProvider} urlConfigProvider\n   */\n  constructor($locationProvider, stateProvider, globals, urlConfigProvider) {\n    /** @private */\n\n    this._locationProvider = $locationProvider;\n    this.stateService = stateProvider;\n\n    /**\n     * @type {UrlRuleFactory} Provides services related to the URL\n     * @ignore\n     */\n    this._urlRuleFactory = new UrlRuleFactory(this, stateProvider, globals);\n\n    /**\n     * The nested [[UrlRules]] API for managing URL rules and rewrites\n     * @ignore\n     * @type {UrlRules}\n     */\n    this._rules = new UrlRules(this._urlRuleFactory);\n    /**\n     * The nested [[UrlConfig]] API to configure the URL and retrieve URL information\n     * @ignore\n     * @type {import(\"./url-config.js\").UrlConfigProvider}\n     */\n    this._config = urlConfigProvider;\n\n    /**\n     * @type {ParamFactory} Creates a new [[Param]] for a given location (DefType)\n     * @ignore\n     */\n    this._paramFactory = new ParamFactory(this._config);\n\n    /**\n     * @type {((evt: ng.ScopeEvent) => void)[]}\n     * @ignore\n     */\n    this._urlListeners = [];\n  }\n\n  /**\n   * Gets the path part of the current url\n   *\n   * If the current URL is `/some/path?query=value#anchor`, this returns `/some/path`\n   *\n   * @return {string} the path portion of the url\n   */\n  getPath() {\n    return /** @type {ng.LocationService} */ (this.$location).getPath();\n  }\n\n  /**\n   * Gets the search part of the current url as an object\n   *\n   * If the current URL is `/some/path?query=value#anchor`, this returns `{ query: 'value' }`\n   *\n   * @return {Object} the search (query) portion of the url, as an object\n   */\n  getSearch() {\n    return /** @type {ng.LocationService} */ (this.$location).getSearch();\n  }\n\n  /**\n   * Gets the hash part of the current url\n   *\n   * If the current URL is `/some/path?query=value#anchor`, this returns `anchor`\n   *\n   * @return {string} the hash (anchor) portion of the url\n   */\n  getHash() {\n    return /** @type {ng.LocationService} */ (this.$location).getHash();\n  }\n\n  $get = [\n    $t._location,\n    $t._rootScope,\n    /**\n     *\n     * @param {ng.LocationService} $location\n     * @param {ng.RootScopeService} $rootScope\n     * @returns {ng.UrlService}\n     */\n    ($location, $rootScope) => {\n      this.$location = $location;\n      $rootScope.$on(\n        \"$locationChangeSuccess\",\n        /** @param {ng.ScopeEvent} evt */ (evt) => {\n          for (let i = 0, j = this._urlListeners.length; i < j; i++) {\n            this._urlListeners[i](evt);\n          }\n        },\n      );\n      this.listen(true);\n\n      return this;\n    },\n  ];\n\n  /**\n   * @returns {string}\n   */\n  baseHref() {\n    return (\n      this._baseHref ||\n      (this._baseHref = getBaseHref() || window.location.pathname)\n    );\n  }\n\n  /**\n   * Gets the current url, or updates the url\n   *\n   * ### Getting the current URL\n   *\n   * When no arguments are passed, returns the current URL.\n   * The URL is normalized using the internal [[path]]/[[search]]/[[hash]] values.\n   *\n   * For example, the URL may be stored in the hash ([[HashLocationServices]]) or\n   * have a base HREF prepended ([[PushStateLocationServices]]).\n   *\n   * The raw URL in the browser might be:\n   *\n   * ```\n   * http://mysite.com/somepath/index.html#/internal/path/123?param1=foo#anchor\n   * ```\n   *\n   * or\n   *\n   * ```\n   * http://mysite.com/basepath/internal/path/123?param1=foo#anchor\n   * ```\n   *\n   * then this method returns:\n   *\n   * ```\n   * /internal/path/123?param1=foo#anchor\n   * ```\n   *\n   *\n   * #### Example:\n   * ```js\n   * locationServices.url(); // \"/some/path?query=value#anchor\"\n   * ```\n   *\n   * ### Updating the URL\n   *\n   * When `newurl` arguments is provided, changes the URL to reflect `newurl`\n   *\n   * #### Example:\n   * ```js\n   * locationServices.url(\"/some/path?query=value#anchor\", true);\n   * ```\n   *\n   * @param {string} [newUrl] The new value for the URL.\n   *               This url should reflect only the new internal [[path]], [[search]], and [[hash]] values.\n   *               It should not include the protocol, site, port, or base path of an absolute HREF.\n   * @param {any} [state] The history's state object, i.e., pushState (if the LocationServices implementation supports it)\n   *\n   * @return the url (after potentially being processed)\n   */\n  url(newUrl, state) {\n    if (isDefined(newUrl)) {\n      const decodeUri = decodeURIComponent(newUrl);\n\n      /** @type {ng.LocationService} */ (this.$location).setUrl(decodeUri);\n    }\n\n    if (state)\n      /** @type {ng.LocationService} */ (this.$location).setState(state);\n\n    return /** @type {ng.LocationService} */ (this.$location).getUrl();\n  }\n\n  /**\n   * @private\n   *\n   * Registers a low level url change handler\n   *\n   * Note: Because this is a low level handler, it's not recommended for general use.\n   *\n   * #### Example:\n   * ```js\n   * let deregisterFn = locationServices.onChange((evt) => console.log(\"url change\", evt));\n   * ```\n   *\n   * @param {(evt: ng.ScopeEvent) => void} callback a function that will be called when the url is changing\n   * @return {() => void} a function that de-registers the callback\n   */\n  onChange(callback) {\n    this._urlListeners.push(callback);\n\n    return () => removeFrom(this._urlListeners, callback);\n  }\n\n  /**\n   * Gets the current URL parts.\n   *\n   * Returns an object with the `path`, `search`, and `hash` components\n   * of the current browser location.\n   *\n   * @returns {import(\"../../services/location/interface.ts\").UrlParts} The current URL's path, search, and hash.\n   */\n  parts() {\n    return {\n      path: /** @type {ng.LocationService} */ (this.$location).getPath(),\n      search: /** @type {ng.LocationService} */ (this.$location).getSearch(),\n      hash: /** @type {ng.LocationService} */ (this.$location).getHash(),\n    };\n  }\n\n  /**\n   * Activates the best rule for the current URL\n   *\n   * Checks the current URL for a matching [[UrlRule]], then invokes that rule's handler.\n   * This method is called internally any time the URL has changed.\n   *\n   * This effectively activates the state (or redirect, etc) which matches the current URL.\n   *\n   * #### Example:\n   * ```js\n   *\n   * fetch('/states.json').then(resp => resp.json()).then(data => {\n   *   data.forEach(state => $stateRegistry.register(state));\n   *   urlService.listen();\n   *   // Find the matching URL and invoke the handler.\n   *   urlService.sync();\n   * });\n   * ```\n   * @param {import(\"../../core/scope/interface.ts\").ScopeEvent | undefined} [evt]\n   */\n  sync(evt) {\n    if (evt && evt.defaultPrevented) return;\n    const { stateService } = this;\n\n    const url = {\n      path: /** @type {ng.LocationService} */ (this.$location).getPath(),\n      search: /** @type {ng.LocationService} */ (this.$location).getSearch(),\n      hash: /** @type {ng.LocationService} */ (this.$location).getHash(),\n    };\n\n    /**\n     * @type {*}\n     */\n    const best = this.match(url);\n\n    const applyResult = pattern([\n      [\n        isString,\n        (/** @type {string | undefined} */ newurl) => this.url(newurl),\n      ],\n      [\n        TargetState.isDef,\n        /** @param {import(\"../state/interface.ts\").TargetStateDef} def */ (\n          def,\n        ) =>\n          stateService.go(\n            /** @type {string} */ (def.state),\n            def.params,\n            def.options,\n          ),\n      ],\n      [\n        is(TargetState),\n        (/** @type {TargetState} */ target) =>\n          stateService.go(\n            /** @type {ng.StateDeclaration} */ (target.state()),\n            target.params(),\n            target.options(),\n          ),\n      ],\n    ]);\n\n    applyResult(best && best.rule.handler(best.match, url));\n  }\n\n  /**\n   * Starts or stops listening for URL changes\n   *\n   * Call this sometime after calling [[deferIntercept]] to start monitoring the url.\n   * This causes ng-router to start listening for changes to the URL, if it wasn't already listening.\n   *\n   * If called with `false`, ng-router will stop listening (call listen(true) to start listening again).\n   *\n   * #### Example:\n   * ```js\n   *\n   * fetch('/states.json').then(resp => resp.json()).then(data => {\n   *   data.forEach(state => $stateRegistry.register(state));\n   *   // Start responding to URL changes\n   *   urlService.listen();\n   *   urlService.sync();\n   * });\n   * ```\n   *\n   * @param {boolean} enabled `true` or `false` to start or stop listening to URL changes\n   */\n  listen(enabled) {\n    if (enabled === false) {\n      this._stopListeningFn && this._stopListeningFn();\n      delete this._stopListeningFn;\n\n      return undefined;\n    } else {\n      return (this._stopListeningFn =\n        this._stopListeningFn || this.onChange((evt) => this.sync(evt)));\n    }\n  }\n\n  /**\n   * Given a URL (as a [[UrlParts]] object), check all rules and determine the best matching rule.\n   * Return the result as a [[MatchResult]].\n   * @param {import(\"../../docs.ts\").UrlParts} url\n   * @returns {any}\n   */\n  match(url) {\n    url = Object.assign({ path: \"\", search: {}, hash: \"\" }, url);\n    const rules = this._rules.rules();\n\n    // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n    /**\n     *\n     * @param {import(\"./interface.ts\").UrlRule} rule\n     */\n    const checkRule = (rule) => {\n      const match = rule.match(url);\n\n      return match && { match, rule, weight: rule.matchPriority(match) };\n    };\n\n    // The rules are pre-sorted.\n    // - Find the first matching rule.\n    // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n    // - Choose the rule with the highest match weight.\n    let best;\n\n    for (let i = 0; i < rules.length; i++) {\n      // Stop when there is a 'best' rule and the next rule sorts differently than it.\n      if (best && best.rule._group !== rules[i]._group) break;\n      const current = checkRule(rules[i]);\n\n      // Pick the best MatchResult\n      best =\n        !best || (current && current.weight > best.weight) ? current : best;\n    }\n\n    return best;\n  }\n\n  /**\n   * @param {boolean | undefined} [read]\n   */\n  update(read) {\n    if (read) {\n      this.location = this.url();\n\n      return;\n    }\n\n    if (this.url() === this.location) return;\n    this.url(/** @type {string} */ (this.location), true);\n  }\n\n  /**\n   * Internal API.\n   *\n   * Pushes a new location to the browser history.\n   * @internal\n   * @param {{ format: (arg0: any) => string | undefined; }} urlMatcher\n   * @param {import(\"../params/state-params.js\").StateParams} params\n   * @param {string} options\n   */\n  push(urlMatcher, params, options) {\n    const replace = options && !!options.replace;\n\n    this.url(urlMatcher.format(params || {}), replace);\n  }\n\n  /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $url.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     * @param {{ format: (arg0: any) => any; }} urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param {Object} params An object of parameter values to fill the matcher's required parameters.\n     * @param {{ absolute: any; }} options Options object. The options are:\n\n    - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n  href(urlMatcher, params, options) {\n    let url = urlMatcher.format(params);\n\n    if (isNull(url)) return null;\n    options = options || { absolute: false };\n    const isHtml5 = this._locationProvider.html5ModeConf.enabled;\n\n    if (!isHtml5) {\n      url = `#${this._locationProvider.hashPrefixConf}${url}`;\n    }\n    url = appendBasePath(url, isHtml5, options.absolute, this.baseHref());\n\n    if (!options.absolute || !url) {\n      return url;\n    }\n    const slash = !isHtml5 && url ? \"/\" : \"\";\n\n    return [\n      `${window.location.protocol}//`,\n      window.location.host,\n      slash,\n      url,\n    ].join(\"\");\n  }\n\n  /**\n   * Creates a [[UrlMatcher]] for the specified pattern.\n   *\n   * @param {string} urlPattern  The URL pattern.\n   * @param {*} [config]  The config object hash.\n   * @returns The UrlMatcher.\n   */\n  compile(urlPattern, config) {\n    const urlConfig = this._config;\n\n    // backward-compatible support for config.params -> config.state.params\n    const params = config && !config.state && config.params;\n\n    config = params ? Object.assign({ state: { params } }, config) : config;\n    const globalConfig = {\n      strict: urlConfig._isStrictMode,\n      caseInsensitive: urlConfig._isCaseInsensitive,\n    };\n\n    return new UrlMatcher(\n      urlPattern,\n      urlConfig.paramTypes,\n      this._paramFactory,\n      Object.assign(globalConfig, config),\n    );\n  }\n\n  /**\n   * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n   *\n   * @param {UrlMatcher & Record<string, any>} object  The object to perform the type check against.\n   * @returns `true` if the object matches the `UrlMatcher` interface, by\n   *          implementing all the same methods.\n   */\n  isMatcher(object) {\n    if (!isObject(object)) return false;\n    let result = true;\n\n    entries(UrlMatcher.prototype).forEach(([name, val]) => {\n      if (isFunction(val))\n        result = result && isDefined(object[name]) && isFunction(object[name]);\n    });\n\n    return result;\n  }\n}\n\n/**\n * @param {string} url\n * @param {boolean} isHtml5\n * @param {any} absolute\n * @param {string} baseHref\n */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n  if (baseHref === \"/\") return url;\n\n  if (isHtml5) return stripLastPathElement(baseHref) + url;\n\n  if (absolute) return baseHref.slice(1) + url;\n\n  return url;\n}\n","import { isString } from \"../../shared/utils.js\";\n\n/** @typedef {import(\"./state-object.js\").StateObject} StateObject */\n/** @typedef {import(\"./interface.ts\").StateOrName} StateOrName */\n/** @typedef {import(\"./interface.ts\").StateStore} StateStore */\n\nexport class StateMatcher {\n  /** @param {StateStore} states */\n  constructor(states) {\n    /** @type {StateStore} */\n    this._states = states;\n  }\n\n  /**\n   * @param {string} stateName\n   */\n  isRelative(stateName) {\n    stateName = stateName || \"\";\n\n    return stateName.indexOf(\".\") === 0 || stateName.indexOf(\"^\") === 0;\n  }\n\n  /**\n   * @param {StateOrName} stateOrName\n   * @param {StateOrName | undefined} [base]\n   * @returns {StateObject | undefined}\n   */\n  find(stateOrName, base, matchGlob = true) {\n    if (!stateOrName && stateOrName !== \"\") return undefined;\n    const isStr = isString(stateOrName);\n\n    let name = isStr ? stateOrName : stateOrName.name;\n\n    if (this.isRelative(name))\n      name = this.resolvePath(name, /** @type {StateOrName} */ (base));\n    const state = this._states[name];\n\n    if (\n      state &&\n      (isStr ||\n        (!isStr && (state === stateOrName || state.self === stateOrName)))\n    ) {\n      return /** @type {StateObject} */ (state);\n    } else if (isStr && matchGlob) {\n      const states = Object.values(this._states);\n\n      const matches = states.filter((stateObj) =>\n        stateObj._stateObjectCache?.nameGlob?.matches(name),\n      );\n\n      if (matches.length > 1) {\n        throw new Error(\n          `stateMatcher.find: Found multiple matches for ${name} using glob: ${matches.map((match) => match.name)}`,\n        );\n      }\n\n      return /** @type {StateObject} */ (matches[0]);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * `\n   * @param {string} name\n   * @param {StateOrName} base\n   * @returns {string}\n   */\n  resolvePath(name, base) {\n    if (!base) throw new Error(`No reference point given for path '${name}'`);\n    const baseState = this.find(base);\n\n    const splitName = name.split(\".\");\n\n    const pathLength = splitName.length;\n\n    let i = 0,\n      current = baseState;\n\n    for (; i < pathLength; i++) {\n      if (splitName[i] === \"\" && i === 0) {\n        current = baseState;\n        continue;\n      }\n\n      if (splitName[i] === \"^\") {\n        if (!current?.parent)\n          throw new Error(\n            `Path '${name}' not valid for state '${baseState?.name}'`,\n          );\n        current = current.parent;\n        continue;\n      }\n      break;\n    }\n    const relName = splitName.slice(i).join(\".\");\n\n    return current?.name + (current?.name && relName ? \".\" : \"\") + relName;\n  }\n}\n","import {\n  applyPairs,\n  copy,\n  inherit,\n  map,\n  omit,\n  tail,\n} from \"../../shared/common.js\";\nimport {\n  hasOwn,\n  isArray,\n  isDefined,\n  isFunction,\n  isString,\n} from \"../../shared/utils.js\";\nimport { stringify } from \"../../shared/strings.js\";\nimport { is, pattern, val } from \"../../shared/hof.js\";\nimport { Resolvable } from \"../resolve/resolvable.js\";\nimport { ng1ViewsBuilder } from \"./views.js\";\nimport { annotate } from \"../../core/di/di.js\";\n\n/** @typedef {import(\"./interface.js\").BuilderFunction} BuilderFunction */\n/** @typedef {import(\"./interface.js\").Builders} Builders */\n/** @typedef {import(\"../url/url-matcher.js\").UrlMatcher} UrlMatcher */\n\n/**\n * @param {unknown} url\n */\nfunction parseUrl(url) {\n  if (!isString(url)) return false;\n  const root = url.charAt(0) === \"^\";\n\n  return { val: root ? url.substring(1) : url, root };\n}\n\n/**\n *\n * @param {ng.BuiltStateDeclaration} state\n * @returns {ng.StateDeclaration}\n */\nfunction selfBuilder(state) {\n  state.self._state = () => state;\n\n  return state.self;\n}\n\n/**\n * @param {ng.BuiltStateDeclaration} state\n * @returns {any}\n */\nfunction dataBuilder(state) {\n  if (state.parent && state.parent.data) {\n    state.data = state.self.data = inherit(state.parent.data, state.data);\n  }\n\n  return state.data;\n}\n\n/**\n * @param {ng.UrlService} $url\n * @param {() => ng.StateObject | ng.BuiltStateDeclaration | undefined} root\n */\nfunction getUrlBuilder($url, root) {\n  return function (/** @type {ng.StateObject} */ stateObject) {\n    let stateDec = stateObject.self;\n\n    // For future states, i.e., states whose name ends with `.**`,\n    // match anything that starts with the url prefix\n    if (\n      stateDec &&\n      stateDec.url &&\n      stateDec.name &&\n      stateDec.name.match(/\\.\\*\\*$/)\n    ) {\n      const newStateDec = /** @type {ng.BuiltStateDeclaration} */ ({});\n\n      copy(stateDec, newStateDec);\n      newStateDec.url += \"{remainder:any}\"; // match any path (.*)\n      stateDec = newStateDec;\n    }\n    const { parent } = stateObject;\n\n    const parsed = parseUrl(stateDec.url);\n\n    const url = /** @type {UrlMatcher & Record<string, any>} */ (\n      !parsed ? stateDec.url : $url.compile(parsed.val, { state: stateDec })\n    );\n\n    if (!url) return null;\n\n    if (!$url.isMatcher(url))\n      throw new Error(`Invalid url '${url}' in state '${stateObject}'`);\n\n    return parsed && parsed.root\n      ? url\n      : (\n          (parent && parent?.navigable) ||\n          /** @type {ng.StateObject | ng.BuiltStateDeclaration} */ (root())\n        ).url.append(url);\n  };\n}\n\n/**\n * @param {{ (state: ng.StateObject): boolean; (arg0: any): any; }} rootFn\n */\nfunction getNavigableBuilder(rootFn) {\n  return function (/** @type {ng.StateObject} */ state) {\n    return !rootFn(state) && state.url\n      ? state\n      : state.parent\n        ? state.parent.navigable\n        : null;\n  };\n}\n\n/**\n * @param {import(\"../params/param-factory.js\").ParamFactory} paramFactory\n */\nfunction getParamsBuilder(paramFactory) {\n  return function (/** @type {ng.BuiltStateDeclaration} */ state) {\n    const makeConfigParam = (\n      /** @type {import(\"../params/interface.js\").ParamDeclaration} */ _config,\n      /** @type {string | number} */ id,\n    ) => paramFactory.fromConfig(/** @type {string} */ (id), null, state.self);\n\n    const urlParams = /** @type {import(\"./state-object.js\").Param[]} */ (\n      (state.url && state.url.parameters({ inherit: false })) || []\n    );\n\n    const nonUrlParams = Object.values(\n      map(\n        omit(\n          state.params || {},\n          urlParams.map((x) => x.id),\n        ),\n        makeConfigParam,\n      ),\n    );\n\n    return urlParams\n      .concat(nonUrlParams)\n      .map((x) => [x.id, x])\n      .reduce(applyPairs, {});\n  };\n}\n\n/**\n * @param {ng.StateObject} state\n */\nfunction pathBuilder(state) {\n  return state.parent ? state.parent?.path?.concat(state) : [state];\n}\n\n/**\n * @param {ng.StateObject} state\n */\nfunction includesBuilder(state) {\n  const includes = state.parent ? Object.assign({}, state.parent.includes) : {};\n\n  includes[state.name] = true;\n\n  return includes;\n}\n\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n * @param {ng.StateObject & ng.StateDeclaration} state\n * @param {boolean | undefined} strictDi\n */\nexport function resolvablesBuilder(state, strictDi) {\n  /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n  const objects2Tuples = (\n    /** @type {Record<string, any> | undefined} */ resolveObj,\n    /** @type {Record<string, import(\"../resolve/interface.js\").ResolvePolicy>} */ resolvePolicies,\n  ) =>\n    Object.keys(resolveObj || {}).map((token) => ({\n      token,\n      val: /** @type {Record<string, any>} */ (resolveObj)[token],\n      deps: undefined,\n      policy: resolvePolicies[token],\n    }));\n\n  /** fetch DI annotations from a function or ng1-style array */\n  const annotateFn = (/** @type {Function} */ fn) => annotate(fn, strictDi);\n\n  /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n  const isResolveLiteral = (\n    /** @type {{ token: any; resolveFn: any; }} */ obj,\n  ) => !!(obj.token && obj.resolveFn);\n\n  /** true if the object looks like a tuple from obj2Tuples */\n  const isTupleFromObj = (/** @type {{ val: unknown; }} */ obj) =>\n    !!(\n      obj &&\n      obj.val &&\n      (isString(obj.val) || isArray(obj.val) || isFunction(obj.val))\n    );\n\n  // Given a literal resolve or provider object, returns a Resolvable\n  const literal2Resolvable = pattern([\n    [\n      (/** @type {{ resolveFn: any; }} */ x) => x.resolveFn,\n      (/** @type {any} */ y) =>\n        new Resolvable(getToken(y), y.resolveFn, y.deps, y.policy),\n    ],\n    [\n      (/** @type {{ useFactory: any; }} */ x) => x.useFactory,\n      (/** @type {any} */ y) =>\n        new Resolvable(\n          getToken(y),\n          y.useFactory,\n          y.deps || y.dependencies,\n          y.policy,\n        ),\n    ],\n    [\n      (/** @type {{ useClass: any; }} */ x) => x.useClass,\n      (/** @type {any} */ y) =>\n        new Resolvable(getToken(y), () => new y.useClass(), [], y.policy),\n    ],\n    [\n      (/** @type {{ useValue: any; }} */ x) => x.useValue,\n      (/** @type {any} */ y) =>\n        new Resolvable(getToken(y), () => y.useValue, [], y.policy, y.useValue),\n    ],\n    [\n      (/** @type {{ useExisting: any; }} */ x) => x.useExisting,\n      (/** @type {any} */ y) =>\n        new Resolvable(\n          getToken(y),\n          (/** @type {any} */ x) => x,\n          [y.useExisting],\n          y.policy,\n        ),\n    ],\n  ]);\n\n  const tuple2Resolvable = pattern([\n    [\n      (/** @type {{ val: unknown; }} */ x) => isString(x.val),\n      (\n        /** @type {{ token: any; val: any; policy: import(\"../resolve/interface.js\").ResolvePolicy | undefined; }} */ tuple,\n      ) =>\n        new Resolvable(\n          tuple.token,\n          (/** @type {any} */ x) => x,\n          [tuple.val],\n          tuple.policy,\n        ),\n    ],\n    [\n      (/** @type {{ val: any; }} */ x) => isArray(x.val),\n      (/** @type {any} */ tuple) =>\n        new Resolvable(\n          tuple.token,\n          tail(tuple.val),\n          tuple.val.slice(0, -1),\n          tuple.policy,\n        ),\n    ],\n    [\n      (/** @type {{ val: any; }} */ x) => isFunction(x.val),\n      (/** @type {any} */ tuple) =>\n        new Resolvable(\n          tuple.token,\n          tuple.val,\n          annotateFn(tuple.val),\n          tuple.policy,\n        ),\n    ],\n  ]);\n\n  const item2Resolvable = pattern([\n    [is(Resolvable), (/** @type {any} */ x) => x],\n    [isResolveLiteral, literal2Resolvable],\n    [isTupleFromObj, tuple2Resolvable],\n    [\n      val(true),\n      (/** @type {any} */ obj) => {\n        throw new Error(`Invalid resolve value: ${stringify(obj)}`);\n      },\n    ],\n  ]);\n\n  // If resolveBlock is already an array, use it as-is.\n  // Otherwise, assume it's an object and convert to an Array of tuples\n  const decl = state.resolve;\n\n  const items = isArray(decl)\n    ? decl\n    : objects2Tuples(decl, /** @type {any} */ (state.resolvePolicy || {}));\n\n  return items.map(item2Resolvable);\n}\n/**\n * A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nexport class StateBuilder {\n  /**\n   * @param {import('./state-matcher.js').StateMatcher} matcher\n   * @param {ng.UrlService} urlService\n   */\n  constructor(matcher, urlService) {\n    this._matcher = matcher;\n    /** @type {ng.InjectorService | undefined} */\n    this._$injector = undefined;\n    const self = this;\n\n    const root = () => matcher.find(\"\");\n\n    /**\n     * @param {ng.StateObject} state\n     */\n    function parentBuilder(state) {\n      if (isRoot(state)) return null;\n\n      return matcher.find(self.parentName(state)) || root();\n    }\n    /** @type {Builders} */\n    this._builders = {\n      name: [(/** @type {ng.StateObject} */ state) => state.name],\n      self: [selfBuilder],\n      parent: [parentBuilder],\n      data: [dataBuilder],\n      // Build a URLMatcher if necessary, either via a relative or absolute URL\n      url: [getUrlBuilder(urlService, root)],\n      // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n      navigable: [getNavigableBuilder(isRoot)],\n      // TODO\n      params: [getParamsBuilder(urlService._paramFactory)],\n      views: [ng1ViewsBuilder],\n      // Keep a full path from the root down to this state as this is needed for state activation.\n      path: [pathBuilder],\n      // Speed up $state.includes() as it's used a lot\n      includes: [includesBuilder],\n      resolvables: [\n        (/** @type {ng.StateObject & ng.StateDeclaration} */ state) =>\n          resolvablesBuilder(\n            state,\n            this._$injector && this._$injector.strictDi,\n          ),\n      ],\n    };\n  }\n\n  /**\n   * @param {string} name\n   * @param {*} fn\n   * @returns {BuilderFunction | BuilderFunction[] | null | undefined}\n   */\n  builder(name, fn) {\n    const { _builders: builders } = this;\n\n    const array = builders[name] || [];\n\n    // Backwards compat: if only one builder exists, return it, else return whole arary.\n    if (isString(name) && !isDefined(fn))\n      return array.length > 1 ? array : array[0];\n\n    if (!isString(name) || !isFunction(fn)) return undefined;\n    builders[name] = array;\n    builders[name].push(fn);\n\n    return () => builders[name].splice(builders[name].indexOf(fn, 1)) && null;\n  }\n\n  /**\n   * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n   * properties and API built.\n   *\n   * @param {ng.StateObject} state an uninitialized State object\n   * @returns {ng.StateObject | null} the built State object\n   */\n  build(state) {\n    const { _matcher: matcher, _builders: builders } = this;\n\n    const parent = this.parentName(state);\n\n    if (parent && !matcher.find(parent, undefined, false)) {\n      return null;\n    }\n\n    for (const key in builders) {\n      if (!hasOwn(builders, key)) continue;\n      const chain = builders[key].reduce(\n        (\n          /** @type {BuilderFunction} */ parentFn,\n          /** @type {BuilderFunction} */ step,\n        ) =>\n          (_state) =>\n            step(_state, parentFn),\n        () => {\n          /* empty */\n        },\n      );\n\n      state[key] = chain(\n        /** @type {ng.StateObject & ng.BuiltStateDeclaration} */ (state),\n      );\n    }\n\n    return state;\n  }\n\n  /**\n   *\n   * @param {ng.StateObject} state\n   * @returns {string}\n   */\n  parentName(state) {\n    // name = 'foo.bar.baz.**'\n    const name = state.name || \"\";\n\n    // segments = ['foo', 'bar', 'baz', '.**']\n    const segments = name.split(\".\");\n\n    // segments = ['foo', 'bar', 'baz']\n    const lastSegment = segments.pop();\n\n    // segments = ['foo', 'bar'] (ignore .** segment for future states)\n    if (lastSegment === \"**\") segments.pop();\n\n    if (segments.length) {\n      if (state.parent) {\n        throw new Error(\n          `States that specify the 'parent:' property should not have a '.' in their name (${name})`,\n        );\n      }\n\n      // 'foo.bar'\n      return segments.join(\".\");\n    }\n\n    if (!state.parent) return \"\";\n\n    return isString(state.parent) ? state.parent : state.parent.name;\n  }\n\n  /** @param {ng.StateObject} state*/\n  name(state) {\n    const { name } = state;\n\n    if (name.indexOf(\".\") !== -1 || !state.parent) return name;\n    const parentName = isString(state.parent)\n      ? state.parent\n      : state.parent.name;\n\n    return parentName ? `${parentName}.${name}` : name;\n  }\n}\n\n/**\n * @param {ng.StateObject} state\n * @returns {boolean}\n */\nfunction isRoot(state) {\n  return state.name === \"\";\n}\n\n/**\n * extracts the token from a Provider or provide literal\n * @param {{ provide: any; token: any; }} provider\n */\nfunction getToken(provider) {\n  return provider.provide || provider.token;\n}\n","import { hasOwn, isString } from \"../../shared/utils.js\";\nimport { StateObject } from \"./state-object.js\";\n\n/** @typedef {import(\"./state-registry.js\").StateRegistryListener} StateRegistryListener */\n\nexport class StateQueueManager {\n  /**\n   * @param {import(\"./state-registry.js\").StateRegistryProvider} stateRegistry\n   * @param {import(\"../url/url-rules.js\").UrlRules} urlServiceRules\n   * @param {import(\"./interface.ts\").StateStore} states\n   * @param {import(\"./state-builder.js\").StateBuilder} builder\n   * @param {StateRegistryListener[]} listeners\n   */\n  constructor(stateRegistry, urlServiceRules, states, builder, listeners) {\n    this.stateRegistry = stateRegistry;\n    /** @type {import(\"../url/url-rules.js\").UrlRules} */\n    this.urlServiceRules = urlServiceRules;\n\n    /** @type {import(\"./interface.ts\").StateStore} */\n    this.states = states;\n    this.builder = builder;\n    /** @type {StateRegistryListener[]} */\n    this.listeners = listeners;\n    /**\n     * @type {Array<StateObject>}\n     */\n    this.queue = [];\n  }\n\n  /**\n   * @param {ng.StateDeclaration} stateDecl\n   * @returns {StateObject}\n   */\n  register(stateDecl) {\n    const state = new StateObject(stateDecl);\n\n    if (!isString(name)) throw new Error(\"State must have a valid name\");\n\n    if (\n      hasOwn(this.states, state.name) ||\n      this.queue.map((x) => x.name).includes(state.name)\n    )\n      throw new Error(`State '${state.name}' is already defined`);\n    this.queue.push(state);\n    this.flush();\n\n    return state;\n  }\n\n  flush() {\n    const { queue, states, builder } = this;\n\n    /** @type {StateObject[]} */\n    const registered = [], // states that got registered\n      orphans = []; // states that don't yet have a parent registered\n\n    /** @type {Record<string, number>} */\n    const previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n\n    const getState = (/** @type {string} */ name) =>\n      hasOwn(this.states, name) && this.states[name];\n\n    const notifyListeners = () => {\n      if (registered.length) {\n        this.listeners.forEach((listener) =>\n          listener(\n            \"registered\",\n            registered.map((x) => x.self),\n          ),\n        );\n      }\n    };\n\n    while (queue.length > 0) {\n      const state = queue.shift();\n\n      const { name } = /** @type {StateObject} */ (state);\n\n      const result = builder.build(/** @type {StateObject} */ (state));\n\n      const orphanIdx = orphans.indexOf(state);\n\n      if (result) {\n        const existingState = getState(name);\n\n        if (existingState && existingState.name === name) {\n          throw new Error(`State '${name}' is already defined`);\n        }\n        const existingFutureState = getState(`${name}.**`);\n\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.stateRegistry.deregister(existingFutureState);\n        }\n        states[name] = /** @type {StateObject} */ (state);\n        this.attachRoute(/** @type {StateObject} */ (state));\n\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(/** @type {StateObject} */ (state));\n        continue;\n      }\n      const prev = previousQueueLength[name];\n\n      previousQueueLength[name] = queue.length;\n\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(/** @type {StateObject} */ (state));\n        notifyListeners();\n\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n      queue.push(/** @type {StateObject} */ (state));\n    }\n    notifyListeners();\n\n    return states;\n  }\n\n  /**\n   *\n   * @param {StateObject | ng.StateDeclaration} state\n   * @returns {void} a function that deregisters the rule\n   */\n  attachRoute(state) {\n    if (!(/** @type {ng.StateDeclaration} */ (state).abstract) && state.url) {\n      const rulesApi = this.urlServiceRules;\n\n      rulesApi.rule(\n        rulesApi._urlRuleFactory.create(/** @type {StateObject} */ (state)),\n      );\n    }\n  }\n}\n","import { StateMatcher } from \"./state-matcher.js\";\nimport { StateBuilder } from \"./state-builder.js\";\nimport { StateQueueManager } from \"./state-queue-manager.js\";\nimport { applyPairs, removeFrom } from \"../../shared/common.js\";\nimport { propEq } from \"../../shared/hof.js\";\nimport { ResolveContext } from \"../resolve/resolve-context.js\";\nimport { isString, keys } from \"../../shared/utils.js\";\nimport { $injectTokens as $t, provider } from \"../../injection-tokens.js\";\n\n/** @typedef {import(\"./state-object.js\").StateObject} StateObject */\n/** @typedef {import(\"./interface.ts\").BuiltStateDeclaration} BuiltStateDeclaration */\n/** @typedef {import('../../interface.ts').ServiceProvider} ServiceProvider } */\n/** @typedef {import(\"./interface.ts\").StateRegistryListener} StateRegistryListener */\n/** @typedef {import(\"./interface.ts\").StateDeclaration} StateDeclaration */\n/** @typedef {import(\"./interface.ts\").StateOrName} StateOrName */\n\n/**\n * A registry for all of the application's [[StateDeclaration]]s\n *\n * This API is found at `$stateRegistry` ([[UIRouter.stateRegistry]])\n *\n */\nexport class StateRegistryProvider {\n  /* @ignore */ static $inject = provider([\n    $t._url,\n    $t._state,\n    $t._router,\n    $t._view,\n  ]);\n\n  /**\n   * @param {ng.UrlService} urlService\n   * @param {ng.StateService} stateService\n   * @param {ng.RouterService} globals\n   * @param {ng.ViewService} viewService\n   */\n  constructor(urlService, stateService, globals, viewService) {\n    /** @type {import(\"./interface.ts\").StateStore} */\n    this.states = {};\n\n    stateService.stateRegistry = this; // <- circular wiring\n\n    /**\n     * @type {ng.UrlService}\n     */\n    this.urlService = urlService;\n\n    /**\n     * @type {import(\"../url/url-rules.js\").UrlRules}\n     */\n    this.urlServiceRules = urlService._rules;\n\n    /**\n     * @type {ng.InjectorService|undefined}\n     */\n    this.$injector = undefined;\n\n    /**\n     * @type {StateRegistryListener[]}\n     */\n    this.listeners = [];\n\n    /**\n     *@type {StateMatcher}\n     */\n    this.matcher = new StateMatcher(this.states);\n\n    /**\n     * @type {StateBuilder}\n     */\n    this.builder = new StateBuilder(this.matcher, urlService);\n    // Apply ng1 specific StateBuilder code for `onExit/Retain/Enter` properties\n    this.builder.builder(\"onExit\", this.getStateHookBuilder(\"onExit\"));\n    this.builder.builder(\"onRetain\", this.getStateHookBuilder(\"onRetain\"));\n    this.builder.builder(\"onEnter\", this.getStateHookBuilder(\"onEnter\"));\n\n    this.stateQueue = new StateQueueManager(\n      this,\n      this.urlServiceRules,\n      this.states,\n      this.builder,\n      this.listeners,\n    );\n\n    this.registerRoot();\n\n    viewService.rootViewContext(this.root());\n    globals.$current = this.root();\n    globals.current = /** @type {import(\"./state-service.js\").StateObject} */ (\n      globals.$current\n    ).self;\n  }\n\n  $get = [\n    $t._injector,\n    /**\n     * @param {import(\"../../core/di/internal-injector\").InjectorService} $injector\n     * @returns {StateRegistryProvider}\n     */\n    ($injector) => {\n      this.$injector = $injector;\n      this.builder._$injector = $injector;\n\n      return this;\n    },\n  ];\n\n  /**\n   * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n   * `onRetain` callback hooks on a [[StateDeclaration]].\n   *\n   * @param {string} hookName\n   */\n  getStateHookBuilder(hookName) {\n    const that = this;\n\n    /**\n     * @param {import(\"./state-object\").StateObject & Record<string, any>} stateObject\n     * @returns {((trans: ng.Transition, state: ng.BuiltStateDeclaration) => any) | undefined}\n     */\n    return function stateHookBuilder(stateObject) {\n      const hook = stateObject[hookName];\n\n      const pathname = hookName === \"onExit\" ? \"from\" : \"to\";\n\n      /**\n       * @param {ng.Transition} trans\n       * @param {ng.BuiltStateDeclaration} state\n       * @returns {any}\n       */\n      function decoratedNg1Hook(trans, state) {\n        const resolveContext = new ResolveContext(\n          /** @type {import(\"../resolve/resolve-context.js\").PathNode[]} */ (\n            trans.treeChanges(pathname)\n          ),\n        );\n\n        const subContext = resolveContext.subContext(state._state());\n\n        const locals = Object.assign(getLocals(subContext), {\n          $state$: state,\n          $transition$: trans,\n        });\n\n        return /** @type {ng.InjectorService} */ (that.$injector).invoke(\n          hook,\n          that,\n          locals,\n        );\n      }\n\n      return hook ? decoratedNg1Hook : undefined;\n    };\n  }\n\n  /**\n   * @private\n   */\n  registerRoot() {\n    /** @type {ng.StateDeclaration} */\n    const rootStateDef = {\n      name: \"\",\n      url: \"^\",\n      params: {\n        \"#\": { value: null, type: \"hash\", dynamic: true },\n      },\n      abstract: true,\n    };\n\n    this._root = this.stateQueue.register(rootStateDef);\n    this._root.navigable = null;\n  }\n\n  /**\n   * Listen for a State Registry events\n   *\n   * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n   *\n   * #### Example:\n   * ```js\n   * let allStates = registry.get();\n   *\n   * // Later, invoke deregisterFn() to remove the listener\n   * let deregisterFn = registry.onStatesChanged((event, states) => {\n   *   switch(event) {\n   *     case: 'registered':\n   *       states.forEach(state => allStates.push(state));\n   *       break;\n   *     case: 'deregistered':\n   *       states.forEach(state => {\n   *         let idx = allStates.indexOf(state);\n   *         if (idx !== -1) allStates.splice(idx, 1);\n   *       });\n   *       break;\n   *   }\n   * });\n   * ```\n   *\n   * @param {import(\"./interface.ts\").StateRegistryListener} listener a callback function invoked when the registered states changes.\n   *        The function receives two parameters, `event` and `state`.\n   *        See [[StateRegistryListener]]\n   * @return a function that deregisters the listener\n   */\n  onStatesChanged(listener) {\n    /** @type {StateRegistryProvider} */\n    const registryProvider = this;\n\n    this.listeners.push(listener);\n\n    return () => {\n      removeFrom(registryProvider.listeners, listener);\n    };\n  }\n\n  /**\n   * Gets the implicit root state\n   *\n   * Gets the root of the state tree.\n   * The root state is implicitly created by ng-router.\n   * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n   *\n   * @return the root [[StateObject]]\n   */\n  root() {\n    return this._root;\n  }\n\n  /**\n   * Adds a state to the registry\n   *\n   * Registers a [[StateDeclaration]] or queues it for registration.\n   *\n   * Note: a state will be queued if the state's parent isn't yet registered.\n   *\n   * @param {import(\"./interface.ts\")._StateDeclaration} stateDefinition the definition of the state to register.\n   * @returns the internal [[StateObject]] object.\n   *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n   *          If the state was only queued, then the object is not fully built.\n   */\n  register(stateDefinition) {\n    return this.stateQueue.register(stateDefinition);\n  }\n\n  /**\n   *\n   * @param {BuiltStateDeclaration} state\n   * @returns {BuiltStateDeclaration[]}\n   */\n  _deregisterTree(state) {\n    /** @type {BuiltStateDeclaration[]} */\n    const all = this.getAll().map((x) => x._state());\n\n    /** @type {(states: BuiltStateDeclaration[]) => BuiltStateDeclaration[]} */\n    const getChildren = /** @param {BuiltStateDeclaration[]} states */ (\n      states,\n    ) => {\n      const _children = all.filter(\n        (x) =>\n          states.indexOf(/** @type {BuiltStateDeclaration} */ (x.parent)) !==\n          -1,\n      );\n\n      return _children.length === 0\n        ? _children\n        : _children.concat(getChildren(_children));\n    };\n\n    const children = getChildren([state]);\n\n    const deregistered = [state].concat(children).reverse();\n\n    deregistered.forEach((_state) => {\n      const rulesApi = this.urlServiceRules;\n\n      // Remove URL rule\n      rulesApi\n        .rules()\n        .filter(propEq(\"state\", _state))\n        .forEach((rule) => rulesApi.removeRule(rule));\n      // Remove state from registry\n      delete this.states[_state.name];\n    });\n\n    return deregistered;\n  }\n\n  /**\n   * Removes a state from the registry\n   *\n   * This removes a state from the registry.\n   * If the state has children, they are are also removed from the registry.\n   *\n   * @param {StateOrName} stateOrName the state's name or object representation\n   * @returns {BuiltStateDeclaration[]} a list of removed states\n   */\n  deregister(stateOrName) {\n    const state = /** @type {BuiltStateDeclaration} */ (this.get(stateOrName));\n\n    if (!state)\n      throw new Error(`Can't deregister state; not found: ${stateOrName}`);\n    const deregisteredStates = this._deregisterTree(state._state());\n\n    this.listeners.forEach((listener) =>\n      listener(\n        \"deregistered\",\n        deregisteredStates.map((x) => x.self),\n      ),\n    );\n\n    return deregisteredStates;\n  }\n\n  /**\n   * @return {ng.BuiltStateDeclaration[]}\n   */\n  getAll() {\n    return keys(this.states).map(\n      (name) =>\n        /** @type {ng.BuiltStateDeclaration} */ (this.states[name].self),\n    );\n  }\n\n  /**\n   *\n   * @param {StateOrName} [stateOrName]\n   * @param {StateOrName} [base]\n   * @returns {import(\"./state-service.js\").StateDeclaration | import(\"./state-service.js\").StateDeclaration[] | null}\n   */\n  get(stateOrName, base) {\n    if (arguments.length === 0)\n      return keys(this.states).map((name) => this.states[name].self);\n    const found = this.matcher.find(\n      /** @type {import(\"./interface.ts\").StateOrName} */ (stateOrName),\n      base,\n    );\n\n    return (found && found.self) || null;\n  }\n\n  /**\n   * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n   * More than one BuilderFunction can be registered for a given property.\n   *\n   * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n   *\n   * @param {string} property The name of the State property being registered for.\n   * @param {import(\"./interface.ts\").BuilderFunction} builderFunction The BuilderFunction which will be used to build the State property\n   * @returns a function which deregisters the BuilderFunction\n   */\n  decorator(property, builderFunction) {\n    return this.builder.builder(property, builderFunction);\n  }\n}\n\nexport const getLocals = /** @param {ResolveContext} ctx */ (ctx) => {\n  /** @type {string[]} */\n  const tokens = ctx.getTokens().filter(isString);\n\n  const tuples = tokens.map((key) => {\n    const resolvable = ctx.getResolvable(key);\n\n    const waitPolicy = ctx.getPolicy(resolvable).async;\n\n    return [\n      key,\n      waitPolicy === \"NOWAIT\" ? resolvable.promise : resolvable.data,\n    ];\n  });\n\n  return tuples.reduce(applyPairs, {});\n};\n","import { removeFrom, tail, uniqR, unnestR } from \"../../shared/common.js\";\nimport {\n  entries,\n  isArray,\n  isNullOrUndefined,\n  isObject,\n  isString,\n} from \"../../shared/utils.js\";\nimport { parse } from \"../../shared/hof.js\";\nimport { getInheritedData } from \"../../shared/dom.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/**\n * @param {string} ref\n */\nfunction parseStateRef(ref) {\n  const paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/);\n\n  if (paramsOnly) ref = `(${paramsOnly[1]})`;\n  const parsed = ref\n    .replace(/\\n/g, \" \")\n    .match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n\n  if (!parsed || parsed.length !== 4)\n    throw new Error(`Invalid state ref '${ref}'`);\n\n  return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n\n/**\n * @param {Node} el\n */\nfunction stateContext(el) {\n  const $ngView = getInheritedData(el, \"$ngView\");\n\n  const path = parse(\"$cfg.path\")($ngView);\n\n  return path ? tail(path).state.name : undefined;\n}\n\n/**\n * @param {ng.StateService} $state\n * @param {HTMLElement} $element\n * @param {Record<string, any>} def\n */\nfunction processedDef($state, $element, def) {\n  const ngState = def.ngState || $state.current?.name;\n\n  const ngStateOpts = Object.assign(\n    defaultOpts($element, $state),\n    def.ngStateOpts || {},\n  );\n\n  const href = $state.href(ngState, def.ngStateParams, ngStateOpts);\n\n  return { ngState, ngStateParams: def.ngStateParams, ngStateOpts, href };\n}\n\n/**\n * @param {HTMLElement} el\n */\nfunction getTypeInfo(el) {\n  // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n  const isSvg =\n    Object.prototype.toString.call(el.getAttribute(\"href\")) ===\n    \"[object SVGAnimatedString]\";\n\n  const isForm = el.nodeName === \"FORM\";\n\n  return {\n    attr: isForm ? \"action\" : isSvg ? \"xlink:href\" : \"href\",\n    isAnchor: el.nodeName === \"A\",\n    clickable: !isForm,\n  };\n}\n\n/**\n * @param {HTMLElement} el\n * @param {import(\"../state/state-service.js\").StateProvider} $state\n * @param {{ attr?: string; isAnchor: any; clickable?: boolean; }} type\n * @param {{ (): { ngState: any; ngStateParams: any; ngStateOpts: any; href: any; }; (): { ngState: any; ngStateParams: any; ngStateOpts: any; href: any; }; (): any; }} getDef\n * @param {ng.Scope} scope\n */\nfunction clickHook(el, $state, type, getDef, scope) {\n  return function (/** @type {MouseEvent} */ event) {\n    const button = event.which || event.button,\n      target = getDef();\n\n    const res =\n      button > 1 ||\n      event.ctrlKey ||\n      event.metaKey ||\n      event.shiftKey ||\n      event.altKey ||\n      el.getAttribute(\"target\");\n\n    if (!res) {\n      // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n      const transition = setTimeout(function () {\n        if (!el.getAttribute(\"disabled\")) {\n          $state\n            .go(target.ngState, target.ngStateParams, target.ngStateOpts)\n            .then(() => {\n              scope.$emit(\"$updateBrowser\");\n            });\n        }\n      });\n\n      event.preventDefault();\n      // if the state has no URL, ignore one preventDefault from the <a> directive.\n      let ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;\n\n      event.preventDefault = function () {\n        if (ignorePreventDefaultCount-- <= 0) clearTimeout(transition);\n      };\n    } else {\n      // ignored\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    }\n  };\n}\n\n/**\n * @param {any} el\n * @param {{ $current: any; }} $state\n */\nfunction defaultOpts(el, $state) {\n  return {\n    relative: stateContext(el) || $state.$current,\n    inherit: true,\n    source: \"sref\",\n  };\n}\n\n/**\n * @param {HTMLElement} element\n * @param {ng.Scope} scope\n * @param {{ (event: any): void; (event: any): void; }} hookFn\n * @param {{ events: any; }} ngStateOpts\n */\nfunction bindEvents(element, scope, hookFn, ngStateOpts) {\n  let events = ngStateOpts ? ngStateOpts.events : undefined;\n\n  if (!isArray(events)) {\n    events = [\"click\"];\n  }\n  //const on = element.on ? \"on\" : \"bind\";\n\n  for (const event of events) {\n    element.addEventListener(event, hookFn);\n  }\n  scope.$on(\"$destroy\", function () {\n    // const off = element.off ? \"off\" : \"unbind\";\n    for (const event of events) {\n      element.removeEventListener(event, hookFn);\n    }\n  });\n}\n\n// // TODO: SEPARATE THESE OUT\n\n$StateRefDirective.$inject = [\n  $injectTokens._state,\n  $injectTokens._stateRegistry,\n  $injectTokens._transitions,\n];\n\n/**\n * @param {ng.StateService} $stateService\n * @param {ng.StateRegistryService} $stateRegistry\n * @param {ng.TransitionService} $transitions\n * @returns {ng.Directive}\n */\nexport function $StateRefDirective(\n  $stateService,\n  $stateRegistry,\n  $transitions,\n) {\n  const $state = $stateService;\n\n  return {\n    restrict: \"A\",\n    require: [\"?^ngSrefActive\", \"?^ngSrefActiveEq\"],\n    link: (scope, element, attrs, ngSrefActive) => {\n      const type = getTypeInfo(element);\n\n      const active = ngSrefActive[1] || ngSrefActive[0];\n\n      /**\n       * @type {(() => void) | null}\n       */\n      let unlinkInfoFn = null;\n\n      const rawDef = {};\n\n      const getDef = () => processedDef($state, element, rawDef);\n\n      const ref = parseStateRef(attrs.ngSref);\n\n      rawDef.ngState = ref.state;\n      rawDef.ngStateOpts = attrs.ngSrefOpts\n        ? scope.$eval(attrs.ngSrefOpts)\n        : {};\n\n      function update() {\n        rawDef.ngStateParams = Object.assign(\n          {},\n          ref.paramExpr && scope.$eval(ref.paramExpr),\n        );\n        const def = getDef();\n\n        if (unlinkInfoFn) {\n          unlinkInfoFn();\n        }\n\n        if (active) {\n          unlinkInfoFn = active._addStateInfo(def.ngState, def.ngStateParams);\n        }\n\n        if (!isNullOrUndefined(def.href)) {\n          attrs.$set(type.attr, def.href);\n        }\n      }\n\n      if (ref.paramExpr) {\n        scope.$watch(\n          ref.paramExpr,\n          function (val) {\n            rawDef.ngStateParams = Object.assign({}, val);\n            update();\n          },\n          true,\n        );\n        rawDef.ngStateParams = Object.assign({}, scope.$eval(ref.paramExpr));\n      }\n\n      update();\n      scope.$on(\"$destroy\", $stateRegistry.onStatesChanged(update));\n      scope.$on(\"$destroy\", $transitions.onSuccess({}, update));\n\n      if (!type.clickable) {\n        return;\n      }\n      bindEvents(\n        element,\n        scope,\n        clickHook(element, $state, type, getDef, scope),\n        rawDef.ngStateOpts,\n      );\n    },\n  };\n}\n\n$StateRefDynamicDirective.$inject = [\n  $injectTokens._state,\n  $injectTokens._stateRegistry,\n  $injectTokens._transitions,\n];\n\n/**\n * @param {ng.StateService} $state\n * @param {ng.StateRegistryService} $stateRegistry\n * @param {ng.TransitionService} $transitions\n * @returns {ng.Directive}\n */\nexport function $StateRefDynamicDirective(\n  $state,\n  $stateRegistry,\n  $transitions,\n) {\n  return {\n    restrict: \"A\",\n    require: [\"?^ngSrefActive\", \"?^ngSrefActiveEq\"],\n    link(scope, element, attrs, ngSrefActive) {\n      const type = getTypeInfo(element);\n\n      const active = ngSrefActive[1] || ngSrefActive[0];\n\n      /**\n       * @type {(() => void) | null}\n       */\n      let unlinkInfoFn = null;\n\n      /** @type {Record<string, any>} */\n      const rawDef = {};\n\n      const getDef = () => processedDef($state, element, rawDef);\n\n      const inputAttrs = [\"ngState\", \"ngStateParams\", \"ngStateOpts\"];\n\n      const watchDeregFns = inputAttrs.reduce(\n        (acc, attr) => (\n          (acc[attr] = () => {\n            /* empty */\n          }),\n          acc\n        ),\n        /** @type {Record<string, any>} */ ({}),\n      );\n\n      function update() {\n        const def = getDef();\n\n        if (unlinkInfoFn) {\n          unlinkInfoFn();\n        }\n\n        if (active) {\n          unlinkInfoFn = active._addStateInfo(def.ngState, def.ngStateParams);\n        }\n\n        if (!isNullOrUndefined(def.href)) {\n          attrs.$set(type.attr, def.href);\n        }\n      }\n      inputAttrs.forEach((field) => {\n        rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n        attrs.$observe(field, (expr) => {\n          watchDeregFns[field]();\n          watchDeregFns[field] = scope.$watch(expr, (newval) => {\n            rawDef[field] = newval;\n            update();\n          });\n        });\n      });\n      update();\n      scope.$on(\"$destroy\", $stateRegistry.onStatesChanged(update));\n      scope.$on(\"$destroy\", $transitions.onSuccess({}, update));\n\n      if (!type.clickable) return;\n      const hookFn = clickHook(element, $state, type, getDef, scope);\n\n      bindEvents(element, scope, hookFn, rawDef.ngStateOpts);\n    },\n  };\n}\n\n$StateRefActiveDirective.$inject = [\n  $injectTokens._state,\n  $injectTokens._router,\n  $injectTokens._interpolate,\n  $injectTokens._stateRegistry,\n  $injectTokens._transitions,\n];\n\n/**\n * @param {ng.StateService} $state\n * @param {ng.RouterService} $router\n * @param {ng.InterpolateService} $interpolate\n * @param {ng.StateRegistryService} $stateRegistry\n * @param {ng.TransitionService} $transitions\n * @returns {ng.Directive}\n */\nexport function $StateRefActiveDirective(\n  $state,\n  $router,\n  $interpolate,\n  $stateRegistry,\n  $transitions,\n) {\n  return {\n    restrict: \"A\",\n    /**\n     * @param {ng.Scope} $scope\n     * @param {HTMLElement} $element\n     * @param {ng.Attributes} $attrs\n     */\n    controller($scope, $element, $attrs) {\n      /**\n       * @type {any[]}\n       */\n      let states = [];\n\n      /**\n       * @type {any}\n       */\n      let ngSrefActive;\n\n      // There probably isn't much point in $observing this\n      // ngSrefActive and ngSrefActiveEq share the same directive object with some\n      // slight difference in logic routing\n      const activeEqClass = /** @type {ng.InterpolationFunction} */ (\n        $interpolate($attrs.ngSrefActiveEq || \"\", false)\n      )($scope);\n\n      try {\n        ngSrefActive = $scope.$eval($attrs.ngSrefActive);\n      } catch {\n        // Do nothing. ngSrefActive is not a valid expression.\n        // Fall back to using $interpolate below\n      }\n      ngSrefActive =\n        ngSrefActive ||\n        /** @type {ng.InterpolationFunction} */ (\n          $interpolate($attrs.ngSrefActive || \"\", false)\n        )($scope);\n      setStatesFromDefinitionObject(ngSrefActive);\n      // Allow ngSref to communicate with ngSrefActive[Equals]\n      this._addStateInfo = function (newState, newParams) {\n        // we already got an explicit state provided by ng-sref-active, so we\n        // shadow the one that comes from ng-sref\n        if (isObject(ngSrefActive) && states.length > 0) {\n          return undefined;\n        }\n        const deregister = addState(newState, newParams, ngSrefActive);\n\n        update();\n\n        return deregister;\n      };\n      /**\n       * @param {ng.Transition} trans\n       */\n      function updateAfterTransition(trans) {\n        trans.promise.then(update, () => {\n          /* empty */\n        });\n      }\n      $scope.$on(\"$destroy\", setupEventListeners());\n\n      if ($router.transition) {\n        updateAfterTransition($router.transition);\n      }\n      function setupEventListeners() {\n        const deregisterStatesChangedListener =\n          $stateRegistry.onStatesChanged(handleStatesChanged);\n\n        const deregisterOnStartListener = $transitions.onStart(\n          {},\n          updateAfterTransition,\n        );\n\n        const deregisterStateChangeSuccessListener = $scope.$on(\n          \"$stateChangeSuccess\",\n          update,\n        );\n\n        return function cleanUp() {\n          deregisterStatesChangedListener();\n          deregisterOnStartListener();\n          deregisterStateChangeSuccessListener();\n        };\n      }\n      function handleStatesChanged() {\n        setStatesFromDefinitionObject(ngSrefActive);\n      }\n      /**\n       * @param {{ [s: string]: any; } | ArrayLike<any>} statesDefinition\n       */\n      function setStatesFromDefinitionObject(statesDefinition) {\n        if (isObject(statesDefinition)) {\n          states = [];\n          entries(statesDefinition).forEach(([activeClass, stateOrName]) => {\n            // Helper function to abstract adding state.\n            /**\n             * @param {string|string[]} stateOrNameParam\n             * @param {string} activeClassParam\n             */\n            const addStateForClass = function (\n              stateOrNameParam,\n              activeClassParam,\n            ) {\n              const ref = parseStateRef(\n                /** @type {string} */ (stateOrNameParam),\n              );\n\n              addState(\n                /** @type {string} */ (ref.state),\n                ref.paramExpr && $scope.$eval(ref.paramExpr),\n                activeClassParam,\n              );\n            };\n\n            if (isString(stateOrName)) {\n              // If state is string, just add it.\n              addStateForClass(stateOrName, activeClass);\n            } else if (isArray(stateOrName)) {\n              // If state is an array, iterate over it and add each array item individually.\n              stateOrName.forEach((stateOrNameParam) => {\n                addStateForClass(stateOrNameParam, activeClass);\n              });\n            }\n          });\n        }\n      }\n      /**\n       * @param {import(\"../state/interface.js\").StateOrName} stateName\n       * @param {any} stateParams\n       * @param {string} activeClass\n       */\n      function addState(stateName, stateParams, activeClass) {\n        const state = $state.get(stateName, stateContext($element));\n\n        const stateInfo = {\n          state: state || { name: stateName },\n          params: stateParams,\n          activeClass,\n        };\n\n        states.push(stateInfo);\n\n        return function removeState() {\n          removeFrom(states, stateInfo);\n        };\n      }\n      // Update route state\n      function update() {\n        const splitClasses = (/** @type {string} */ str) =>\n          str.split(/\\s/).filter(Boolean);\n\n        const getClasses = (/** @type {any[]} */ stateList) =>\n          stateList\n            .map((x) => x.activeClass)\n            .map(splitClasses)\n            .reduce(unnestR, []);\n\n        const allClasses = getClasses(states)\n          .concat(splitClasses(activeEqClass))\n          .reduce(uniqR, []);\n\n        const fuzzyClasses = getClasses(\n          states.filter((x) => $state.includes(x.state.name, x.params)),\n        );\n\n        const exactlyMatchesAny = !!states.filter((x) =>\n          $state.is(x.state.name, x.params),\n        ).length;\n\n        const exactClasses = exactlyMatchesAny\n          ? splitClasses(activeEqClass)\n          : [];\n\n        const addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);\n\n        const removeClasses = allClasses.filter(\n          (/** @type {any} */ cls) => !addClasses.includes(cls),\n        );\n\n        addClasses.forEach((/** @type {string} */ className) =>\n          $element.classList.add(className),\n        );\n        removeClasses.forEach((/** @type {string} */ className) =>\n          $element.classList.remove(className),\n        );\n      }\n      update();\n    },\n  };\n}\n","import { tail, unnestR } from \"../../shared/common.js\";\nimport { hasAnimate, isDefined, isFunction } from \"../../shared/utils.js\";\nimport { parse } from \"../../shared/hof.js\";\nimport { ResolveContext } from \"../resolve/resolve-context.js\";\nimport { trace } from \"../common/trace.js\";\nimport { ViewConfig } from \"../state/views.js\";\nimport {\n  dealoc,\n  getCacheData,\n  getInheritedData,\n  setCacheData,\n} from \"../../shared/dom.js\";\nimport { getLocals } from \"../state/state-registry.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\n/**\n * `ng-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ng-view can be targeted in a View using the name ([[StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ng-view` will be scrolled into view when it is activated.\n *   Uses [[$anchorScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * <!-- Unnamed -->\n * <div ng-view></div>\n *\n * <!-- Named -->\n * <div ng-view=\"viewName\"></div>\n *\n * <!-- Named (different style) -->\n * <ng-view name=\"viewName\"></ng-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ng-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ng-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ng-view></div>\n * <div ng-view=\"chart\"></div>\n * <div ng-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * <!-- If autoscroll present with no expression,\n *      then scroll ng-view into view -->\n * <ng-view autoscroll/>\n *\n * <!-- If autoscroll present with valid expression,\n *      then scroll ng-view into view if expression evaluates to true -->\n * <ng-view autoscroll='true'/>\n * <ng-view autoscroll='false'/>\n * <ng-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\n\n$ViewDirective.$inject = [\n  $injectTokens._view,\n  $injectTokens._animate,\n  $injectTokens._anchorScroll,\n  $injectTokens._interpolate,\n];\n\n/**\n * @param {ng.ViewService} $view\n * @param {ng.AnimateService} $animate\n * @param {ng.AnchorScrollService} $anchorScroll\n * @param {ng.InterpolateService} $interpolate\n * @returns {ng.Directive}\n */\nexport function $ViewDirective($view, $animate, $anchorScroll, $interpolate) {\n  function getRenderer() {\n    return {\n      /**\n       * @param {HTMLElement} element\n       * @param {HTMLElement} target\n       * @param {() => void} cb\n       */\n      enter(element, target, cb) {\n        if (hasAnimate(element)) {\n          $animate.enter(element, null, target).then(cb);\n        } else {\n          target.after(element);\n          cb();\n        }\n      },\n\n      /**\n       * @param {HTMLElement} element\n       * @param {() => void} cb\n       */\n      leave(element, cb) {\n        if (hasAnimate(element)) {\n          $animate.leave(element).then(cb);\n        } else {\n          /** @type {HTMLElement} */ (element.parentElement).removeChild(\n            element,\n          );\n          cb();\n        }\n      },\n    };\n  }\n\n  const rootData = {\n    $cfg: { viewDecl: { $context: $view.rootViewContext() } },\n    $ngView: {},\n  };\n\n  /** @type {ng.Directive} */\n  const directive = {\n    count: 0,\n    terminal: true,\n    priority: 400,\n    transclude: \"element\",\n    compile(_tElement, _tAttrs, $transclude) {\n      return function (scope, $element, attrs) {\n        const onloadExp = attrs.onload || \"\",\n          autoScrollExp = attrs.autoscroll,\n          renderer = getRenderer(),\n          inherited = getInheritedData($element, \"$ngView\") || rootData,\n          name =\n            /** @type {import(\"../../core/interpolate/interface.ts\").InterpolationFunction} */ (\n              $interpolate(attrs.ngView || attrs.name || \"\")\n            )(scope) || \"$default\";\n\n        /**\n         * @type {HTMLElement | null}\n         */\n        let previousEl;\n\n        /**\n         * @type {HTMLElement | null}\n         */\n        let currentEl;\n\n        /**\n         * @type {ng.Scope | null}\n         */\n        let currentScope;\n\n        /**\n         * @type {any}\n         */\n        let viewConfig;\n\n        /** @type {import(\"../view/interface.ts\").ActiveUIView} */\n        const activeUIView = {\n          id: /** @type {number} */ (directive.count)++, // Global sequential ID for ng-view tags added to DOM\n          name, // ng-view name (<div ng-view=\"name\"></div>\n          fqn: inherited.$ngView.fqn\n            ? `${inherited.$ngView.fqn}.${name}`\n            : name, // fully qualified name, describes location in DOM\n          config: null, // The ViewConfig loaded (from a state.views definition)\n          configUpdated: configUpdatedCallback, // Called when the matching ViewConfig changes\n          get creationContext() {\n            // The context in which this ng-view \"tag\" was created\n            const fromParentTagConfig = parse(\"$cfg.viewDecl.$context\")(\n              inherited,\n            );\n\n            // Allow <ng-view name=\"foo\"><ng-view name=\"bar\"></ng-view></ng-view>\n            // See https://github.com/angular-ui/ui-router/issues/3355\n            const fromParentTag = parse(\"$ngView.creationContext\")(inherited);\n\n            return fromParentTagConfig || fromParentTag;\n          },\n        };\n\n        trace.traceUIViewEvent(\"Linking\", activeUIView);\n\n        /**\n         * @param {ViewConfig} config\n         */\n        function configUpdatedCallback(config) {\n          if (config && !(config instanceof ViewConfig)) return;\n\n          if (viewConfig === config) return;\n          trace.traceUIViewConfigUpdated(\n            activeUIView,\n            config && config.viewDecl && config.viewDecl.$context,\n          );\n          viewConfig = config;\n          updateView(config);\n        }\n\n        setCacheData($element, \"$ngView\", { $ngView: activeUIView });\n        updateView();\n        const unregister = $view.registerUIView(activeUIView);\n\n        scope.$on(\"$destroy\", function () {\n          trace.traceUIViewEvent(\"Destroying/Unregistering\", activeUIView);\n          unregister();\n        });\n        function cleanupLastView() {\n          if (previousEl) {\n            trace.traceUIViewEvent(\n              \"Removing (previous) el\",\n              getCacheData(previousEl, \"$ngView\"),\n            );\n            previousEl.remove();\n            previousEl = null;\n          }\n\n          if (currentScope) {\n            trace.traceUIViewEvent(\"Destroying scope\", activeUIView);\n            currentScope.$destroy();\n            currentScope = null;\n          }\n\n          if (currentEl) {\n            const _viewData = getCacheData(currentEl, \"$ngViewAnim\");\n\n            trace.traceUIViewEvent(\"Animate out\", _viewData);\n            renderer.leave(currentEl, function () {\n              _viewData.$$animLeave.resolve();\n              previousEl = null;\n            });\n            previousEl = currentEl;\n            currentEl = null;\n          }\n        }\n\n        /**\n         * @param {ViewConfig | undefined} [config]\n         */\n        function updateView(config) {\n          const newScope = scope.$new();\n\n          const animEnter = Promise.withResolvers();\n\n          const animLeave = Promise.withResolvers();\n\n          const $ngViewData = {\n            $cfg: config,\n            $ngView: activeUIView,\n          };\n\n          const $ngViewAnim = {\n            $animEnter: animEnter.promise,\n            $animLeave: animLeave.promise,\n            $$animLeave: animLeave,\n          };\n\n          /**\n           * Fired once the view **begins loading**, *before* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           * @param {string} viewName Name of the view.\n           */\n          newScope.$emit(\"$viewContentLoading\", name);\n          currentEl = /** @type {HTMLElement} */ (\n            /** @type {ng.TranscludeFn} */ ($transclude)(newScope, (clone) => {\n              setCacheData(\n                /** @type {HTMLElement} */ (clone),\n                \"$ngViewAnim\",\n                $ngViewAnim,\n              );\n              setCacheData(\n                /** @type {HTMLElement} */ (clone),\n                \"$ngView\",\n                $ngViewData,\n              );\n              renderer.enter(\n                /** @type {HTMLElement} */ (clone),\n                $element,\n                () => {\n                  animEnter.resolve(undefined);\n\n                  if (currentScope)\n                    currentScope.$emit(\"$viewContentAnimationEnded\");\n\n                  if (\n                    (isDefined(autoScrollExp) && !autoScrollExp) ||\n                    (autoScrollExp && scope.$eval(autoScrollExp))\n                  ) {\n                    $anchorScroll(/** @type {HTMLElement} */ (clone));\n                  }\n                },\n              );\n              cleanupLastView();\n            })\n          );\n\n          currentScope = newScope;\n          /**\n           * Fired once the view is **loaded**, *after* the DOM is rendered.\n           *\n           * @param {Object} event Event object.\n           */\n          currentScope.$emit(\"$viewContentLoaded\", config || viewConfig);\n          currentScope.$eval(onloadExp);\n        }\n      };\n    },\n  };\n\n  return directive;\n}\n\n$ViewDirectiveFill.$inject = [\n  $injectTokens._compile,\n  $injectTokens._controller,\n  $injectTokens._transitions,\n];\n\n/**\n * @param {ng.CompileService} $compile\n * @param {ng.ControllerService} $controller\n * @param {ng.TransitionService} $transitions\n * @return {ng.Directive}\n */\nexport function $ViewDirectiveFill($compile, $controller, $transitions) {\n  const getControllerAs = parse(\"viewDecl.controllerAs\");\n\n  const getResolveAs = parse(\"viewDecl.resolveAs\");\n\n  return {\n    priority: -400,\n    compile(tElement) {\n      const initial = tElement.innerHTML;\n\n      dealoc(tElement, true);\n\n      return function (scope, $element) {\n        const data = getCacheData($element, \"$ngView\");\n\n        if (!data) {\n          $element.innerHTML = initial;\n\n          $compile(\n            /** @type {HTMLIFrameElement} */ ($element).contentDocument ||\n              $element.childNodes,\n          )(scope);\n\n          return;\n        }\n        const cfg = data.$cfg || {\n          viewDecl: {},\n          getTemplate: () => {\n            /* empty */\n          },\n        };\n\n        const resolveCtx = cfg.path && new ResolveContext(cfg.path);\n\n        $element.innerHTML = cfg.getTemplate($element, resolveCtx) || initial;\n        trace.traceUIViewFill(data.$ngView, $element.innerHTML);\n        const link = $compile(\n          /** @type {HTMLIFrameElement} */ ($element).contentDocument ||\n            $element.childNodes,\n        );\n\n        const { controller } = cfg;\n\n        const controllerAs = getControllerAs(cfg);\n\n        const resolveAs = getResolveAs(cfg);\n\n        const locals = resolveCtx && getLocals(resolveCtx);\n\n        if (resolveAs) {\n          scope.$target[resolveAs] = locals;\n        }\n\n        if (controller) {\n          const controllerInstance = $controller(\n            controller,\n            Object.assign({}, locals, { $scope: scope, $element }),\n          );\n\n          if (controllerAs) {\n            scope.$target[controllerAs] = controllerInstance;\n            scope.$target[controllerAs][resolveAs] = locals;\n          }\n          // TODO: Use $view service as a central point for registering component-level hooks\n          // Then, when a component is created, tell the $view service, so it can invoke hooks\n          // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n          // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n          setCacheData($element, \"$ngControllerController\", controllerInstance);\n          Array.from($element.children).forEach((ell) => {\n            setCacheData(ell, \"$ngControllerController\", controllerInstance);\n          });\n          registerControllerCallbacks(\n            $transitions,\n            controllerInstance,\n            scope,\n            cfg,\n          );\n        }\n        // Wait for the component to appear in the DOM\n        // if (isString(cfg.component)) {\n        //const kebobName = kebobString(cfg.component);\n        // const tagRegexp = new RegExp(`^(x-|data-)?${kebobName}$`, \"i\");\n        // const getComponentController = () => {\n        //   const directiveEl = [].slice\n        //     .call($element.children)\n        //     .filter((el) => el && el.tagName && tagRegexp.exec(el.tagName));\n        //   return (\n        //     directiveEl &&\n        //     getCacheData(directiveEl, `$${cfg.component}Controller`)\n        //   );\n        // };\n        //console.error(getComponentController());\n        // const deregisterWatch = scope.$watch(\n        //   getComponentController,\n        //   function (ctrlInstance) {\n        //     if (!ctrlInstance) return;\n        //     registerControllerCallbacks(\n        //       $transitions,\n        //       ctrlInstance,\n        //       scope,\n        //       cfg,\n        //     );\n        //     deregisterWatch();\n        //   },\n        // );\n        // }\n        link(scope);\n      };\n    },\n  };\n}\n/** @ignore */\n/** @ignore incrementing id */\nlet _uiCanExitId = 0;\n\n/**\n * @ignore TODO: move these callbacks to $view and/or `/hooks/components.ts` or something\n * @param {ng.TransitionService} $transitions\n * @param {any} controllerInstance\n * @param {ng.Scope} $scope\n * @param {{ viewDecl: { component: any; componentProvider: any; }; path: import(\"../transition/transition.js\").PathNode[]; }} cfg\n */\nfunction registerControllerCallbacks(\n  $transitions,\n  controllerInstance,\n  $scope,\n  cfg,\n) {\n  // Call $onInit() ASAP\n  if (\n    isFunction(controllerInstance.$onInit) &&\n    !(cfg.viewDecl.component || cfg.viewDecl.componentProvider)\n  ) {\n    controllerInstance.$onInit();\n  }\n  const viewState = tail(cfg.path).state.self;\n\n  const hookOptions = { bind: controllerInstance };\n\n  // Add component-level hook for onUiParamsChanged\n  if (isFunction(controllerInstance.uiOnParamsChanged)) {\n    const resolveContext = new ResolveContext(cfg.path);\n\n    const viewCreationTrans = resolveContext.getResolvable(\"$transition$\").data;\n\n    // Fire callback on any successful transition\n    const paramsUpdated = (\n      /** @type {ng.Transition | undefined} */ $transition$,\n    ) => {\n      if (!$transition$) return;\n\n      // Exit early if the $transition$ is the same as the view was created within.\n      // Exit early if the $transition$ will exit the state the view is for.\n      if (\n        $transition$ === viewCreationTrans ||\n        $transition$.exiting().indexOf(viewState) !== -1\n      ) {\n        return;\n      }\n\n      const toParams = $transition$.params(\"to\");\n\n      const fromParams = $transition$.params(\"from\");\n\n      const getNodeSchema = (/** @type {{ paramSchema: any }} */ node) =>\n        node.paramSchema;\n\n      const treeChanges = $transition$ && $transition$.treeChanges;\n\n      const toNodes = isFunction(treeChanges)\n        ? (treeChanges.call($transition$, \"to\") ?? [])\n        : [];\n\n      const fromNodes = isFunction(treeChanges)\n        ? (treeChanges.call($transition$, \"from\") ?? [])\n        : [];\n\n      const toSchema =\n        /** @type {import(\"../transition/transition.js\").PathNode[]} */ (\n          toNodes\n        )\n          .map(getNodeSchema)\n          .reduce(unnestR, []);\n\n      const fromSchema =\n        /** @type {import(\"../transition/transition.js\").PathNode[]} */ (\n          fromNodes\n        )\n          .map(getNodeSchema)\n          .reduce(unnestR, []);\n\n      // Find the to params that have different values than the from params\n      const changedToParams = toSchema.filter(\n        (/** @type {{ id: string | number; }} */ param) => {\n          const idx = fromSchema.indexOf(param);\n\n          return (\n            idx === -1 ||\n            !fromSchema[idx].type.equals(\n              toParams[param.id],\n              fromParams[param.id],\n            )\n          );\n        },\n      );\n\n      // Only trigger callback if a to param has changed or is new\n      if (changedToParams.length) {\n        const changedKeys = /** @type {any[]} */ (\n          changedToParams.map((/** @type {{ id: any; }} */ x) => x.id)\n        );\n\n        // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n        /** @type {Record<string, any>} */\n        const newValues = {};\n\n        changedKeys.forEach((key) => {\n          if (key in toParams) newValues[key] = toParams[key];\n        });\n        controllerInstance.uiOnParamsChanged(newValues, $transition$);\n      }\n    };\n\n    $scope.$on(\n      \"$destroy\",\n      $transitions.onSuccess({}, paramsUpdated, hookOptions),\n    );\n  }\n\n  // Add component-level hook for uiCanExit\n  if (isFunction(controllerInstance.uiCanExit)) {\n    const id = _uiCanExitId++;\n\n    const cacheProp = \"_uiCanExitIds\";\n\n    /**\n     * Returns true if any transition in the redirect chain already answered truthy\n     * @param {import(\"../transition/transition.js\").Transition | null | undefined} trans\n     * @returns {boolean}\n     */\n    const prevTruthyAnswer = (\n      /** @type {ng.Transition & Record<String, any>} */ trans,\n    ) =>\n      !!trans &&\n      ((trans[cacheProp] && trans[cacheProp][id] === true) ||\n        prevTruthyAnswer(trans.redirectedFrom()));\n\n    // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n    const wrappedHook = (\n      /** @type {ng.Transition & Record<String, any>} */ trans,\n    ) => {\n      let promise;\n\n      const ids = (trans[cacheProp] = trans[cacheProp] || {});\n\n      if (!prevTruthyAnswer(trans)) {\n        promise = Promise.resolve(controllerInstance.uiCanExit(trans));\n        promise.then((val) => (ids[id] = val !== false));\n      }\n\n      return promise;\n    };\n\n    const criteria = { exiting: viewState.name };\n\n    $scope.$on(\n      \"$destroy\",\n      $transitions.onBefore(criteria, wrappedHook, hookOptions),\n    );\n  }\n}\n","import { isObject, isString } from \"../../shared/utils.js\";\nimport { $injectTokens } from \"../../injection-tokens.js\";\n\nngChannelDirective.$inject = [$injectTokens._eventBus];\n/**\n * @param {ng.PubSubService} $eventBus\n * @returns {ng.Directive}\n */\nexport function ngChannelDirective($eventBus) {\n  return {\n    scope: false,\n    link: (scope, element, attrs) => {\n      const channel = attrs.ngChannel;\n\n      const hasTemplateContent = element.childNodes.length > 0;\n\n      const unsubscribe = $eventBus.subscribe(\n        channel,\n        (/** @type {string | Object} */ value) => {\n          if (hasTemplateContent) {\n            if (isObject(value)) {\n              scope.$merge(value);\n            }\n          } else {\n            element.innerHTML = isString(value) ? value : value.toString();\n          }\n        },\n      );\n\n      scope.$on(\"$destroy\", () => unsubscribe());\n    },\n  };\n}\n","import { $injectTokens as $t } from \"../../injection-tokens.js\";\n\nngSetterDirective.$inject = [$t._parse, $t._log];\n\n/**\n * @param {ng.ParseService} $parse\n * @param {ng.LogService} $log\n * @returns {ng.Directive}\n */\nexport function ngSetterDirective($parse, $log) {\n  return {\n    restrict: \"A\",\n    link(scope, element, attrs) {\n      const modelExpression = attrs.ngSetter;\n\n      if (!modelExpression) {\n        $log.warn(\"ng-setter: expression null\");\n\n        return;\n      }\n\n      const assignModel = $parse(modelExpression)._assign;\n\n      if (!assignModel) {\n        $log.warn(\"ng-setter: expression invalid\");\n\n        return;\n      }\n\n      const updateModel = (/** @type {string} */ value) => {\n        assignModel(scope, value.trim());\n      };\n\n      const observer = new MutationObserver((mutationsList) => {\n        let contentChanged = false;\n\n        for (const mutation of mutationsList) {\n          if (\n            mutation.type === \"childList\" ||\n            mutation.type === \"characterData\"\n          ) {\n            contentChanged = true;\n            break;\n          }\n        }\n\n        if (contentChanged) {\n          updateModel(element.innerHTML);\n        }\n      });\n\n      observer.observe(element, {\n        childList: true,\n        subtree: true,\n        characterData: true,\n      });\n\n      scope.$on(\"$destroy\", () => observer.disconnect());\n      updateModel(element.innerHTML);\n    },\n  };\n}\n","import { $injectTokens, provider } from \"../../injection-tokens.js\";\nimport { nullObject } from \"../../shared/utils.js\";\n\n/**\n * Configurable provider for an injectable event bus\n * @extends {ng.ServiceProvider}\n */\nexport class PubSubProvider {\n  static $inject = provider([\n    $injectTokens._exceptionHandler,\n    $injectTokens._angular,\n  ]);\n\n  /**\n   * @param {ng.ExceptionHandlerProvider} $exceptionHandler\n   * @param {ng.ServiceProvider} angularProvider\n   */\n  constructor($exceptionHandler, angularProvider) {\n    /**\n     * @type {PubSub}\n     */\n    this.eventBus = new PubSub($exceptionHandler.handler);\n    /** @type {ng.Angular} */ (angularProvider.$get()).$eventBus =\n      this.eventBus;\n  }\n\n  $get = () => this.eventBus;\n}\n\nexport class PubSub {\n  /**\n   * @param {ng.ExceptionHandlerService} $exceptionHandler\n   */\n  constructor($exceptionHandler) {\n    /** @private {Object<string, Array<{fn: Function, context: any}>>} */\n    this._topics = nullObject();\n\n    /** @private */\n    this._disposed = false;\n\n    /** @public @type {ng.ExceptionHandlerService} */\n    this.$exceptionHandler = $exceptionHandler;\n  }\n\n  /**\n   * Set instance to initial state\n   */\n  reset() {\n    /** @private {Object<string, Array<{fn: Function, context: any}>>} */\n    this._topics = nullObject();\n\n    /** @private */\n    this._disposed = false;\n  }\n\n  /**\n   * Checks if instance has been disposed.\n   * @returns {boolean} True if disposed.\n   */\n  isDisposed() {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose the instance, removing all topics and listeners.\n   */\n  dispose() {\n    if (this._disposed) return;\n    this._disposed = true;\n    this._topics = nullObject();\n  }\n\n  /**\n   * Subscribe a function to a topic.\n   * @param {string} topic - The topic to subscribe to.\n   * @param {Function} fn - The callback function to invoke when published.\n   * @param {*} [context] - Optional `this` context for the callback.\n   * @returns {() => boolean} A function that unsubscribes this listener.\n   */\n  subscribe(topic, fn, context = undefined) {\n    if (this._disposed) return () => false;\n\n    /** @type {Array<{fn: Function, context: any}>} */\n    let listeners = this._topics[topic];\n\n    if (!listeners) this._topics[topic] = listeners = [];\n\n    const entry = { fn, context };\n\n    listeners.push(entry);\n\n    return () => this.unsubscribe(topic, fn, context);\n  }\n\n  /**\n   * Subscribe a function to a topic only once.\n   * Listener is removed before the first invocation.\n   * @param {string} topic - The topic to subscribe to.\n   * @param {Function} fn - The callback function.\n   * @param {*} [context] - Optional `this` context for the callback.\n   * @returns {() => boolean} A function that unsubscribes this listener.\n   */\n  subscribeOnce(topic, fn, context = undefined) {\n    if (this._disposed) return () => false;\n\n    let called = false;\n\n    const wrapper = (/** @type {any[]} */ ...args) => {\n      if (called) return;\n      called = true;\n\n      unsub(); // unsubscribe before running\n      fn.apply(context, args);\n    };\n\n    const unsub = this.subscribe(topic, wrapper);\n\n    return unsub;\n  }\n\n  /**\n   * Unsubscribe a specific function from a topic.\n   * Matches by function reference and optional context.\n   * @param {string} topic - The topic to unsubscribe from.\n   * @param {Function} fn - The listener function.\n   * @param {*} [context] - Optional `this` context.\n   * @returns {boolean} True if the listener was found and removed.\n   */\n  unsubscribe(topic, fn, context = undefined) {\n    if (this._disposed) return false;\n\n    const listeners = this._topics[topic];\n\n    if (!listeners || listeners.length === 0) return false;\n\n    for (let i = 0; i < listeners.length; i++) {\n      const l = listeners[i];\n\n      if (l.fn === fn && l.context === context) {\n        listeners.splice(i, 1);\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the number of subscribers for a topic.\n   * @param {string} topic\n   * @returns {number}\n   */\n  getCount(topic) {\n    const listeners = this._topics[topic];\n\n    return listeners ? listeners.length : 0;\n  }\n\n  /**\n   * Publish a value to a topic asynchronously.\n   * All listeners are invoked in the order they were added.\n   * @param {string} topic - The topic to publish.\n   * @param {...*} args - Arguments to pass to listeners.\n   * @returns {boolean} True if any listeners exist for this topic.\n   */\n  publish(topic, ...args) {\n    if (this._disposed) return false;\n\n    const listeners = this._topics[topic];\n\n    if (!listeners || listeners.length === 0) return false;\n\n    // snapshot to prevent modifications during publish from affecting this call\n    const snapshot = listeners.slice();\n\n    queueMicrotask(() => {\n      for (const { fn, context } of snapshot) {\n        try {\n          fn.apply(context, args);\n        } catch (err) {\n          this.$exceptionHandler(err);\n        }\n      }\n    });\n\n    return true;\n  }\n}\n","import { $injectTokens as $t } from \"../../injection-tokens.js\";\n\nngInjectDirective.$inject = [$t._log, $t._injector];\n\n/**\n * @param {ng.LogService} $log\n * @param {ng.InjectorService} $injector\n * @returns {ng.Directive}\n */\nexport function ngInjectDirective($log, $injector) {\n  return {\n    restrict: \"A\",\n    link(scope, _element, attrs) {\n      const expr = attrs.ngInject;\n\n      if (!expr) return;\n      const tokens = expr\n        .split(\";\")\n        .map((x) => x.trim())\n        .filter(Boolean);\n\n      for (const name of tokens) {\n        if ($injector.has(name)) {\n          scope[name] = $injector.get(name);\n        } else {\n          $log.warn(`Injectable ${name} not found in $injector`);\n        }\n      }\n    },\n  };\n}\n","/**\n * @returns {ng.Directive}\n */\nexport function ngElDirective() {\n  return {\n    restrict: \"A\",\n    link(scope, element, attrs) {\n      const expr = attrs.ngEl;\n\n      const key = !expr ? element.id : expr;\n\n      scope.$target[key] = element;\n      const parent = element.parentNode;\n\n      if (!parent) return;\n\n      const observer = new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n          Array.from(mutation.removedNodes).forEach((removedNode) => {\n            if (removedNode === element) {\n              //\n              delete scope.$target[key];\n              observer.disconnect();\n            }\n          });\n        }\n      });\n\n      observer.observe(parent, { childList: true });\n    },\n  };\n}\n","/**\n * Shared Stream Connection Manager\n * Handles reconnect, heartbeat, and event callbacks for SSE or WebSocket\n */\nexport class StreamConnection {\n  /**\n   * @param {() => EventSource | WebSocket} createFn - Function that creates a new EventSource or WebSocket.\n   * @param {ng.StreamConnectionConfig} config - Configuration object with callbacks, retries, heartbeat, transformMessage.\n   * @param {ng.LogService} log - Optional logger (default: console).\n   */\n  constructor(createFn, config = {}, log = console) {\n    /** @private @type {() => EventSource | WebSocket} */\n    this._createFn = createFn;\n    this._config = {\n      retryDelay: 1000,\n      maxRetries: Infinity,\n      heartbeatTimeout: 15000,\n      transformMessage: (/** @type {string} */ data) => {\n        try {\n          return JSON.parse(data);\n        } catch {\n          return data;\n        }\n      },\n      ...config,\n    };\n    this._log = log;\n    this._retryCount = 0;\n    this._closed = false;\n    this._heartbeatTimer = undefined;\n    /** @type {EventSource | WebSocket | null} */\n    this._connection = null;\n\n    this.connect();\n  }\n\n  /**\n   * Establishes a new connection using the provided createFn.\n   * Closes any existing connection before creating a new one.\n   */\n  connect() {\n    if (this._closed) return;\n\n    // Close the old connection if it exists\n    if (this._connection && typeof this._connection.close === \"function\") {\n      this._connection.close();\n    }\n\n    // Create new connection\n    this._connection = this._createFn();\n\n    // Bind events for the new connection\n    this._bindEvents();\n  }\n\n  /**\n   * Sends data over a WebSocket connection.\n   * Logs a warning if called on a non-WebSocket connection.\n   * @param {any} data - Data to send.\n   */\n  send(data) {\n    if (this._connection instanceof WebSocket) {\n      this._connection.send(JSON.stringify(data));\n    } else {\n      this._log.warn(\"Send is only supported on WebSocket connections\");\n    }\n  }\n\n  /**\n   * Closes the connection manually and clears the heartbeat timer.\n   */\n  close() {\n    this._closed = true;\n    clearTimeout(this._heartbeatTimer);\n\n    if (this._connection && this._connection.close) {\n      this._connection.close();\n    }\n  }\n\n  /**\n   * @private\n   * Binds event handlers to the underlying connection (EventSource or WebSocket)\n   * for open, message, error, and close events.\n   */\n  _bindEvents() {\n    const conn = this._connection;\n\n    if (conn instanceof EventSource) {\n      conn.addEventListener(\"open\", (err) => this._handleOpen(err));\n      conn.addEventListener(\"message\", (err) =>\n        this._handleMessage(err.data, err),\n      );\n      conn.addEventListener(\"error\", (err) => this._handleError(err));\n    } else if (conn instanceof WebSocket) {\n      conn.onopen = (err) => this._handleOpen(err);\n      conn.onmessage = (err) => this._handleMessage(err.data, err);\n      conn.onerror = (err) => this._handleError(err);\n      conn.onclose = () => this._handleClose();\n    }\n  }\n\n  /**\n   * @private\n   * Handles the open event from the connection.\n   * @param {Event} event - The open event.\n   */\n  _handleOpen(event) {\n    this._retryCount = 0;\n    this._config.onOpen?.(event);\n    this._resetHeartbeat();\n  }\n\n  /**\n   * @private\n   * Handles incoming messages, applies the transformMessage function,\n   * and calls the onMessage callback.\n   * @param {any} data - Raw message data.\n   * @param {Event} event - The message event.\n   */\n  _handleMessage(data, event) {\n    try {\n      data = this._config.transformMessage?.(data) ?? data;\n    } catch {\n      /* empty */\n    }\n    this._config.onMessage?.(data, event);\n    this._resetHeartbeat();\n  }\n\n  /**\n   * @private\n   * Handles errors emitted from the connection.\n   * Calls onError callback and schedules a reconnect.\n   * @param {any} err - Error object or message.\n   */\n  _handleError(err) {\n    this._config.onError?.(err);\n    this._scheduleReconnect();\n  }\n\n  /**\n   * @private\n   * Handles close events for WebSocket connections.\n   * Triggers reconnect logic.\n   */\n  _handleClose() {\n    this._scheduleReconnect();\n  }\n\n  /**\n   * @private\n   * Schedules a reconnect attempt based on retryCount and config.maxRetries.\n   * Calls onReconnect callback if reconnecting.\n   */\n  _scheduleReconnect() {\n    if (this._closed) return;\n\n    if (this._retryCount < this._config.maxRetries) {\n      this._retryCount++;\n      this._config.onReconnect?.(this._retryCount);\n      setTimeout(() => this.connect(), this._config.retryDelay);\n    } else {\n      this._log.warn(\"StreamConnection: Max retries reached\");\n    }\n  }\n\n  /**\n   * @private\n   * Resets the heartbeat timer. If the timer expires, the connection is closed\n   * and a reconnect is attempted.\n   */\n  _resetHeartbeat() {\n    if (!this._config.heartbeatTimeout) return;\n\n    clearTimeout(this._heartbeatTimer);\n    this._heartbeatTimer = setTimeout(() => {\n      this._log.warn(\"StreamConnection: heartbeat timeout, reconnecting...\");\n      this._closeInternal();\n      this._retryCount++;\n      this._config.onReconnect?.(this._retryCount);\n      this.connect();\n    }, this._config.heartbeatTimeout);\n  }\n\n  /**\n   * @private\n   */\n  _closeInternal() {\n    clearTimeout(this._heartbeatTimer);\n    this._connection?.close();\n  }\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { entries } from \"../../shared/utils.js\";\nimport { StreamConnection } from \"../stream/stream.js\";\n\nexport class SseProvider {\n  constructor() {\n    /** @type {ng.SseConfig} */\n    this.defaults = {\n      retryDelay: 1000,\n      maxRetries: Infinity,\n      heartbeatTimeout: 15000,\n      transformMessage(data) {\n        try {\n          return JSON.parse(data);\n        } catch {\n          return data;\n        }\n      },\n    };\n  }\n\n  $get = [\n    $injectTokens._log,\n    /** @param {ng.LogService} log */ (log) => {\n      this._$log = log;\n\n      /** @type {ng.SseService} */\n      return (url, config = {}) => {\n        const mergedConfig = { ...this.defaults, ...config };\n\n        const finalUrl = this.#buildUrl(url, mergedConfig.params);\n\n        return new StreamConnection(\n          () =>\n            new EventSource(finalUrl, {\n              withCredentials: !!mergedConfig.withCredentials,\n            }),\n          {\n            ...mergedConfig,\n            onMessage: (data, event) => {\n              // Cast Event -> MessageEvent safely\n              mergedConfig.onMessage?.(\n                data,\n                /** @type{MessageEvent} */ (event),\n              );\n            },\n          },\n          this._$log,\n        );\n      };\n    },\n  ];\n\n  /**\n   * Build URL with query parameters\n   * @param {string} url\n   * @param {Record<string, any>=} params\n   * @returns {string}\n   * @throws {URIError}\n   */\n  #buildUrl(url, params) {\n    if (!params) return url;\n    const query = entries(params)\n      .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n      .join(\"&\");\n\n    return url + (url.includes(\"?\") ? \"&\" : \"?\") + query;\n  }\n}\n","/**\n * @returns {ng.Directive}\n */\nexport function ngViewportDirective() {\n  return {\n    restrict: \"A\",\n    link(scope, element, attrs) {\n      const enterExpr = attrs.onEnter;\n\n      const leaveExpr = attrs.onLeave;\n\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.isIntersecting) {\n              if (enterExpr) scope.$eval(enterExpr);\n            } else {\n              if (leaveExpr) scope.$eval(leaveExpr);\n            }\n          });\n        },\n        {\n          root: null, // viewport\n          threshold: 0.1, // consider \"in view\" if 10% visible\n        },\n      );\n\n      observer.observe(element);\n\n      // Clean up when the element is removed from DOM\n      const parent = element.parentNode;\n\n      /** @type {MutationObserver} */\n      let mutationObserver;\n\n      if (parent) {\n        mutationObserver = new MutationObserver((mutations) => {\n          for (const mutation of mutations) {\n            Array.from(mutation.removedNodes).forEach((removedNode) => {\n              if (removedNode === element) {\n                observer.disconnect();\n                mutationObserver.disconnect();\n              }\n            });\n          }\n        });\n        mutationObserver.observe(parent, { childList: true });\n      }\n\n      scope.$on(\"$destroy\", () => {\n        observer.disconnect();\n\n        if (mutationObserver) mutationObserver.disconnect();\n      });\n    },\n  };\n}\n","import { instantiateWasm } from \"../../shared/utils.js\";\n\n/**\n * @return {ng.Directive}\n */\nexport function ngWasmDirective() {\n  return {\n    async link($scope, _, $attrs) {\n      $scope.$target[$attrs.as || \"wasm\"] = (\n        await instantiateWasm($attrs.src)\n      ).exports;\n    },\n  };\n}\n","/**\n * @return {ng.Directive}\n */\nexport function ngScopeDirective() {\n  return {\n    scope: false,\n    async link($scope, _, $attrs) {\n      $scope.$scopename = $attrs.ngScope;\n    },\n  };\n}\n","import {\n  isDefined,\n  isNullOrUndefined,\n  isNumber,\n  isString,\n  nullObject,\n} from \"../../shared/utils.js\";\nimport {\n  validateIsString,\n  validateRequired,\n  BADARG,\n} from \"../../shared/validate.js\";\n\n/**\n * Service provider that creates a {@link CookieService $cookie} service.\n * @type {ng.ServiceProvider}\n */\nexport class CookieProvider {\n  constructor() {\n    /** @type {ng.CookieOptions} */\n    this.defaults = {};\n  }\n\n  $get = () => new CookieService(this.defaults);\n}\n\n/**\n *\n * Provides high-level APIs for interacting with browser cookies:\n *  - Raw get/set/remove\n *  - JSON serialization helpers\n *  - Global defaults supplied by $cookiesProvider\n */\nexport class CookieService {\n  /**\n   * @param {ng.CookieOptions} defaults\n   *   Default cookie attributes defined by `$cookiesProvider.defaults`.\n   */\n  constructor(defaults) {\n    /** @private @type {ng.CookieOptions} */\n    this._defaults = Object.freeze({ ...defaults });\n  }\n\n  /**\n   * Retrieves a raw cookie value.\n   *\n   * @param {string} key\n   * @returns {string|null}\n   * @throws {URIError}  If decodeURIComponent fails.\n   */\n  get(key) {\n    validateIsString(key, \"key\");\n    const all = parseCookies();\n\n    return all[key] || null;\n  }\n\n  /**\n   * Retrieves a cookie and deserializes its JSON content.\n   *\n   * @template T\n   * @param {string} key\n   * @returns {T|null}\n   * @throws {SyntaxError} if cookie JSON is invalid\n   */\n  getObject(key) {\n    validateIsString(key, \"key\");\n\n    const raw = this.get(key);\n\n    if (!raw) return null;\n\n    return /** @type {T} */ (JSON.parse(raw));\n  }\n\n  /**\n   * Returns an object containing all raw cookies.\n   *\n   * @returns {Record<string, string>}\n   * @throws {URIError}  If decodeURIComponent fails\n   */\n  getAll() {\n    return parseCookies();\n  }\n\n  /**\n   * Sets a raw cookie value.\n   *\n   * @param {string} key\n   * @param {string} value\n   * @param {ng.CookieOptions} [options]\n   * @throws {URIError} if key or value cannot be encoded\n   */\n  put(key, value, options = {}) {\n    validateIsString(key, \"key\");\n    validateIsString(value, \"value\");\n    const encodedKey = encodeURIComponent(key);\n\n    const encodedVal = encodeURIComponent(value);\n\n    document.cookie = `${encodedKey}=${encodedVal}${buildOptions({\n      ...this._defaults,\n      ...options,\n    })}`;\n  }\n\n  /**\n   * Serializes an object as JSON and stores it as a cookie.\n   *\n   * @param {string} key\n   * @param {any} value\n   * @param {ng.CookieOptions} [options]\n   * @throws {TypeError} if Object cannot be converted to JSON\n   */\n  putObject(key, value, options) {\n    validateIsString(key, \"key\");\n    validateRequired(value, \"value\");\n    const str = JSON.stringify(value);\n\n    this.put(key, str, options);\n  }\n\n  /**\n   * Removes a cookie by setting an expired date.\n   *\n   * @param {string} key\n   * @param {ng.CookieOptions} [options]\n   */\n  remove(key, options = {}) {\n    validateIsString(key, \"key\");\n    this.put(key, \"\", {\n      ...this._defaults,\n      ...options,\n      expires: new Date(0),\n    });\n  }\n}\n\n/*----------Helpers----------*/\n\n// Internal cache\nlet _lastCookieString = \"\";\n\n/** @type {Record<string, string>} */\nlet _lastCookieMap = nullObject();\n\n/**\n * @returns {Record<string,string>}\n * @throws {URIError}  If decodeURIComponent fails\n */\nfunction parseCookies() {\n  const current = document.cookie;\n\n  // Fast path: return cached object if nothing changed\n  if (current === _lastCookieString) {\n    return _lastCookieMap;\n  }\n\n  _lastCookieString = current;\n\n  /** @type {Record<string, string>} */\n  const out = nullObject();\n\n  if (!current) {\n    _lastCookieMap = out;\n\n    return out;\n  }\n\n  const parts = current.split(\"; \");\n\n  for (const part of parts) {\n    const eq = part.indexOf(\"=\");\n\n    if (eq === -1) continue; // skip malformed cookie\n\n    const key = decodeURIComponent(part.substring(0, eq));\n\n    const val = decodeURIComponent(part.substring(eq + 1));\n\n    out[key] = val; // last wins\n  }\n\n  _lastCookieMap = out;\n\n  return out;\n}\n\n/**\n * Build cookie options string from an options object.\n * Safely validates types for path, domain, expires, secure, and samesite.\n *\n * @param {ng.CookieOptions} opts\n * @returns {string}\n * @throws {TypeError} if any of options are invalid\n */\nfunction buildOptions(opts = {}) {\n  const parts = [];\n\n  // Path\n  if (isDefined(opts.path)) {\n    if (!isString(opts.path))\n      throw new TypeError(`${BADARG}:path ${opts.path}`);\n    parts.push(`path=${opts.path}`);\n  }\n\n  // Domain\n  if (isDefined(opts.domain)) {\n    if (!isString(opts.domain))\n      throw new TypeError(`${BADARG}:domain ${opts.domain}`);\n    parts.push(`domain=${opts.domain}`);\n  }\n\n  // Expires\n  if (!isNullOrUndefined(opts.expires)) {\n    let expDate;\n\n    if (opts.expires instanceof Date) {\n      expDate = opts.expires;\n    } else if (isNumber(opts.expires) || isString(opts.expires)) {\n      expDate = new Date(opts.expires);\n    } else {\n      throw new TypeError(`${BADARG}:expires ${String(opts.expires)}`);\n    }\n\n    if (isNaN(expDate.getTime())) {\n      throw new TypeError(`${BADARG}:expires ${String(opts.expires)}`);\n    }\n\n    parts.push(`expires=${expDate.toUTCString()}`);\n  }\n\n  // Secure\n  if (opts.secure) {\n    parts.push(\"secure\");\n  }\n\n  // SameSite\n  if (isDefined(opts.samesite)) {\n    if (!isString(opts.samesite))\n      throw new TypeError(`${BADARG}:samesite ${opts.samesite}`);\n    const samesite = opts.samesite.toLowerCase();\n\n    if (![\"lax\", \"strict\", \"none\"].includes(samesite)) {\n      throw new TypeError(`${BADARG}:samesite ${opts.samesite}`);\n    }\n    parts.push(`samesite=${samesite}`);\n  }\n\n  // Join all parts with semicolons\n  return parts.length ? `;${parts.join(\";\")}` : \"\";\n}\n","import { isArray } from \"../../shared/utils.js\";\n\n/**\n * RFC 6570 Level 4 URI Template expander\n *\n * Supports operators: (none), +, #, ., /, ;, ?, &\n * Supports varspec modifiers: explode (*) and prefix (:len)\n *\n * Usage:\n *   expandUriTemplate(\"/users/{id}\", { id: 10 }) === \"/users/10\"\n *   expandUriTemplate(\"/search{?q,lang}\", { q: \"a b\", lang: \"en\" }) === \"/search?q=a%20b&lang=en\"\n *   expandUriTemplate(\"/repos/{owner}/{repo}/issues{?labels*}\", { labels: [\"bug\",\"ui\"] }) === \"/repos/x/y/issues?labels=bug&labels=ui\"\n *\n * @param {string} template\n * @param {Object<string, any>} vars\n * @returns {string}\n */\nexport function expandUriTemplate(template, vars = {}) {\n  if (typeof template !== \"string\")\n    throw new TypeError(\"template must be a string\");\n\n  return template.replace(/\\{([^}]+)\\}/g, (match, expression) => {\n    return expandExpression(expression, vars);\n  });\n}\n\n/**\n * Helper: percent-encode a string. If allowReserved true, reserved chars are NOT encoded.\n * @param {string} str\n * @param {boolean} allowReserved\n * @returns {string}\n */\nexport function pctEncode(str, allowReserved) {\n  // encodeURIComponent, then restore reserved if allowed\n  const encoded = encodeURIComponent(String(str));\n\n  if (allowReserved) {\n    // Reserved characters per RFC 3986\n    return encoded.replace(\n      /(%3A|%2F|%3F|%23|%5B|%5D|%40|%21|%24|%26|%27|%28|%29|%2A|%2B|%2C|%3B|%3D)/gi,\n      (char) => decodeURIComponent(char),\n    );\n  }\n\n  return encoded;\n}\n\n/**\n * Parse and expand a single expression (content between { and }).\n * @param {string} expression\n * @param {Object<string, any>} vars\n * @returns {string}\n */\nexport function expandExpression(expression, vars) {\n  // Operator if first char in operator set\n  const operator = /^[+#./;?&]/.test(expression) ? expression[0] : \"\";\n\n  const op = operator;\n\n  const varlist = op ? expression.slice(1) : expression;\n\n  // operator configuration (separator, prefix, named, ifEmpty, allowReserved)\n  /** @type {Record<string, any>} */\n  const OP = {\n    \"\": {\n      sep: \",\",\n      prefix: \"\",\n      named: false,\n      ifEmpty: \"\",\n      allowReserved: false,\n    },\n    \"+\": {\n      sep: \",\",\n      prefix: \"\",\n      named: false,\n      ifEmpty: \"\",\n      allowReserved: true,\n    },\n    \"#\": {\n      sep: \",\",\n      prefix: \"#\",\n      named: false,\n      ifEmpty: \"\",\n      allowReserved: true,\n    },\n    \".\": {\n      sep: \".\",\n      prefix: \".\",\n      named: false,\n      ifEmpty: \"\",\n      allowReserved: false,\n    },\n    \"/\": {\n      sep: \"/\",\n      prefix: \"/\",\n      named: false,\n      ifEmpty: \"\",\n      allowReserved: false,\n    },\n    \";\": {\n      sep: \";\",\n      prefix: \";\",\n      named: true,\n      ifEmpty: \"\",\n      allowReserved: false,\n    },\n    \"?\": {\n      sep: \"&\",\n      prefix: \"?\",\n      named: true,\n      ifEmpty: \"=\",\n      allowReserved: false,\n    },\n    \"&\": {\n      sep: \"&\",\n      prefix: \"&\",\n      named: true,\n      ifEmpty: \"=\",\n      allowReserved: false,\n    },\n  };\n\n  const conf = OP[op];\n\n  if (!conf) throw new Error(`Unsupported operator: ${op}`);\n\n  // split varspecs by comma, preserve whitespace trimmed\n  const varspecs = varlist\n    .split(\",\")\n    .map((str) => str.trim())\n    .filter(Boolean);\n\n  const expandedParts = [];\n\n  for (const spec of varspecs) {\n    // parse varspec: name, explode (*), prefix (:len)\n    const varspec = /^([A-Za-z0-9_.]+)(\\*|(?::(\\d+)))?$/.exec(spec);\n\n    if (!varspec) throw new Error(`Invalid varspec: ${spec}`);\n    const varname = varspec[1];\n\n    const explode = varspec[2] === \"*\";\n\n    const prefixLength = varspec[3] ? parseInt(varspec[3], 10) : undefined;\n\n    const value = vars[varname];\n\n    // undefined or null = skip (no expansion)\n    if (value === undefined || value === null) {\n      continue;\n    }\n\n    // PROCESS arrays\n    if (isArray(value)) {\n      if (value.length === 0) {\n        // empty array: for named operators, emit key with empty ifEmpty, otherwise skip\n        if (conf.named) {\n          // emit key without value or with = depending on ifEmpty\n          if (conf.ifEmpty === \"=\") {\n            expandedParts.push(\n              `${pctEncode(varname, conf.allowReserved)}${conf.ifEmpty}`,\n            );\n          } else {\n            expandedParts.push(pctEncode(varname, conf.allowReserved));\n          }\n        }\n        continue;\n      }\n\n      if (explode) {\n        // each item becomes either 'k=v' (named) or 'v' (unnamed)\n        for (const item of value) {\n          if (item === null || item === undefined) continue;\n\n          if (conf.named) {\n            expandedParts.push(\n              `${pctEncode(varname, conf.allowReserved)}=${pctEncode(item, conf.allowReserved)}`,\n            );\n          } else {\n            expandedParts.push(pctEncode(item, conf.allowReserved));\n          }\n        }\n      } else {\n        // join by comma (or operator.sep?)  RFC: simple join with ','\n        const joined = value\n          .filter((val) => val !== null && val !== undefined)\n          .map((val) => pctEncode(val, conf.allowReserved))\n          .join(\",\");\n\n        if (conf.named) {\n          if (joined === \"\") {\n            expandedParts.push(\n              pctEncode(varname, conf.allowReserved) +\n                (conf.ifEmpty === \"=\" ? conf.ifEmpty : \"\"),\n            );\n          } else {\n            expandedParts.push(\n              `${pctEncode(varname, conf.allowReserved)}=${joined}`,\n            );\n          }\n        } else {\n          expandedParts.push(joined);\n        }\n      }\n      continue;\n    }\n\n    // PROCESS objects (associative arrays)\n    if (typeof value === \"object\") {\n      const keys = Object.keys(value);\n\n      if (keys.length === 0) {\n        if (conf.named) {\n          expandedParts.push(\n            pctEncode(varname, conf.allowReserved) +\n              (conf.ifEmpty === \"=\" ? conf.ifEmpty : \"\"),\n          );\n        }\n        continue;\n      }\n\n      if (explode) {\n        // each key/value pair becomes k=v (named) or k,v? For explode + named, RFC says 'k=v'\n        for (const key of keys) {\n          const encVal = value[key];\n\n          if (encVal === null || encVal === undefined) continue;\n\n          if (conf.named) {\n            expandedParts.push(\n              `${pctEncode(key, conf.allowReserved)}=${pctEncode(encVal, conf.allowReserved)}`,\n            );\n          } else {\n            // unnamed explode => k,encVal form pairs\n            expandedParts.push(\n              `${pctEncode(key, conf.allowReserved)}=${pctEncode(encVal, conf.allowReserved)}`,\n            );\n          }\n        }\n      } else {\n        // not exploded: join k,v pairs by ','\n        const pairs = keys\n          .map(\n            (key) =>\n              `${pctEncode(key, conf.allowReserved)},${pctEncode(value[key], conf.allowReserved)}`,\n          )\n          .join(\",\");\n\n        if (conf.named) {\n          if (pairs === \"\") {\n            expandedParts.push(\n              pctEncode(varname, conf.allowReserved) +\n                (conf.ifEmpty === \"=\" ? conf.ifEmpty : \"\"),\n            );\n          } else {\n            expandedParts.push(\n              `${pctEncode(varname, conf.allowReserved)}=${pairs}`,\n            );\n          }\n        } else {\n          expandedParts.push(pairs);\n        }\n      }\n      continue;\n    }\n\n    // PROCESS scalar (string/number/boolean)\n    let str = String(value);\n\n    // apply prefix modifier if present\n    if (typeof prefixLength === \"number\") {\n      str = str.substring(0, prefixLength);\n    }\n\n    // empty string handling\n    if (str === \"\") {\n      if (conf.named) {\n        // for named operators, emit key or key= depending on ifEmpty\n        if (conf.ifEmpty === \"=\") {\n          expandedParts.push(\n            `${pctEncode(varname, conf.allowReserved)}${conf.ifEmpty}`,\n          );\n        } else {\n          expandedParts.push(pctEncode(varname, conf.allowReserved));\n        }\n      } else {\n        // unnamed operators: empty string -> nothing (skip)\n        if (op === \"+\" || op === \"#\") {\n          // these allow empty expansions (produce nothing)\n          expandedParts.push(pctEncode(str, conf.allowReserved));\n        } else {\n          // skip adding anything\n          expandedParts.push(pctEncode(str, conf.allowReserved));\n        }\n      }\n      continue;\n    }\n\n    // default scalar behavior\n    if (conf.named) {\n      expandedParts.push(\n        `${pctEncode(varname, conf.allowReserved)}=${pctEncode(str, conf.allowReserved)}`,\n      );\n    } else {\n      expandedParts.push(pctEncode(str, conf.allowReserved));\n    }\n  } // end for varspecs\n\n  if (expandedParts.length === 0) return \"\";\n\n  // join parts with operator separator; prefix if needed\n  return conf.prefix + expandedParts.join(conf.sep);\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport {\n  assert,\n  isArray,\n  isNullOrUndefined,\n  isString,\n} from \"../../shared/utils.js\";\nimport { BADARG } from \"../../shared/validate.js\";\nimport { expandUriTemplate } from \"./rfc.js\";\n\n/**\n * @template T, ID\n */\nexport class RestService {\n  static $nonscope = true;\n\n  /**\n   * Core REST service for CRUD operations.\n   * Safe, predictable, and optionally maps raw JSON to entity class instances.\n   *\n   * @param {ng.HttpService} $http Angular-like $http service\n   * @param {string} baseUrl Base URL or URI template\n   * @param {ng.EntityClass<T>} [entityClass] Optional constructor to map JSON to objects\n   * @param {Object} [options] Optional settings (interceptors, headers, etc.)\n   */\n  constructor($http, baseUrl, entityClass, options = {}) {\n    assert(isString(baseUrl) && baseUrl.length > 0, \"baseUrl required\");\n\n    /** @private */\n    this._$http = $http;\n    /** @private */\n    this._baseUrl = baseUrl;\n    /** @private */\n    this._entityClass = entityClass;\n    /** @private */\n    this._options = options;\n  }\n\n  /**\n   * Build full URL from template and parameters\n   * @param {string} template\n   * @param {Record<string, any>} params\n   * @returns {string}\n   */\n  buildUrl(template, params) {\n    // Safe: ensure params is an object\n    return expandUriTemplate(template, params || {});\n  }\n\n  /**\n   * Map raw JSON to entity instance or return as-is\n   * @param {any} data\n   * @returns {T|any}\n   */\n  #mapEntity(data) {\n    if (!data) return data;\n\n    return this._entityClass ? new this._entityClass(data) : data;\n  }\n\n  /**\n   * List entities\n   * @param {Record<string, any>=} params\n   * @returns {Promise<T[]>}\n   */\n  async list(params = {}) {\n    const url = this.buildUrl(this._baseUrl, params);\n\n    const resp = await this.#request(\"GET\", url, null, params);\n\n    if (!isArray(resp.data)) return [];\n\n    return resp.data.map(\n      /** @param {unknown} data */ (data) => this.#mapEntity(data),\n    );\n  }\n\n  /**\n   * Read single entity by ID\n   * @param {ID} id\n   * @param {Record<string, any>=} params\n   * @returns {Promise<T|null>}\n   */\n  async read(id, params = {}) {\n    assert(!isNullOrUndefined(id), `${BADARG}:id ${id}`);\n    const url = this.buildUrl(`${this._baseUrl}/${id}`, params);\n\n    const resp = await this.#request(\"GET\", url, null, params);\n\n    return this.#mapEntity(resp.data);\n  }\n\n  /**\n   * Create a new entity\n   * @param {T} item\n   * @returns {Promise<T>}\n   */\n  async create(item) {\n    assert(!isNullOrUndefined(item), `${BADARG}:item ${item}`);\n    const resp = await this.#request(\"POST\", this._baseUrl, item);\n\n    return this.#mapEntity(resp.data);\n  }\n\n  /**\n   * Update entity by ID\n   * @param {ID} id\n   * @param {Partial<T>} item\n   * @returns {Promise<T|null>}\n   */\n  async update(id, item) {\n    assert(!isNullOrUndefined(id), `${BADARG}:id ${id}`);\n    const url = `${this._baseUrl}/${id}`;\n\n    try {\n      const resp = await this.#request(\"PUT\", url, item);\n\n      return this.#mapEntity(resp.data);\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Delete entity by ID\n   * @param {ID} id\n   * @returns {Promise<boolean>}\n   */\n  async delete(id) {\n    assert(!isNullOrUndefined(id), `${BADARG}:id ${id}`);\n    const url = `${this._baseUrl}/${id}`;\n\n    try {\n      await this.#request(\"DELETE\", url);\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Core HTTP request wrapper\n   * @param {ng.HttpMethod} method\n   * @param {string} url\n   * @param {any=} data\n   * @param {Record<string, any>=} params\n   * @returns {Promise<any>}\n   */\n  async #request(method, url, data = null, params = {}) {\n    return this._$http({\n      method,\n      url,\n      data,\n      params,\n      ...this._options,\n    });\n  }\n}\n\n/**\n * Provider for registering REST endpoints during module configuration.\n */\nexport class RestProvider {\n  constructor() {\n    /** @private @type {ng.RestDefinition<any>[]} */\n    this._definitions = [];\n  }\n\n  /**\n   * Register a REST resource at config phase\n   * @template T\n   * @param {string} name Service name\n   * @param {string} url Base URL or URI template\n   * @param {{new(data:any):T}=} entityClass Optional entity constructor\n   * @param {Object=} options Optional service options\n   */\n  rest(name, url, entityClass, options = {}) {\n    this._definitions.push({ name, url, entityClass, options });\n  }\n\n  /**\n   * $get factory: returns a factory function and allows access to named services\n   * @returns {(baseUrl:string, entityClass?:Function, options?:object) => RestService & { get(name:string): RestService, listNames(): string[] }}\n   */\n  $get = [\n    $injectTokens._http,\n    /** @param {ng.HttpService} $http */\n    ($http) => {\n      const services = new Map();\n\n      /**\n       * @template T, ID\n       * @type {(baseUrl: string, entityClass?: ng.EntityClass<T>, options?: object) => RestService<T, ID>}\n       */\n      const factory = (baseUrl, entityClass, options = {}) => {\n        return new RestService($http, baseUrl, entityClass, options);\n      };\n\n      // create services from pre-registered definitions\n      for (const def of this._definitions) {\n        const svc = factory(def.url, def.entityClass, def.options);\n\n        services.set(def.name, svc);\n      }\n\n      return factory;\n    },\n  ];\n}\n","import { isObject, isString } from \"../../shared/utils.js\";\n\n/**\n * @returns {ng.Directive}\n */\nexport function ngListenerDirective() {\n  return {\n    scope: false,\n    link: (scope, element, attrs) => {\n      const channel = attrs.ngListener || element.id;\n\n      const hasTemplateContent = element.childNodes.length;\n\n      /** @type {EventListener} */\n      const fn = (event) => {\n        const value = /** @type {CustomEvent} */ (event).detail;\n\n        if (hasTemplateContent) {\n          if (isObject(value)) {\n            scope.$merge(value);\n          }\n        } else if (isString(value)) {\n          element.innerHTML = value;\n        }\n      };\n\n      element.addEventListener(channel, fn);\n\n      scope.$on(\"$destroy\", () => element.removeEventListener(channel, fn));\n    },\n  };\n}\n","import { $injectTokens } from \"../../injection-tokens.js\";\nimport { StreamConnection } from \"../stream/stream.js\";\n\n/**\n * WebSocketProvider\n * Provides a pre-configured WebSocket connection as an injectable.\n */\nexport class WebSocketProvider {\n  constructor() {\n    /** @type {ng.WebSocketConfig} */\n    this.defaults = {\n      protocols: [],\n      autoReconnect: true,\n      reconnectInterval: 1000,\n      maxRetries: Infinity,\n      heartbeatInterval: 0, // ms, 0 = disabled\n      transformMessage(data) {\n        try {\n          return JSON.parse(data);\n        } catch {\n          return data;\n        }\n      },\n    };\n  }\n\n  $get = [\n    $injectTokens._log,\n    /** @param {ng.LogService} log */ (log) => {\n      this._$log = log;\n\n      /** @type {ng.WebSocketService} */\n      return (url, protocols = [], config = {}) => {\n        const mergedConfig = { ...this.defaults, ...config };\n\n        mergedConfig.protocols = protocols.length\n          ? protocols\n          : mergedConfig.protocols;\n\n        return new StreamConnection(\n          () => new WebSocket(url, mergedConfig.protocols),\n          {\n            ...mergedConfig,\n            onMessage: (data, event) => {\n              mergedConfig.onMessage?.(data, event);\n            },\n            onOpen: (event) => {\n              mergedConfig.onOpen?.(event);\n            },\n            onClose: /** @param {CloseEvent} event */ (event) => {\n              mergedConfig.onClose?.(event);\n            },\n            onError: (event) => {\n              mergedConfig.onError?.(event);\n            },\n          },\n          this._$log,\n        );\n      };\n    },\n  ];\n}\n","import {\n  assertNotHasOwnProperty,\n  errorHandlingConfig,\n  hasOwn,\n  isArray,\n  isObject,\n  isString,\n  minErr,\n  ngAttrPrefixes,\n} from \"./shared/utils.js\";\nimport {\n  getController,\n  getInjector,\n  getScope,\n  setCacheData,\n} from \"./shared/dom.js\";\nimport { createInjector } from \"./core/di/injector.js\";\nimport { NgModule } from \"./core/di/ng-module/ng-module.js\";\nimport { registerNgModule } from \"./ng.js\";\nimport { unnestR } from \"./shared/common.js\";\nimport { $injectTokens as $t } from \"./injection-tokens.js\";\nimport { annotate } from \"./core/di/di.js\";\nimport { validateIsString } from \"./shared/validate.js\";\n\nconst ngMinErr = minErr(\"ng\");\n\nconst $injectorMinErr = minErr(\"$injector\");\n\nconst STRICT_DI = \"strict-di\";\n\n/** @typedef {Object.<string, NgModule|null>} ModuleRegistry */\n\n/** @type {ModuleRegistry} */\nconst moduleRegistry = {};\n\nexport class Angular extends EventTarget {\n  constructor(submodule = false) {\n    super();\n\n    /** @private @type {boolean} */\n    this._submodule = submodule;\n\n    /** @private @type {!Array<string|any>} */\n    this._bootsrappedModules = [];\n\n    /** @public @type {ng.PubSubService} */\n    this.$eventBus;\n\n    /** @public @type {ng.InjectorService} */\n    this.$injector;\n\n    /**\n     * @public\n     * @type {string} `version` from `package.json`\n     */\n    this.version = \"[VI]{version}[/VI]\"; //inserted via rollup plugin\n\n    /**\n     * Gets the controller instance for a given element, if exists. Defaults to \"ngControllerController\"\n     *\n     * @type {typeof getController}\n     */\n    this.getController = getController;\n\n    /**\n     * Return instance of InjectorService attached to element\n     * @type {typeof getInjector}\n     */\n    this.getInjector = getInjector;\n\n    /**\n     * Gets scope for a given element.\n     *  @type {typeof getScope}\n     */\n    this.getScope = getScope;\n\n    /** @type {typeof errorHandlingConfig} */\n    this.errorHandlingConfig = errorHandlingConfig;\n\n    /** @type {ng.InjectionTokens} */\n    this.$t = /** @type {ng.InjectionTokens} */ ({});\n    Object.values($t).forEach((i) => {\n      /** @type {any} */ (this.$t)[i] = i;\n    });\n\n    if (!submodule) {\n      window.angular = this;\n    }\n    registerNgModule(this);\n  }\n\n  /**\n   *\n   * The `angular.module` is a global place for creating, registering and retrieving AngularTS\n   * modules.\n   * All modules (AngularTS core or 3rd party) that should be available to an application must be\n   * registered using this mechanism.\n   *\n   * Passing one argument retrieves an existing {@link ng.NgModule},\n   * whereas passing more than one argument creates a new {@link ng.NgModule}\n   *\n   *\n   * # Module\n   *\n   * A module is a collection of services, directives, controllers, filters, workers, WebAssembly modules, and configuration information.\n   * `angular.module` is used to configure the {@link auto.$injector $injector}.\n   *\n   * ```js\n   * // Create a new module\n   * let myModule = angular.module('myModule', []);\n   *\n   * // register a new service\n   * myModule.value('appName', 'MyCoolApp');\n   *\n   * // configure existing services inside initialization blocks.\n   * myModule.config(['$locationProvider', function($locationProvider) {\n   *   // Configure existing providers\n   *   $locationProvider.hashPrefix('!');\n   * }]);\n   * ```\n   *\n   * Then you can create an injector and load your modules like this:\n   *\n   * ```js\n   * let injector = angular.injector(['ng', 'myModule'])\n   * ```\n   *\n   * However it's more likely that you'll just use\n   * `ng-app` directive or\n   * {@link bootstrap} to simplify this process for you.\n   *\n   * @param {string} name The name of the module to create or retrieve.\n   * @param {Array.<string>} [requires] If specified then new module is being created. If\n   *        unspecified then the module is being retrieved for further configuration.\n   * @param {ng.Injectable<any>} [configFn] Optional configuration function for the module that gets\n   *        passed to {@link NgModule.config NgModule.config()}.\n   * @returns {NgModule} A newly registered module.\n   */\n  module(name, requires, configFn) {\n    assertNotHasOwnProperty(name, \"module\");\n\n    if (requires && hasOwn(moduleRegistry, name)) {\n      moduleRegistry[name] = null; // force ensure to recreate the module\n    }\n\n    return ensure(moduleRegistry, name, () => {\n      if (!requires) {\n        throw $injectorMinErr(\n          \"nomod\",\n          \"Module '{0}' is not available. Possibly misspelled or not loaded\",\n          name,\n        );\n      }\n\n      return new NgModule(name, requires, configFn);\n    });\n  }\n\n  /**\n   * @param {CustomEvent<string | ng.InvocationDetail>} event\n   */\n  dispatchEvent(event) {\n    const $parse = this.$injector.get($t._parse);\n\n    const injectable = event.type;\n\n    const target = this.$injector.has(injectable)\n      ? this.$injector.get(injectable)\n      : this.getScopeByName(injectable);\n\n    if (!target) {\n      const { detail } = event;\n\n      if (\n        isObject(detail) &&\n        /** @type {ng.InvocationDetail} */ (detail)._reply\n      ) {\n        /** @type {ng.InvocationDetail} */ (detail)._reply.reject(\n          new Error(`No target found for \"${injectable}\"`),\n        );\n      }\n\n      return false;\n    }\n    const { detail } = event;\n\n    const expr = isString(detail)\n      ? detail\n      : isObject(detail)\n        ? detail.expr\n        : \"\";\n\n    try {\n      const result = $parse(expr)(target);\n\n      if (\n        isObject(detail) &&\n        /** @type {ng.InvocationDetail} */ (detail)._reply\n      ) {\n        Promise.resolve(result).then(\n          /** @type {ng.InvocationDetail} */ (detail)._reply.resolve,\n          /** @type {ng.InvocationDetail} */ (detail)._reply.reject,\n        );\n      }\n    } catch (err) {\n      if (detail && typeof detail === \"object\" && detail._reply) {\n        detail._reply.reject(err);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Fire-and-forget. Accepts a single string: \"<target>.<expression>\"\n   * @param {string} input\n   */\n  emit(input) {\n    const { type, expr } = this.#split(input);\n\n    this.dispatchEvent(new CustomEvent(type, { detail: expr }));\n  }\n\n  /**\n   * Await result. Accepts a single string: \"<target>.<expression>\"\n   * @param {string} input\n   * @returns {Promise<any>}\n   */\n  call(input) {\n    const { type, expr } = this.#split(input);\n\n    return new Promise((resolve, reject) => {\n      const ok = this.dispatchEvent(\n        new CustomEvent(type, {\n          detail: { expr, __reply: { resolve, reject } },\n        }),\n      );\n\n      if (!ok) reject(new Error(`Dispatch failed for \"${type}\"`));\n    });\n  }\n\n  /**\n   * Split by period. First segment => target, rest => expression (re-joined by '.').\n   * @param {string} input\n   * @returns {{ type: string, expr: string }}\n   */\n  #split(input) {\n    if (typeof input !== \"string\") {\n      throw new TypeError(\"Invocation must be a string.\");\n    }\n\n    const trimmed = input.trim();\n\n    const parts = trimmed.split(\".\");\n\n    if (parts.length < 2) {\n      throw new Error(\n        `Invalid invocation \"${input}\". Expected \"<target>.<expression>\".`,\n      );\n    }\n\n    const type = /** @type {string} */ (parts.shift()).trim();\n\n    const expr = parts.join(\".\").trim();\n\n    if (!type || !expr) {\n      throw new Error(\n        `Invalid invocation \"${input}\". Expected \"<target>.<expression>\".`,\n      );\n    }\n\n    return { type, expr };\n  }\n\n  /**\n   * Use this function to manually start up AngularTS application.\n   *\n   * AngularTS will detect if it has been loaded into the browser more than once and only allow the\n   * first loaded script to be bootstrapped and will report a warning to the browser console for\n   * each of the subsequent scripts. This prevents strange results in applications, where otherwise\n   * multiple instances of AngularTS try to work on the DOM.\n   *   *\n   * <div class=\"alert alert-warning\">\n   * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},\n   * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.\n   * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},\n   * causing animations to stop working and making the injector inaccessible from outside the app.\n   * </div>\n   *\n   * ```html\n   * <!doctype html>\n   * <html>\n   * <body>\n   * <div ng-controller=\"WelcomeController\">\n   *   {{greeting}}\n   * </div>\n   *\n   * <script src=\"angular.js\"></script>\n   * <script>\n   *   let app = angular.module('demo', [])\n   *   .controller('WelcomeController', function($scope) {\n   *       $scope.greeting = 'Welcome!';\n   *   });\n   *   angular.bootstrap(document, ['demo']);\n   * </script>\n   * </body>\n   * </html>\n   * ```\n   *\n   * @param {string | HTMLElement | HTMLDocument} element DOM element which is the root of AngularTS application.\n   * @param {Array<String|any>} [modules] an array of modules to load into the application.\n   *     Each item in the array should be the name of a predefined module or a (DI annotated)\n   *     function that will be invoked by the injector as a `config` block.\n   *     See: {@link angular.module modules}\n   * @param {import(\"./interface.ts\").AngularBootstrapConfig} [config]\n   * @returns {ng.InjectorService} The created injector instance for this application.\n   */\n  bootstrap(element, modules, config) {\n    config = config || {\n      strictDi: false,\n    };\n\n    if (\n      (element instanceof Element || element instanceof Document) &&\n      getInjector(/** @type {Element} */ (element))\n    ) {\n      throw ngMinErr(\"btstrpd\", \"App already bootstrapped\");\n    }\n\n    if (isArray(modules)) {\n      this._bootsrappedModules = modules;\n    }\n\n    this._bootsrappedModules.unshift([\n      \"$provide\",\n      /**\n       * @param {import('./interface.ts').Provider} $provide\n       */\n      ($provide) => {\n        $provide.value(\"$rootElement\", element);\n      },\n    ]);\n\n    this._bootsrappedModules.unshift(\"ng\");\n\n    const injector = createInjector(this._bootsrappedModules, config.strictDi);\n\n    injector.invoke([\n      $t._rootScope,\n      $t._rootElement,\n      $t._compile,\n      $t._injector,\n      /**\n       * @param {ng.Scope} scope\n       * @param {HTMLElement} el\n       * @param {ng.CompileService} compile\n       * @param {ng.InjectorService} $injector\n       */\n      (scope, el, compile, $injector) => {\n        this.$rootScope = scope;\n        // ng-route deps\n        this.$injector = $injector; // TODO refactor away as this as this prevents multiple apps from being used\n\n        setCacheData(el, \"$injector\", $injector);\n\n        const compileFn = compile(el);\n\n        compileFn(scope);\n\n        // https://github.com/angular-ui/ui-router/issues/3678\n        if (!hasOwn($injector, \"strictDi\")) {\n          try {\n            $injector.invoke(() => {\n              /* empty */\n            });\n          } catch (error) {\n            /** @type {string} */\n            const errorStr =\n              error instanceof Error ? error.toString() : String(error);\n\n            $injector.strictDi = !!/strict mode/.exec(errorStr);\n          }\n        }\n\n        /** @type {import(\"./router/state/state-registry.js\").StateRegistryProvider} */\n        const stateRegistry = $injector.get($t._stateRegistry);\n\n        stateRegistry\n          .getAll()\n          .map((x) => {\n            return x._state().resolvables;\n          })\n          .reduce(unnestR, [])\n          .filter(\n            /** @param {import(\"./router/resolve/resolvable.js\").Resolvable} x */ (\n              x,\n            ) => {\n              return x.deps === \"deferred\";\n            },\n          )\n          .forEach(\n            /** @param {import(\"./router/resolve/resolvable.js\").Resolvable} resolvable */\n            (resolvable) =>\n              (resolvable.deps = annotate(\n                resolvable.resolveFn,\n                $injector.strictDi,\n              )),\n          );\n      },\n    ]);\n\n    return injector;\n  }\n\n  /**\n   * @param {any[]} modules\n   * @param {boolean} [strictDi]\n   * @returns {ng.InjectorService}\n   */\n  injector(modules, strictDi) {\n    this.$injector = createInjector(modules, strictDi);\n\n    return this.$injector;\n  }\n\n  /**\n   * @param {HTMLElement|HTMLDocument} element\n   */\n  init(element) {\n    /** @type {HTMLElement|undefined} */\n    let appElement;\n\n    let module;\n\n    const config = {};\n\n    // The element `element` has priority over any other element.\n    ngAttrPrefixes.forEach((prefix) => {\n      const name = `${prefix}app`;\n\n      if (\n        /** @type {HTMLElement} */ (element).hasAttribute &&\n        /** @type {HTMLElement} */ (element).hasAttribute(name)\n      ) {\n        appElement = /** @type {HTMLElement} */ (element);\n        module = appElement.getAttribute(name);\n      }\n\n      /** @type {HTMLElement} */\n      let candidate;\n\n      if (\n        !appElement &&\n        (candidate = /** @type {HTMLElement} */ (\n          element.querySelector(`[${name.replace(\":\", \"\\\\:\")}]`)\n        ))\n      ) {\n        appElement = candidate;\n        module = candidate.getAttribute(name);\n      }\n    });\n\n    if (appElement) {\n      config.strictDi =\n        appElement.hasAttribute(STRICT_DI) ||\n        appElement.hasAttribute(`data-${STRICT_DI}`);\n      this.bootstrap(appElement, module ? [module] : [], config);\n    }\n  }\n\n  /**\n   * Retrieves a scope by its registered name and returns its Proxy wrapper.\n   *\n   * Internally, this walks down the `Scope` tree starting from `$rootScope`\n   * and checks for a matching `$scopename` property. The `$scopename` property\n   * may be defined statically on controllers using `as` syntax, assigned via the `ngScope` directive,\n   * or defined on `$scope` injectable.\n   *\n   * @param {string} name\n   * @returns {Proxy<ng.Scope>|undefined}\n   */\n  getScopeByName(name) {\n    validateIsString(name, \"name\");\n    /** @type {ng.RootScopeService} */\n    const $rootScope = this.$injector.get(\"$rootScope\");\n\n    const scope = $rootScope.$searchByName(name);\n\n    if (scope) {\n      return scope.$proxy;\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * @param {ModuleRegistry} obj\n * @param {string} name\n * @param {Function} factory\n * @returns {NgModule}\n */\nfunction ensure(obj, name, factory) {\n  return obj[name] || (obj[name] = factory());\n}\n","import { CompileProvider } from \"./core/compile/compile.js\";\nimport {\n  hiddenInputDirective,\n  inputDirective,\n  ngValueDirective,\n} from \"./directive/input/input.js\";\nimport { formDirective, ngFormDirective } from \"./directive/form/form.js\";\nimport { scriptDirective } from \"./directive/script/script.js\";\nimport { optionDirective, selectDirective } from \"./directive/select/select.js\";\nimport {\n  ngBindDirective,\n  ngBindHtmlDirective,\n  ngBindTemplateDirective,\n} from \"./directive/bind/bind.js\";\nimport {\n  ngClassDirective,\n  ngClassEvenDirective,\n  ngClassOddDirective,\n} from \"./directive/class/class.js\";\nimport { ngCloakDirective } from \"./directive/cloak/cloak.js\";\nimport { ngControllerDirective } from \"./directive/controller/controller.js\";\nimport {\n  ngHideDirective,\n  ngShowDirective,\n} from \"./directive/show-hide/show-hide.js\";\nimport { ngIfDirective } from \"./directive/if/if.js\";\nimport {\n  ngIncludeDirective,\n  ngIncludeFillContentDirective,\n} from \"./directive/include/include.js\";\nimport { ngInitDirective } from \"./directive/init/init.js\";\nimport { ngNonBindableDirective } from \"./directive/non-bindable/non-bindable.js\";\nimport { ngRefDirective } from \"./directive/ref/ref.js\";\nimport { ngRepeatDirective } from \"./directive/repeat/repeat.js\";\nimport { ngStyleDirective } from \"./directive/style/style.js\";\nimport {\n  ngSwitchDefaultDirective,\n  ngSwitchDirective,\n  ngSwitchWhenDirective,\n} from \"./directive/switch/switch.js\";\nimport { ngOptionsDirective } from \"./directive/options/options.js\";\nimport { ngTranscludeDirective } from \"./directive/transclude/transclude.js\";\nimport { ngModelDirective } from \"./directive/model/model.js\";\nimport {\n  maxlengthDirective,\n  minlengthDirective,\n  patternDirective,\n  requiredDirective,\n} from \"./directive/validators/validators.js\";\nimport { ngModelOptionsDirective } from \"./directive/model-options/model-options.js\";\nimport { ngAttributeAliasDirectives } from \"./directive/attrs/attrs.js\";\nimport { ngEventDirectives } from \"./directive/events/events.js\";\nimport { AnchorScrollProvider } from \"./services/anchor-scroll/anchor-scroll.js\";\nimport { AnimateProvider } from \"./animations/animate.js\";\nimport { TemplateCacheProvider } from \"./services/template-cache/template-cache.js\";\nimport { ControllerProvider } from \"./core/controller/controller.js\";\nimport { ExceptionHandlerProvider } from \"./services/exception/exception.js\";\nimport { FilterProvider } from \"./core/filter/filter.js\";\nimport { InterpolateProvider } from \"./core/interpolate/interpolate.js\";\nimport {\n  HttpParamSerializerProvider,\n  HttpProvider,\n} from \"./services/http/http.js\";\nimport { LocationProvider } from \"./services/location/location.js\";\nimport { LogProvider } from \"./services/log/log.js\";\nimport { ParseProvider } from \"./core/parse/parse.js\";\nimport { RootScopeProvider } from \"./core/scope/scope.js\";\nimport { SceDelegateProvider, SceProvider } from \"./services/sce/sce.js\";\nimport { TemplateRequestProvider } from \"./services/template-request/template-request.js\";\nimport { SanitizeUriProvider } from \"./core/sanitize/sanitize-uri.js\";\nimport {\n  ngMessageDefaultDirective,\n  ngMessageDirective,\n  ngMessageExpDirective,\n  ngMessagesDirective,\n  ngMessagesIncludeDirective,\n} from \"./directive/messages/messages.js\";\nimport {\n  AriaProvider,\n  ngCheckedAriaDirective,\n  ngClickAriaDirective,\n  ngDblclickAriaDirective,\n  ngDisabledAriaDirective,\n  ngHideAriaDirective,\n  ngMessagesAriaDirective,\n  ngModelAriaDirective,\n  ngReadonlyAriaDirective,\n  ngRequiredAriaDirective,\n  ngShowAriaDirective,\n  ngValueAriaDirective,\n} from \"./directive/aria/aria.js\";\nimport { AnimateCssProvider } from \"./animations/css/animate-css.js\";\nimport { AnimateQueueProvider } from \"./animations/queue/animate-queue.js\";\nimport { AnimateJsProvider } from \"./animations/animate-js.js\";\nimport { AnimationProvider } from \"./animations/animation.js\";\nimport { AnimateCssDriverProvider } from \"./animations/animate-css-driver.js\";\nimport { AnimateJsDriverProvider } from \"./animations/animate-js-driver.js\";\nimport { ngAnimateSwapDirective } from \"./animations/animate-swap.js\";\nimport { $$AnimateChildrenDirective } from \"./animations/animate-children-directive.js\";\nimport { UrlConfigProvider } from \"./router/url/url-config.js\";\nimport { RouterProvider } from \"./router/router.js\";\nimport { ViewService } from \"./router/view/view.js\";\nimport { TransitionProvider } from \"./router/transition/transition-service.js\";\nimport { StateProvider } from \"./router/state/state-service.js\";\nimport { TemplateFactoryProvider } from \"./router/template-factory.js\";\nimport { UrlService } from \"./router/url/url-service.js\";\nimport { StateRegistryProvider } from \"./router/state/state-registry.js\";\nimport { trace } from \"./router/common/trace.js\";\nimport {\n  $StateRefActiveDirective,\n  $StateRefDirective,\n  $StateRefDynamicDirective,\n} from \"./router/directives/state-directives.js\";\nimport {\n  $ViewDirectiveFill,\n  $ViewDirective,\n} from \"./router/directives/view-directive.js\";\nimport { ngChannelDirective } from \"./directive/channel/channel.js\";\nimport { ngSetterDirective } from \"./directive/setter/setter.js\";\nimport { PubSubProvider } from \"./services/pubsub/pubsub.js\";\nimport {\n  ngDeleteDirective,\n  ngGetDirective,\n  ngPostDirective,\n  ngPutDirective,\n  ngSseDirective,\n} from \"./directive/http/http.js\";\nimport { $injectTokens as $t } from \"./injection-tokens.js\";\nimport { ngInjectDirective } from \"./directive/inject/inject.js\";\nimport { ngElDirective } from \"./directive/el/el.js\";\nimport { SseProvider } from \"./services/sse/sse.js\";\nimport { ngViewportDirective } from \"./directive/viewport/viewport.js\";\nimport { ngWorkerDirective } from \"./directive/worker/worker.js\";\nimport { ngWasmDirective } from \"./directive/wasm/wasm.js\";\nimport { ngScopeDirective } from \"./directive/scope/scope.js\";\nimport { CookieProvider } from \"./services/cookie/cookie.js\";\nimport { RestProvider } from \"./services/rest/rest.js\";\nimport { ngListenerDirective } from \"./directive/listener/listener.js\";\nimport { WebSocketProvider } from \"./services/websocket/websocket.js\";\n\n/**\n * Initializes core `ng` module.\n * @param {ng.Angular} angular\n * @returns {ng.NgModule} `ng` module\n */\nexport function registerNgModule(angular) {\n  return angular\n    .module(\n      \"ng\",\n      [],\n      [\n        $t._provide,\n        /** @param {ng.ProvideService} $provide */\n        ($provide) => {\n          // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.\n          $provide.provider({\n            $$sanitizeUri: SanitizeUriProvider,\n          });\n          $provide.value($t._angular, angular);\n          $provide.value($t._window, window);\n          $provide.value($t._document, document);\n          $provide\n            .provider($t._compile, CompileProvider)\n            .directive({\n              input: inputDirective,\n              textarea: inputDirective,\n              form: formDirective,\n              script: scriptDirective,\n              select: selectDirective,\n              option: optionDirective,\n              ngBind: ngBindDirective,\n              ngBindHtml: ngBindHtmlDirective,\n              ngBindTemplate: ngBindTemplateDirective,\n              ngChannel: ngChannelDirective,\n              ngClass: ngClassDirective,\n              ngClassEven: ngClassEvenDirective,\n              ngClassOdd: ngClassOddDirective,\n              ngCloak: ngCloakDirective,\n              ngController: ngControllerDirective,\n              ngDelete: ngDeleteDirective,\n              ngDisabled: ngDisabledAriaDirective,\n              ngEl: ngElDirective,\n              ngForm: ngFormDirective,\n              ngGet: ngGetDirective,\n              ngHide: ngHideDirective,\n              ngIf: ngIfDirective,\n              ngInclude: ngIncludeDirective,\n              ngInject: ngInjectDirective,\n              ngInit: ngInitDirective,\n              ngListener: ngListenerDirective,\n              ngMessages: ngMessagesDirective,\n              ngMessage: ngMessageDirective,\n              ngMessageExp: ngMessageExpDirective,\n              ngMessagesInclude: ngMessagesIncludeDirective,\n              ngMessageDefault: ngMessageDefaultDirective,\n              ngNonBindable: ngNonBindableDirective,\n              ngPost: ngPostDirective,\n              ngPut: ngPutDirective,\n              ngRef: ngRefDirective,\n              ngRepeat: ngRepeatDirective,\n              ngSetter: ngSetterDirective,\n              ngShow: ngShowDirective,\n              ngStyle: ngStyleDirective,\n              ngSse: ngSseDirective,\n              ngSwitch: ngSwitchDirective,\n              ngSwitchWhen: ngSwitchWhenDirective,\n              ngSwitchDefault: ngSwitchDefaultDirective,\n              ngOptions: ngOptionsDirective,\n              ngTransclude: ngTranscludeDirective,\n              ngModel: ngModelDirective,\n              pattern: patternDirective,\n              ngPattern: patternDirective,\n              required: requiredDirective,\n              ngRequired: requiredDirective,\n              ngMinlength: minlengthDirective,\n              minlength: minlengthDirective,\n              ngMaxlength: maxlengthDirective,\n              maxlength: maxlengthDirective,\n              ngValue: ngValueDirective,\n              ngModelOptions: ngModelOptionsDirective,\n              ngViewport: ngViewportDirective,\n              ngWasm: ngWasmDirective,\n              ngWorker: ngWorkerDirective,\n              ngScope: ngScopeDirective,\n            })\n            .directive({\n              input: hiddenInputDirective,\n              ngAnimateSwap: ngAnimateSwapDirective,\n              ngAnimateChildren: $$AnimateChildrenDirective,\n              // aria directives\n              ngChecked: ngCheckedAriaDirective,\n              ngClick: ngClickAriaDirective,\n              ngDblclick: ngDblclickAriaDirective,\n              ngInclude: ngIncludeFillContentDirective,\n              ngHide: ngHideAriaDirective,\n              ngShow: ngShowAriaDirective,\n              ngMessages: ngMessagesAriaDirective,\n              ngModel: ngModelAriaDirective,\n              ngReadonly: ngReadonlyAriaDirective,\n              ngRequired: ngRequiredAriaDirective,\n              ngValue: ngValueAriaDirective,\n              // router directives\n              ngSref: $StateRefDirective,\n              ngSrefActive: $StateRefActiveDirective,\n              ngSrefActiveEq: $StateRefActiveDirective,\n              ngState: $StateRefDynamicDirective,\n              ngView: $ViewDirective,\n            })\n            .directive({\n              ngView: $ViewDirectiveFill,\n            })\n            .directive(ngAttributeAliasDirectives)\n            .directive(ngEventDirectives);\n          $provide.provider({\n            $aria: AriaProvider,\n            $anchorScroll: AnchorScrollProvider,\n            $animate: AnimateProvider,\n            $$animation: AnimationProvider,\n            $animateCss: AnimateCssProvider,\n            $$animateCssDriver: AnimateCssDriverProvider,\n            $$animateJs: AnimateJsProvider,\n            $$animateJsDriver: AnimateJsDriverProvider,\n            $$animateQueue: AnimateQueueProvider,\n            $controller: ControllerProvider,\n            $cookie: CookieProvider,\n            $exceptionHandler: ExceptionHandlerProvider,\n            $filter: FilterProvider,\n            $interpolate: InterpolateProvider,\n            $http: HttpProvider,\n            $httpParamSerializer: HttpParamSerializerProvider,\n            $location: LocationProvider,\n            $log: LogProvider,\n            $parse: ParseProvider,\n            $rest: RestProvider,\n            $rootScope: RootScopeProvider,\n            $router: RouterProvider,\n            $sce: SceProvider,\n            $sceDelegate: SceDelegateProvider,\n            $sse: SseProvider,\n            $templateCache: TemplateCacheProvider,\n            $templateRequest: TemplateRequestProvider,\n            $urlConfig: UrlConfigProvider,\n            $view: ViewService,\n            $transitions: TransitionProvider,\n            $state: StateProvider,\n            $templateFactory: TemplateFactoryProvider,\n            $url: UrlService,\n            $stateRegistry: StateRegistryProvider,\n            $eventBus: PubSubProvider,\n            $websocket: WebSocketProvider,\n          });\n        },\n      ],\n    )\n    .factory(\"$stateParams\", [\n      $t._router,\n      /**\n       * @param {ng.RouterService} globals\n       * @returns {import('./router/params/state-params.js').StateParams }\n       */\n      (globals) => globals.params,\n    ])\n    .value(\"$trace\", trace);\n}\n","import { Angular } from \"./angular.js\";\n\nexport const angular = new Angular();\ndocument.addEventListener(\"DOMContentLoaded\", () => angular.init(document), {\n  once: true,\n});\n"],"names":["VALID_CLASS","INVALID_CLASS","PRISTINE_CLASS","DIRTY_CLASS","UNTOUCHED_CLASS","TOUCHED_CLASS","EMPTY_CLASS","PREFIX_REGEXP","ALIASED_ATTR","ngMinlength","ngMaxlength","ngMin","ngMax","ngPattern","ngStep","isProxy","value","isProxySymbol","deProxy","val","$target","uid$1","lowercase","string","isString","toLowerCase","isArrayLike","obj","isNumber","len","isUndefined","isDefined","isArray","array","Array","isInstanceOf","type","isObject","isNull","isNullOrUndefined","notNullOrUndefined","isDate","toString","call","Error","isFunction","isRegExp","isWindow","Window","isScope","$watch","isBoolean","isPromiseLike","then","trim","snakeCase","name","separator","replace","letter","pos","modseparator","baseExtend","dst","objs","deep","i","ii","length","j","jj","keyList","src","key","valueOf","cloneNode","hashkey","_hashKey","extend","isNumberNaN","num","Number","isNaN","inherit$1","parent","extra","Object","create","hasCustomToString","getNodeName","element","nodeName","includes","prototype","indexOf","splice","index","simpleCompare","val1","val2","equals$1","o1","equals","o2","getTime","keySet","assertNotHasOwnProperty","context","ngMinErr","ngMinErr$1","stringify$1","toJson","concat","array1","slice","array2","sliceArgs","args","startIndex","bind","fn","RegExp","curryArgs","arguments","apply","toJsonReplacer","charAt","undefined","window","document","pretty","JSON","stringify","parseKeyValue","forEach","keyValue","splitPoint","substring","hasOwn","push","toKeyValue","entries","arrayValue","parts","encodeUriQuery","join","tryDecodeURIComponent","decodeURIComponent","encodeUriSegment","pctEncodeSpaces","encodeURIComponent","shallowCopy","startsWith","out","assert","argument","errorMsg","assertArg","arg","reason","assertArgFn","acceptArrayAnnotation","constructor","minErrConfig","objectMaxDepth","urlErrorParamsEnabled","errorHandlingConfig","config","maxDepth","NaN","minErr","module","copyObj","structuredClone","seen","message","template","match","templateArgs","hashKey","objType","nextUid","mergeClasses","firstClass","secondClass","normalizeStringArray","arr","item","trimmed","cleaned","directiveNormalize","SPECIAL_CHARS_REGEXP","offset","toUpperCase","hasAnimate","node","attr","nodeType","dataset","getAttribute","hasCustomOrDataAttribute","isObjectEmpty","keys","hasOwnProperty","callBackAfterFirst","calledOnce","wait","timeout","Promise","resolve","setTimeout","str","search","async","imports","instance","WebAssembly","instantiateStreaming","res","clone","exports","nullObject","$injectTokens","_angular","_attrs","_scope","_element","_animateCssDriver","_animateJs","_animateJsDriver","_animateQueue","_animation","_taskTrackerFactory","_anchorScroll","_animate","_animateCss","_aria","_compile","_cookie","_controller","_document","_eventBus","_exceptionHandler","_filter","_http","_httpParamSerializer","_interpolate","_location","_log","_parse","_rest","_rootScope","_rootElement","_router","_sce","_sceDelegate","_state","_stateRegistry","_sse","_sanitizeUri","_sanitizeUriProvider","_templateCache","_templateFactory","_templateRequest","_transitions","_urlConfig","_url","_view","_window","_provide","_injector","_compileProvider","_animateProvider","_filterProvider","_controllerProvider","provider","services","map","x","BOOLEAN_ATTR","BOOLEAN_ELEMENTS","fnCamelCaseReplace","_all","kebabToCamel","DASH_LOWERCASE_REGEXP","snakeToCamel","UNDERSCORE_LOWERCASE_REGEXP","removeElementData","expandoStore","data","Cache","expandoId","EXPANDO","removeIfEmptyData","getExpando","createIfNecessary","elId","set","isTextNode","html","test","elementAcceptsData","dealoc","onlyDescendants","cleanElementData","querySelectorAll","innerHTML","getOrSetCacheData","isSimpleSetter","massGetter","isSimpleGetter","prop","setCacheData","parentElement","getCacheData","getScope","SCOPE_KEY","setScope","scope","setIsolateScope","getController","getInheritedData","documentElement","next","host","removeElement","keepData","removeChild","startingTag","elementOrStr","firstChild","Node","divWrapper","appendChild","elemHtml","_match","getBlockNodes","nodes","endNode","blockNodes","getBooleanAttrName","normalizedName","getInjector","htmlString","content","createElementFromHTML","createNodelistFromHTML","parseHTML","childNodes","emptyElement","replaceChildren","domInsert","afterElement","afterNode","parentNode","previousSibling","after","prepend","animatedomInsert","assign","style","visibility","position","pointerEvents","requestAnimationFrame","originalVisibility","originalPosition","originalPointerEvents","getBaseHref","href","extractElementNode","elm","stringifyFn","Function","annotate","strictDi","inject","$injectorMinErr$3","argDecl","fnText","ARROW_ARG","FN_ARGS","extractArgs","split","FN_ARG","_underscore","injName","$inject","last","AbstractInjector","this","_cache","_path","_modules","get","serviceName","$injectorMinErr","INSTANTIATING","$injectorMinErr$2","unshift","factory","err","_injectionArgs","locals","invoke","self","instantiate","ctor","_serviceName","ProviderInjector","cache","super","caller","InjectorService","loadNewModules","providerInjector","_providerInjector","$get","has","hasProvider","providerSuffix$1","hasCache","target","storage","options","saved","deserialize","Proxy","deleteProperty","deleted","head","filter","injectable","tail","isPromise","reasons","Map","isInjectable","validate","v","String","TypeError","getReason","validateRequired","validateIsString","createInjector","$provide","supportObject","service","$injector","providerCache","providerSuffix","constant","protoInstanceInjector","store","backendOrConfig","createPersistentProxy","sessionStorage","localStorage","getItem","raw","setItem","k","$cookie","put","cookieOpts","removeItem","remove","serialize","backend","decorator","decorFn","origProvider","instanceInjector","$delegate","origInstance","$injectorProvider","mods","newProvider","$injectorMinErr$1","factoryFn","result","loadModules","modules","moduleKey","moduleFn","angular","moduleRunBlocks","_requires","_invokeQueue","_configBlocks","invokeArgs","providerInstance","moduleName","stack","delegate","urlResolve","url","urlParsingNode","URL","location","hostname","protocol","hash","port","pathname","urlsAreSameOrigin","url1","url2","trimEmptyHash","APPLICATION_JSON","serializeValue","toISOString","HttpParamSerializerProvider","params","sort","serializedValue","sanitizedValue","defaultHttpResponseTransform","headers","hasJsonContentType","jsonStart","JSON_ENDS","isJsonLike","tempData","json","parse","$httpMinErr","parseHeaders","fillInParsed","parsed","line","headerKey","headerVal","headersGetter","headersObj","transformData","status","fns","isSuccess","Http","HttpProvider","defaults","transformResponse","transformRequest","isBlob","isFormData","common","Accept","post","CONTENT_TYPE_APPLICATION_JSON","patch","xsrfCookieName","xsrfHeaderName","paramSerializer","useApplyAsync","$t","$sce","that","interceptors","interceptorFactory","reversedInterceptors","urlIsAllowedOrigin","trustedOriginUrls","parsedAllowedOriginUrls","some","parsedUrl","urlIsAllowedOriginFactory","xsrfTrustedOrigins","$http","requestConfig","method","configParam","reqHeaders","defHeaders","defHeaderName","reqHeaderName","lowercaseDefHeaderName","header","headerFn","headerContent","processedHeaders","executeHeaderFns","mergeHeaders","interceptor","request","requestError","requestInterceptors","response","responseError","responseInterceptors","promise","chainInterceptors","reqData","withCredentials","serializedParams","buildUrl","defaultCache","cachedResp","resolvePromiseWithResult","resolvePromise","getAll","xsrfValue","callback","responseType","eventHandlers","uploadEventHandlers","xhr","setRequestHeader","completeRequest","getAllResponseHeaders","statusText","onerror","onabort","abortedByTimeout","handler","addEventListener","upload","timeoutRequest","abort","headersString","xhrStatus","timeoutId","clearTimeout","http","resolveHttpPromise","delete","createApplyHandlers","eventHandler","applyHandlers","event","callEventHandler","handleEvent","reject","removePendingReq","idx","pendingRequests","sendReq","promiseParam","thenFn","rejectFn","httpResponse","resp","createShortMethods","defineDirective","attrOverride","attrName","directive","$compile","$log","$parse","$state","$sse","$animate","collectFormData","form","hasAttribute","formId","maybeForm","tagName","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","formData","restrict","link","attrs","latch","$observe","dispatchEvent","Event","eventName","interval","intervalId","setInterval","parseInt","preventDefault","swap","loading","$set","loadingClass","$removeClass","success","$res","go","stateSuccess","error","stateError","$eval","$merge","scopeParam","attrsParam","elementParam","animate","animationEnabled","compiled","DocumentFragment","targetSelector","querySelector","replaceChild","frag","placeholder","display","leave","done","insertedNodes","enter","insertBefore","$flushQueue","textContent","reverse","nextSibling","handleSwapResponse","delay","throttle","throttled","$addClass","enctype","catch","ngSse","transformMessage","onOpen","onMessage","onError","onReconnect","count","$count","$on","info","source","close","clearInterval","tag","ngWorkerDirective","$exceptionHandler","workerName","worker","createWorkerConnection","logger","dataOnResult","$result","temp","insertAdjacentHTML","handleSwap","dataOnError","$error","scriptPath","autoRestart","autoTerminate","cfg","reconnect","terminated","terminate","Worker","wire","workerParam","onmessage","warn","postMessage","log","restart","NgModule","requires","configFn","_restDefinitions","object","run","component","providerFunction","serviceFunction","_services","providerType","directiveFactory","animation","animationFactory","filterFn","controller","ctlFn","wasm","instantiateWasm","rest","entityClass","$rest","sse","websocket","protocols","_websocket","$ws","NodeRef","static","Element","NodeList","_nodes","from","_isList","_node","el","nodelist","fragment","dom","size","_getAny","_getAll","_collection","_getIndex","_setIndex","_clone","cloned","_isElement","normalizeControllerDef","$controllerMinErr","controllers","register","expression","later","ident","constructorName","lookedUp","argNameForErrors","func","identifier","$controllerIdentifier","addIdentifier","exportName","$scope","$scopename","meta","SCE_CONTEXTS","RESOURCE_URL","adjustMatcher","matcher","$sceMinErr","trustedResourceUrlList","bannedResourceUrlList","$$sanitizeUri","htmlSanitizer","matchUrl","originUrl","baseURI","exec","generateHolderType","Base","holderType","trustedValue","_unwrapTrustedValue","byType","HTML","trustedValueHolderBase","CSS","MEDIA_URL","trustAs","Constructor","getTrusted","maybeTrusted","allowed","SceProvider","enabled","$sceDelegate","sce","expr","_literal","enumValue","createEventDirective","directiveName","compile","$event","removeEventListener","createWindowEventDirective","$window","ngEventDirectives","Attributes","nodeRef","attributesToCopy","l","_nodeRef","classVal","addClass","classList","add","removeClass","$updateClass","newClasses","oldClasses","toAdd","toRemove","writeAttr","booleanKey","aliasedKey","observer","$attr","maybeSanitizedValue","sanitizeSrcset","elem","removeAttribute","SIMPLE_ATTR_NAME","toggleAttribute","setAttribute","setSpecialAttr","_observers","listeners","_inter","arrayRemove","specialAttrHolder","attributes","removeNamedItem","attribute","setNamedItem","invokeType","$compileMinErr","$compileMinErr$1","nbrUrisWith2parts","getTrustedMediaUrl","rawUris","innerIdx","lastTuple","tokenDifference","str1","str2","ngObserveDirective","normalized","MutationObserver","mutations","newValue","observe","attributeFilter","disconnect","CompileProvider","$sanitizeUriProvider","parseIsolateBindings","isController","scopeName","definition","bindingCache","bindings","mode","collection","optional","parseDirectiveBindings","isolateScope","bindToController","getDirectiveRequire","require","entryList","getDirectiveRestrict","registerDirective","assertValidDirectiveName","hasDirectives","DirectiveSuffix","valueFn","priority","directives","makeInjectable","tElement","tAttrs","$element","$attrs","ddo","controllerAs","identifierForController","templateUrl","transclude","aHrefSanitizationTrustedUrlList","regexp","imgSrcSanitizationTrustedUrlList","strictComponentBindingsEnabled","addPropertySecurityContext","elementName","propertyName","ctx","PROP_CONTEXTS","registerContext","values","$interpolate","$templateRequest","$controller","flushOnChangesQueue","onChangesQueue","denormalizeTemplate","startSymbol","endSymbol","transcludeFn","maxPriority","ignoreDirective","previousCompileContext","compositeLinkFn","compileNodes","cloneConnectFn","needsNewScope","$parent","$new","_parentBoundTranscludeFn","_boundTransclude","namespace","detectNamespaceForChildElements","_futureParentElement","append","wrappedTemplate","wrapTemplate","$linkNode","controllerName","nodeRefList","collectDirectives","nodeLinkFnCtx","applyDirectivesToNode","parentNodeRef","ctxNodeRef","nodeLinkFn","terminal","childLinkFn","transcluded","transcludeOnThisElement","templateOnThisElement","linkFnsList","linkFnFound","nodeLinkFnFound","stableNodeList","stableLength","stable","childBoundTranscludeFn","createBoundTranscludeFn","childScope","previousBoundTranscludeFn","boundTranscludeFn","transcludedScope","cloneFn","containingScope","$transcluded","transcludeControllers","slotName","_slots","boundSlots","addDirective","isNgAttr","ngPrefixMatch","isNgProp","isNgEvent","isNgObserve","addPropertyDirective","nName","addAttrInterpolateDirective","text","interpolateFn","expressions","nodeValue","addTextInterpolateDirective","compilationGenerator","eager","compileNode","templateAttrs","originalReplaceDirective","preLinkFns","postLinkFns","Yt","_newScopeDirective","Qt","_controllerDirectives","tn","_newIsolateScopeDirective","nn","_templateDirective","en","_nonTlbTranscludeDirective","hasElementTranscludeDirective","compileNodeRef","linkNode","$newIsolate","controllerScope","newTrancludeFn","cloneAttachFn","elementControllers","slotTranscludeFn","scopeToChild","isSlotFilled","controllerKey","_isolateScope","$transclude","controllerInstance","setupControllers","_isolateBindings","scopeBindingInfo","initializeDirectiveBindings","removeWatches","controllerDirective","bindingInfo","controllerDirectives","getControllers","$onChanges","initialChanges","$onInit","$onDestroy","preLinkFn","postLinkFn","$postLink","terminalPriority","directivePriority","directiveValue","assertNoDuplicate","hasReplacedTemplate","shouldTransclude","didScanForMultipleTransclusion","candidateDirective","scanningIndex","EXCLUDED_DIRECTIVES","mightHaveMultipleTransclusionError","$template","createComment","replaceWith","childTranscludeFn","replaceDirective","elementSelector","filledSlots","slotMap","slots","filled","slotCompileNodes","_newScope","hasTemplate","templateNamespace","_templateDirectives","newTemplateAttrs","unprocessedDirectives","markDirectiveScope","compileTemplateUrl","hasTranscludeDirective","linkFn","addLinkFns","pre","Math","max","newScope","cloneAndAnnotateFn","REQUIRE_PREFIX_REGEXP","inheritType","dataName","property","inherit","tDirectives","MAX_VALUE","maxPriorityValue","_bindings","mergeTemplateAttributes","dstAny","srcAny","srcAttr","dstAttr","$compileNode","$rootElement","origAsyncDirective","shift","_originalDirective","tempTemplateAttrs","derivedSyncDirective","afterTemplateNodeLinkFnCtx","afterTemplateChildLinkFn","linkQueue","beforeTemplateLinkNode","_destroyed","beforeTemplateCompileNode","cls","afterTemplateNodeLinkFn","isError","_ignoreChildLinkFn","rootElement","byPriority","a","b","diff","what","previousDirective","wrapper","propName","trustedContext","sanitizer","_","applyPropValue","propValue","attrNormalizedName","mustHaveExpression","allOrNothing","outerHTML","newInterpolatedValue","elementsToRemove","newNode","oldChild","annotation","destination","recordChanges","currentValue","initial","$postUpdate","changes","triggerOnChangesHook","firstChange","strictBindingsCheck","destAny","attrsAny","removeWatch","firstCall","lastValue","removeWatchCollection","compare","parentGet","parentSet","_assign","parentValueWatch","parentValue","_inputs","$handler","_watchers","watchFn","listenerFn","nullFormCtrl","$nonscope","$addControl","$getControls","_renameControl","control","$name","$removeControl","$setValidity","$setDirty","$setPristine","$setSubmitted","_setSubmitted","PENDING_CLASS","FormController","ngForm","$pristine","$valid","$invalid","$submitted","_success","$pending","_classCache","isValid","$rollbackViewValue","_controls","$commitViewValue","_parentForm","newName","oldName","$dirty","setClass","SUBMITTED_CLASS","$setUntouched","rootForm","list","unset","validationErrorKey","state","ctrl","validationErrorKeyParam","cachedToggleClass","controllerParam","createAndSet","unsetAndCleanup","toggleValidationCss","combinedState","formDirectiveFactory","isNgForm","formElement","nameAttr","formElementParam","attrParam","ctrls","handleFormSubmission","setter","formDirective","className","switchValue","_isAnimated","NgModelOptionsController","$options","defaultModelOptions","parentOptions","parentCtrl","modelOptionsDefinition","ngModelOptions","createChild","ModelOptions","_options","getOption","option","inheritAll","updateOnDefault","DEFAULT_REGEXP","defaults$1","updateOn","debounce","getterSetter","allowInvalid","ngModelOptionsDirective","NgModelController","$modelValue","_updateEvents","_parsedNgModel","ngModel","_parsedNgModelAssign","_ngModelGet","_ngModelSet","_pendingDebounce","_attr","modelValue","_setModelValue","_initGetterSetters","invokeModelGetter","invokeModelSetter","_$p","ngModelMinErr","$render","$isEmpty","_updateEmptyClasses","NOT_EMPTY_CLASS","$touched","$setTouched","$viewValue","_lastCommittedViewValue","$validate","_runValidators","viewValue","allValid","prevValid","prevModelValue","_writeModelToScope","doneCallback","_currentValidationRunId","setValidity","validationDone","localValidationRunId","_parserValid","errorKey","$validators","$asyncValidators","processParseErrors","validator","syncValidatorsValid","processSyncValidators","validatorPromises","all","_hasNativeValidators","_parseAndValidate","_parserName","$parsers","writeToModelIfNeeded","$viewChangeListeners","listener","$setViewValue","trigger","_debounceViewValueCommit","debounceVal","debounceDelay","default","$overrideModelOptions","_removeAllEventListeners","_setUpdateOnEvents","$processModelValue","_format","formatters","_rawModelValue","_eventRemovers","removeCallback","clear","ev","_updateEventHandler","ngModelDirective","modelCtrl","optionsCtrl","deregisterWatch","elementPost","change","URL_REGEXP","EMAIL_REGEXP","PARTIAL_VALIDATION_TYPES","inputType","baseInputType","stringBasedInputType","date","createStringDateInputType","time","week","month","number","badInputChecker","numberFormatterParser","min","minVal","parsedMinVal","parseNumberAttrVal","maxVal","parsedMaxVal","step","parsedStepVal","isValidForStep","stepVal","email","radio","checked","doTrim","deproxy","range","setInitialValueAndObserver","htmlAttrName","changeFn","oldVal","supportsRange","validity","rangeUnderflow","rangeOverflow","originalRender","stepMismatch","checkbox","trueValue","parseConstantExpr","ngTrueValue","falseValue","ngFalseValue","hidden","button","submit","reset","file","$formatters","composing","ngTrim","badInput","origBadInput","typeMismatch","origTypeMismatch","_modelValue","parserName","parseFloat","isNumberInteger","countDecimals","decimalSymbolIndex","numString","stepBase","isNonIntegerValue","isNonIntegerStepBase","stepDecimals","valueDecimals","stepBaseDecimals","multiplier","isNonIntegerStep","round","fallback","parseFn","inputDirective","hiddenInputDirective","ngValueDirective","updateElementValue","tplAttr","ngValue","scriptDirective","$templateCache","id","innerText","SelectController","_renderUnknownOption","_unknownOption","unknownVal","selected","_updateUnknownOption","_generateUnknownOptionValue","_removeUnknownOption","_selectEmptyOption","_emptyOption","_un_selectEmptyOption","_hasEmptyOption","_readValue","realVal","_hasOption","_writeValue","currentlySelectedOption","hashedVal","_selectValueMap","selectedOption","_selectUnknownOrEmptyOption","_addOption","_optionsMap","_scheduleRender","_removeOption","$hasEmptyOption","$isUnknownOptionSelected","$isEmptyOptionSelected","selectedIndex","_renderScheduled","_ngModelCtrl","_scheduleViewValueUpdate","renderAfter","_updateScheduled","registerOption","optionScope","optionElement","optionAttrs","interpolateValueFn","interpolateTextFn","newVal","removal","previouslySelected","_multiple","removeValue","selectDirective","ngModelCtrl","selectCtrl","multiple","shouldBeSelected","lastViewRef","lastView","optionDirective","elemParam","selectCtrlName","ngBindDirective","lazy","ngBindTemplateDirective","ngBindHtmlDirective","_tElement","ngBindHtml","classDirective","selector","classCounts","digestClassCounts","classArray","classesToUpdate","newModulo","$index","classString","addClasses","oldClassString","removeClasses","oldModulo","newClassString","toClassString","oldClassStringParam","updateClasses","arrayDifference","tokens2","tokens1","set2","classValue","Boolean","ks","valueMap","ngClassDirective","ngClassOddDirective","ngCloakDirective","ngControllerDirective","ngShowDirective","ngShow","NG_HIDE_CLASS","tempClasses","NG_HIDE_IN_PROGRESS_CLASS","ngHideDirective","ngHide","ngIfDirective","_ctrl","ngIf","previousElements","block","nextElementSibling","ngIncludeDirective","$anchorScroll","_$attr","maybeScroll","autoScrollExp","cleanupLastIncludeContent","previousElement","currentScope","currentElement","srcExp","afterAnimation","$emit","changeCounter","cloneParam","onloadExp","ngIncludeFillContentDirective","ngInitDirective","ngInit","ngNonBindableDirective","ngRefDirective","getter","ngRefMinErr","ngRef","ngRefRead","refValue","VAR_OR_TUPLE_REGEX","ngRepeatDirective","updateScope","valueIdentifier","keyIdentifier","arrayLength","$first","$last","$middle","$odd","$even","getBlockStart","getBlockEnd","trackByIdArrayFn","_$scope","_key","trackByIdObjFn","_$element","ngRepeatMinErr","lhs","aliasAs","called","callBackOnce","rhs","collectionKeys","trackByIdFn","itemKey","collectionLength","lastBlockMap","trackById","nextBlockMap","nextBlockOrder","blockKey","NG_REMOVED","$destroy","nextNode","move","previousNode","ngStyleDirective","newStyles","oldStyles","removeProperty","setProperty","ngSwitchDirective","cases","ngSwitchController","spliceFactory","watchExpr","previousLeaveAnimations","cancel","pop","selectedScopes","runner","selectedElements","selectedTranscludes","selectedTransclude","caseElement","selectedScope","comment","anchor","ngSwitchWhenDirective","ngSwitchWhen","ngSwitchWhenSeparator","whenCase","ngSwitchDefaultDirective","NG_OPTIONS_REGEXP","OptionItem","selectValue","label","group","disabled","ngOptionsDirective","selectElement","children","hasEmptyOption","emptyOption","ngOptions","optionsExp","ngOptionsMinErr","getTrackByValueFn","trackBy","getTrackByValue","getLocals","keyName","getWatchables","valuesFn","getOptions","optionValues","optionValuesKeys","optionValuesLength","optionItem","optionItems","selectValueMap","items","getOptionFromViewValue","getViewValueFromOption","parseOptionsExpression","selectedOptions","optionsEls","optionEl","selections","providedEmptyOption","_optionScope","needsRerender","_decoratedNode","body","_addOptionElement","optionTemplate","updateOptionElement","groupElement","optGroupTemplate","groupElementMap","listFragment","previousValue","nextValue","ngTranscludeDirective","ngTranscludeMinErr","ngTransclude","useFallbackContent","fallbackLinkFn","defaultLinkFn","ngAttributeAliasDirectives","ngAttr","_elm","ngRequired","required","_Elm","tAttr","REGEX_STRING_REGEXP","attrVal","patternExp","pattern","oldRegexp","maxlength","maxlengthParsed","parseLength","minlengthParsed","minlength","parsePatternAttr","input","regex","intVal","autoScrollingEnabled","$location","$rootScope","getBoundingClientRect","bottom","scrollBy","rect","top","scrollTo","scroll","hashOrElement","HTMLElement","getElementById","getFirstAnchor","getElementsByName","_e","readyState","queueMicrotask","action","ADD_CLASS_SUFFIX","REMOVE_CLASS_SUFFIX","ACTIVE_CLASS_SUFFIX","NG_ANIMATE_CLASSNAME","pendClasses","classes","fix","isPrefix","klass","prepareAnimationOptions","_prepared","domOperation","animateOptions","_domOperationFired","applyAnimationStyles","applyAnimationFromStyles","applyAnimationToStyles","to","mergeAnimationDetails","oldAnimation","newAnimation","newOptions","preparationClasses","addList","removeList","existingSet","Set","finalAdd","finalRemove","_blockKeyframeAnimations","applyBlock","applyInlineStyle","styleTuple","concatWithSpace","prepareAnimateOptions","AnimateProvider","$animateMinErr","_registeredAnimations","customFilter","classNameFilter","$$animateQueue","exception","filterFilter","comparator","anyPropertyKey","getTypeForFilter","predicateFn","createPredicateFn","matchAgainstAnyProp","actual","expected","deepCompare","dontMatchWholeObject","expectedType","actualType","expectedVal","matchAnyProperty","jsonFilter","spacing","limitToFilter","limit","begin","abs","Infinity","sliceFn","end","orderByFilter","sortPredicate","reverseOrder","compareFn","predicate","descending","compareValues","tieBreaker","predicateValues","predicates","isPrimitive","objectValue","getPredicateValue","v1","v2","defaultCompare","type1","type2","value1","value2","FilterProvider","limitTo","orderBy","SUFFIX","interr","$interpolateMinErr","escapedStartRegexp","escape","escapedEndRegexp","ch","unescapeText","contextAllowsConcatenation","unescapedText","constantInterp","exp","textLength","endIndex","startSymbolLength","endSymbolLength","expressionPositions","singleExpression","throwNoconcat","cb","watchProp","vals","parseFns","compute","Location","appBase","appBaseNoFile","html5","prefix","absUrl","setUrl","$locationMinErr","setPath","setSearch","getUrl","path","newPath","decodePath","getPath","setHash","_hash","getHash","paramValue","_search","getSearch","_compose","pathValue","hashValue","decodedSegment","segments","normalizePath","hashPrefix","urlUpdatedByLocation","_updateBrowser","setState","getState","parseLinkUrl","relHref","appUrl","stripBaseUrl","rewrittenUrl","basePrefix","prevAppUrl","stripHash","pathUrl","withoutBaseUrl","withoutHashUrl","parseAppUrl","html5ModeConf","requireBase","rewriteLinks","_urlChangeListeners","_cachedState","_lastHistoryState","_lastBrowserUrl","cacheState","history","pushState","getBrowserUrl","currentState","lastCachedState","fireStateOrUrlChange","prevLastHistoryState","onUrlChange","_urlChangeInit","slashIndex","serverBase","initialUrl","baseHref","lastIndexOf","hashPrefixConf","setBrowserUrlWithFallback","oldState","ctrlKey","metaKey","shiftKey","absHref","animVal","defaultPrevented","newState","newUrl","$broadcast","oldUrl","initializing","afterLocationChange","updateBrowser","urlOrStateChanged","y","normalizeUrl","html5Mode","prefixed","base","endsWith","LogProvider","debug","_override","setLogger","_formatError","_consoleLog","console","logFn","formattedArgs","ESCAPE","n","f","r","t","OPERATORS","ASTType","ASTInterpreter","$filter","_$filter","ast","stmt","isAssignable","left","right","operator","assignable","recurse","candidate","lastExpression","toWatch","watch","inputs","watchId","computed","computedMember","nonComputedMember","elements","$proxy","alternate","findConstantAndWatchExpressions","parentIsPure","decoratedLeft","decoratedRight","decoratedTest","decoratedAlternate","decoratedConsequent","decoratedObject","decoratedProperty","allConstants","decorated","astIsPure","decoratedNode","isFilter","argsToWatch","properties","decoratedKey","literals","true","false","null","AST","lexer","_lexer","_selfReferential","$locals","_index","_ast","_text","_tokens","_throwError","_program","hasMore","_peek","_expressionStatement","_filterChain","_expect","_assignment","$parseMinErr","_ternary","_consume","consequent","_logicalOR","_logicalAND","_equality","token","_relational","_additive","_multiplicative","_unary","_primary","primary","_arrayDeclaration","_object","_identifier","_constant","callee","_parseArguments","baseExpression","_peekToken","kind","msg","e1","txt","Parser","_astCompiler","isLiteral","_lex","_readString","_isNumber","_readNumber","_isIdentifierStart","_peekMultichar","_readIdent","_is","_isWhitespace","op1","op2","op3","chars","_isIdentifierContinue","cp1","cp2","peek","_isExpOperator","start","colStr","$parseMinErr$1","peekCh","quote","_handleUnicodeEscape","hex","fromCharCode","interceptorFn","parsedExpression","addInterceptor","rootScope","createScope","exceptionHandler","global","frames","nonScopeConstructors","Document","EventTarget","HTMLCollection","Date","WeakMap","WeakSet","ArrayBuffer","DataView","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Float64Array","Blob","File","FormData","URLSearchParams","Ctor","wStr","ctorNonScope","proxy","Scope","uid","propertyMap","$apply","_children","$getById","$id","$isRoot","$root","$searchByName","nonscopeProps","oldValue","scheduleListener","_foreignListeners","_objectListeners","checkeListenersForAllKeys","currentListeners","_foreignProxies","jl","keyListeners","expectedTarget","lengthListeners","propListeners","scheduled","expectedHandler","originalTarget","_scheduled","model","child","ids","watchers","scopeId","targetProp","filteredListeners","registerKey","deregisterKey","isPure","potentialProxy","_registerForeignKey","currentKey","listenerObject","childInstance","proto","setPrototypeOf","parentInstance","listenerList","_deregisterForeignKey","namedListeners","_listeners","eventHelper","broadcast","targetScope","stopped","stopPropagation","currentLength","isRoot","$postUpdateQueue","notifyListener","found","TemplateRequestProvider","httpOptions","_aHrefSanitizationTrustedUrlList","_imgSrcSanitizationTrustedUrlList","uri","isMediaUrl","normalizedVal","NgMessageCtrl","_latestKey","_nextAttachId","_messages","_renderLater","_head","ngMessages","for","_render","_getAttachId","isAttrTruthy","ngMessagesMultiple","totalMessages","messageFound","messageUsed","messageCtrl","matchedKeys","attach","unmatchedMessages","messageItem","detach","attachDefault","_default","messageMatched","ACTIVE_CLASS","INACTIVE_CLASS","reRender","_cachedCollection","isDefault","nextKey","insertMessageNode","_ngMessageNode","deregister","findPreviousMessage","prevNode","prevKey","parentLookup","messageNode","removeMessageNode","ngMessagesDirective","truthy","ngMessagesIncludeDirective","contents","ngMessageDirective","ngMessageDirectiveFactory","ngMessageExpDirective","ngMessageDirectiveFn","ngMessagesCtrl","commentNode","staticExp","ngMessage","when","records","dynamicExp","assignRecords","contains","attachId","_attachId","nativeAriaNodeNames","isNodeOneOf","nodeTypeArray","AriaProvider","ariaHidden","ariaChecked","ariaReadonly","ariaDisabled","ariaRequired","ariaInvalid","ariaValue","tabindex","bindKeydown","bindRoleForClick","ariaAttr","nativeAriaNodeNamesParam","negate","ariaCamelName","boolVal","newConfig","_watchExpr","ngDisabledAriaDirective","$aria","ngShowAriaDirective","ngMessagesAriaDirective","ngClickAriaDirective","ngKeydown","ngKeypress","ngKeyup","keyCode","ngRequiredAriaDirective","ngCheckedAriaDirective","ngValueAriaDirective","ngHideAriaDirective","ngReadonlyAriaDirective","ngModelAriaDirective","shouldAttachAttr","normalizedAttr","allowNonAriaNodes","shouldAttachRole","role","attrPost","needsTabIndex","shape","needsAriaValuemin","needsAriaValuemax","needsAriaValuenow","ngDblclickAriaDirective","flush","queue","tasks","schedule","AnimateRunner","jsAnimation","rafTick","timeoutTick","_tick","setHost","_host","_doneCallbacks","progress","pause","resume","_finish","complete","callbacks","getPromise","_promise","ok","onFulfilled","onRejected","onFinally","finally","_chain","runners","remaining","_cacheKey","_containsCachedAnimationWithoutDuration","entry","_flush","_count","total","_get","_put","_cancelFn","_nextTick","_queue","_schedule","_waitUntilQuiet","cancelAnimationFrame","DETECT_CSS_PROPERTIES","transitionDuration","transitionDelay","transitionProperty","animationDuration","animationDelay","animationIterationCount","DETECT_STAGGER_CSS_PROPERTIES","getCssDelayStyle","computeCssStyles","detectedStyles","actualStyleName","formalStyleName","parseMaxTime","styles","truthyTimingValue","getCssTransitionDurationStyle","duration","applyOnlyDuration","backup","getPropertyValue","AnimateCssProvider","waitUntilQuiet","rafWaitQueue","rafScheduler","computeTimings","cacheKey","allowNoDuration","timings","hasDuration","computeCachedCssStyles","maxDelay","aD","tD","initialOptions","_skipPreparationClasses","closeAndReturnNoopAnimator","isStructural","structuralClassName","addRemoveClassName","applyClassesEarly","applyAnimationClasses","hasToStyles","animateCache","staggerVal","stagger","staggerClassName","staggerCacheKey","computeCachedCssStaggerStyles","temporaryStyles","transitionStyle","transition","durationStyle","keyframeStyle","staggerIndex","isFirst","blockTransitions","relativeDelay","_hasTransitions","_hasAnimations","_hasTransitionAll","_applyTransitionDuration","_applyAnimationDuration","_applyTransitionDelay","_applyAnimationDelay","_recalculateTimingStyles","_blockTransition","_blockKeyframeAnimation","flags","maxDuration","delayStyle","maxDelayTime","ONE_SECOND","cleanupStyles","registerRestorableStyles","restoreStyles","applyBlocking","skipBlocking","_willAnimate","endFn","animationClosed","noopRunner","runnerHost","cancelFn","rejected","animationCompleted","animationPaused","activeClasses","onDone","events","onAnimationProgress","animationTimerData","ANIMATE_TIMER_KEY","elapsedTime","toFixed","startTime","playPause","playAnimation","maxStagger","itemIndex","triggerAnimationStart","easing","easeProp","easeVal","now","timerTime","setupFallbackTimer","currentTimerData","timer","animationsData","expectedEndTime","endTime","floor","AnimateQueueProvider","$animateProvider","rules","skip","getEventData","hasMatchingClasses","currentClassString","currentClassMap","isAllowed","ruleType","currentAnimation","previousAnimation","hasAnimationClasses","and","structural","nA","nR","cA","cR","$$animation","isAnimatableClassName","returnTrue","normalizeAnimationDetails","matchContainer","matchCallback","containerNode","phase","off","on","container","callbackRegistry","eventType","filterFromRegistry","pin","NG_ANIMATE_PIN_DATA","originalElement","postDigestCalled","isAnimatableByFilter","skipAnimations","existingAnimation","hasExistingAnimation","parentHost","rootNodeDetected","rootNode","parentAnimationDetected","parentNodeDisabled","elementDisabled","details","animateChildren","NG_ANIMATE_CHILDREN_DATA","bodyNodeDetected","bodyNode","areAnimationsAllowed","NG_ANIMATE_ATTR_NAME","animationDetails","activeAnimationsLookup","closeChildAnimations","applyGeneratedPreparationClasses","isValidAnimation","markElementAnimationState","isCurrentAnimationValid","animationCancelled","counter","clearElementAnimationState","realRunner","notifyProgress","runnerParam","eventParam","runInNextPostDigestOrNow","targetParentNode","targetNode","matches","cleanupEventListeners","clearGeneratedClasses","queueAnimation","AnimateJsProvider","animationOptions","flagMap","animations","beforeFn","afterFn","before","packageAnimations","classesToAdd","classesToRemove","finish","finished","partDone","applyOptions","optionsParam","animationsParam","fnName","classNames","ani","operations","animationFn","op","completed","AnimationProvider","getRunner","RUNNER_STORAGE_KEY","PREPARE_CLASSES_KEY","animationQueue","beforeStart","prepareClassName","anchorNodes","NG_ANIMATE_REF_ATTR","nodeItem","anchors","getAnchorNodes","refLookup","direction","animationID","preparedAnimations","usedIndicesLookup","indexKey","anchorGroups","lookupKey","fromAnimation","toAnimation","cssClassesIntersection","in","groupedAnimations","animationEntry","fromElement","extraClasses","toBeSortedAnimations","domNode","drivers","driver","operation","startAnimationFn","animationRunner","closeFn","newRunner","update","updateAnimationRunners","tree","lookup","processNode","theeParam","remainingLevelEntries","nextLevelEntries","row","childEntry","processed","parentEntry","finalAnimations","innerArray","flatFinalAnimations","normalizeClassValue","aa","deleteCacheData","AnimateCssDriverProvider","$$animationProvider","$animateCss","rootBodyElement","outAnchor","inAnchor","animator","NG_OUT_ANCHOR_CLASS_NAME","calculateAnchorStyles","animatorOut","animatorIn","startingAnimator","scrollTop","scrollLeft","prepareInAnimation","endingClasses","filterCssClasses","NG_ANIMATE_SHIM_CLASS_NAME","anchorAnimations","animationRunners","runnerItem","prepareFromToAnchorAnimation","prepareRegularAnimation","getUniqueValues","AnimateJsDriverProvider","$$animateJs","prepareAnimation","endFnFactory","ngAnimateSwapDirective","previousScope","$$AnimateChildrenDirective","setData","t1","a1","a2","_arraysEq","tup","every","newObj","removeFrom","opts","defaultsList","defaultVals","pick","propNames","_prop","objCopy","omit","reduce","acc","accept","find","allTrueR","memo","anyTrueR","pushR","uniqR","maxArrayLen","MAX_SAFE_INTEGER","applyPairs","keyValTuple","dest","curry","curried","nextArgs","propEq","_val","is","struct","ParamType","def","encode","decode","$normalize","$asArray","ArrayType","arrayWrap","arrayHandler","allTruthyMode","arrayUnwrap","arrayEqualsHandler","wrapperFn","paramTypeFn","dynamic","$arrayMode","enqueue","typeQueue","defaultTypes","ParamTypes","types","definitionFn","_flushTypeQueue","makeDefaultType","valToString","defaultTypeBase","query","int","bool","getFullYear","getMonth","getDate","capture","any","paramTypes","_isCaseInsensitive","_isStrictMode","_defaultSquashPolicy","pathType","caseInsensitive","defaultSquashPolicy","strictMode","StateParams","$inherit","$current","$to","first","second","firstPath","secondPath","parents","parentParamsKeys","parentParams","inheritList","inherited","newParams","Queue","_limit","isInteger","_evictListeners","onEvict","_items","evict","dequeue","cleared","peekTail","peekHead","_transitionHistory","_successfulTransitions","maxLength","DOTS","functionToString","toStr","fnToString","_fn","stringifyPattern","reg","_transitionRejection","format","joinNeighborsR","ngViewString","ngView","creationContext","fqn","normalizedCat","Category","_RESOLVE","_TRANSITION","_HOOK","_UIVIEW","_VIEWCONFIG","transLbl","trans","_tid","_rid","_enabled","approximateDigests","$logger","_set","categories","category","enable","disable","traceTransitionStart","traceTransitionIgnored","traceHookInvocation","traceHookResult","hookResult","traceResolvePath","traceResolvableResolved","resolvable","traceError","traceSuccess","finalState","traceUIViewEvent","viewData","padString","traceUIViewConfigUpdated","traceUIViewFill","traceViewSync","pairs","mapping","viewConfig","uivheader","uiv","cfgheader","table","traceViewServiceEvent","view","$ngViewName","$ngViewContextAnchor","viewConfigString","traceViewServiceUIViewEvent","Resolvable","arg1","resolveFn","deps","policy","resolved","getPolicy","thisPolicy","statePolicy","resolveContext","customAsyncPolicy","asyncPolicy","resolvedDeps","resolvedValue","fromData","TargetState","_params","_definition","relative","exists","valid","stateName","withState","withParams","withOptions","newOpts","isDef","Param","urlConfig","paramName","noReloadOnSearch","reloadOnSearch","paramConfig","getStaticDefaultValue","isShorthand","unwrapShorthand","defaultConfig","urlType","getType","arrayDefaults","arrayParamNomenclature","arrayMode","isOptional","squash","defaultPolicy","getSquashPolicy","configuredKeys","matchingKeys","isDefaultValue","tuple","defaultValue","_cacheable","_defaultValueCache","getDefaultValue","isSearch","validates","encoded","paramValues","param","changed","values1","values2","PathNode","stateOrNode","paramSchema","resolvables","views","parameters","applyRawParams","pDef","paramDef","parameter","paramsFn","PathUtils","targetState","toParams","buildToPath","fromPath","inheritParams","toPath","applyViewConfigs","$view","states","viewConfigs","viewDecls","_createViewConfig","unnestR","toKeys","noInherit","toNode","toParamVals","fromParamVals","nodeParamVals","ownParamVals","incomingParamVals","treeChanges","reloadState","nodesMatch","node1","node2","keep","retainedNode","retained","retainedWithToParams","exiting","entering","matching","pathA","pathB","nodeA","nodeB","subPath","elementIdx","nonDynamicParams","makeTargetState","registry","at","resolvePolicies","ResolveContext","getTokens","getResolvable","subContext","addResolvables","newResolvables","resolvePath","matchedWhens","trace","matchesPolicy","acceptedVals","whenOrAsync","nodeResolvables","getResult","promises","findNode","getDependencies","availableResolvables","fromInjector","hasAnyKey","ng1ViewsBuilder","compKeys","nonCompKeys","allViewKeys","resolveAs","$context","ViewConfig","normalizeUIViewTarget","ngViewName","ngViewContextAnchor","viewDecl","loaded","getTemplate","makeComponentTemplate","load","fromConfig","results","rawViewName","viewAtContext","relativeViewNameSugar","hops","anchorState","_ngViews","_viewConfigs","_viewConfigFactory","templateFactory","getViewConfigFactory","rootViewContext","_rootContext","decl","cfgFactory","deactivateViewConfig","activateViewConfig","sync","ngViewsByFqn","viewConfigDepth","depthCompare","depthFn","posNeg","configureUIView","configUpdated","stateDepth","ViewService","matchingConfigs","unmatchedConfigTuples","matchedViewConfigs","ngViewTuples","allTuples","registerUIView","ngViews","available","active","vcSegments","uivSegments","vc","ngViewContext","Rejection","detail","redirected","rejection","superseded","invalid","ignored","aborted","errored","toPromise","defaultOptions","current","traceData","TransitionHookScope","_STATE","TransitionHook","chain","hooks","waitFor","prev","nextHook","invokeHooks","remainingHooks","runAllHooks","hook","invokeHook","stateContext","registeredHook","isSuperseded","hookPhase","logError","_deregistered","notCurrent","invokeCallback","normalizeErr","handleError","handleResult","synchronous","normalize","invokeLimit","invokeCount","handleHookResult","getNotCurrentRejection","HANDLE_RESULT","LOG_ERROR","REJECT_ERROR","THROW_ERROR","Glob","fromString","hasGlobs","regexpString","seg","_regexp","RegisteredHook","tranSvc","matchCriteria","removeHookFromRegistry","_matchingNodes","criterion","toMatch","globStrings","glob","matchState","_getDefaultMatchCriteria","_getPathTypes","_getMatchingNodes","criteria","mn","pathtype","registerHook","hookSource","transitionService","_registeredHooks","HookBuilder","buildHooksForPhase","_transitionService","_getEvents","buildHooks","hookType","matchingHooks","getMatchingHooks","baseHookOptions","criteriaMatchPath","transitionHook","reverseDepthSort","depthDelta","tupleSort","reverseSort","isCreate","$transitions","getHooks","predicateOrMap","errMsg","assertPredicate","Transition","globals","_deferred","_treeChanges","onCreateHooks","_hookBuilder","hookName","onBefore","onStart","onEnter","onRetain","onExit","onFinish","onSuccess","_getEventType","enteringStates","$from","_targetState","freeze","getResolveTokens","addResolvable","topath","redirectedFrom","originalTransition","rf","redirect","redirects","redirectOpts","newTransition","redirectEnteringNodes","originalEnteringNodes","_changedParams","tc","toValues","fromValues","schema","toVals","fromVals","_ignoredReason","same","pendTC","newTC","getHooksFor","allBeforeHooks","_globals","_lastStartedTransitionId","allRunHooks","_error","_aborted","abstract","invalidParams","paramDefs","invalidValues","avoidEmptyHash","fromStateOrName","toStateOrName","treeChangesCleanup","TRANSITION_TOKENS","replaceTransitionWithNull","makeEnterExitRetainHook","hookFn","RESOLVE_HOOK_PRIORITY","eagerResolvePath","lazyResolveState","resolveRemaining","loadEnteringViews","enteringViews","registerLazyLoadHook","stateService","urlService","stateRegistry","lazyLoad","lazyLoadState","orig","rule","lazyLoadFn","lazyLoadPromiseCache","TransitionEventType","hookOrder","getResultHandler","getErrorHandler","ignoredHook","ignoredReason","pending","invalidTransitionHook","defaultTransOpts","notify","reload","supercede","custom","TransitionProvider","viewService","_transitionCount","_eventTypes","_criteriaPaths","_deregisterHookFns","_defineCorePaths","_defineCoreEvents","updateUrl","navigable","urlOptions","registerUpdateUrl","redirectTo","registerRedirectToHook","activateViews","exitingViews","registerActivateViews","NORMAL_SORT","_defineEvent","paths","TH","LOG_REJECTED_RESULT","SYNCHRONOUS","_definePathType","TRANSITION","STATE","matchObject","removeHookFn","makeEvent","cmpByPhase","hookScope","onCreate","_registerCoreTransitionHooks","addCoreResolves","registerIgnoredTransitionHook","onExitHook","onRetainHook","registerOnRetainHook","onEnterHook","registerOnEnterHook","eagerResolve","registerEagerResolvePath","lazyResolve","registerLazyResolveState","resolveAll","registerResolveRemaining","updateGlobals","clearCurrentTransition","copy","StateProvider","exceptionHandlerProvider","_defaultErrorHandler","$url","stdErr","_handleInvalidTargetState","toState","fromState","checkForRedirect","transitionTo","invokeNextCallback","nextCallback","injector","onInvalid","invalidCallbacks","transOpts","root","getCurrentPath","latestSuccess","rootPath","getCurrent","rejectedTransitionHandler","transitionToPromise","stateOrName","lossy","absolute","nav","defaultErrorHandler","currentPath","TemplateFactoryProvider","asTemplate","fromUrl","fromProvider","templateProvider","asComponent","fromComponentProvider","componentProvider","providerFn","camelCase","$1","kebobed","cmpDefs","getBindings","getComponentBindings","resolveName","kebobName","scopeBindings","bindingsObj","quoteRegExp","surroundPattern","re","strict","UrlMatcher","pathSegmentsAndParams","arrayTuples","weights","splitOnSlash","segment","weightsA","padArrays","weightsB","_pairs","cmp","paramFactory","_compiled","searchPlaceholder","checkParamErrors","nameValidator","matchDetails","makeRegexpType","patterns","lastIndex","matchArray","fromSearch","_segments","_getDecodedParamValue","unnest","allParams","pathParams","searchParams","nPathSegments","urlm","decodePathArray","paramVal","reverseString","findParam","getDetails","queryParams","pathString","encodeDashes","queryString","paramDetails","char","charCodeAt","StateObject","_stateObjectCache","nameGlob","ref","isStateDeclaration","isState","UrlRuleFactory","routerGlobals","makeRule","_what","fromUrlMatcher","fromRegExp","BaseUrlRule","urlMatcher","_handler","stateOrDecl","isUrlRule","matchPriority","defaultRuleSortFn","URLMATCHER","REGEXP","RAW","OTHER","urlMatcherSort","useMatchPriority","idSort","UrlRules","urlRuleFactory","_sortFn","_rules","_id","_urlRuleFactory","removeRule","sorted","stableSort","_sorted","ensureSorted","arrOfWrapper","wrapperA","wrapperB","cmpDiff","ParamFactory","urlServiceConfig","UrlService","$locationProvider","stateProvider","urlConfigProvider","_locationProvider","_urlListeners","evt","_baseHref","decodeUri","onChange","newurl","applyResult","best","listen","_stopListeningFn","checkRule","weight","_group","isHtml5","slash","urlPattern","globalConfig","isMatcher","StateMatcher","_states","isRelative","isStr","matchGlob","stateObj","pathLength","splitName","baseState","relName","selfBuilder","dataBuilder","getUrlBuilder","stateObject","stateDec","newStateDec","pathBuilder","StateBuilder","_matcher","_$injector","rootFn","_builders","parentName","_paramFactory","urlParams","nonUrlParams","_config","includesBuilder","literal2Resolvable","getToken","useFactory","dependencies","useClass","useValue","useExisting","tuple2Resolvable","item2Resolvable","resolveObj","resolvablesBuilder","builder","builders","build","parentFn","provide","StateQueueManager","urlServiceRules","stateDecl","registered","notifyListeners","existingState","existingFutureState","orphanIdx","orphans","attachRoute","rulesApi","StateRegistryProvider","getStateHookBuilder","stateQueue","$state$","$transition$","registerRoot","_root","onStatesChanged","registryProvider","stateDefinition","_deregisterTree","getChildren","deregistered","deregisteredStates","builderFunction","paramsOnly","paramExpr","processedDef","ngStateOpts","defaultOpts","ngState","ngStateParams","getTypeInfo","isSvg","isAnchor","clickable","isForm","clickHook","getDef","which","altKey","stopImmediatePropagation","ignorePreventDefaultCount","$StateRefDirective","$stateService","$stateRegistry","rawDef","unlinkInfoFn","_addStateInfo","ngSrefOpts","bindEvents","$StateRefDynamicDirective","watchDeregFns","inputAttrs","field","newval","$StateRefActiveDirective","$router","activeEqClass","ngSrefActiveEq","ngSrefActive","updateAfterTransition","handleStatesChanged","setStatesFromDefinitionObject","statesDefinition","activeClass","addStateForClass","stateOrNameParam","activeClassParam","parseStateRef","addState","stateParams","stateInfo","splitClasses","getClasses","stateList","allClasses","fuzzyClasses","exactClasses","deregisterStatesChangedListener","deregisterOnStartListener","deregisterStateChangeSuccessListener","$ViewDirective","rootData","$cfg","$ngView","_tAttrs","onload","autoscroll","renderer","activeUIView","updateView","fromParentTagConfig","fromParentTag","$ngViewData","$ngViewAnim","$animEnter","animEnter","$animLeave","$$animLeave","animLeave","currentEl","previousEl","_viewData","cleanupLastView","unregister","$ViewDirectiveFill","contentDocument","resolveCtx","ell","paramsUpdated","viewCreationTrans","viewState","getNodeSchema","toNodes","fromNodes","toSchema","fromSchema","changedToParams","fromParams","changedKeys","newValues","uiOnParamsChanged","hookOptions","uiCanExit","prevTruthyAnswer","cacheProp","wrappedHook","registerControllerCallbacks","ngChannelDirective","$eventBus","unsubscribe","subscribe","channel","hasTemplateContent","ngSetterDirective","modelExpression","assignModel","updateModel","mutationsList","mutation","contentChanged","childList","subtree","characterData","PubSubProvider","angularProvider","eventBus","PubSub","_disposed","isDisposed","dispose","_topics","topic","subscribeOnce","unsub","getCount","publish","snapshot","ngInjectDirective","tokens","ngElDirective","removedNodes","removedNode","StreamConnection","createFn","_createFn","retryDelay","maxRetries","heartbeatTimeout","_retryCount","_closed","_heartbeatTimer","connect","_connection","_bindEvents","send","WebSocket","conn","EventSource","_handleOpen","_handleMessage","_handleError","onopen","onclose","_handleClose","_resetHeartbeat","_scheduleReconnect","_closeInternal","mergedConfig","_$log","ngViewportDirective","IntersectionObserver","enterExpr","leaveExpr","threshold","mutationObserver","ngWasmDirective","as","ngScopeDirective","ngScope","CookieService","_defaults","getObject","parseCookies","cookie","encodedKey","encodedVal","BADARG","domain","expires","expDate","toUTCString","secure","samesite","buildOptions","putObject","_lastCookieString","_lastCookieMap","part","pctEncode","allowReserved","RestService","_$http","_baseUrl","baseUrl","_entityClass","vars","sep","named","ifEmpty","varspecs","varlist","spec","conf","expandedParts","varname","explode","joined","encVal","prefixLength","expandExpression","expandUriTemplate","mapEntity","_definitions","svc","ngListenerDirective","autoReconnect","reconnectInterval","heartbeatInterval","onClose","Angular","submodule","SanitizeUriProvider","textarea","script","select","ngBind","ngBindTemplate","ngChannel","ngClass","ngClassEven","ngClassEvenDirective","ngClassOdd","ngCloak","ngController","ngDelete","ngDeleteDirective","ngDisabled","ngEl","ngFormDirective","ngGet","ngInclude","ngInject","ngListener","ngMessageExp","ngMessagesInclude","ngMessageDefault","ngMessageDefaultDirective","ngNonBindable","ngPost","ngPostDirective","ngPut","ngPutDirective","ngRepeat","ngSetter","ngStyle","ngSseDirective","ngSwitch","ngSwitchDefault","patternDirective","requiredDirective","minlengthDirective","maxlengthDirective","ngViewport","ngWasm","ngWorker","ngAnimateSwap","ngAnimateChildren","ngChecked","ngClick","ngDblclick","ngReadonly","ngSref","AnchorScrollProvider","$$animateCssDriver","$$animateJsDriver","ControllerProvider","CookieProvider","ExceptionHandlerProvider","InterpolateProvider","$httpParamSerializer","LocationProvider","ParseProvider","RestProvider","RootScopeProvider","RouterProvider","SceDelegateProvider","SseProvider","TemplateCacheProvider","$urlConfig","UrlConfigProvider","$templateFactory","$websocket","WebSocketProvider","registerNgModule","moduleRegistry","ensure","_reply","emit","CustomEvent","__reply","bootstrap","_bootsrappedModules","errorStr","init","ngAttrPrefixes","appElement","STRICT_DI","getScopeByName","once"],"mappings":"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"}