/* Version: 0.15.0 - December 14, 2025 04:42:34 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.angular = {}));
})(this, (function (exports) { 'use strict';

  const VALID_CLASS = "ng-valid";
  const INVALID_CLASS = "ng-invalid";
  const PRISTINE_CLASS = "ng-pristine";
  const DIRTY_CLASS = "ng-dirty";
  const UNTOUCHED_CLASS = "ng-untouched";
  const TOUCHED_CLASS = "ng-touched";
  const EMPTY_CLASS = "ng-empty";
  const NOT_EMPTY_CLASS = "ng-not-empty";

  // x prefix is being kept for view-directive.spec lines 1550, 565
  const PREFIX_REGEXP = /^((?:x|data)[-])/i;
  const SPECIAL_CHARS_REGEXP = /[-]+(.)/g;

  const ALIASED_ATTR = {
    ngMinlength: "minlength",
    ngMaxlength: "maxlength",
    ngMin: "min",
    ngMax: "max",
    ngPattern: "pattern",
    ngStep: "step",
  };

  /** @internal */
  /** @enum {number} */
  const NodeType = {
    _ELEMENT_NODE: Node.ELEMENT_NODE,
    _DOCUMENT_NODE: Node.DOCUMENT_NODE,
    _TEXT_NODE: Node.TEXT_NODE,
    _COMMENT_NODE: Node.COMMENT_NODE,
    _DOCUMENT_FRAGMENT_NODE: Node.DOCUMENT_FRAGMENT_NODE,
  };

  const isProxySymbol = Symbol("isProxy");

  /**
   * @param {any} value
   * @returns {value is Proxy<ng.Scope> | ng.Scope}
   */
  function isProxy(value) {
    return !!(value && value[isProxySymbol]);
  }

  /**
   * Unwraps a proxy if the value is a proxy, otherwise returns the value as-is.
   *
   * @template T
   * @param {T | (T & { $target: T })} val - A value that might be a proxy.
   * @returns {T} The unproxied value.
   */
  function deProxy(val) {
    return isProxy(val) ? /** @type {ng.Scope} */ (val).$target : val;
  }

  const ngMinErr$1 = minErr("ng");

  /**
   * @type {number}
   */
  let uid$1 = 0;

  /**
   * @returns {number} an unique alpha-numeric string
   */
  function nextUid() {
    uid$1 += 1;

    return uid$1;
  }

  /**
   *
   * @description Converts the specified string to lowercase.
   * @param {string} string String to be converted to lowercase.
   * @returns {string} Lowercased string.
   */
  function lowercase(string) {
    return isString(string) ? string.toLowerCase() : string;
  }

  /**
   *
   * @description Converts the specified string to uppercase.
   * @param {string} string String to be converted to uppercase.
   * @returns {string} Uppercased string.
   */
  function uppercase(string) {
    return isString(string) ? string.toUpperCase() : string;
  }

  /**
   * @param {unknown} obj Reference to check.
   * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,
   *                   String ...)
   */
  function isArrayLike(obj) {
    // `null`, `undefined` and `window` are not array-like
    if (isNullOrUndefined(obj) || isWindow(obj)) return false;

    // arrays, strings and jQuery/jqLite objects are array like
    // * we have to check the existence of JQLite first as this method is called
    //   via the forEach method when constructing the JQLite object in the first place
    if (isArray(obj) || obj instanceof Array || isString(obj)) return true;

    const len = /** @type {Object} */ (obj).length;

    // NodeList objects (with `item` method) and
    // other objects with suitable length characteristics are array-like
    return (
      isNumber(len) &&
      ((len >= 0 && len - 1 in /** @type {Object} */ (obj)) ||
        typeof (/** @type {Object} */ (obj).item) === "function")
    );
  }

  /**
   * Determines if a reference is undefined.
   *
   * @param {*} value Reference to check.
   * @returns {boolean} True if `value` is undefined.
   */
  function isUndefined(value) {
    return typeof value === "undefined";
  }

  /**
   * Determines if a reference is defined (not `undefined`).
   *
   * @template T
   * @param {T | undefined} value - Reference to check.
   * @returns {value is T} True if `value` is defined.
   */
  function isDefined(value) {
    return typeof value !== "undefined";
  }

  /**
   * @template T
   * @param {any} array
   * @returns {array is T[]} true if array is an Array
   */
  function isArray(array) {
    return Array.isArray(array);
  }

  /**
   * @template T
   * @param {any} val
   * @param {new (...args: any[]) => T} type  The constructor to test against
   * @returns {val is T}
   */
  function isIntanceOf(val, type) {
    return val instanceof type;
  }

  /**
   * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
   * considered to be objects. Note that JavaScript arrays are objects.
   *
   * @template T
   * @param {T} value - Reference to check.
   * @returns {value is T & object} True if `value` is an `Object` but not `null`.
   */
  function isObject(value) {
    // http://jsperf.com/isobject4
    return value !== null && typeof value === "object";
  }

  /**
   * Determines if a reference is a `string`.
   *
   * @param value - The value to check.
   * @returns {value is string} True if `value` is a string.
   */
  function isString(value) {
    return typeof value === "string";
  }

  /**
   * Determines if a reference is a null.
   *
   * @param {unknown} value Reference to check.
   * @returns {value is null} True if `value` is a null.
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Determines if a reference is null or undefined.
   *
   * @param {unknown} obj Reference to check.
   * @returns {obj is null | undefined} True if `value` is null or undefined.
   */
  function isNullOrUndefined(obj) {
    return obj === null || typeof obj === "undefined";
  }

  /**
   * Determines if a reference is not null or undefined.
   *
   * @param {*} obj Reference to check.
   * @returns {boolean} True if `value` is null or undefined.
   */
  function notNullOrUndefined(obj) {
    return !isNullOrUndefined(obj);
  }

  /**
   * Determines if a reference is a `Number`.
   *
   * This includes the "special" numbers `NaN`, `+Infinity` and `-Infinity`.
   *
   * If you wish to exclude these then you can use the native
   * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)
   * method.
   *
   * @param {unknown} value Reference to check.
   * @returns {value is number} True if `value` is a `Number`.
   */
  function isNumber(value) {
    return typeof value === "number";
  }

  /**
   *
   * Determines if a value is a date.
   *
   * @param {*} value Reference to check.
   * @returns {boolean} True if `value` is a `Date`.
   */
  function isDate(value) {
    return toString.call(value) === "[object Date]";
  }

  /**
   * Determines if a reference is an `Error`.
   * Loosely based on https://www.npmjs.com/package/iserror
   *
   * @param {*} value Reference to check.
   * @returns {value is Error} True if `value` is an `Error`.
   */
  function isError(value) {
    const tag = toString.call(value);

    switch (tag) {
      case "[object Error]":
        return true;
      case "[object Exception]":
        return true;
      case "[object DOMException]":
        return true;
      default:
        return value instanceof Error;
    }
  }

  /**
   * Determines if a reference is a `Function`.
   *
   * @param {*} value Reference to check.
   * @returns {boolean} True if `value` is a `Function`.
   */
  function isFunction(value) {
    return typeof value === "function";
  }

  /**
   * Determines if a value is a regular expression object.
   *
   * @param {*} value Reference to check.
   * @returns {boolean} True if `value` is a `RegExp`.
   */
  function isRegExp(value) {
    return toString.call(value) === "[object RegExp]";
  }

  /**
   * Checks if `obj` is a window object.
   *
   * @param {unknown} obj Object to check
   * @returns {obj is Window} True if `obj` is a window obj.
   */
  function isWindow(obj) {
    return obj && isIntanceOf(obj, Window);
  }

  /**
   * @param {*} obj
   * @returns {boolean}
   */
  function isScope(obj) {
    return obj && obj.$watch;
  }

  /**
   * @param {*} obj
   * @returns {boolean}
   */
  function isFile(obj) {
    return toString.call(obj) === "[object File]";
  }

  /**
   * @param {*} obj
   * @returns {boolean}
   */
  function isFormData(obj) {
    return toString.call(obj) === "[object FormData]";
  }

  /**
   * @param {*} obj
   * @returns {boolean}
   */
  function isBlob(obj) {
    return toString.call(obj) === "[object Blob]";
  }

  /**
   * @param {*} value
   * @returns {boolean}
   */
  function isBoolean(value) {
    return typeof value === "boolean";
  }

  /**
   * @param {*} obj
   * @returns {boolean}
   */
  function isPromiseLike(obj) {
    return obj && isFunction(obj.then);
  }

  /**
   * @param {*} value
   * @returns {string | *}
   */
  function trim(value) {
    return isString(value) ? value.trim() : value;
  }

  function snakeCase(name, separator) {
    const modseparator = separator;

    return name.replace(
      /[A-Z]/g,
      (letter, pos) => (pos ? modseparator : "") + letter.toLowerCase(),
    );
  }

  /**
   * Set or clear the hashkey for an object.
   * @param obj object
   * @param hashkey the hashkey (!truthy to delete the hashkey)
   */
  function setHashKey(obj, hashkey) {
    if (hashkey) {
      obj.$$hashKey = hashkey;
    } else {
      delete obj.$$hashKey;
    }
  }

  /**
   * Deeply extends a destination object with one or more source objects.
   * Safely handles Dates, RegExps, DOM nodes, arrays, and nested objects.
   * Ignores the `__proto__` key to prevent prototype pollution.
   *
   * @param {Object<string, any>} dst - The destination object to extend.
   * @param {Array<Object<string, any>>} objs - Array of source objects to copy properties from.
   * @param {boolean} [deep=false] - Whether to perform a deep merge of nested objects.
   * @returns {Object<string, any>} The extended destination object.
   */
  function baseExtend(dst, objs, deep = false) {
    const hasKey = dst.$$hashKey;

    for (let i = 0, ii = objs.length; i < ii; ++i) {
      const obj = objs[i];

      if (!isObject(obj) && !isFunction(obj)) continue;
      const keyList = keys(obj);

      for (let j = 0, jj = keyList.length; j < jj; j++) {
        const key = keyList[j];

        const src = obj[key];

        if (deep && isObject(src)) {
          if (isDate(src)) {
            dst[key] = new Date(src.valueOf());
          } else if (isRegExp(src)) {
            dst[key] = new RegExp(src);
          } else if (src.nodeName) {
            dst[key] = src.cloneNode(true);
          } else if (key !== "__proto__") {
            if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
            baseExtend(dst[key], [src], true);
          }
        } else {
          dst[key] = src;
        }
      }
    }

    setHashKey(dst, hasKey);

    return dst;
  }

  /**
   * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
   * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
   * by passing an empty object as the target: `let object = angular.extend({}, object1, object2)`.
   *
   * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy).
   *
   * @param {Object} dst Destination object.
   * @param {...Object} src Source object(s).
   * @returns {Object} Reference to `dst`.
   */
  function extend(dst, ...src) {
    return baseExtend(dst, src, false);
  }

  /**
   * @param {any} num
   * @returns {boolean}
   */
  function isNumberNaN(num) {
    return Number.isNaN(num);
  }

  /**
   * @param {Object} parent
   * @param {Object} extra
   * @returns {Object}
   */
  function inherit$1(parent, extra) {
    return extend(Object.create(parent), extra);
  }

  function hasCustomToString(obj) {
    return isFunction(obj.toString) && obj.toString !== toString;
  }

  /**
   * Returns a string appropriate for the type of node.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Node/nodeName)
   *
   * @param {Element} element
   * @returns
   */
  function getNodeName(element) {
    return lowercase(element.nodeName);
  }

  function includes(array, obj) {
    return Array.prototype.indexOf.call(array, obj) !== -1;
  }

  /**
   * Removes the first occurrence of a specified value from an array.
   *
   * @template T
   * @param {Array<T>} array - The array from which to remove the value.
   * @param {T} value - The value to remove.
   * @returns {number} - The index of the removed value, or -1 if the value was not found.
   */
  function arrayRemove(array, value) {
    const index = array.indexOf(value);

    if (index >= 0) {
      array.splice(index, 1);
    }

    return index;
  }

  function simpleCompare(val1, val2) {
    return val1 === val2 || (Number.isNaN(val1) && Number.isNaN(val2));
  }

  /**
   * Determines if two objects or two values are equivalent. Supports value types, regular
   * expressions, arrays and objects.
   *
   * Two objects or values are considered equivalent if at least one of the following is true:
   *
   * * Both objects or values pass `===` comparison.
   * * Both objects or values are of the same type and all of their properties are equal by
   *   comparing them with `angular.equals`.
   * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)
   * * Both values represent the same regular expression (In JavaScript,
   *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual
   *   representation matches).
   *
   * During a property comparison, properties of `function` type and properties with names
   * that begin with `$` are ignored.
   *
   * Scope and DOMWindow objects are being compared only by identify (`===`).
   *
   * @param {*} o1 Object or value to compare.
   * @param {*} o2 Object or value to compare.
   * @returns {boolean} True if arguments are equal.
   *
   * @example
     <example module="equalsExample" name="equalsExample">
       <file name="index.html">
        <div ng-controller="ExampleController">
          <form novalidate>
            <h3>User 1</h3>
            Name: <input type="text" ng-model="user1.name">
            Age: <input type="number" ng-model="user1.age">

            <h3>User 2</h3>
            Name: <input type="text" ng-model="user2.name">
            Age: <input type="number" ng-model="user2.age">

            <div>
              <br/>
              <input type="button" value="Compare" ng-click="compare()">
            </div>
            User 1: <pre>{{user1 | json}}</pre>
            User 2: <pre>{{user2 | json}}</pre>
            Equal: <pre>{{result}}</pre>
          </form>
        </div>
      </file>
      <file name="script.js">
          angular.module('equalsExample', []).controller('ExampleController', ['$scope', function($scope) {
            $scope.user1 = {};
            $scope.user2 = {};
            $scope.compare = function() {
              $scope.result = angular.equals($scope.user1, $scope.user2);
            };
          }]);
      </file>
    </example>
   */
  function equals$1(o1, o2) {
    if (o1 === o2) return true;

    if (o1 === null || o2 === null) return false;

    if (Number.isNaN(o1) && Number.isNaN(o2)) return true; // NaN === NaN

    const t1 = typeof o1;

    const t2 = typeof o2;

    if (t1 !== t2 || t1 !== "object") return false;

    // Handle arrays
    if (isArray(o1)) {
      if (!isArray(o2)) return false;

      const { length } = o1;

      if (length !== o2.length) return false;

      for (let key = 0; key < length; key++) {
        if (!equals$1(o1[key], o2[key])) return false;
      }

      return true;
    }

    // Handle Dates
    if (isDate(o1)) {
      if (!isDate(o2)) return false;

      return simpleCompare(o1.getTime(), o2.getTime());
    }

    // Handle RegExps
    if (isRegExp(o1)) {
      if (!isRegExp(o2)) return false;

      return o1.toString() === o2.toString();
    }

    // Reject unsafe objects
    if (
      isScope(o1) ||
      isScope(o2) ||
      isWindow(o1) ||
      isWindow(o2) ||
      isArray(o2) ||
      isDate(o2) ||
      isRegExp(o2)
    )
      return false;

    // Handle general objects
    const keySet = Object.create(null);

    for (const key in o1) {
      if (key.charAt(0) === "$" || isFunction(o1[key])) continue;

      if (!equals$1(o1[key], o2[key])) return false;
      keySet[key] = true;
    }

    for (const key in o2) {
      if (
        !(key in keySet) &&
        key.charAt(0) !== "$" &&
        isDefined(o2[key]) &&
        !isFunction(o2[key])
      ) {
        return false;
      }
    }

    return true;
  }

  /**
   * throw error if the name given is hasOwnProperty
   * @param  {string} name    the name to test
   * @param  {string} context the context in which the name is used, such as module or directive
   */
  function assertNotHasOwnProperty(name, context) {
    if (name === "hasOwnProperty") {
      throw ngMinErr$1(
        "badname",
        "hasOwnProperty is not a valid {0} name",
        context,
      );
    }
  }

  function stringify$1(value) {
    if (isNull(value) || isUndefined(value)) {
      return "";
    }
    switch (typeof value) {
      case "string":
        break;
      case "number":
        value = `${value}`;
        break;
      default:
        if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {
          value = value.toString();
        } else {
          value = toJson(value);
        }
    }

    return value;
  }

  /**
   * @param {Number} maxDepth
   * @return {boolean}
   */
  function isValidObjectMaxDepth(maxDepth) {
    return isNumber(maxDepth) && maxDepth > 0;
  }

  function concat(array1, array2, index) {
    return array1.concat(Array.prototype.slice.call(array2, index));
  }

  function sliceArgs(args, startIndex) {
    return Array.prototype.slice.call(args, startIndex);
  }

  /**
   * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
   * `fn`). You can supply optional `args` that are prebound to the function. This feature is also
   * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as
   * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).
   *
   * @param {Object} context Context which `fn` should be evaluated in.
   * @param {*} fn Function to be bound.
   * @returns {Function} Function that wraps the `fn` with all the specified bindings.
   */
  function bind(context, fn) {
    const curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];

    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length
        ? function () {
            return arguments.length
              ? fn.apply(context, concat(curryArgs, arguments, 0))
              : fn.apply(context, curryArgs);
          }
        : function () {
            return arguments.length
              ? fn.apply(context, arguments)
              : fn.call(context);
          };
    }

    // In IE, native methods are not functions so they cannot be bound (note: they don't need to be).
    return fn;
  }

  function toJsonReplacer(key, value) {
    let val = value;

    if (
      typeof key === "string" &&
      key.charAt(0) === "$" &&
      key.charAt(1) === "$"
    ) {
      val = undefined;
    } else if (isWindow(value)) {
      val = "$WINDOW";
    } else if (value && window.document === value) {
      val = "$DOCUMENT";
    } else if (isScope(value)) {
      val = "$SCOPE";
    }

    return val;
  }

  /**
   * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be
   * stripped since AngularTS uses this notation internally.
   *
   * @param {Object|Array|Date|string|number|boolean} obj Input to be serialized into JSON.
   * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.
   *    If set to an integer, the JSON output will contain that many spaces per indentation.
   * @returns {string|undefined} JSON-ified string representing `obj`.
   * @knownIssue
   *
   * The Safari browser throws a `RangeError` instead of returning `null` when it tries to stringify a `Date`
   * object with an invalid date value. The only reliable way to prevent this is to monkeypatch the
   * `Date.prototype.toJSON` method as follows:
   *
   * ```
   * let _DatetoJSON = Date.prototype.toJSON;
   * Date.prototype.toJSON = function() {
   *   try {
   *     return _DatetoJSON.call(this);
   *   } catch(e) {
   *     if (e instanceof RangeError) {
   *       return null;
   *     }
   *     throw e;
   *   }
   * };
   * ```
   *
   * See https://github.com/angular/angular.js/pull/14221 for more information.
   */
  function toJson(obj, pretty) {
    if (isUndefined(obj)) return undefined;

    if (!isNumber(pretty)) {
      pretty = pretty ? 2 : null;
    }

    return JSON.stringify(obj, toJsonReplacer, /** @type {Number} */ (pretty));
  }

  /**
   * Deserializes a JSON string.
   *
   * @param {string} json JSON string to deserialize.
   * @returns {Object|Array|string|number} Deserialized JSON string.
   */
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }

  const MS_PER_MINUTE = 60_000; // 60,000 ms in a minute

  function timezoneToOffset(timezone, fallback) {
    const requestedTimezoneOffset =
      Date.parse(`Jan 01, 1970 00:00:00 ${timezone}`) / MS_PER_MINUTE;

    return isNumberNaN(requestedTimezoneOffset)
      ? fallback
      : requestedTimezoneOffset;
  }

  function addDateMinutes(date, minutes) {
    const newDate = new Date(date.getTime());

    newDate.setMinutes(newDate.getMinutes() + minutes);

    return newDate;
  }

  function convertTimezoneToLocal(date, timezone, reverse) {
    const doReverse = 1;

    const dateTimezoneOffset = date.getTimezoneOffset();

    const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);

    return addDateMinutes(
      date,
      doReverse * (timezoneOffset - dateTimezoneOffset),
    );
  }

  /**
   * Parses an escaped url query string into key-value pairs.
   * @param {string} keyValue
   * @returns {Object.<string,boolean|Array>}
   */
  function parseKeyValue(keyValue) {
    const obj = {};

    (keyValue || "").split("&").forEach((item) => {
      let splitPoint;

      let key;

      let val;

      if (item) {
        key = keyValue = item.replace(/\+/g, "%20");
        splitPoint = item.indexOf("=");

        if (splitPoint !== -1) {
          key = item.substring(0, splitPoint);
          val = item.substring(splitPoint + 1);
        }
        key = tryDecodeURIComponent(key);

        if (isDefined(key)) {
          val = isDefined(val) ? tryDecodeURIComponent(val) : true;

          if (!hasOwn(obj, /** @type {string} */ (key))) {
            obj[key] = val;
          } else if (isArray(obj[key])) {
            obj[key].push(val);
          } else {
            obj[key] = [obj[key], val];
          }
        }
      }
    });

    return /** @type {Object.<string,boolean|Array>} */ (obj);
  }

  function toKeyValue(obj) {
    const parts = [];

    obj &&
      entries(obj).forEach(([key, value]) => {
        if (isArray(value)) {
          value.forEach((arrayValue) => {
            parts.push(
              encodeUriQuery(key, true) +
                (arrayValue === true
                  ? ""
                  : `=${encodeUriQuery(arrayValue, true)}`),
            );
          });
        } else {
          parts.push(
            encodeUriQuery(key, true) +
              (value === true ? "" : `=${encodeUriQuery(value, true)}`),
          );
        }
      });

    return parts.length ? parts.join("&") : "";
  }

  /**
   * Tries to decode the URI component without throwing an exception.
   *
   * @param  {string} value potential URI component to check.
   * @returns {string|undefined}
   */
  function tryDecodeURIComponent(value) {
    try {
      return decodeURIComponent(value);
    } catch {
      return undefined;
    }
  }

  /**
   * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
   * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
   * segments:
   *    segment       = *pchar
   *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
   *    pct-encoded   = "%" HEXDIG HEXDIG
   *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
   *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
   *                     / "*" / "+" / "," / ";" / "="
   * @param {string} val
   */
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true)
      .replace(/%26/gi, "&")
      .replace(/%3D/gi, "=")
      .replace(/%2B/gi, "+");
  }

  /**
   * This method is intended for encoding *key* or *value* parts of query component. We need a custom
   * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
   * encoded per http://tools.ietf.org/html/rfc3986:
   *    query         = *( pchar / "/" / "?" )
   *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
   *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
   *    pct-encoded   = "%" HEXDIG HEXDIG
   *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
   *                     / "*" / "+" / "," / ";" / "="
   */
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val)
      .replace(/%40/gi, "@")
      .replace(/%3A/gi, ":")
      .replace(/%24/g, "$")
      .replace(/%2C/gi, ",")
      .replace(/%3B/gi, ";")
      .replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
  }

  const ngAttrPrefixes = ["ng-", "data-ng-"];

  /**
   * Creates a shallow copy of an object, an array or a primitive.
   *
   * Assumes that there are no proto properties for objects.
   */
  function shallowCopy(src, dst) {
    if (isArray(src)) {
      dst = dst || [];

      for (let i = 0, ii = src.length; i < ii; i++) {
        dst[i] = src[i];
      }
    } else if (isObject(src)) {
      dst = dst || {};

      for (const key in src) {
        if (!(key.startsWith("$") && key.charAt(1) === "$")) {
          dst[key] = src[key];
        }
      }
    }

    return dst || src;
  }

  /**
   * Throw error if the argument is false
   * @param {boolean} argument
   * @param {string} errorMsg
   */
  function assert(argument, errorMsg = "Assertion failed") {
    if (!argument) {
      throw new Error(errorMsg);
    }
  }

  /**
   * Throw error if the argument is falsy.
   */
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw ngMinErr$1(
        "areq",
        "Argument '{0}' is {1}",
        name || "?",
        reason || "required",
      );
    }

    return arg;
  }

  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }

    assertArg(
      isFunction(arg),
      name,
      `not a function, got ${
      arg && typeof arg === "object"
        ? arg.constructor.name || "Object"
        : typeof arg
    }`,
    );

    return arg;
  }

  /** @type {ng.ErrorHandlingConfig} */
  const minErrConfig = {
    objectMaxDepth: 5,
    urlErrorParamsEnabled: true,
  };

  /**
   * Configure several aspects of error handling if used as a setter or return the
   * current configuration if used as a getter.
   *
   * Omitted or undefined options will leave the corresponding configuration values unchanged.
   *
   * @param {ng.ErrorHandlingConfig} [config]
   * @returns {ng.ErrorHandlingConfig}
   */
  function errorHandlingConfig(config) {
    if (isObject(config)) {
      if (isDefined(config.objectMaxDepth)) {
        minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth)
          ? config.objectMaxDepth
          : NaN;
      }

      if (
        isDefined(config.urlErrorParamsEnabled) &&
        isBoolean(config.urlErrorParamsEnabled)
      ) {
        minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled;
      }
    }

    return minErrConfig;
  }

  /**
   * This object provides a utility for producing rich Error messages within
   * AngularTS. It can be called as follows:
   *
   * let exampleMinErr = minErr('example');
   * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);
   *
   * The above creates an instance of minErr in the example namespace. The
   * resulting error will have a namespaced error code of example.one.  The
   * resulting error will replace {0} with the value of foo, and {1} with the
   * value of bar. The object is not restricted in the number of arguments it can
   * take.
   *
   * If fewer arguments are specified than necessary for interpolation, the extra
   * interpolation markers will be preserved in the final string.
   *
   * Since data will be parsed statically during a build step, some restrictions
   * are applied with respect to how minErr instances are created and called.
   * Instances should have names of the form namespaceMinErr for a minErr created
   * using minErr('namespace'). Error codes, namespaces and template strings
   * should all be static strings, not variables or general expressions.
   *
   * @param {string} module The namespace to use for the new minErr instance.
   * @returns {function(string, ...*): Error} minErr instance
   */
  function minErr(module) {
    return function (...args) {
      const code = args[0];

      const template = args[1];

      let message = `[${module ? `${module}:` : ""}${code}] `;

      const templateArgs = sliceArgs(args, 2).map((arg) => toDebugString(arg));

      message += template.replace(/\{\d+\}/g, (match) => {
        const index = +match.slice(1, -1);

        if (index < templateArgs.length) {
          return templateArgs[index];
        }

        return match;
      });

      return new Error(message);
    };
  }

  /**
   * Converts a value into a simplified debug-friendly string.
   *
   * @template T
   * @param {T|ng.Scope} obj
   * @returns {string}
   */
  function toDebugString(obj) {
    if (typeof obj === "function") {
      return obj.toString().replace(/ \{[\s\S]*$/, "");
    }

    if (isUndefined(obj)) {
      return "undefined";
    }

    if (typeof obj !== "string") {
      /** @type {object[]} */
      const seen = [];

      const copyObj = structuredClone(
        isProxy(obj) ? /** @type {ng.Scope} */ (obj).$target : obj,
      );

      return JSON.stringify(copyObj, (key, val) => {
        const replace = toJsonReplacer(key, val);

        if (isObject(replace)) {
          if (seen.indexOf(replace) >= 0) return "...";

          seen.push(replace);
        }

        return replace;
      });
    }

    return obj;
  }

  /**
   * Computes a hash of an 'obj'.
   * Hash of a:
   *  string is string
   *  number is number as string
   *  object is either result of calling $$hashKey function on the object or uniquely generated id,
   *         that is also assigned to the $$hashKey property of the object.
   *
   * @param {*} obj
   * @returns {string} hash string such that the same input will have the same hash string.
   *         The resulting string key is in 'type:hashKey' format.
   */
  function hashKey(obj) {
    const key = obj && obj.$$hashKey;

    if (key) {
      if (typeof key === "function") {
        return obj.$$hashKey();
      }

      return key;
    }

    const objType = typeof obj;

    if (objType === "function" || (objType === "object" && obj !== null)) {
      obj.$$hashKey = `${objType}:${nextUid()}`;

      return obj.$$hashKey;
    }

    if (objType === "undefined") {
      return `${objType}:${nextUid()}`;
    }

    // account for primitives
    return `${objType}:${obj}`;
  }

  /**
   * Merges two class name values into a single space-separated string.
   * Accepts strings, arrays of strings, or null/undefined values.
   *
   * @param {string | string[] | null | undefined} firstClass - The first class name(s).
   * @param {string | string[] | null | undefined} secondClass - The second class name(s).
   * @returns {string} A single string containing all class names separated by spaces.
   */
  function mergeClasses(firstClass, secondClass) {
    if (!firstClass && !secondClass) return "";

    if (!firstClass)
      // @ts-ignore
      return isArray(secondClass) ? secondClass.join(" ").trim() : secondClass;

    if (!secondClass)
      // @ts-ignore
      return isArray(firstClass) ? firstClass.join(" ").trim() : firstClass;

    // @ts-ignore
    if (isArray(firstClass)) firstClass = normalizeStringArray(firstClass);

    // @ts-ignore
    if (isArray(secondClass)) secondClass = normalizeStringArray(secondClass);

    // @ts-ignore
    return `${firstClass.trim()} ${secondClass.trim()}`.trim();
  }

  /**
   * Joins an array of strings into a single string, trimming each
   * element and ignoring empty strings, null, and undefined
   * @param {any[]} arr
   * @returns {string}
   */
  function normalizeStringArray(arr) {
    const cleaned = [];

    for (const item of arr) {
      if (item) {
        const trimmed = item.trim();

        if (trimmed) cleaned.push(trimmed);
      }
    }

    return cleaned.join(" ");
  }

  /**
   * Converts all accepted directives format into proper directive name.
   * @param {string} name Name to normalize
   * @returns {string}
   */

  function directiveNormalize(name) {
    return name
      .replace(PREFIX_REGEXP, "")
      .replace(SPECIAL_CHARS_REGEXP, (_name, letter, offset) =>
        offset ? letter.toUpperCase() : letter,
      );
  }

  /**
   * Whether element should be animated
   * @param {Node} node
   * @returns {boolean}
   */
  function hasAnimate(node) {
    return hasCustomOrDataAttribute(node, "animate");
  }

  /**
   * @param {Node} node
   * @param {string} attr
   * @returns {boolean}
   */
  function hasCustomOrDataAttribute(node, attr) {
    if (node.nodeType !== NodeType._ELEMENT_NODE) return false;
    const element = /** @type {HTMLElement} */ (node);

    return (
      element.dataset[attr] === "true" || element.getAttribute(attr) === "true"
    );
  }

  /**
   * @param {Object|null|undefined} obj
   * @returns {boolean}
   */
  function isObjectEmpty(obj) {
    if (!obj) return true;

    return !keys(obj).length;
  }

  /**
   * Checks whether the given object has the specified property as its own (not inherited).
   *
   * This is a safe version of `hasOwnProperty` that avoids issues with objects
   * that have it overridden or missing from their prototype chain.
   *
   * @param {object} obj - The object to check.
   * @param {string|number|symbol} key - The property key to look for.
   * @returns {boolean} True if the object has the property as its own; otherwise, false.
   *
   * @example
   * hasOwn({ foo: 123 }, 'foo'); // true
   * hasOwn({}, 'bar'); // false
   */
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  /**
   * @param {Object} obj
   * @returns {string[]}
   */
  function keys(obj) {
    return Object.keys(obj);
  }

  /**
   * @template T
   * @param {{ [s: string]: T; } | ArrayLike<T>} obj
   * @returns {[string, T][]}
   */
  function entries(obj) {
    return Object.entries(obj);
  }

  /**
   * Wraps a function so it can only be called once.
   * Subsequent calls do nothing and return undefined.
   *
   * @template {(...args: any[]) => any} F
   * @param {F} fn - The function to wrap.
   * @returns {(this: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F> | undefined}
   */
  function callBackOnce(fn) {
    let called = false;

    return (...args) => {
      if (!called) {
        called = true;

        return fn(...args);
      }

      return undefined; // satisfies consistent-return
    };
  }

  /**
   * Wraps a function so it will only be called starting from the second invocation.
   * The first call does nothing and returns undefined.
   *
   * @template {(...args: any[]) => any} F
   * @param {F} fn - The function to wrap.
   * @returns {(this: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F> | undefined}
   */
  function callBackAfterFirst(fn) {
    let calledOnce = false;

    return (...args) => {
      if (calledOnce) {
        return fn(...args);
      }
      calledOnce = true;

      return undefined;
    };
  }

  /**
   * Delays execution for a specified number of milliseconds.
   *
   * @param {number} [timeout=0] - The number of milliseconds to wait. Defaults to 0.
   * @returns {Promise<void>} A promise that resolves after the delay.
   */
  function wait(timeout = 0) {
    return new Promise((resolve) => setTimeout(resolve, timeout));
  }

  /**
   * Checks if a given string starts with a specified substring.
   *
   * This is a simple polyfill-like function that mimics the behavior of
   * `String.prototype.startsWith` without using the built-in method.
   *
   * @param {string} str - The full string to evaluate.
   * @param {string} search - The substring to test against the beginning of `str`.
   * @returns {boolean} `true` if `str` starts with `search`, otherwise `false`.
   *
   * @example
   * startsWith("hello world", "hello");
   * // returns true
   *
   * @example
   * startsWith("hello world", "world");
   * // returns false
   *
   * @example
   * startsWith("test", "");
   * // returns true (empty search string always matches)
   *
   * @example
   * startsWith("abc", "abcd");
   * // returns false
   */
  function startsWith(str, search) {
    return str.slice(0, search.length) === search;
  }

  /**
   * Loads and instantiates a WebAssembly module.
   * Tries streaming first, then falls back.
   * @param {string} src
   * @param {WebAssembly.Imports} imports
   */
  async function instantiateWasm(src, imports = {}) {
    const res = await fetch(src);

    if (!res.ok) throw new Error("fetch failed");

    try {
      const { instance, module } = await WebAssembly.instantiateStreaming(
        res.clone(),
        imports,
      );

      return { instance, exports: instance.exports, module };
    } catch {
      /* empty */
    }

    const bytes = await res.arrayBuffer();

    const { instance, module } = await WebAssembly.instantiate(bytes, imports);

    return { instance, exports: instance.exports, module };
  }

  /**
   * @param {*} fn
   * @returns {boolean}
   */
  function isArrowFunction(fn) {
    return typeof fn === "function" && !fn.prototype;
  }

  /**
   * Expando cache for adding properties to DOM nodes with JavaScript.
   * This used to be an Object in JQLite decorator, but swapped out for a Map
   *
   * @type {Map<number, import('../interface.ts').ExpandoStore>}
   */
  const Cache = new Map();

  const ADD_CLASS_SUFFIX = "-add";
  const REMOVE_CLASS_SUFFIX = "-remove";
  const EVENT_CLASS_PREFIX = "ng-";
  const ACTIVE_CLASS_SUFFIX = "-active";
  const PREPARE_CLASS_SUFFIX = "-prepare";

  const NG_ANIMATE_CLASSNAME = "ng-animate";
  const NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren";

  function packageStyles(options) {
    const styles = {};

    if (options && (options.to || options.from)) {
      styles.to = options.to;
      styles.from = options.from;
    }

    return styles;
  }

  function pendClasses(classes, fix, isPrefix) {
    let className = "";

    classes = isArray(classes)
      ? classes
      : classes && isString(classes) && classes.length
        ? classes.split(/\s+/)
        : [];
    classes.forEach((klass, i) => {
      if (klass && klass.length > 0) {
        className += i > 0 ? " " : "";
        className += isPrefix ? fix + klass : klass + fix;
      }
    });

    return className;
  }

  function removeFromArray(arr, val) {
    const index = arr.indexOf(val);

    if (val >= 0) {
      arr.splice(index, 1);
    }
  }

  /**
   *
   * @param {NodeList|Node} element
   * @returns {Node[]|Node|undefined}
   */
  function stripCommentsFromElement(element) {
    if (element instanceof NodeList) {
      return Array.from(element).filter(
        (x) => x.nodeType === NodeType._ELEMENT_NODE,
      );
    } else if (element.nodeType === NodeType._ELEMENT_NODE) {
      return /** @type {Node} */ (element);
    } else {
      return undefined;
    }
  }

  /**
   * @param {NodeList|Node} element
   * @returns {Node}
   */
  function extractElementNode(element) {
    if (!element || !isArray(element)) return /** @type {Node} */ (element);

    for (let i = 0; i < /** @type {NodeList} */ (element).length; i++) {
      const elm = element[i];

      if (elm.nodeType === NodeType._ELEMENT_NODE) {
        return elm;
      }
    }

    return undefined; // TODO mayb throw?
  }

  function applyAnimationClassesFactory() {
    return function (element, options) {
      if (options.addClass) {
        element.classList.add(...options.addClass.trim().split(" "));
        options.addClass = null;
      }

      if (options.removeClass) {
        element.classList.remove(...options.removeClass.trim().split(" "));
        options.removeClass = null;
      }
    };
  }

  function prepareAnimationOptions(options) {
    options = options || {};

    if (!options.$$prepared) {
      let domOperation =
        options.domOperation ||
        (() => {
          /* empty */
        });

      options.domOperation = function () {
        options.$$domOperationFired = true;
        domOperation();
        domOperation = () => {
          /* empty */
        };
      };
      options.$$prepared = true;
    }

    return options;
  }

  function applyAnimationStyles(element, options) {
    applyAnimationFromStyles(element, options);
    applyAnimationToStyles(element, options);
  }

  /**
   * Applies initial animation styles to a DOM element.
   *
   * This function sets the element's inline styles using the properties
   * defined in `options.from`, then clears the property to prevent reuse.
   *
   * @param {HTMLElement} element - The target DOM element to apply styles to.
   * @param {{ from?: Partial<CSSStyleDeclaration> | null }} options - options containing a `from` object with CSS property–value pairs.
   */
  function applyAnimationFromStyles(element, options) {
    if (options.from) {
      Object.assign(element.style, options.from);
      options.from = null;
    }
  }

  /**
   * Applies final animation styles to a DOM element.
   *
   * This function sets the element's inline styles using the properties
   * defined in `options.to`, then clears the property to prevent reuse.
   *
   * @param {HTMLElement} element - The target DOM element to apply styles to.
   * @param {{ to?: Partial<CSSStyleDeclaration> | null }} options - options containing a `from` object with CSS property–value pairs.
   */
  function applyAnimationToStyles(element, options) {
    if (options.to) {
      Object.assign(element.style, options.to);
      options.to = null;
    }
  }

  function mergeAnimationDetails(element, oldAnimation, newAnimation) {
    const target = oldAnimation.options || {};

    const newOptions = newAnimation.options || {};

    const toAdd = `${target.addClass || ""} ${newOptions.addClass || ""}`;

    const toRemove = `${target.removeClass || ""} ${newOptions.removeClass || ""}`;

    const classes = resolveElementClasses(
      element.getAttribute("class"),
      toAdd,
      toRemove,
    );

    if (newOptions.preparationClasses) {
      target.preparationClasses = concatWithSpace(
        newOptions.preparationClasses,
        target.preparationClasses,
      );
      delete newOptions.preparationClasses;
    }

    extend(target, newOptions);

    if (classes.addClass) {
      target.addClass = classes.addClass;
    } else {
      target.addClass = null;
    }

    if (classes.removeClass) {
      target.removeClass = classes.removeClass;
    } else {
      target.removeClass = null;
    }

    oldAnimation.addClass = target.addClass;
    oldAnimation.removeClass = target.removeClass;

    return target;
  }

  function resolveElementClasses(existing, toAdd, toRemove) {
    const ADD_CLASS = 1;

    const REMOVE_CLASS = -1;

    const flags = {};

    existing = splitClassesToLookup(existing);

    toAdd = splitClassesToLookup(toAdd);
    Object.keys(toAdd).forEach((key) => {
      flags[key] = ADD_CLASS;
    });

    toRemove = splitClassesToLookup(toRemove);
    keys(toRemove).forEach((key) => {
      flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
    });

    const classes = {
      addClass: "",
      removeClass: "",
    };

    entries(flags).forEach(([klass, val]) => {
      let prop, allow;

      if (val === ADD_CLASS) {
        prop = "addClass";
        allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
      } else if (val === REMOVE_CLASS) {
        prop = "removeClass";
        allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
      }

      if (allow) {
        if (classes[prop].length) {
          classes[prop] += " ";
        }
        classes[prop] += klass;
      }
    });

    function splitClassesToLookup(cls) {
      if (isString(cls)) {
        cls = cls.trim().split(" ");
      }

      const obj = {};

      if (cls) {
        cls.forEach((klass) => {
          // sometimes the split leaves empty string values
          // incase extra spaces were applied to the options
          if (klass.length) {
            obj[klass] = true;
          }
        });
      }

      return obj;
    }

    return classes;
  }

  function applyGeneratedPreparationClasses(element, event, options) {
    let classes = "";

    if (event) {
      classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
    }

    if (options.addClass) {
      classes = concatWithSpace(
        classes,
        pendClasses(options.addClass, ADD_CLASS_SUFFIX),
      );
    }

    if (options.removeClass) {
      classes = concatWithSpace(
        classes,
        pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX),
      );
    }

    if (classes.length) {
      options.preparationClasses = classes;
      element.className += ` ${classes}`;
    }
  }

  function clearGeneratedClasses(element, options) {
    if (options.preparationClasses) {
      options.preparationClasses
        .split(" ")
        .forEach((cls) => element.classList.remove(cls));
      options.preparationClasses = null;
    }

    if (options.activeClasses) {
      options.activeClasses
        .split(" ")
        .forEach((cls) => element.classList.remove(cls));
      options.activeClasses = null;
    }
  }

  function blockKeyframeAnimations(node, applyBlock) {
    const value = applyBlock ? "paused" : "";

    const key = `animationPlayState`;

    applyInlineStyle(node, [key, value]);

    return [key, value];
  }

  function applyInlineStyle(node, styleTuple) {
    const prop = styleTuple[0];

    node.style[prop] = styleTuple[1];
  }

  function concatWithSpace(a, b) {
    if (!a) return b;

    if (!b) return a;

    return `${a} ${b}`;
  }

  /**
   * A helper list of tokens matching the standard injectables that come predefined in the core `ng` module.
   * These string tokens are commonly injected into services, directives, or components via `$inject`.
   *
   * Example:
   * ```js
   *
   * myDirective.$inject = [
   *   angular.$t.$animate,
   *   angular.$t.$templateRequest,
   * ];
   *
   * function myDirective($animate, $templateRequest) { ... }
   *
   * ```
   * @private
   * @type Readonly<Record<string, string>>
   */
  const $injectTokens = {
    _angular: "$angular",
    _attrs: "$attrs",
    _scope: "$scope",
    _element: "$element",
    _animateCache: "$$animateCache",
    _animateCssDriver: "$$animateCssDriver",
    _animateJs: "$$animateJs",
    _animateJsDriver: "$$animateJsDriver",
    _animateQueue: "$$animateQueue",
    _animation: "$$animation",
    _rAFScheduler: "$$rAFScheduler",
    _taskTrackerFactory: "$$taskTrackerFactory",
    _anchorScroll: "$anchorScroll",
    _animate: "$animate",
    _animateCss: "$animateCss",
    _aria: "$aria",
    _compile: "$compile",
    _cookie: "$cookie",
    _controller: "$controller",
    _document: "$document",
    _eventBus: "$eventBus",
    _exceptionHandler: "$exceptionHandler",
    _filter: "$filter",
    _http: "$http",
    _httpParamSerializer: "$httpParamSerializer",
    _interpolate: "$interpolate",
    _location: "$location",
    _log: "$log",
    _viewScroll: "$viewScroll",
    _parse: "$parse",
    _rest: "$rest",
    _rootScope: "$rootScope",
    _rootElement: "$rootElement",
    _router: "$router",
    _sce: "$sce",
    _sceDelegate: "$sceDelegate",
    _state: "$state",
    _stateRegistry: "$stateRegistry",
    _sse: "$sse",
    _sanitizeUri: "$$sanitizeUri",
    _sanitizeUriProvider: "$$sanitizeUriProvider",
    _templateCache: "$templateCache",
    _templateFactory: "$templateFactory",
    _templateRequest: "$templateRequest",
    _transitions: "$transitions",
    _urlConfig: "$urlConfig",
    _url: "$url",
    _view: "$view",
    _window: "$window",
    // provide literals
    _provide: "$provide",
    _injector: "$injector",
    _compileProvider: "$compileProvider",
    _animateProvider: "$animateProvider",
    _filterProvider: "$filterProvider",
    _controllerProvider: "$controllerProvider",
  };

  /**
   * Utility for mapping to service-names to providers
   * @param {String[]} services
   */
  function provider(services) {
    return services.map((x) => `${x}Provider`);
  }

  /** @type {number} */
  let elId = 1;

  /**
   * Key for storing isolate scope data, attached to an element
   */
  const ISOLATE_SCOPE_KEY = "$isolateScope";

  const EXPANDO = "ng";

  /**
   * Key for storing scope data, attached to an element
   */
  const SCOPE_KEY = "$scope";

  const DASH_LOWERCASE_REGEXP = /-([a-z])/g;

  const UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;

  /**
   * A list of boolean attributes in HTML.
   * @type {string[]}
   */
  const BOOLEAN_ATTR = [
    "multiple",
    "selected",
    "checked",
    "disabled",
    "readonly",
    "required",
    "open",
  ];

  /**
   * A list of boolean attributes in HTML
   * @type {string[]}
   */
  const BOOLEAN_ELEMENTS = [
    "INPUT",
    "SELECT",
    "OPTION",
    "TEXTAREA",
    "BUTTON",
    "FORM",
    "DETAILS",
  ];

  ///////////////////////////////////////////////////////////////////
  ////////////        HELPER FUNCTIONS      /////////////////////////
  ///////////////////////////////////////////////////////////////////

  /**
   *
   * @returns {number} Next unique JQInstance id
   */
  function elemNextId() {
    return ++elId;
  }

  /**
   * @param {string} _all
   * @param {string} letter
   * @returns {string}
   */
  function fnCamelCaseReplace(_all, letter) {
    return letter.toUpperCase();
  }

  /**
   * Converts kebab-case to camelCase.
   * @param {string} name Name to normalize
   * @returns {string}
   */
  function kebabToCamel(name) {
    return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
  }

  /**
   * Converts sname to camelCase.
   * @param {string} name
   * @returns {string}
   */
  function snakeToCamel(name) {
    return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
  }

  /**
   * Removes expando data from this element. If key is provided, only
   * its field is removed. If data is empty, also removes `ExpandoStore`
   * from cache.
   * @param {Element} element
   * @param {string} [name] - key of field to remove
   */
  function removeElementData(element, name) {
    const expandoId = element[EXPANDO];

    const expandoStore = expandoId && Cache.get(expandoId);

    if (expandoStore) {
      if (name) {
        delete expandoStore.data[name];
      } else {
        expandoStore.data = {};
      }

      removeIfEmptyData(element);
    }
  }

  /**
   * Stores data associated with an element inside the expando property of the DOM element.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Glossary/Expando MDN Glossary: Expando}
   *
   * @param {Element} element
   * @param {boolean} [createIfNecessary=false]
   * @returns {import("../interface.ts").ExpandoStore}
   */
  function getExpando(element, createIfNecessary = false) {
    let expandoId = element[EXPANDO];

    let expandoStore = expandoId && Cache.get(expandoId);

    if (createIfNecessary && !expandoStore) {
      element[EXPANDO] = expandoId = elemNextId();
      expandoStore = {
        data: {},
      };
      Cache.set(expandoId, expandoStore);
    }

    return expandoStore;
  }

  /**
   * Checks if the string contains HTML tags or entities.
   * @param {string} html
   * @returns {boolean} True if the string is plain text, false if it contains HTML tags or entities.
   */
  function isTextNode(html) {
    return !/<|&#?\w+;/.test(html);
  }

  /**
   * Check if element can accept expando data
   * @param {Element|Node} node
   * @returns {boolean}
   */
  function elementAcceptsData(node) {
    // The window object can accept data but has no nodeType
    // Otherwise we are only interested in elements (1) and documents (9)
    switch (node.nodeType) {
      case NodeType._ELEMENT_NODE:
      case NodeType._DOCUMENT_NODE:
      case NodeType._COMMENT_NODE:
      case undefined: // window.object
        return true;
      default:
        return false;
    }
  }

  /**
   * @param {Element} element
   * @param {boolean} [onlyDescendants]
   * @returns {void}
   */
  function dealoc(element, onlyDescendants) {
    if (!element || element instanceof Comment) return;

    if (isArray(element)) {
      /* @ts-ignore */
      element.forEach((item) => dealoc(item, onlyDescendants));
    } else {
      if (!onlyDescendants && elementAcceptsData(element)) {
        cleanElementData([element]);
      }

      if (elementAcceptsData(element)) {
        cleanElementData(element.querySelectorAll("*"));
      }
    }
    delete element[EXPANDO];
    element.innerHTML = "";
  }

  /**
   * If expando store data is empty, then delete it and set its expando id.
   * to undefined.
   * @param {Element} element
   */
  function removeIfEmptyData(element) {
    const expandoId = element[EXPANDO];

    const { data } = Cache.get(expandoId);

    if (!data || !keys(data).length) {
      Cache.delete(expandoId);
      element[EXPANDO] = undefined; // don't delete DOM expandos. Chrome don't like it
    }
  }

  /**
   * Gets or sets cache data for a given element.
   *
   * @param {Element} element - The DOM element to get or set data on.
   * @param {string|Object} key - The key (as a string) to get/set or an object for mass-setting.
   * @param {*} [value] - The value to set. If not provided, the function acts as a getter.
   * @returns {*} - The retrieved data if acting as a getter. Otherwise, returns undefined.
   */
  function getOrSetCacheData(element, key, value) {
    if (elementAcceptsData(element)) {
      let prop;

      const isSimpleSetter = isDefined(value);

      const isSimpleGetter = !isSimpleSetter && key && !isObject(key);

      const massGetter = !key;

      const expandoStore = getExpando(element, !isSimpleGetter);

      const data = expandoStore && expandoStore.data;

      if (isSimpleSetter) {
        data[kebabToCamel(key)] = value;
      } else {
        if (massGetter) {
          return data;
        }

        if (isSimpleGetter) {
          // don't force creation of expandoStore if it doesn't exist yet
          return data && data[kebabToCamel(key)];
        }

        // mass-setter: data({key1: val1, key2: val2})
        for (prop in key) {
          data[kebabToCamel(prop)] = key[prop];
        }
      }

      return undefined;
    } else {
      // TODO: check should occur perhaps prior at compilation level that this is a valid element
      return undefined;
    }
  }

  /**
   * Sets cache data for a given element.
   *
   * @param {Element|Node} element - The DOM element to get or set data on.
   * @param {string} key - The key (as a string) to get/set or an object for mass-setting.
   * @param {*} [value] - The value to set. If not provided, the function acts as a getter.
   * @returns
   */
  function setCacheData(element, key, value) {
    if (elementAcceptsData(element)) {
      const expandoStore = getExpando(/** @type {Element} */ (element), true);

      const data = expandoStore && expandoStore.data;

      data[kebabToCamel(key)] = value;
    } else {
      if (element.parentElement) {
        // TODO: check should occur perhaps prior at compilation level that this is a valid element
        setCacheData(element.parentElement, key, value);
      }
    }
  }

  /**
   * Gets cache data for a given element.
   *
   * @param {Element} element - The DOM element to get data from.
   * @param {string} [key] - The key (as a string) to retrieve. If not provided, returns all data.
   * @returns {*} - The retrieved data for the given key or all data if no key is provided.
   */
  function getCacheData(element, key) {
    if (elementAcceptsData(element)) {
      const expandoStore = getExpando(element, false); // Don't create if it doesn't exist

      const data = expandoStore && expandoStore.data;

      if (!key) {
        return undefined;
      }

      return data && data[kebabToCamel(key)];
    }

    return undefined;
  }

  /**
   * Deletes cache data for a given element for a particular key.
   *
   * @param {Element} element - The DOM element to delete data from.
   * @param {string} key - The key (as a string) to delete.
   * @returns void
   */
  function deleteCacheData(element, key) {

    if (elementAcceptsData(element)) {
      const expandoStore = getExpando(element, false); // Don't create if it doesn't exist

      const data = expandoStore?.data;

      if (data && hasOwn(data, kebabToCamel(key))) {
        delete data[kebabToCamel(key)];
      }
    }
  }
  /**
   * Gets scope for a given element.
   *
   * @param {Element} element - The DOM element to get data from.
   * @returns {ng.Scope} - The retrieved data for the given key or all data if no key is provided.
   */
  function getScope(element) {
    return getCacheData(element, SCOPE_KEY);
  }

  /**
   * Set scope for a given element.
   *
   * @param {Element|Node|ChildNode} element - The DOM element to set data on.
   * @param {ng.Scope} scope - The Scope attached to this element
   */
  function setScope(element, scope) {
    return setCacheData(element, SCOPE_KEY, scope);
  }

  /**
   * Set isolate scope for a given element.
   *
   * @param {Element} element - The DOM element to set data on.
   * @param {ng.Scope} scope - The Scope attached to this element
   */
  function setIsolateScope(element, scope) {
    return setCacheData(element, ISOLATE_SCOPE_KEY, scope);
  }

  /**
   * Gets the controller instance for a given element, if exists. Defaults to "ngControllerController"
   *
   * @param {Element} element - The DOM element to get data from.
   * @param {string} [name] - Controller name.
   * @returns {ng.Scope|undefined} - The retrieved data
   */
  function getController(element, name) {
    return getInheritedData(element, `$${name || "ngController"}Controller`);
  }

  /**
   *
   * @param {Node} element
   * @param {string} name
   * @returns
   */
  function getInheritedData(element, name) {
    // if element is the document object work with the html element instead
    // this makes $(document).scope() possible
    if (element.nodeType === NodeType._DOCUMENT_NODE) {
      element = /** @type {Document} */ (element).documentElement;
    }

    let value;

    while (element) {
      if (
        isDefined((value = getCacheData(/** @type {Element} */ (element), name)))
      )
        return value;

      // If dealing with a document fragment node with a host element, and no parent, use the host
      // element as the parent. This enables directives within a Shadow DOM or polyfilled Shadow DOM
      // to lookup parent controllers.
      element =
        element.parentNode ||
        (element.nodeType === NodeType._DOCUMENT_FRAGMENT_NODE &&
          /** @type {ShadowRoot} */ (element).host);
    }

    return undefined;
  }

  /**
   *
   * @param {Element} element
   * @param {boolean} keepData
   */
  function removeElement(element, keepData = false) {
    if (!keepData) {
      dealoc(element);
    }
    const parent = element.parentNode;

    if (parent) parent.removeChild(element);
  }

  /**
   * Extracts the starting tag from an HTML string or DOM element.
   *
   * @param {string|Element|Node} elementOrStr - The HTML string or DOM element to process.
   * @returns {string} The starting tag or processed result.
   */
  function startingTag(elementOrStr) {
    let clone;

    if (typeof elementOrStr === "string") {
      const parser = new DOMParser();

      const doc = parser.parseFromString(elementOrStr, "text/html");

      clone = doc.body.firstChild.cloneNode(true);
    } else if (elementOrStr instanceof Element || elementOrStr instanceof Node) {
      clone = elementOrStr.cloneNode(true);
    } else {
      throw new Error("Input must be an HTML string or a DOM element.");
    }

    while (clone.firstChild) {
      clone.removeChild(clone.firstChild);
    }

    const divWrapper = document.createElement("div");

    divWrapper.appendChild(clone);
    const elemHtml = divWrapper.innerHTML;

    try {
      if (clone.nodeType === NodeType._TEXT_NODE) {
        return elemHtml.toLowerCase();
      } else if (clone.nodeType === NodeType._COMMENT_NODE) {
        return `<!--${/** @type {Comment} **/ (clone).data.trim()}-->`;
      } else {
        const match = elemHtml.match(/^(<[^>]+>)/);

        if (match) {
          return match[1].replace(/^<([\w-]+)/, (_match, nodeName) => {
            return `<${nodeName.toLowerCase()}`;
          });
        }
      }
    } catch {
      return elemHtml.toLowerCase();
    }

    return elemHtml.toLowerCase();
  }

  /**
   * Return the DOM siblings between the first and last node in the given array.
   * @param {Array<Node>} nodes An array-like object
   * @returns {Element} the inputted object or a JQLite collection containing the nodes
   */
  function getBlockNodes(nodes) {
    // TODO(perf): update `nodes` instead of creating a new object?
    let node = nodes[0];

    const endNode = nodes[nodes.length - 1];

    let blockNodes;

    for (let i = 1; node !== endNode && (node = node.nextSibling); i++) {
      if (blockNodes || nodes[i] !== node) {
        if (!blockNodes) {
          // use element to avoid circular dependency
          blockNodes = Array.prototype.slice.call(nodes, 0, i);
        }
        blockNodes.push(node);
      }
    }

    return blockNodes || nodes;
  }

  /**
   * Gets the name of a boolean attribute if it exists on a given element.
   *
   * @param {Element} element - The DOM element to check.
   * @param {string} name - The name of the attribute.
   * @returns {string|false} - The attribute name if valid, otherwise false.
   */
  function getBooleanAttrName(element, name) {
    const normalizedName = name.toLowerCase();

    const isBooleanAttr = BOOLEAN_ATTR.includes(normalizedName);

    return isBooleanAttr && BOOLEAN_ELEMENTS.includes(element.nodeName)
      ? normalizedName
      : false;
  }

  /**
   * Takes an array of elements, calls any `$destroy` event handlers, removes any data in cache, and finally removes any
   * listeners.
   * @param {NodeListOf<Element>|Element[]} nodes
   */
  function cleanElementData(nodes) {
    for (let i = 0, ii = nodes.length; i < ii; i++) {
      removeElementData(nodes[i]);
    }
  }

  /**
   * Return instance of InjectorService attached to element
   * @param {Element} element
   * @returns {ng.InjectorService}
   */
  function getInjector(element) {
    return getInheritedData(element, $injectTokens._injector);
  }

  /**
   * Creates a DOM element from an HTML string.
   * @param {string} htmlString - A string representing the HTML to parse. Must have only one root element.
   * @returns {Element} - The parsed DOM element.
   */
  function createElementFromHTML(htmlString) {
    const template = document.createElement("template");

    template.innerHTML = htmlString.trim();

    return /** @type {Element} */ (template.content.firstChild);
  }

  /**
   * Creates a DOM element from an HTML string.
   * @param {string} htmlString - A string representing the HTML to parse.
   * @returns {NodeList} - The parsed DOM element.
   */
  function createNodelistFromHTML(htmlString) {
    const template = document.createElement("template");

    template.innerHTML = htmlString.trim();

    return template.content.childNodes;
  }

  /**
   * Remove element from the DOM and clear Cache data, associated with the node.
   * @param {Element} element
   */
  function emptyElement(element) {
    dealoc(element, true);
    switch (element.nodeType) {
      case NodeType._ELEMENT_NODE:
      case NodeType._DOCUMENT_NODE:
      case NodeType._DOCUMENT_FRAGMENT_NODE:
        element.replaceChildren();
        break;
    }
  }

  /**
   * Inserts a DOM element before or at the beginning of a parent element.
   *
   * @param {HTMLElement | Element} element
   *   The element to insert into the DOM.
   *
   * @param {HTMLElement | Element} parentElement
   *   The parent element that will receive the inserted element.
   *
   * @param {HTMLElement | Element | null} [afterElement]
   *   An optional sibling element — if present and valid, `element`
   *   will be inserted after it. If omitted or invalid, `element`
   *   is prepended to `parentElement`.
   *
   * @returns {void}
   */
  function domInsert(element, parentElement, afterElement) {
    // if for some reason the previous element was removed
    // from the dom sometime before this code runs then let's
    // just stick to using the parent element as the anchor
    if (afterElement) {
      const afterNode = extractElementNode(afterElement);

      if (afterNode && !afterNode.parentNode && !afterNode.previousSibling) {
        afterElement = null;
      }
    }

    if (afterElement) {
      afterElement.after(element);
    } else {
      parentElement.prepend(element);
    }
  }

  function animatedomInsert(element, parent, after) {
    const originalVisibility = element.style.visibility;

    const originalPosition = element.style.position;

    const originalPointerEvents = element.style.pointerEvents;

    Object.assign(element.style, {
      visibility: "hidden",
      position: "absolute",
      pointerEvents: "none",
    });

    domInsert(element, parent, after);

    requestAnimationFrame(() => {
      element.style.visibility = originalVisibility;
      element.style.position = originalPosition;
      element.style.pointerEvents = originalPointerEvents;
    });
  }

  /**
   * Returns the base href of the document.
   *
   * @returns {string} The base href.
   */
  function getBaseHref() {
    const href = document.querySelector("base")?.getAttribute("href");

    return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : "";
  }

  /**
   * Shared utility functions
   */

  const $injectorMinErr$3 = minErr($injectTokens._injector);

  const ARROW_ARG = /^([^(]+?)=>/;

  const FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m;

  const FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;

  const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;

  /**
   * @param {Function} fn
   * @returns {string}
   */
  function stringifyFn(fn) {
    return Function.prototype.toString.call(fn);
  }

  /**
   * @param {Function} fn
   * @returns {Array<any>}
   */
  function extractArgs(fn) {
    const fnText = stringifyFn(fn).replace(STRIP_COMMENTS, "");

    return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
  }

  /**
   * @param {Function} func
   * @returns {boolean}
   */
  function isClass(func) {
    return /^class\b/.test(stringifyFn(func));
  }

  /**
   * @param {any} fn
   * @param {boolean} [strictDi]
   * @param {string} [name]
   * @returns {Array<string>}
   */
  function annotate(fn, strictDi, name) {
    let $inject, argDecl, last;

    if (isFunction(fn)) {
      // eslint-disable-next-line prefer-destructuring
      $inject = fn.$inject;

      if (!$inject) {
        $inject = [];

        if (fn.length) {
          if (strictDi) {
            throw $injectorMinErr$3(
              "strictdi",
              "{0} is not using explicit annotation and cannot be invoked in strict mode",
              name,
            );
          }
          argDecl = extractArgs(fn);
          argDecl[1].split(/,/).forEach(function (arg) {
            arg.replace(FN_ARG, function (_all, _underscore, injName) {
              $inject.push(injName);
            });
          });
        }
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = /** @type {Array} */ (fn).length - 1;
      assertArgFn(fn[last], "fn");
      $inject = /** @type {Array} */ (fn).slice(0, last);
    } else {
      assertArgFn(fn, "fn", true);
    }

    return $inject;
  }

  const $injectorMinErr$2 = minErr($injectTokens._injector);

  const providerSuffix$1 = "Provider";

  const INSTANTIATING = true;

  class AbstractInjector {
    /**
     * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
     */
    constructor(strictDi) {
      /**
       * @type {Object<String, Function>}
       */
      this.cache = {};
      /** @type {boolean} */
      this.strictDi = strictDi;
      /** @type {string[]} */
      this.path = [];
      /** @type {Object.<string, ng.NgModule>} */
      this.modules = {};
    }

    /**
     * Get a service by name.
     *
     * @param {string} serviceName
     * @returns {any}
     */
    get(serviceName) {
      if (hasOwn(this.cache, serviceName)) {
        if (this.cache[serviceName] === INSTANTIATING) {
          throw $injectorMinErr$2(
            "cdep",
            "Circular dependency found: {0}",
            `${serviceName} <- ${this.path.join(" <- ")}`,
          );
        }

        return this.cache[serviceName];
      }

      this.path.unshift(serviceName);
      this.cache[serviceName] = INSTANTIATING;

      try {
        this.cache[serviceName] = this.factory(serviceName);
      } catch (err) {
        // this is for the error handling being thrown by the providerCache multiple times
        delete this.cache[serviceName];
        throw err;
      }

      return this.cache[serviceName];
    }

    /**
     * Get the injection arguments for a function.
     *
     * @param {Function|Array} fn
     * @param {Object} locals
     * @param {string} serviceName
     * @returns
     */
    injectionArgs(fn, locals, serviceName) {
      const args = [];

      const $inject = annotate(fn, this.strictDi, serviceName);

      for (let i = 0, { length } = $inject; i < length; i++) {
        const key = $inject[i];

        if (typeof key !== "string") {
          throw $injectorMinErr$2(
            "itkn",
            "Incorrect injection token! Expected service name as string, got {0}",
            key,
          );
        }
        args.push(locals && hasOwn(locals, key) ? locals[key] : this.get(key));
      }

      return args;
    }

    /**
     * Invoke a function with optional context and locals.
     *
     * @param {Function|String|Array<any>} fn
     * @param {*} [self]
     * @param {Object} [locals]
     * @param {string} [serviceName]
     * @returns {*}
     */
    invoke(fn, self, locals, serviceName) {
      if (typeof locals === "string") {
        serviceName = locals;
        locals = null;
      }

      const args = this.injectionArgs(
        /** @type {Function} */ (fn),
        locals,
        serviceName,
      );

      if (isArray(fn)) {
        fn = fn[fn.length - 1];
      }

      if (isClass(/** @type {Function} */ (fn))) {
        args.unshift(null);

        return new (Function.prototype.bind.apply(fn, args))();
      } else {
        return /** @type {Function} */ (fn).apply(self, args);
      }
    }

    /**
     * Instantiate a type constructor with optional locals.
     * @param {Function|Array} type
     * @param {*} [locals]
     * @param {string} [serviceName]
     */
    instantiate(type, locals, serviceName) {
      // Check if type is annotated and use just the given function at n-1 as parameter
      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);
      const ctor = isArray(type) ? type[type.length - 1] : type;

      const args = this.injectionArgs(type, locals, serviceName);

      // Empty object at position 0 is ignored for invocation with `new`, but required.
      args.unshift(null);

      try {
        return new (Function.prototype.bind.apply(ctor, args))();
      } catch (err) {
        // try arrow function
        if (isArrowFunction(ctor)) {
          return ctor(args);
        } else {
          throw err;
        }
      }
    }

    /**
     * @abstract
     */
    loadNewModules() {
      /* empty */
    }

    /**
     * @abstract
     * @param {string} _serviceName
     * @returns {any}
     */
    // eslint-disable-next-line no-unused-vars
    factory(_serviceName) {
      /* empty */
    }
  }

  /**
   * Injector for providers
   */
  class ProviderInjector extends AbstractInjector {
    /**
     * @param {Object} cache
     * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
     */
    constructor(cache, strictDi) {
      super(strictDi);
      this.cache = cache;
    }

    /**
     * Factory method for creating services.
     * @param {string} caller - The name of the caller requesting the service.
     * @throws {Error} If the provider is unknown.
     */
    factory(caller) {
      this.path.push(caller);
      // prevents lookups to providers through get
      throw $injectorMinErr$2(
        "unpr",
        "Unknown provider: {0}",
        this.path.join(" <- "),
      );
    }

    loadNewModules() {
      /* empty */
    }
  }

  /**
   * Injector for factories and services
   */
  class InjectorService extends AbstractInjector {
    /**
     * @param {ProviderInjector} providerInjector
     * @param {boolean} strictDi - Indicates if strict dependency injection is enforced.
     */
    constructor(providerInjector, strictDi) {
      super(strictDi);

      /** @type {ProviderInjector} */
      this.providerInjector = providerInjector;
      /** @type {Object.<string, ng.NgModule>} */
      this.modules = providerInjector.modules;
    }

    /**
     * @param {string} serviceName
     * @returns {*}
     */
    factory(serviceName) {
      const provider = this.providerInjector.get(serviceName + providerSuffix$1);

      return this.invoke(provider.$get, provider, undefined, serviceName);
    }

    /**
     *
     * @param {string} name
     * @returns {boolean}
     */
    has(name) {
      const hasProvider = hasOwn(
        this.providerInjector.cache,
        name + providerSuffix$1,
      );

      const hasCache = hasOwn(this.cache, name);

      return hasProvider || hasCache;
    }

    loadNewModules() {
      /* empty */
    }
  }

  /**
   * Creates a proxy that automatically persists an object's state
   * into a storage backend whenever a property is set.
   *
   * @param {object} target - The object to wrap
   * @param {string} key - The storage key
   * @param {object} storage - Any storage-like object with getItem/setItem/removeItem
   * @param {{serialize?: function, deserialize?: function}} [options] - Optional custom (de)serialization
   * @returns {Proxy}
   */
  function createPersistentProxy(target, key, storage, options = {}) {
    const serialize = options.serialize || JSON.stringify;

    const deserialize = options.deserialize || JSON.parse;

    // Restore saved state
    const saved = storage.getItem(key);

    if (saved) {
      Object.assign(target, deserialize(saved));
    }

    return new Proxy(target, {
      set(obj, prop, value) {
        obj[prop] = value;
        storage.setItem(key, serialize(obj));

        return true;
      },
      deleteProperty(obj, prop) {
        const deleted = delete obj[prop];

        storage.setItem(key, serialize(obj));

        return deleted;
      },
    });
  }

  /**
   * Predicate which checks if a value is injectable
   *
   * A value is "injectable" if it is a function, or if it is an ng1 array-notation-style array
   * where all the elements in the array are Strings, except the last one, which is a Function
   * @param {*} val
   * @returns {boolean}
   */
  function isInjectable(val) {
    if (isArray(val) && val.length) {
      const head = val.slice(0, -1),
        tail = val.slice(-1);

      return !(
        head.filter((injectable) => !isString(injectable)).length ||
        tail.filter((injectable) => !isFunction(injectable)).length
      );
    }

    return isFunction(val);
  }
  /**
   * Predicate which checks if a value looks like a Promise
   *
   * It is probably a Promise if it's an object, and it has a `then` property which is a Function
   * @param {any} obj
   * @returns {boolean}
   */
  function isPromise(obj) {
    return (
      obj !== null && typeof obj === "object" && typeof obj.then === "function"
    );
  }

  const BADARG = "badarg";
  const BADARGVALUE = "badarg: value";

  /** @type {Map<ng.Validator, string>} */
  const reasons = new Map([
    [notNullOrUndefined, "required"],
    [isArray, "notarray"],
    [isInjectable, "notinjectable"],
    [isDefined, "required"],
    [isString, "notstring"],
  ]);

  /**
   *
   * @param {ng.Validator} val
   * @returns {string}
   */
  function getReason(val) {
    return reasons.get(val) ?? "fail";
  }

  /**
   * Validate a value using a predicate function.
   * Throws if the predicate returns false.
   * IMPORTANT: use this function only for developper errors and not for user/data errors
   *
   * @param {ng.Validator} fn - Predicate validator function.
   * @param {*} arg - The value to validate.
   * @param {string} name - Parameter name (included in error message).
   * @returns {*} The validated value.
   * @throws {TypeError} If the value does not satisfy the validator.
   */
  function validate(fn, arg, name) {
    if (fn(arg)) return arg;

    let v;

    try {
      v = JSON.stringify(arg);
    } catch {
      v = String(arg);
    }

    throw new TypeError(`badarg:${getReason(fn)} ${name}=${v}`);
  }

  /**
   * @param {*} arg - The value to validate.
   * @param {string} name - Parameter name (included in error message).
   * @returns {*} The validated value.
   * @throws {TypeError} If the value does not satisfy the validator.
   */
  function validateRequired(arg, name) {
    return validate(notNullOrUndefined, arg, name);
  }

  /**
   * @param {*} arg - The value to validate.
   * @param {string} name - Parameter name (included in error message).
   * @returns {*} The validated value.
   * @throws {TypeError} If the value does not satisfy the validator.
   */
  function validateArray(arg, name) {
    return validate(isArray, arg, name);
  }

  /**
   * @param {*} arg - The value to validate.
   * @param {string} name - Parameter name (included in error message).
   * @returns {*} The validated value.
   * @throws {TypeError} If the value does not satisfy the validator.
   */
  function validateIsString(arg, name) {
    return validate(isString, arg, name);
  }

  /**
   * @template T
   * @param {unknown} arg - The value to validate.
   * @param {new (...args: any[]) => T} type - The constructor to check against.
   * @param {string} name - Parameter name (included in error message).
   * @returns {T} The validated instance.
   * @throws {TypeError} If the value is not an instance of the specified type.
   */
  function validateInstanceOf(arg, type, name) {
    return validate((v) => v instanceof type, arg, name);
  }

  const $injectorMinErr$1 = minErr($injectTokens._injector);

  const providerSuffix = "Provider";

  /**
   *
   * @param {Array<String|Function>} modulesToLoad
   * @param {boolean} [strictDi]
   * @returns {InjectorService}
   */
  function createInjector(modulesToLoad, strictDi = false) {
    assert(isArray(modulesToLoad), "modules required");

    /** @type {Map<String|Function, boolean>} */
    const loadedModules = new Map(); // Keep track of loaded modules to avoid circular dependencies

    const providerCache = {
      $provide: {
        provider: supportObject(provider),
        factory: supportObject(factory),
        service: supportObject(service),
        value: supportObject(value),
        constant: supportObject(constant),
        store,
        decorator,
      },
    };

    const providerInjector = (providerCache.$injector = new ProviderInjector(
      providerCache,
      strictDi,
    ));

    const protoInstanceInjector = new InjectorService(providerInjector, strictDi);

    providerCache.$injectorProvider = {
      // $injectionProvider return instance injector
      $get: () => protoInstanceInjector,
    };

    let instanceInjector = protoInstanceInjector;

    const runBlocks = loadModules(modulesToLoad);

    instanceInjector = protoInstanceInjector.get($injectTokens._injector);

    runBlocks.forEach((fn) => fn && instanceInjector.invoke(fn));

    instanceInjector.loadNewModules = (mods) =>
      loadModules(mods).forEach((fn) => fn && instanceInjector.invoke(fn));

    return instanceInjector;

    ////////////////////////////////////
    // $provide methods
    ////////////////////////////////////

    /**
     * Registers a provider.
     * @param {string} name
     * @param {import('../../interface.ts').ServiceProvider | import('../../interface.ts').Injectable<any>} provider
     * @returns {import('../../interface.ts').ServiceProvider}
     */
    // eslint-disable-next-line no-shadow
    function provider(name, provider) {
      assertNotHasOwnProperty(name, "service");
      let newProvider;

      if (isFunction(provider) || isArray(provider)) {
        newProvider = providerInjector.instantiate(
          /** @type {Function} */ (provider),
        );
      } else {
        newProvider = provider;
      }

      if (!newProvider.$get) {
        throw $injectorMinErr$1(
          "pget",
          "Provider '{0}' must define $get factory method.",
          name,
        );
      }
      providerCache[name + providerSuffix] = newProvider;

      return newProvider;
    }

    /**
     * Registers a factory.
     * @param {string} name
     * @param {(string|(function(*): *))[]} factoryFn
     * @returns {import('../../interface.ts').ServiceProvider}
     */
    function factory(name, factoryFn) {
      return provider(name, {
        $get() {
          const result = instanceInjector.invoke(factoryFn, this);

          if (isUndefined(result)) {
            throw $injectorMinErr$1(
              "undef",
              "Provider '{0}' must return a value from $get factory method.",
              name,
            );
          }

          return result;
        },
      });
    }

    /**
     * Registers a service constructor.
     * @param {string} name
     * @param {Function} constructor
     * @returns {import('../../interface.ts').ServiceProvider}
     */
    function service(name, constructor) {
      return factory(name, [
        $injectTokens._injector,
        ($injector) => $injector.instantiate(constructor),
      ]);
    }

    /**
     * Register a fixed value as a service.
     * @param {String} name
     * @param {any} val
     * @returns {ng.ServiceProvider}
     */
    function value(name, val) {
      return (providerCache[name + providerSuffix] = { $get: () => val });
    }

    /**
     * Register a constant value (available during config).
     * @param {string} name
     * @param {any} value
     * @returns {void}
     */
    // eslint-disable-next-line no-shadow
    function constant(name, value) {
      assertNotHasOwnProperty(name, "constant");
      providerInjector.cache[name] = value;
      protoInstanceInjector.cache[name] = value;
    }

    /**
     * Register a decorator function to modify or replace an existing service.
     * @param {string} serviceName - The name of the service to decorate.
     * @param {Function} decorFn - A function that takes `$delegate` and returns a decorated service.
     * @returns {void}
     */
    function decorator(serviceName, decorFn) {
      const origProvider = providerInjector.get(serviceName + providerSuffix);

      const origGet = origProvider.$get;

      origProvider.$get = function () {
        const origInstance = instanceInjector.invoke(origGet, origProvider);

        return instanceInjector.invoke(decorFn, null, {
          $delegate: origInstance,
        });
      };
    }

    /**
     * Registers a service persisted in a storage
     *
     * @param {string} name - Service name
     * @param {Function} ctor - Constructor for the service
     * @param {ng.StorageType} type - Type of storage to be instantiated
     * @param {Storage|Object} backendOrConfig - Either a Storage-like object (getItem/setItem) or a config object
     *                                           with { backend, serialize, deserialize }
     */
    function store(name, ctor, type, backendOrConfig = {}) {
      return provider(name, {
        $get: /** @param {ng.InjectorService} $injector */ ($injector) => {
          switch (type) {
            case "session": {
              const instance = $injector.instantiate(ctor);

              return createPersistentProxy(instance, name, sessionStorage);
            }
            case "local": {
              const instance = $injector.instantiate(ctor);

              return createPersistentProxy(instance, name, localStorage);
            }
            case "cookie": {
              const instance = $injector.instantiate(ctor);

              const $cookie = $injector.get($injectTokens._cookie);

              const serialize = backendOrConfig.serialize ?? JSON.stringify;

              const deserialize = backendOrConfig.deserialize ?? JSON.parse;

              const cookieOpts = backendOrConfig.cookie ?? {};

              return createPersistentProxy(instance, name, {
                getItem(key) {
                  const raw = $cookie.get(key);

                  return isNullOrUndefined(raw) ? null : raw;
                },

                setItem(k, v) {
                  $cookie.put(k, v, cookieOpts);
                },

                removeItem(k) {
                  $cookie.remove(k, cookieOpts);
                },

                serialize,
                deserialize,
              });
            }
            case "custom": {
              const instance = $injector.instantiate(ctor);

              let backend;

              let serialize = JSON.stringify;

              let deserialize = JSON.parse;

              if (backendOrConfig) {
                if (typeof backendOrConfig.getItem === "function") {
                  // raw Storage object
                  backend = backendOrConfig;
                } else if (isObject(backendOrConfig)) {
                  backend = backendOrConfig.backend || localStorage;

                  if (backendOrConfig.serialize)
                    // eslint-disable-next-line prefer-destructuring
                    serialize = backendOrConfig.serialize;

                  if (backendOrConfig.deserialize)
                    // eslint-disable-next-line prefer-destructuring
                    deserialize = backendOrConfig.deserialize;
                }
              } else {
                // fallback default
                backend = localStorage;
              }

              return createPersistentProxy(instance, name, backend, {
                serialize,
                deserialize,
              });
            }
          }

          return undefined;
        },
      });
    }

    /**
     *
     * @param {Array<String|Function>} modules
     * @returns
     */
    function loadModules(modules) {
      validateArray(modules, "modules");
      let moduleRunBlocks = [];

      modules.forEach((module) => {
        if (loadedModules.get(module)) return;
        loadedModules.set(module, true);

        try {
          if (isString(module)) {
            /** @type {ng.NgModule} */
            const moduleFn = window.angular.module(
              /** @type {string} */ (module),
            );

            instanceInjector.modules[/** @type {string } */ (module)] = moduleFn;
            moduleRunBlocks = moduleRunBlocks
              .concat(loadModules(moduleFn._requires))
              .concat(moduleFn._runBlocks);

            const invokeQueue = moduleFn._invokeQueue.concat(
              moduleFn._configBlocks,
            );

            invokeQueue.forEach((invokeArgs) => {
              const providerInstance = providerInjector.get(invokeArgs[0]);

              providerInstance[invokeArgs[1]].apply(
                providerInstance,
                invokeArgs[2],
              );
            });
          } else if (isFunction(module)) {
            moduleRunBlocks.push(providerInjector.invoke(module));
          } else if (isArray(module)) {
            moduleRunBlocks.push(providerInjector.invoke(module));
          } else {
            assertArgFn(module, "module");
          }
        } catch (err) {
          if (isArray(module)) {
            module = module[module.length - 1];
          }
          throw $injectorMinErr$1(
            "modulerr",
            "Failed to instantiate module {0} due to:\n{1}",
            module,
            err.stack || err.message || err,
          );
        }
      });

      return moduleRunBlocks;
    }
  }

  function supportObject(delegate) {
    return function (key, value) {
      if (isObject(key)) {
        entries(key).forEach(([k, v]) => {
          delegate(k, v);
        });

        return undefined;
      } else {
        return delegate(key, value);
      }
    };
  }

  const originUrl = urlResolve(window.location.href);

  /**
   * @param {import("./interface.ts").ResolvableUrl} url
   * @return {import("./interface.ts").ParsedUrl}
   */
  function urlResolve(url) {
    if (!isString(url))
      return /** @type {import("./interface.ts").ParsedUrl} */ (url);

    const urlParsingNode = new URL(
      /** @type {string} */ (url),
      window.location.href,
    );

    const hostname = urlParsingNode.hostname.includes(":")
      ? `[${urlParsingNode.hostname}]`
      : urlParsingNode.hostname;

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol,
      host: urlParsingNode.host,
      search: urlParsingNode.search
        ? urlParsingNode.search.replace(/^\?/, "")
        : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname,
      port: urlParsingNode.port,
      pathname:
        urlParsingNode.pathname.charAt(0) === "/"
          ? urlParsingNode.pathname
          : `/${urlParsingNode.pathname}`,
    };
  }

  /**
   * Parse a request URL and determine whether this is a same-origin request as the application
   * document.
   *
   * @param {import("./interface.ts").ResolvableUrl} requestUrl The url of the request as a string that will be resolved
   * or a parsed URL object.
   * @returns {boolean} Whether the request is for the same origin as the application document.
   */
  function urlIsSameOrigin(requestUrl) {
    return urlsAreSameOrigin(requestUrl, originUrl);
  }

  /**
   * Parse a request URL and determine whether it is same-origin as the current document base URL.
   *
   * Note: The base URL is usually the same as the document location (`location.href`) but can
   * be overriden by using the `<base>` tag.
   *
   * @param {import("./interface.ts").ResolvableUrl} requestUrl The url of the request as a string that will be resolved
   * or a parsed URL object.
   * @returns {boolean} Whether the URL is same-origin as the document base URL.
   */
  function urlIsSameOriginAsBaseUrl(requestUrl) {
    return urlsAreSameOrigin(requestUrl, document.baseURI);
  }

  /**
   * Create a function that can check a URL's origin against a list of allowed/trusted origins.
   * The current location's origin is implicitly trusted.
   *
   * @param {string[]} trustedOriginUrls - A list of URLs (strings), whose origins are trusted.
   *
   * @returns {(url: import("./interface.ts").ResolvableUrl) => boolean } - A function that receives a URL (string or parsed URL object) and returns
   *     whether it is of an allowed origin.
   */
  function urlIsAllowedOriginFactory(trustedOriginUrls) {
    const parsedAllowedOriginUrls = [originUrl].concat(
      trustedOriginUrls.map(urlResolve),
    );

    /**
     * Check whether the specified URL (string or parsed URL object) has an origin that is allowed
     * based on a list of trusted-origin URLs. The current location's origin is implicitly
     * trusted.
     *
     * @param {import("./interface.ts").ResolvableUrl} requestUrl - The URL to be checked (provided as a string that will be
     *     resolved or a parsed URL object).
     *
     * @returns {boolean} - Whether the specified URL is of an allowed origin.
     */
    return function urlIsAllowedOrigin(requestUrl) {
      const parsedUrl = urlResolve(requestUrl);

      return parsedAllowedOriginUrls.some(
        urlsAreSameOrigin.bind(null, parsedUrl),
      );
    };
  }

  /**
   * Determine if two URLs share the same origin.
   *
   * @param {import("./interface.ts").ResolvableUrl} url1 - First URL to compare as a string or a normalized URL in the form of
   *     a dictionary object returned by `urlResolve()`.
   * @param {import("./interface.ts").ResolvableUrl} url2 - Second URL to compare as a string or a normalized URL in the form
   *     of a dictionary object returned by `urlResolve()`.
   *
   * @returns {boolean} - True if both URLs have the same origin, and false otherwise.
   */
  function urlsAreSameOrigin(url1, url2) {
    url1 = urlResolve(url1);
    url2 = urlResolve(url2);

    return url1.protocol === url2.protocol && url1.host === url2.host;
  }

  /**
   * Removes a trailing hash ('#') from the given URL if it exists.
   *
   * @param {string} url
   * @returns {string}
   */
  function trimEmptyHash(url) {
    return url.replace(/#$/, "");
  }

  const APPLICATION_JSON = "application/json";

  /**
   * @internal
   * @enum {number}
   */
  const Http = {
    _OK: 200,
    _MultipleChoices: 300,
    _BadRequest: 400,
    _NotFound: 404,
    _ErrorMax: 599,
  };

  const CONTENT_TYPE_APPLICATION_JSON = {
    "Content-Type": `${APPLICATION_JSON};charset=utf-8`,
  };

  const JSON_START = /^\[|^\{(?!\{)/;

  const JSON_ENDS = {
    "[": /]$/,
    "{": /}$/,
  };

  const JSON_PROTECTION_PREFIX = /^\)]\}',?\n/;

  const $httpMinErr = minErr("$http");

  function serializeValue(v) {
    if (isObject(v)) {
      return isDate(v) ? v.toISOString() : toJson(v);
    }

    return v;
  }

  /**
   * Default params serializer that converts objects to strings
   * according to the following rules:
   *
   * * `{'foo': 'bar'}` results in `foo=bar`
   * * `{'foo': Date.now()}` results in `foo=2015-04-01T09%3A50%3A49.262Z` (`toISOString()` and encoded representation of a Date object)
   * * `{'foo': ['bar', 'baz']}` results in `foo=bar&foo=baz` (repeated key for each array element)
   * * `{'foo': {'bar':'baz'}}` results in `foo=%7B%22bar%22%3A%22baz%22%7D` (stringified and encoded representation of an object)
   *
   * Note that serializer will sort the request parameters alphabetically.
   */
  function HttpParamSerializerProvider() {
    /**
     * @returns {import('./interface.ts').HttpParamSerializer}
     * A function that serializes parameters into a query string.
     */
    this.$get = () => {
      return (params) => {
        if (!params) return "";
        const parts = [];

        keys(params)
          .sort()
          .forEach((key) => {
            const value = params[key];

            if (value === null || isUndefined(value) || isFunction(value)) return;

            if (isArray(value)) {
              /** @type {any[]} */ (value).forEach((v) => {
                parts.push(
                  `${encodeUriQuery(key)}=${encodeUriQuery(serializeValue(v))}`,
                );
              });
            } else {
              parts.push(
                `${encodeUriQuery(key)}=${encodeUriQuery(serializeValue(value))}`,
              );
            }
          });

        return parts.join("&");
      };
    };
  }

  function defaultHttpResponseTransform(data, headers) {
    if (isString(data)) {
      // Strip json vulnerability protection prefix and trim whitespace
      const tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();

      if (tempData) {
        const contentType = headers("Content-Type");

        const hasJsonContentType =
          contentType && contentType.indexOf(APPLICATION_JSON) === 0;

        if (hasJsonContentType || isJsonLike(tempData)) {
          try {
            data = fromJson(tempData);
          } catch (err) {
            if (!hasJsonContentType) {
              return data;
            }
            throw $httpMinErr(
              "baddata",
              'Data must be a valid JSON object. Received: "{0}". ' +
                'Parse error: "{1}"',
              data,
              err,
            );
          }
        }
      }
    }

    return data;
  }

  /**
   * @param {string} str
   * @return {boolean}
   */
  function isJsonLike(str) {
    const jsonStart = str.match(JSON_START);

    return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
  }

  /**
   * Parse headers into key value object
   *
   * @param {string} headers Raw headers as a string
   * @returns {Object} Parsed headers as key value object
   */
  function parseHeaders(headers) {
    const parsed = Object.create(null);

    let i;

    function fillInParsed(key, val) {
      if (key) {
        parsed[key] = parsed[key] ? `${parsed[key]}, ${val}` : val;
      }
    }

    if (isString(headers)) {
      headers.split("\n").forEach(
        /** @param {string} line */
        (line) => {
          i = line.indexOf(":");
          fillInParsed(
            line.substring(0, i).trim().toLowerCase(),
            trim(line.substring(i + 1)),
          );
        },
      );
    } else if (isObject(headers)) {
      entries(headers).forEach(([headerKey, headerVal]) => {
        fillInParsed(headerKey.toLowerCase(), trim(headerVal));
      });
    }

    return parsed;
  }

  /**
   * Returns a function that provides access to parsed headers.
   *
   * Headers are lazy parsed when first requested.
   * @see parseHeaders
   *
   * @param {(string|Object)} headers Headers to provide access to.
   * @returns {function(string=)} Returns a getter function which if called with:
   *
   *   - if called with an argument returns a single header value or null
   *   - if called with no arguments returns an object containing all headers.
   */
  function headersGetter(headers) {
    let headersObj;

    return function (name) {
      if (!headersObj) headersObj = parseHeaders(headers);

      if (name) {
        let value = headersObj[name.toLowerCase()];

        if (value === undefined) {
          value = null;
        }

        return value;
      }

      return headersObj;
    };
  }

  /**
   * Chain all given functions
   *
   * This function is used for both request and response transforming
   *
   * @param {*} data Data to transform.
   * @param {function(string=):any} headers HTTP headers getter fn.
   * @param {number} status HTTP status code of the response.
   * @param {function(...any): any | Array<Function>} fns Function or an array of functions.
   * @returns {*} Transformed data.
   */
  function transformData(data, headers, status, fns) {
    if (isFunction(fns)) {
      return fns(data, headers, status);
    }

    if (isArray(fns)) {
      /** @type {Array<function(...any): any>} */ (fns).forEach((fn) => {
        data = fn(data, headers, status);
      });
    }

    return data;
  }

  function isSuccess(status) {
    return status >= Http._OK && status < Http._MultipleChoices;
  }

  /**
   * Use `$httpProvider` to change the default behavior of the {@link ng.$http $http} service.
   */
  function HttpProvider() {
    /**
     * Object containing default values for all {@link ng.$http $http} requests.
     *
     * - **`defaults.cache`** - {boolean|Object} - A boolean value or object created with
     * {@link ng.$cacheFactory `$cacheFactory`} to enable or disable caching of HTTP responses
     * by default. See {@link $http#caching $http Caching} for more information.
     *
     * - **`defaults.headers`** - {Object} - Default headers for all $http requests.
     * Refer to {@link ng.$http#setting-http-headers $http} for documentation on
     * setting default headers.
     *     - **`defaults.headers.common`**
     *     - **`defaults.headers.post`**
     *     - **`defaults.headers.put`**
     *     - **`defaults.headers.patch`**
     *   *
     * - **`defaults.paramSerializer`** - `{string|function(Object<string,string>):string}` - A function
     *  used to the prepare string representation of request parameters (specified as an object).
     *  If specified as string, it is interpreted as a function registered with the {@link auto.$injector $injector}.
     *  Defaults to {@link ng.$httpParamSerializer $httpParamSerializer}.
     *
     * - **`defaults.transformRequest`** -
     * `{Array<function(data, headersGetter)>|function(data, headersGetter)}` -
     * An array of functions (or a single function) which are applied to the request data.
     * By default, this is an array with one request transformation function:
     *
     *   - If the `data` property of the request configuration object contains an object, serialize it
     *     into JSON format.
     *
     * - **`defaults.transformResponse`** -
     * `{Array<function(data, headersGetter, status)>|function(data, headersGetter, status)}` -
     * An array of functions (or a single function) which are applied to the response data. By default,
     * this is an array which applies one response transformation function that does two things:
     *
     *  - If XSRF prefix is detected, strip it
     *    (see {@link ng.$http#security-considerations Security Considerations in the $http docs}).
     *  - If the `Content-Type` is `application/json` or the response looks like JSON,
     *    deserialize it using a JSON parser.
     *
     * - **`defaults.xsrfCookieName`** - {string} - Name of cookie containing the XSRF token.
     * Defaults value is `'XSRF-TOKEN'`.
     *
     * - **`defaults.xsrfHeaderName`** - {string} - Name of HTTP header to populate with the
     * XSRF token. Defaults value is `'X-XSRF-TOKEN'`.
     *
     */
    const defaults = (this.defaults = {
      // transform incoming response data
      transformResponse: [defaultHttpResponseTransform],

      // transform outgoing request data
      transformRequest: [
        function (data) {
          return isObject(data) &&
            !isFile(data) &&
            !isBlob(data) &&
            !isFormData(data)
            ? toJson(data)
            : data;
        },
      ],

      // default headers
      headers: {
        common: {
          Accept: "application/json, text/plain, */*",
        },
        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
      },

      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",

      paramSerializer: "$httpParamSerializer",
    });

    let useApplyAsync = false;

    /**
     * Configure $http service to combine processing of multiple http responses received at around
     * the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in
     * significant performance improvement for bigger applications that make many HTTP requests
     * concurrently (common during application bootstrap).
     *
     * Defaults to false. If no value is specified, returns the current configured value.
     *
     * @param {boolean=} value If true, when requests are loaded, they will schedule a deferred
     *    "apply" on the next tick, giving time for subsequent requests in a roughly ~10ms window
     *    to load and share the same digest cycle.
     *
     * @returns {boolean|Object} If a value is specified, returns the $httpProvider for chaining.
     *    otherwise, returns the current configured value.
     */
    this.useApplyAsync = function (value) {
      if (isDefined(value)) {
        useApplyAsync = !!value;

        return this;
      }

      return useApplyAsync;
    };

    /**
     * Array containing service factories for all synchronous or asynchronous {@link ng.$http $http}
     * pre-processing of request or postprocessing of responses.
     *
     * These service factories are ordered by request, i.e. they are applied in the same order as the
     * array, on request, but reverse order, on response.
     *
     * {@link ng.$http#interceptors Interceptors detailed info}
     */
    this.interceptors = [];

    /**
     * Array containing URLs whose origins are trusted to receive the XSRF token. See the
     * {@link ng.$http#security-considerations Security Considerations} sections for more details on
     * XSRF.
     *
     * **Note:** An "origin" consists of the [URI scheme](https://en.wikipedia.org/wiki/URI_scheme),
     * the [hostname](https://en.wikipedia.org/wiki/Hostname) and the
     * [port number](https://en.wikipedia.org/wiki/Port_(computer_networking). For `http:` and
     * `https:`, the port number can be omitted if using th default ports (80 and 443 respectively).
     * Examples: `http://example.com`, `https://api.example.com:9876`
     *
     * <div class="alert alert-warning">
     *   It is not possible to trust specific URLs/paths. The `path`, `query` and `fragment` parts
     *   of a URL will be ignored. For example, `https://foo.com/path/bar?query=baz#fragment` will be
     *   treated as `https://foo.com`, meaning that **all** requests to URLs starting with
     *   `https://foo.com/` will include the XSRF token.
     * </div>
     *
     * @example
     *
     * ```js
     * // App served from `https://example.com/`.
     * angular.
     *   module('xsrfTrustedOriginsExample', []).
     *   config(['$httpProvider', function($httpProvider) {
     *     $httpProvider.xsrfTrustedOrigins.push('https://api.example.com');
     *   }]).
     *   run(['$http', function($http) {
     *     // The XSRF token will be sent.
     *     $http.get('https://api.example.com/preferences').then(...);
     *
     *     // The XSRF token will NOT be sent.
     *     $http.get('https://stats.example.com/activity').then(...);
     *   }]);
     * ```
     *
     * @type {string[]}
     */
    this.xsrfTrustedOrigins = [];

    /**
     * This property is deprecated. Use {@link $httpProvider#xsrfTrustedOrigins xsrfTrustedOrigins}
     * instead.
     */
    Object.defineProperty(this, "xsrfWhitelistedOrigins", {
      get() {
        return this.xsrfTrustedOrigins;
      },
      set(origins) {
        this.xsrfTrustedOrigins = origins;
      },
    });

    const that = this;

    this.$get = [
      $injectTokens._injector,
      $injectTokens._sce,
      $injectTokens._cookie,
      /**
       *
       * @param {ng.InjectorService} $injector
       * @param {*} $sce
       * @param {ng.CookieService} $cookie
       * @returns
       */
      function ($injector, $sce, $cookie) {
        /**
         * @type {Map<string, string>}
         */
        const defaultCache = new Map();

        /**
         * Make sure that default param serializer is exposed as a function
         */
        defaults.paramSerializer = isString(defaults.paramSerializer)
          ? $injector.get(defaults.paramSerializer)
          : defaults.paramSerializer;

        /**
         * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
         * The reversal is needed so that we can build up the interception chain around the
         * server request.
         */
        const reversedInterceptors = [];

        that.interceptors.forEach((interceptorFactory) => {
          reversedInterceptors.unshift(
            isString(interceptorFactory)
              ? $injector.get(interceptorFactory)
              : $injector.invoke(interceptorFactory),
          );
        });

        /**
         * A function to check request URLs against a list of allowed origins.
         */
        const urlIsAllowedOrigin = urlIsAllowedOriginFactory(
          that.xsrfTrustedOrigins,
        );

        /**
         * @property {Array.<Object>} requestConfig Array of config objects for currently pending
         * requests. This is primarily meant to be used for debugging purposes.
         */
        function $http(requestConfig) {
          if (!isObject(requestConfig)) {
            throw minErr("$http")(
              "badreq",
              "Http request configuration must be an object.  Received: {0}",
              requestConfig,
            );
          }

          if (!isString($sce.valueOf(requestConfig.url))) {
            throw minErr("$http")(
              "badreq",
              "Http request configuration url must be a string or a $sce trusted object.  Received: {0}",
              requestConfig.url,
            );
          }

          const config = extend(
            {
              method: "get",
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer,
            },
            requestConfig,
          );

          config.headers = mergeHeaders(requestConfig);
          config.method = uppercase(config.method);
          config.paramSerializer = isString(config.paramSerializer)
            ? $injector.get(config.paramSerializer)
            : config.paramSerializer;

          const requestInterceptors = [];

          const responseInterceptors = [];

          let promise = Promise.resolve(config);

          // apply interceptors
          reversedInterceptors.forEach((interceptor) => {
            if (interceptor.request || interceptor.requestError) {
              requestInterceptors.unshift(
                interceptor.request,
                interceptor.requestError,
              );
            }

            if (interceptor.response || interceptor.responseError) {
              responseInterceptors.push(
                interceptor.response,
                interceptor.responseError,
              );
            }
          });

          promise = chainInterceptors(promise, requestInterceptors);
          promise = promise.then(serverRequest);
          promise = chainInterceptors(promise, responseInterceptors);

          return promise;

          function chainInterceptors(promiseParam, interceptors) {
            for (let i = 0, ii = interceptors.length; i < ii; ) {
              const thenFn = interceptors[i++];

              const rejectFn = interceptors[i++];

              promiseParam = promiseParam.then(thenFn, rejectFn);
            }

            interceptors.length = 0;

            return promiseParam;
          }

          function executeHeaderFns(headers, configParam) {
            let headerContent;

            const processedHeaders = {};

            entries(headers).forEach(([header, headerFn]) => {
              if (isFunction(headerFn)) {
                headerContent = headerFn(configParam);

                if (!isNullOrUndefined(headerContent)) {
                  processedHeaders[header] = headerContent;
                }
              } else {
                processedHeaders[header] = headerFn;
              }
            });

            return processedHeaders;
          }

          function mergeHeaders(configParam) {
            let defHeaders = defaults.headers;

            const reqHeaders = extend({}, configParam.headers);

            defHeaders = extend(
              {},
              defHeaders.common,
              defHeaders[lowercase(configParam.method)],
            );

            keys(defHeaders).forEach((defHeaderName) => {
              const lowercaseDefHeaderName = lowercase(defHeaderName);

              const hasMatchingHeader = keys(reqHeaders).some((reqHeaderName) => {
                return lowercase(reqHeaderName) === lowercaseDefHeaderName;
              });

              if (!hasMatchingHeader) {
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
            });

            // execute if header value is a function for merged headers
            return executeHeaderFns(reqHeaders, shallowCopy(configParam));
          }

          function serverRequest(configParam) {
            const { headers } = configParam;

            const reqData = transformData(
              configParam.data,
              headersGetter(headers),
              undefined,
              configParam.transformRequest,
            );

            // strip content-type if data is undefined
            if (isUndefined(reqData)) {
              keys(headers).forEach((header) => {
                if (lowercase(header) === "content-type") {
                  delete headers[header];
                }
              });
            }

            if (
              isUndefined(configParam.withCredentials) &&
              !isUndefined(defaults.withCredentials)
            ) {
              configParam.withCredentials = defaults.withCredentials;
            }

            // send request
            return sendReq(configParam, reqData).then(
              transformResponse,
              transformResponse,
            );
          }

          function transformResponse(response) {
            // make a copy since the response must be cacheable
            const resp = extend({}, response);

            resp.data = transformData(
              response.data,
              response.headers,
              response.status,
              config.transformResponse,
            );

            return isSuccess(response.status) ? resp : Promise.reject(resp);
          }
        }

        $http.pendingRequests = [];

        /**
         * Shortcut method to perform `GET` request.
         *
         * @param {string} url Absolute or relative URL of the resource that is being requested;
         *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
         * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
         * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
         * See {@link ng.$http#$http-returns `$http()` return value}.
         */

        /**
         * Shortcut method to perform `DELETE` request.
         *
         * @param {string} url Absolute or relative URL of the resource that is being requested;
         *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
         * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
         * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
         * See {@link ng.$http#$http-returns `$http()` return value}.
         */

        /**
         * Shortcut method to perform `HEAD` request.
         *
         * @param {string} url Absolute or relative URL of the resource that is being requested;
         *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
         * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
         * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
         * See {@link ng.$http#$http-returns `$http()` return value}.
         */

        /**
         * Shortcut method to perform `JSONP` request.
         *
         * Note that, since JSONP requests are sensitive because the response is given full access to the browser,
         * the url must be declared, via {@link $sce} as a trusted resource URL.
         * You can trust a URL by adding it to the trusted resource URL list via
         * {@link $sceDelegateProvider#trustedResourceUrlList  `$sceDelegateProvider.trustedResourceUrlList`} or
         * by explicitly trusting the URL via {@link $sce#trustAsResourceUrl `$sce.trustAsResourceUrl(url)`}.
         *
         * You should avoid generating the URL for the JSONP request from user provided data.
         * Provide additional query parameters via `params` property of the `config` parameter, rather than
         * modifying the URL itself.
         *
         * You can also specify a default callback parameter name in `$http.defaults.jsonpCallbackParam`.
         * Initially this is set to `'callback'`.
         *
         * <div class="alert alert-danger">
         * You can no longer use the `JSON_CALLBACK` string as a placeholder for specifying where the callback
         * parameter value should go.
         * </div>
         *
         * If you would like to customise where and how the callbacks are stored then try overriding
         * or decorating the {@link $jsonpCallbacks} service.
         *
         * @param {string} url Absolute or relative URL of the resource that is being requested;
         *                                   or an object created by a call to `$sce.trustAsResourceUrl(url)`.
         * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
         * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
         * See {@link ng.$http#$http-returns `$http()` return value}.
         */
        createShortMethods("get", "delete", "head");

        /**
         * Shortcut method to perform `POST` request.
         *
         * @param {string} url Relative or absolute URL specifying the destination of the request
         * @param {*} data Request content
         * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
         * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
         * See {@link ng.$http#$http-returns `$http()` return value}.
         */

        /**
         * Shortcut method to perform `PUT` request.
         *
         * @param {string} url Relative or absolute URL specifying the destination of the request
         * @param {*} data Request content
         * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
         * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
         * See {@link ng.$http#$http-returns `$http()` return value}.
         */

        /**
         * Shortcut method to perform `PATCH` request.
         *
         * @param {string} url Relative or absolute URL specifying the destination of the request
         * @param {*} data Request content
         * @param {Object=} config Optional configuration object. See {@link ng.$http#$http-arguments `$http()` arguments}.
         * @returns {HttpPromise}  A Promise that will be resolved or rejected with a response object.
         * See {@link ng.$http#$http-returns `$http()` return value}.
         */
        createShortMethodsWithData("post", "put", "patch");

        /**
         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of
         * default headers, withCredentials as well as request and response transformations.
         *
         * See "Setting HTTP Headers" and "Transforming Requests and Responses" sections above.
         */
        $http.defaults = defaults;

        return $http;

        function createShortMethods(...names) {
          names.forEach((name) => {
            $http[name] = function (url, config) {
              return $http(
                extend({}, config || {}, {
                  method: name,
                  url,
                }),
              );
            };
          });
        }

        function createShortMethodsWithData(...names) {
          names.forEach((name) => {
            $http[name] = function (url, data, config) {
              return $http(
                extend({}, config || {}, {
                  method: name,
                  url,
                  data,
                }),
              );
            };
          });
        }

        /**
         * Makes the request.
         *
         * !!! ACCESSES CLOSURE VARS:
         * defaults, $log, $rootScope, defaultCache, $http.pendingRequests
         */
        function sendReq(config, reqData) {
          const { promise, resolve, reject } = Promise.withResolvers();

          let cache;

          let cachedResp;

          const reqHeaders = config.headers;

          let { url } = config;

          if (!isString(url)) {
            // If it is not a string then the URL must be a $sce trusted object
            url = $sce.valueOf(url);
          }

          url = buildUrl(url, config.paramSerializer(config.params));

          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);

          if (
            (config.cache || defaults.cache) &&
            config.cache !== false &&
            config.method === "GET"
          ) {
            cache = isObject(config.cache)
              ? config.cache
              : isObject(/** @type {?} */ (defaults).cache)
                ? /** @type {?} */ (defaults).cache
                : defaultCache;
          }

          if (cache) {
            cachedResp = cache.get(url);

            if (isDefined(cachedResp)) {
              if (isPromiseLike(cachedResp)) {
                // cached request has already been sent, but there is no response yet
                cachedResp.then(
                  resolvePromiseWithResult,
                  resolvePromiseWithResult,
                );
              } else {
                // serving from cache
                if (isArray(cachedResp)) {
                  resolvePromise(
                    cachedResp[1],
                    cachedResp[0],
                    shallowCopy(cachedResp[2]),
                    cachedResp[3],
                    cachedResp[4],
                  );
                } else {
                  resolvePromise(cachedResp, Http._OK, {}, "OK", "complete");
                }
              }
            } else {
              // put the promise for the non-transformed response into cache as a placeholder
              cache.set(url, promise);
            }
          }

          // if we won't have the response in cache, set the xsrf headers and
          // send the request to the backend
          if (isUndefined(cachedResp)) {
            const xsrfValue = urlIsAllowedOrigin(config.url)
              ? $cookie.getAll()[config.xsrfCookieName || defaults.xsrfCookieName]
              : undefined;

            if (xsrfValue) {
              reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] =
                xsrfValue;
            }

            http(
              config.method,
              url,
              reqData,
              done,
              reqHeaders,
              config.timeout,
              config.withCredentials,
              config.responseType,
              createApplyHandlers(config.eventHandlers),
              createApplyHandlers(config.uploadEventHandlers),
            );
          }

          return promise;

          /**
           * @param eventHandlers
           * @return {Record<string, EventListener>}
           */
          function createApplyHandlers(eventHandlers) {
            if (eventHandlers) {
              const applyHandlers = {};

              entries(eventHandlers).forEach(([key, eventHandler]) => {
                applyHandlers[key] = function (event) {
                  if (useApplyAsync) {
                    setTimeout(() => callEventHandler());
                  } else {
                    callEventHandler();
                  }

                  function callEventHandler() {
                    eventHandler(event);
                  }
                };
              });

              return /** @type {Record<string, EventListener>} */ (applyHandlers);
            } else {
              return {};
            }
          }

          /**
           * Callback registered to http():
           *  - caches the response if desired
           *  - resolves the raw $http promise
           *  - calls $apply
           */
          function done(status, response, headersString, statusText, xhrStatus) {
            if (cache) {
              if (isSuccess(status)) {
                cache.set(url, [
                  status,
                  response,
                  parseHeaders(headersString),
                  statusText,
                  xhrStatus,
                ]);
              } else {
                // remove promise from the cache
                cache.delete(url);
              }
            }

            function resolveHttpPromise() {
              resolvePromise(
                response,
                status,
                headersString,
                statusText,
                xhrStatus,
              );
            }

            if (useApplyAsync) {
              setTimeout(resolveHttpPromise);
            } else {
              resolveHttpPromise();
            }
          }

          /**
           * Resolves the raw $http promise.
           */
          function resolvePromise(
            response,
            status,
            headers,
            statusText,
            xhrStatus,
          ) {
            // status: HTTP response status code, 0, -1 (aborted by timeout / promise)
            status = status >= -1 ? status : 0;

            (isSuccess(status) ? resolve : reject)({
              data: response,
              status,
              headers: headersGetter(headers),
              config,
              statusText,
              xhrStatus,
            });
          }

          function resolvePromiseWithResult(result) {
            resolvePromise(
              result.data,
              result.status,
              shallowCopy(result.headers()),
              result.statusText,
              result.xhrStatus,
            );
          }

          function removePendingReq() {
            const idx = $http.pendingRequests.indexOf(config);

            if (idx !== -1) $http.pendingRequests.splice(idx, 1);
          }
        }

        function buildUrl(url, serializedParams) {
          if (serializedParams.length > 0) {
            url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
          }

          return url;
        }
      },
    ];
  }

  /**
   * Makes an HTTP request using XMLHttpRequest with flexible options.
   *
   * @param {string} method - The HTTP method (e.g., "GET", "POST").
   * @param {string} [url] - The URL to send the request to. Defaults to the current page URL.
   * @param {*} [post] - The body to send with the request, if any.
   * @param {function(number, any, string|null, string, string): void} [callback] - Callback invoked when the request completes.
   * @param {Object<string, string|undefined>} [headers] - Headers to set on the request.
   * @param {number|Promise<any>} [timeout] - Timeout in ms or a cancellable promise.
   * @param {boolean} [withCredentials] - Whether to send credentials with the request.
   * @param {XMLHttpRequestResponseType} [responseType] - The type of data expected in the response.
   * @param {Record<string, EventListener>} [eventHandlers] - Event listeners for the XMLHttpRequest object.
   * @param {Record<string, EventListener>} [uploadEventHandlers] - Event listeners for the XMLHttpRequest.upload object.
   * @returns {void}
   */
  function http(
    method,
    url,
    post,
    callback,
    headers,
    timeout,
    withCredentials,
    responseType,
    eventHandlers,
    uploadEventHandlers,
  ) {
    url = url || trimEmptyHash(window.location.href);

    const xhr = new XMLHttpRequest();

    let abortedByTimeout = false;

    let timeoutId;

    xhr.open(method, url, true);

    if (headers) {
      for (const [key, value] of entries(headers)) {
        if (isDefined(value)) {
          xhr.setRequestHeader(key, value);
        }
      }
    }

    xhr.onload = () => {
      let status = xhr.status || 0;

      const statusText = xhr.statusText || "";

      if (status === 0) {
        status = xhr.response
          ? Http._OK
          : new URL(url).protocol === "file:"
            ? Http._NotFound
            : 0;
      }

      completeRequest(
        status,
        xhr.response,
        xhr.getAllResponseHeaders(),
        statusText,
        "complete",
      );
    };

    xhr.onerror = () => completeRequest(-1, null, null, "", "error");
    xhr.ontimeout = () => completeRequest(-1, null, null, "", "timeout");

    xhr.onabort = () => {
      completeRequest(-1, null, null, "", abortedByTimeout ? "timeout" : "abort");
    };

    if (eventHandlers) {
      for (const [key, handler] of entries(eventHandlers)) {
        xhr.addEventListener(key, handler);
      }
    }

    if (uploadEventHandlers) {
      for (const [key, handler] of entries(uploadEventHandlers)) {
        xhr.upload.addEventListener(key, handler);
      }
    }

    if (withCredentials) {
      xhr.withCredentials = true;
    }

    if (responseType) {
      try {
        xhr.responseType = responseType;
      } catch (err) {
        if (responseType !== "json") throw err;
      }
    }

    xhr.send(isUndefined(post) ? null : post);

    if (typeof timeout === "number" && timeout > 0) {
      timeoutId = setTimeout(() => timeoutRequest("timeout"), timeout);
    } else if (isPromiseLike(timeout)) {
      /** @type {Promise} */ (timeout).then(() => {
        timeoutRequest("abort");
      });
    }

    /**
     * @param {"timeout"|"abort"} reason
     */
    function timeoutRequest(reason) {
      abortedByTimeout = reason === "timeout";

      if (xhr) xhr.abort();
    }

    /**
     * @param {number} status - HTTP status code or -1 for network errors.
     * @param {*} response - The parsed or raw response from the server.
     * @param {string|null} headersString - The raw response headers as a string.
     * @param {string} statusText - The status text returned by the server.
     * @param {"complete"|"error"|"timeout"|"abort"} xhrStatus - Final status of the request.
     */
    function completeRequest(
      status,
      response,
      headersString,
      statusText,
      xhrStatus,
    ) {
      if (isDefined(timeoutId)) {
        clearTimeout(timeoutId);
      }
      callback(status, response, headersString, statusText, xhrStatus);
    }
  }

  /**
   * @param {"get" | "delete" | "post" | "put"} method - HTTP method applied to request
   * @param {string} [attrOverride] - Custom name to use for the attribute
   * @returns {ng.DirectiveFactory}
   */
  function defineDirective(method, attrOverride) {
    const attrName =
      attrOverride || `ng${method.charAt(0).toUpperCase()}${method.slice(1)}`;

    const directive = createHttpDirective(method, attrName);

    // @ts-ignore
    directive.$inject = [
      $injectTokens._http,
      $injectTokens._compile,
      $injectTokens._log,
      $injectTokens._parse,
      $injectTokens._state,
      $injectTokens._sse,
      $injectTokens._animate,
    ];

    return directive;
  }

  /** @type {ng.DirectiveFactory} */
  const ngGetDirective = defineDirective("get");

  /** @type {ng.DirectiveFactory} */
  const ngDeleteDirective = defineDirective("delete");

  /** @type {ng.DirectiveFactory} */
  const ngPostDirective = defineDirective("post");

  /** @type {ng.DirectiveFactory} */
  const ngPutDirective = defineDirective("put");

  /** @type {ng.DirectiveFactory} */
  const ngSseDirective = defineDirective("get", "ngSse");

  /**
   * Selects DOM event to listen for based on the element type.
   *
   * @param {Element} element - The DOM element to inspect.
   * @returns {"click" | "change" | "submit"} The name of the event to listen for.
   */
  function getEventNameForElement(element) {
    const tag = element.tagName.toLowerCase();

    if (["input", "textarea", "select"].includes(tag)) {
      return "change";
    } else if (tag === "form") {
      return "submit";
    }

    return "click";
  }

  /**
   * Creates an HTTP directive factory that supports GET, DELETE, POST, PUT.
   *
   * @param {"get" | "delete" | "post" | "put"} method - HTTP method to use.
   * @param {string} attrName - Attribute name containing the URL.
   * @returns {ng.DirectiveFactory}
   */
  function createHttpDirective(method, attrName) {
    /**
     * @param {ng.HttpService} $http
     * @param {ng.CompileService} $compile
     * @param {ng.LogService} $log
     * @param {ng.ParseService} $parse
     * @param {ng.StateService} $state
     * @param {ng.SseService} $sse
     * @param {ng.AnimateService} $animate
     * @returns {ng.Directive}
     */
    return function ($http, $compile, $log, $parse, $state, $sse, $animate) {
      /**
       * Collects form data from the element or its associated form.
       *
       * @param {HTMLElement} element
       * @returns {Object<string, any>}
       */
      function collectFormData(element) {
        /** @type {HTMLFormElement | null} */
        let form = null;

        const tag = element.tagName.toLowerCase();

        if (tag === "form") {
          form = /** @type {HTMLFormElement} */ (element);
        } else if ("form" in element && element.form) {
          // eslint-disable-next-line prefer-destructuring
          form = /** @type {HTMLFormElement} */ (element.form);
        } else if (element.hasAttribute("form")) {
          const formId = element.getAttribute("form");

          if (formId) {
            const maybeForm = document.getElementById(formId);

            if (maybeForm && maybeForm.tagName.toLowerCase() === "form") {
              form = /** @type {HTMLFormElement} */ (maybeForm);
            }
          }
        }

        if (!form) {
          if (
            "name" in element &&
            typeof element.name === "string" &&
            element.name.length > 0
          ) {
            if (
              element instanceof HTMLInputElement ||
              element instanceof HTMLTextAreaElement ||
              element instanceof HTMLSelectElement
            ) {
              const key = element.name;

              const { value } = element;

              return { [key]: value };
            }
          }

          return {};
        }

        const formData = new FormData(form);

        const data = {};

        formData.forEach((value, key) => {
          data[key] = value;
        });

        return data;
      }

      return {
        restrict: "A",
        link(scope, element, attrs) {
          const eventName = attrs.trigger || getEventNameForElement(element);

          const tag = element.tagName.toLowerCase();

          let content = undefined;

          if (isDefined(attrs.latch)) {
            attrs.$observe(
              "latch",
              callBackAfterFirst(() =>
                element.dispatchEvent(new Event(eventName)),
              ),
            );
          }

          let throttled = false;

          let intervalId;

          if (isDefined(attrs.interval)) {
            element.dispatchEvent(new Event(eventName));
            intervalId = setInterval(
              () => element.dispatchEvent(new Event(eventName)),
              parseInt(attrs.interval) || 1000,
            );
          }

          /**
           * Handles DOM manipulation based on a swap strategy and server-rendered HTML.
           *
           * @param {string | Object} html - The HTML string or object returned from the server.
           * @param {import("./interface.ts").SwapModeType} swap
           * @param {ng.Scope} scopeParam
           * @param {ng.Attributes} attrsParam
           * @param {Element} elmenetParam
           */
          function handleSwapResponse(
            html,
            swap,
            scopeParam,
            attrsParam,
            elmenetParam,
          ) {
            let animationEnabled = false;

            if (attrsParam.animate) {
              animationEnabled = true;
            }
            let nodes = [];

            if (!["textcontent", "delete", "none"].includes(swap)) {
              if (!html) return;
              const compiled = $compile(html)(scopeParam);

              nodes =
                compiled instanceof DocumentFragment
                  ? Array.from(compiled.childNodes)
                  : [compiled];
            }

            const targetSelector = attrsParam.target;

            const target = targetSelector
              ? document.querySelector(targetSelector)
              : elmenetParam;

            if (!target) {
              $log.warn(`${attrName}: target "${targetSelector}" not found`);

              return;
            }

            switch (swap) {
              case "outerHTML": {
                const parent = target.parentNode;

                if (!parent) return;

                // Build fragment for static replacement OR a list for animation
                const frag = document.createDocumentFragment();

                nodes.forEach((x) => frag.appendChild(x));

                if (!animationEnabled) {
                  parent.replaceChild(frag, target);
                  break;
                }

                const placeholder = document.createElement("span");

                placeholder.style.display = "none";
                parent.insertBefore(placeholder, target.nextSibling);

                $animate.leave(target).done(() => {
                  const insertedNodes = Array.from(frag.childNodes);

                  // Insert each node in order
                  for (const x of insertedNodes) {
                    if (x.nodeType === NodeType._ELEMENT_NODE) {
                      // Animate elements
                      $animate.enter(
                        /** @type {Element} */ (x),
                        /** @type {Element} */ (parent),
                        placeholder,
                      );
                    } else {
                      // Insert text nodes statically
                      parent.insertBefore(x, placeholder);
                    }
                  }

                  content = insertedNodes;
                  scopeParam.$flushQueue(); // flush once after all insertions
                });

                scopeParam.$flushQueue(); // flush leave animation
                break;
              }

              case "textContent":
                if (animationEnabled) {
                  $animate.leave(target).done(() => {
                    target.textContent = html;
                    $animate.enter(
                      target,
                      /** @type {Element} */ (target.parentNode),
                    );
                    scopeParam.$flushQueue();
                  });

                  scopeParam.$flushQueue();
                } else {
                  target.textContent = html;
                }
                break;

              case "beforebegin": {
                const parent = target.parentNode;

                if (!parent) break;

                nodes.forEach((node) => {
                  if (
                    animationEnabled &&
                    node.nodeType === NodeType._ELEMENT_NODE
                  ) {
                    $animate.enter(node, /** @type {Element} */ (parent), target); // insert before target
                  } else {
                    parent.insertBefore(node, target);
                  }
                });

                if (animationEnabled) scopeParam.$flushQueue();
                break;
              }

              case "afterbegin": {
                const { firstChild } = target;

                [...nodes].reverse().forEach((node) => {
                  if (
                    animationEnabled &&
                    node.nodeType === NodeType._ELEMENT_NODE
                  ) {
                    $animate.enter(
                      node,
                      target,
                      /** @type {Element} */ (firstChild),
                    ); // insert before first child
                  } else {
                    target.insertBefore(node, firstChild);
                  }
                });

                if (animationEnabled) scopeParam.$flushQueue();
                break;
              }

              case "beforeend": {
                nodes.forEach((node) => {
                  if (
                    animationEnabled &&
                    node.nodeType === NodeType._ELEMENT_NODE
                  ) {
                    $animate.enter(node, target, null); // append at end
                  } else {
                    target.appendChild(node);
                  }
                });

                if (animationEnabled) scopeParam.$flushQueue();
                break;
              }

              case "afterend": {
                const parent = target.parentNode;

                if (!parent) break;
                const { nextSibling } = target;

                [...nodes].reverse().forEach((node) => {
                  if (
                    animationEnabled &&
                    node.nodeType === NodeType._ELEMENT_NODE
                  ) {
                    $animate.enter(
                      node,
                      /** @type {Element} */ (parent),
                      /** @type {Element} */ (nextSibling),
                    ); // insert after target
                  } else {
                    parent.insertBefore(node, nextSibling);
                  }
                });

                if (animationEnabled) scopeParam.$flushQueue();
                break;
              }

              case "delete":
                if (animationEnabled) {
                  $animate.leave(target).done(() => {
                    target.remove(); // safety: actually remove in case $animate.leave didn't
                    scopeParam.$flushQueue();
                  });
                  scopeParam.$flushQueue();
                } else {
                  target.remove();
                }
                break;

              case "none":
                break;

              case "innerHTML":
              default:
                if (animationEnabled) {
                  if (content && content.nodeType !== NodeType._TEXT_NODE) {
                    $animate.leave(content).done(() => {
                      content = nodes[0];
                      $animate.enter(nodes[0], target);
                      scopeParam.$flushQueue();
                    });
                    scopeParam.$flushQueue();
                  } else {
                    content = nodes[0];

                    if (content.nodeType === NodeType._TEXT_NODE) {
                      target.replaceChildren(...nodes);
                    } else {
                      $animate.enter(nodes[0], target);
                      scopeParam.$flushQueue();
                    }
                  }
                } else {
                  target.replaceChildren(...nodes);
                }
                break;
            }
          }

          element.addEventListener(eventName, async (event) => {
            if (/** @type {HTMLButtonElement} */ (element).disabled) return;

            if (tag === "form") event.preventDefault();
            const swap =
              /** @type {import("./interface.ts").SwapModeType} */ (attrs.swap) ||
              "innerHTML";

            const url = attrs[attrName];

            if (!url) {
              $log.warn(`${attrName}: no URL specified`);

              return;
            }

            const handler = (res) => {
              if (isDefined(attrs.loading)) {
                attrs.$set("loading", false);
              }

              if (isDefined(attrs.loadingClass)) {
                attrs.$removeClass(attrs.loadingClass);
              }

              const html = res.data;

              if (
                Http._OK <= res.status &&
                res.status <= Http._MultipleChoices - 1
              ) {
                if (isDefined(attrs.success)) {
                  $parse(attrs.success)(scope, { $res: html });
                }

                if (isDefined(attrs.stateSuccess)) {
                  $state.go(attrs.stateSuccess);
                }
              } else if (
                Http._BadRequest <= res.status &&
                res.status <= Http._ErrorMax
              ) {
                if (isDefined(attrs.error)) {
                  $parse(attrs.error)(scope, { $res: html });
                }

                if (isDefined(attrs.stateError)) {
                  $state.go(attrs.stateError);
                }
              }

              if (isObject(html)) {
                if (attrs.target) {
                  scope.$eval(`${attrs.target} = ${JSON.stringify(html)}`);
                } else {
                  scope.$merge(html);
                }
              } else if (isString(html)) {
                handleSwapResponse(html, swap, scope, attrs, element);
              }
            };

            if (isDefined(attrs.delay)) {
              await wait(parseInt(attrs.delay) | 0);
            }

            if (throttled) return;

            if (isDefined(attrs.throttle)) {
              throttled = true;
              attrs.$set("throttled", true);
              setTimeout(() => {
                attrs.$set("throttled", false);
                throttled = false;
              }, parseInt(attrs.throttle));
            }

            if (isDefined(attrs.loading)) {
              attrs.$set("loading", true);
            }

            if (isDefined(attrs.loadingClass)) {
              attrs.$addClass(attrs.loadingClass);
            }

            if (method === "post" || method === "put") {
              let data;

              const config = {};

              if (attrs.enctype) {
                config.headers = {
                  "Content-Type": attrs.enctype,
                };
                data = toKeyValue(collectFormData(element));
              } else {
                data = collectFormData(element);
              }
              $http[method](url, data, config).then(handler).catch(handler);
            } else {
              if (method === "get" && attrs.ngSse) {
                const sseUrl = url;

                const config = {
                  withCredentials: attrs.withCredentials === "true",
                  transformMessage: (data) => {
                    try {
                      return JSON.parse(data);
                    } catch {
                      return data;
                    }
                  },
                  onOpen: () => {
                    $log.info(`${attrName}: SSE connection opened to ${sseUrl}`);

                    if (isDefined(attrs.loading)) attrs.$set("loading", false);

                    if (isDefined(attrs.loadingClass))
                      attrs.$removeClass(attrs.loadingClass);
                  },
                  onMessage: (data) => {
                    const res = { status: 200, data };

                    handler(res);
                  },
                  onError: (err) => {
                    $log.error(`${attrName}: SSE error`, err);
                    const res = { status: 500, data: err };

                    handler(res);
                  },
                  onReconnect: (count) => {
                    $log.info(`ngSse: reconnected ${count} time(s)`);

                    if (attrs.onReconnect)
                      $parse(attrs.onReconnect)(scope, { $count: count });
                  },
                };

                const source = $sse(sseUrl, config);

                scope.$on("$destroy", () => {
                  $log.info(`${attrName}: closing SSE connection`);
                  source.close();
                });
              } else {
                $http[method](url).then(handler).catch(handler);
              }
            }
          });

          if (intervalId) {
            scope.$on("$destroy", () => clearInterval(intervalId));
          }

          if (eventName === "load") {
            element.dispatchEvent(new Event("load"));
          }
        },
      };
    };
  }

  ngWorkerDirective.$inject = [$injectTokens._parse, $injectTokens._log, $injectTokens._exceptionHandler];
  /**
   * Usage: <div ng-worker="workerName" data-params="{{ expression }}" data-on-result="callback($result)"></div>
   *
   * @param {ng.ParseService} $parse
   * @param {ng.LogService} $log
   * @param {ng.ExceptionHandlerService} $exceptionHandler
   * @returns {ng.Directive}
   */
  function ngWorkerDirective($parse, $log, $exceptionHandler) {
    return {
      restrict: "A",
      link(scope, element, attrs) {
        const workerName = attrs.ngWorker;

        if (!workerName) {
          $log.warn("ngWorker: missing worker name");

          return;
        }

        /** @type {string} */
        const eventName = attrs.trigger || getEventNameForElement(element);

        let throttled = false;

        let intervalId;

        if (isDefined(attrs.latch)) {
          attrs.$observe(
            "latch",
            callBackAfterFirst(() => element.dispatchEvent(new Event(eventName))),
          );
        }

        if (isDefined(attrs.interval)) {
          element.dispatchEvent(new Event(eventName));
          intervalId = setInterval(
            () => element.dispatchEvent(new Event(eventName)),
            parseInt(attrs.interval) || 1000,
          );
        }

        const worker = createWorkerConnection(workerName, {
          logger: $log,
          err: $exceptionHandler,
          onMessage: (result) => {
            if (isDefined(attrs.dataOnResult)) {
              $parse(attrs.dataOnResult)(scope, { $result: result });
            } else {
              const swap = attrs.swap || "innerHTML";

              handleSwap(result, swap, element);
            }
          },
          onError: (err) => {
            $log.error(`[ng-worker:${workerName}]`, err);

            if (isDefined(attrs.dataOnError)) {
              $parse(attrs.dataOnError)(scope, { $error: err });
            } else {
              element.textContent = "Error";
            }
          },
        });

        element.addEventListener(eventName, async () => {
          if (element.hasAttribute("disabled")) return;

          if (isDefined(attrs.delay)) {
            await wait(parseInt(attrs.delay) || 0);
          }

          if (throttled) return;

          if (isDefined(attrs.throttle)) {
            throttled = true;
            attrs.$set("throttled", true);
            setTimeout(() => {
              attrs.$set("throttled", false);
              throttled = false;
            }, parseInt(attrs.throttle));
          }

          let params;

          try {
            params = attrs.params ? scope.$eval(attrs.params) : undefined;
          } catch (err) {
            $log.error("ngWorker: failed to evaluate data-params", err);
            params = undefined;
          }

          worker.post(params);
        });

        if (intervalId) {
          scope.$on("$destroy", () => clearInterval(intervalId));
        }

        if (eventName === "load") {
          element.dispatchEvent(new Event("load"));
        }
      },
    };
  }

  /**
   * Swap result into DOM based on strategy
   */
  function handleSwap(result, swap, element) {
    switch (swap) {
      case "outerHTML": {
        const parent = element.parentNode;

        if (!parent) return;
        const temp = document.createElement("div");

        temp.innerHTML = result;
        parent.replaceChild(temp.firstChild, element);
        break;
      }
      case "textContent":
        element.textContent = result;
        break;
      case "beforebegin":
        element.insertAdjacentHTML("beforebegin", result);
        break;
      case "afterbegin":
        element.insertAdjacentHTML("afterbegin", result);
        break;
      case "beforeend":
        element.insertAdjacentHTML("beforeend", result);
        break;
      case "afterend":
        element.insertAdjacentHTML("afterend", result);
        break;
      case "innerHTML":
      default:
        element.innerHTML = result;
        break;
    }
  }

  /**
   * Creates a managed Web Worker connection.
   *
   * @param {string | URL} scriptPath
   * @param {ng.WorkerConfig} [config]
   * @returns {ng.WorkerConnection}
   */
  function createWorkerConnection(scriptPath, config) {
    if (!scriptPath) throw new Error("Worker script path required");

    const defaults = {
      autoRestart: false,
      autoTerminate: false,
      onMessage() {
        /* empty */
      },
      onError() {
        /* empty */
      },
      transformMessage(data) {
        try {
          return JSON.parse(data);
        } catch {
          return data;
        }
      },
    };

    /** @type {ng.WorkerConfig} */
    const cfg = Object.assign({}, defaults, config);

    let worker = new Worker(scriptPath, { type: "module" });

    let terminated = false;

    const reconnect = function () {
      if (terminated) return;
      cfg.logger.info("Worker: restarting...");
      worker.terminate();
      worker = new Worker(scriptPath, { type: "module" });
      wire(worker);
    };

    const wire = (workerParam) => {
      workerParam.onmessage = function (event) {
        let { data } = event;

        try {
          data = cfg.transformMessage(data);
        } catch {
          /* no-op */
        }
        cfg.onMessage(data, event); // always provide both args
      };

      workerParam.onerror = function (err) {
        cfg.onError(err);

        if (cfg.autoRestart) reconnect();
      };
    };

    wire(worker);

    return {
      post(data) {
        if (terminated) {
          cfg.logger.warn("Worker already terminated");
        }

        try {
          worker.postMessage(data);
        } catch (err) {
          cfg.logger.log("Worker post failed", err);
        }
      },

      terminate() {
        terminated = true;
        worker.terminate();
      },

      restart() {
        if (terminated) cfg.logger.warn("Worker cannot restart after terminate");
        reconnect();
      },

      config: cfg,
    };
  }

  /**
   * Modules are collections of application configuration information for components:
   * controllers, directives, filters, etc. They provide recipes for the injector
   * to do the actual instantiation. A module itself has no behaviour but only state.
   * A such, it acts as a data structure between the Angular instance and the injector service.
   */
  class NgModule {
    /**
     * @param {string} name - Name of the module
     * @param {Array<string>} requires - List of modules which the injector will load before the current module
     * @param {ng.Injectable<any>} [configFn]
     */
    constructor(name, requires, configFn) {
      validate(isString, name, "name");
      validate(isArray, requires, "requires");
      /**
       * @public
       * Name of the current module.
       * @type {string}
       */
      this.name = name;

      /**
       * Array of module names that this module depends on.
       * @type {string[]}
       */
      this._requires = requires;

      /**
       * Holds a collection of tasks, required to instantiate an angular component
       * @type {!Array<Array<*>>}
       */
      this._invokeQueue = [];

      /** @type {!Array<Array<*>>} */
      this._configBlocks = [];

      /** @type {!Array.<ng.Injectable<any>>} */
      this._runBlocks = [];

      if (configFn) {
        this.config(configFn);
      }

      this._services = [];

      this._restDefinitions = [];
    }

    /**
     * @param {string} name
     * @param {any} object - Allows undefined
     * @returns {NgModule}
     */
    value(name, object) {
      validate(isString, name, "name");

      this._invokeQueue.push([$injectTokens._provide, "value", [name, object]]);

      return this;
    }

    /**
     * @param {string} name
     * @param {Object|string|number} object
     * @returns {NgModule}
     */
    constant(name, object) {
      validate(isString, name, "name");
      validate(isDefined, object, "object");

      this._invokeQueue.unshift([$injectTokens._provide, "constant", [name, object]]);

      return this;
    }

    /**
     *
     * @param {ng.Injectable<any>} configFn
     * @returns {NgModule}
     */
    config(configFn) {
      validate(isInjectable, configFn, "configFn");

      this._configBlocks.push([$injectTokens._injector, "invoke", [configFn]]);

      return this;
    }

    /**
     * @param {ng.Injectable<any>} block
     * @returns {NgModule}
     */
    run(block) {
      validate(isInjectable, block, "block");

      this._runBlocks.push(block);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.Component} options
     * @returns {NgModule}
     */
    component(name, options) {
      validate(isString, name, "name");
      validate(isDefined, options, "object");

      this._invokeQueue.push([$injectTokens._compileProvider, "component", [name, options]]);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.Injectable<any>} providerFunction
     * @returns {NgModule}
     */
    factory(name, providerFunction) {
      validate(isString, name, "name");
      validateRequired(providerFunction, "providerFunction");
      this._invokeQueue.push([$injectTokens._provide, "factory", [name, providerFunction]]);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.Injectable<any>} serviceFunction
     * @returns {NgModule}
     */
    service(name, serviceFunction) {
      validate(isString, name, "name");
      validateRequired(serviceFunction, "serviceFunction");
      this._services.push(name);
      this._invokeQueue.push([$injectTokens._provide, "service", [name, serviceFunction]]);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.Injectable<any>} providerType
     * @returns {NgModule}
     */
    provider(name, providerType) {
      validate(isString, name, "name");
      validateRequired(providerType, "providerType");
      this._invokeQueue.push([$injectTokens._provide, "provider", [name, providerType]]);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.Injectable<any>} decorFn
     * @returns {NgModule}
     */
    decorator(name, decorFn) {
      validate(isString, name, "name");
      validateRequired(decorFn, "decorFn");
      this._configBlocks.push([$injectTokens._provide, "decorator", [name, decorFn]]);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.Injectable<any>} directiveFactory
     * @returns {NgModule}
     */
    directive(name, directiveFactory) {
      validate(isString, name, "name");
      validateRequired(directiveFactory, "directiveFactory");
      this._invokeQueue.push([
        $injectTokens._compileProvider,
        "directive",
        [name, directiveFactory],
      ]);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.Injectable<any>} animationFactory
     * @returns {NgModule}
     */
    animation(name, animationFactory) {
      validate(isString, name, "name");
      validateRequired(animationFactory, "animationFactory");
      this._invokeQueue.push([
        $injectTokens._animateProvider,
        "register",
        [name, animationFactory],
      ]);

      return this;
    }

    /**
     * @param {string} name
     * @param {ng.FilterFactory} filterFn
     * @return {NgModule}
     */
    filter(name, filterFn) {
      validate(isString, name, "name");
      validate(isFunction, filterFn, `filterFn`);
      this._invokeQueue.push([$injectTokens._filterProvider, "register", [name, filterFn]]);

      return this;
    }

    /**
     * The $controller service is used by Angular to create new controllers.
     * This provider allows controller registration via the register method.
     *
     * @param {string} name Controller name
     * @param {ng.Injectable<ng.ControllerConstructor>} ctlFn Controller constructor fn (optionally decorated with DI annotations in the array notation)
     * @returns {NgModule}
     */
    controller(name, ctlFn) {
      validate(isString, name, "name");
      validateRequired(ctlFn, `fictlFnlterFn`);
      this._invokeQueue.push([$injectTokens._controllerProvider, "register", [name, ctlFn]]);

      return this;
    }

    /**
     * Register a named WebAssembly module that will be instantiated via $provide.
     *
     * @param {string} name - The injectable name used to access the instantiated WebAssembly module.
     *
     * @param {string} src - URL of the `.wasm` file to fetch and instantiate.
     *
     * @param {Object<string, any>} [imports] WebAssembly import object, passed to `WebAssembly.instantiate` or  `WebAssembly.instantiateStreaming`.
     *
     * @param {Object<string, any>} [opts] - Configuration object.
     *
     *   Supported keys:
     *   - **raw**: `boolean`
     *       - `false` (default): the injectable resolves to `instance.exports`
     *         (ideal for plain WASM modules).
     *       - `true`: the injectable resolves to the full instantiation result:
     *         `{ instance, exports, module }`
     *         (required for runtimes such as Go, Emscripten, wasm-bindgen, etc).
     *
     * @returns {NgModule}
     */
    wasm(name, src, imports = {}, opts = {}) {
      validate(isString, name, "name");
      validate(isString, src, "src");
      const raw = !!opts.raw;

      this._invokeQueue.push([
        $injectTokens._provide,
        "provider",
        [
          name,
          class {
            $get() {
              return instantiateWasm(src, imports).then((result) =>
                raw ? result : result.exports,
              );
            }
          },
        ],
      ]);

      return this;
    }

    /**
     * Register a named worker that will be instantiated via $provide.
     *
     * @param {string} name
     * @param {string | URL} scriptPath
     * @param {ng.WorkerConfig} [config]
     * @returns {NgModule}
     */
    worker(name, scriptPath, config) {
      validate(isString, name, "name");
      validate(isString, scriptPath, "scriptPath");
      this._invokeQueue.push([
        $injectTokens._provide,
        "provider",
        [
          name,
          class {
            $get = () => createWorkerConnection(scriptPath, config);
          },
        ],
      ]);

      return this;
    }

    /**
     * @param {string} name
     * @param {Function|Object} ctor - A regular function, an arrow function or an object
     * @param {ng.StorageType} type
     * @param {ng.StorageBackend} [backendOrConfig]
     * @returns {NgModule}
     */
    store(name, ctor, type, backendOrConfig) {
      validate(isString, name, "name");
      validateRequired(ctor, "ctor");
      this._invokeQueue.push([
        $injectTokens._provide,
        "store",
        [name, isObject(ctor) ? () => ctor : ctor, type, backendOrConfig],
      ]);

      return this;
    }

    /**
     * @template T, ID
     * Register a REST resource during module configuration.
     * @param {string} name - Service name
     * @param {string} url - Base URL or URI template
     * @param {ng.EntityClass<T>} entityClass - Optional constructor for mapping JSON
     * @param {Object=} options - Optional RestService options (interceptors, etc)
     * @returns {NgModule}
     */
    rest(name, url, entityClass, options = {}) {
      validate(isString, name, "name");
      validate(isString, url, "url");
      validate(isFunction, entityClass, "entityClass");
      const def = { name, url, entityClass, options };

      this._restDefinitions.push(def);

      // push provider/factory to invokeQueue
      this._invokeQueue.push([
        $injectTokens._provide,
        "factory",
        [
          name,
          [
            $injectTokens._rest,
            /** @param {(baseUrl:string, entityClass?:Function, options?:object) => ng.RestService<T, ID>} $rest */ (
              $rest,
            ) => $rest(url, entityClass, options),
          ],
        ],
      ]);

      return this;
    }
  }

  /**
   * A type-safe wrapper around a DOM Node, HTMLElement, HTML string, NodeList, or an array of Nodes.
   * Provides guarantees around presence and access.
   */
  class NodeRef {
    static $nonscope = true;
    /**
     * @param {Node | Element | string | NodeList | Node[]} element - The DOM node(s) or HTML string to wrap.
     * @throws {Error} If the argument is invalid or cannot be wrapped properly.
     */
    constructor(element) {
      /** @private @type {Node | ChildNode | null} */
      this._node = null;

      /** @type {Element | undefined} */
      this._element = undefined;

      /** @private @type {Array<Node> | undefined} a stable list on nodes */
      this._nodes = undefined;

      /** @type {boolean} */
      this._isList = false;

      // Handle HTML string
      if (isString(element)) {
        const res = createElementFromHTML(/** @type {string} */ (element));

        switch (true) {
          case res instanceof Element:
            this.element = res;
            break;
          case res instanceof Node:
            this.node = res;
            break;
        }
      }

      // Handle NodeList
      else if (element instanceof NodeList) {
        if (element.length === 1) {
          this.node = element[0];
        } else {
          this._nodes = Array.from(element);
          this._isList = true;
        }
      }

      // Handle single Element
      else if (element instanceof Element) {
        this.element = /** @type {Element} */ element;
      }

      // Handle single Node
      else if (element instanceof Node) {
        this._node = element;
      }

      // Handle array of elements
      else if (isArray(element)) {
        if (element.length === 1) {
          this.node = /** @type {Node} */ (element[0]);
        } else {
          this.nodes = /** @type {Node[]} */ (element);
        }
      } else {
        throw new Error("Invalid element passed to NodeRef");
      }
    }

    /** @returns {Element} */
    get element() {
      return /** @type {Element} */ (this._element);
    }

    /** @param {Element} el */
    set element(el) {
      this._element = el;
      this._isList = false;
    }

    /** @returns {Node | ChildNode} */
    get node() {
      return /** @type {Node | ChildNode} */ (this._node || this._element);
    }

    /** @param {Node | ChildNode} node */
    set node(node) {
      this._node = node;

      if (node.nodeType === NodeType._ELEMENT_NODE) {
        this._element = /** @type {Element} */ (node);
      } else {
        this._element = undefined;
      }
    }

    /** @param {Array<Node>} nodes */
    set nodes(nodes) {
      this._nodes = nodes;
      this._isList = true;
    }

    /** @returns {Array<Node>} */
    get nodes() {
      return this._nodes;
    }

    /** @returns {NodeList|Node[]} */
    get nodelist() {
      if (this._nodes.length === 0) return [];

      if (this._nodes[0].parentElement)
        return this._nodes[0].parentElement.childNodes;
      const fragment = document.createDocumentFragment();

      this._nodes.forEach((el) => fragment.appendChild(el));

      return fragment.childNodes;
    }

    /** @returns {Element | Node | ChildNode | NodeList | Node[]} */
    get dom() {
      if (this._isList) return this.nodelist;
      else return this.node;
    }

    /** @returns {number} */
    get size() {
      return this._isList ? this._nodes.length : 1;
    }

    /** @returns {Element | Node | ChildNode} */
    _getAny() {
      if (this._isList) {
        return this._nodes[0];
      } else {
        return this._element || this._node;
      }
    }

    /** @returns {Element | Array<Node> | Node | ChildNode} */
    _getAll() {
      if (this._isList) {
        return this._nodes;
      } else {
        return this._element || this._node;
      }
    }

    /** @returns {Array<Element> | Array<Node>} */
    _collection() {
      if (this._isList) {
        return Array.from(this._nodes);
      } else {
        return [this._element || this._node];
      }
    }

    /**
     * @param {number} index
     * @returns {Element | Node | ChildNode}
     */
    _getIndex(index) {
      if (this._isList) {
        return this._nodes[index];
      } else {
        return this.node;
      }
    }

    /**
     * @param {number} index
     * @param {Element | Node | ChildNode} node
     */
    _setIndex(index, node) {
      if (this._isList) {
        this._nodes[index] = node;
      } else {
        this.node = node;
      }
    }

    /**
     * @returns {NodeRef}
     */
    _clone() {
      const cloned = this._isList
        ? this.nodes.map((el) => el.cloneNode(true))
        : this.node.cloneNode(true);

      return new NodeRef(cloned);
    }

    _isElement() {
      return this._element !== undefined;
    }
  }

  const $controllerMinErr = minErr("$controller");

  const CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;

  function identifierForController(controller, ident) {

    if (isString(controller)) {
      const match = CNTRL_REG.exec(controller);

      if (match) return match[3];
    }

    return undefined;
  }

  /**
   * The {@link ng.$controller $controller service} is used by AngularTS to create new
   * controllers.
   *
   * This provider allows controller registration via the
   * {@link ng.$controllerProvider#register register} method.
   */
  class ControllerProvider {
    constructor() {
      /**
       * @type {Map<string, Function|Object>}
       * @private
       */
      this.controllers = new Map();
    }

    /**
     * Check if a controller with a given name exists.
     *
     * @param {string} name Controller name to check.
     * @returns {boolean} True if the controller exists, false otherwise.
     */
    has(name) {
      return this.controllers.has(name);
    }

    /**
     * Register a controller.
     *
     * @param {string|Object} name Controller name, or an object map of controllers where the keys are
     *    the names and the values are the constructors.
     * @param {Function|Array} constructor Controller constructor function (optionally decorated with DI
     *    annotations in the array notation).
     */
    register(name, constructor) {
      assertNotHasOwnProperty(name, "controller");

      if (isObject(name)) {
        entries(name).forEach(([key, value]) => {
          this.controllers.set(key, value);
        });
      } else {
        this.controllers.set(name, constructor);
      }
    }

    /**
     * $get method for dependency injection.
     */
    $get = [
      $injectTokens._injector,

      /**
       * @param {ng.InjectorService} $injector
       * @returns {import("./interface.ts").ControllerService} A service function that creates controllers.
       */
      ($injector) => {
        return (expression, locals, later, ident) => {
          let instance;

          let match;

          let constructor;

          let identifier = ident && isString(ident) ? ident : null;

          later = later === true;

          if (isString(expression)) {
            match = /** @type {string} */ (expression).match(CNTRL_REG);

            if (!match) {
              throw $controllerMinErr(
                "ctrlfmt",
                "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.",
                expression,
              );
            }
            constructor = match[1];
            identifier = identifier || match[3];
            expression = this.controllers.get(constructor);

            if (!expression) {
              throw $controllerMinErr(
                "ctrlreg",
                "The controller with the name '{0}' is not registered.",
                constructor,
              );
            }

            assertArgFn(expression, constructor, true);
          }

          if (later) {
            const controllerPrototype = (
              isArray(expression) ? expression[expression.length - 1] : expression
            ).prototype;

            instance = Object.create(controllerPrototype || null);

            if (identifier) {
              instance.$controllerIdentifier = identifier;
              this.addIdentifier(
                locals,
                identifier,
                instance,
                constructor || /** @type {any} */ (expression).name,
              );
            }

            if (instance?.constructor?.$scopename) {
              locals.$scope.$scopename = instance.constructor.$scopename;
            }

            return function () {
              const result = $injector.invoke(
                expression,
                instance,
                locals,
                constructor,
              );

              if (
                result !== instance &&
                (isObject(result) || isFunction(result))
              ) {
                instance = result;

                if (identifier) {
                  instance.$controllerIdentifier = identifier;
                  this.addIdentifier(
                    locals,
                    identifier,
                    instance,
                    constructor || /** @type {any} */ (expression).name,
                  );
                }
              }

              return instance;
            }.bind(this, { instance, identifier });
          }

          instance = $injector.instantiate(
            /** @type {any} */ (expression),
            locals,
            constructor,
          );

          if (identifier) {
            this.addIdentifier(
              locals,
              identifier,
              instance,
              constructor || /** @type {any} */ (expression).name,
            );
          }

          return instance;
        };
      },
    ];

    /**
     * Adds an identifier to the controller instance in the given locals' scope.
     *
     * @param {Object} locals The locals object containing the scope.
     * @param {string} identifier The identifier to assign.
     * @param {Object} instance The controller instance.
     * @param {string} name The name of the controller.
     */
    addIdentifier(locals, identifier, instance, name) {
      if (!(locals && isObject(locals.$scope))) {
        throw minErr("$controller")(
          "noscp",
          "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.",
          name,
          identifier,
        );
      }
      locals.$scope[identifier] = instance;
      locals.$scope.$controllerIdentifier = identifier;
    }
  }

  const $sceMinErr = minErr("$sce");

  const SCE_CONTEXTS = {
    // HTML is used when there's HTML rendered (e.g. ng-bind-html, iframe srcdoc binding).
    HTML: "html",

    // Style statements or stylesheets. Currently unused in AngularTS.
    CSS: "css",

    // An URL used in a context where it refers to the source of media, which are not expected to be run
    // as scripts, such as an image, audio, video, etc.
    MEDIA_URL: "mediaUrl",

    // An URL used in a context where it does not refer to a resource that loads code.
    // A value that can be trusted as a URL can also trusted as a MEDIA_URL.
    URL: "url",

    // RESOURCE_URL is a subtype of URL used where the referred-to resource could be interpreted as
    // code. (e.g. ng-include, script src binding, templateUrl)
    // A value that can be trusted as a RESOURCE_URL, can also trusted as a URL and a MEDIA_URL.
    RESOURCE_URL: "resourceUrl",

    // Script. Currently unused in AngularTS.
    JS: "js",
  };

  // Copied from:
  // http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021
  // Prereq: s is a string.
  function escapeForRegexp(str) {
    return str.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1");
  }

  /**
   * Adjusts a matcher string or RegExp into a proper RegExp.
   *
   * @param {string | RegExp | "self"} matcher
   * @returns {RegExp | "self"}
   */
  function adjustMatcher(matcher) {
    if (matcher === "self") {
      return matcher;
    }

    if (isString(matcher)) {
      // Strings match exactly except for 2 wildcards - '*' and '**'.
      // '*' matches any character except those from the set ':/.?&'.
      // '**' matches any character (like .* in a RegExp).
      // More than 2 *'s raises an error as it's ill defined.
      if (matcher.indexOf("***") > -1) {
        throw $sceMinErr(
          "iwcard",
          "Illegal sequence *** in string matcher.  String: {0}",
          matcher,
        );
      }
      matcher = escapeForRegexp(matcher)
        .replace(/\\\*\\\*/g, ".*")
        .replace(/\\\*/g, "[^:/.?&;]*");

      return new RegExp(`^${matcher}$`);
    }

    if (isRegExp(matcher)) {
      // The only other type of matcher allowed is a Regexp.
      // Match entire URL / disallow partial matches.
      // Flags are reset (i.e. no global, ignoreCase or multiline)
      return new RegExp(`^${matcher.source}$`);
    }
    throw $sceMinErr(
      "imatcher",
      'Matchers may only be "self", string patterns or RegExp objects',
    );
  }

  /**
   * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict
   * Contextual Escaping (SCE)} services to AngularTS.
   *
   * For an overview of this service and the functionality it provides in AngularTS, see the main
   * page for {@link ng.$sce SCE}. The current page is targeted for developers who need to alter how
   * SCE works in their application, which shouldn't be needed in most cases.
   *
   * <div class="alert alert-danger">
   * AngularTS strongly relies on contextual escaping for the security of bindings: disabling or
   * modifying this might cause cross site scripting (XSS) vulnerabilities. For libraries owners,
   * changes to this service will also influence users, so be extra careful and document your changes.
   * </div>
   *
   * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of
   * the `$sce` service to customize the way Strict Contextual Escaping works in AngularTS.  This is
   * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to
   * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things
   * work because `$sce` delegates to `$sceDelegate` for these operations.
   *
   * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.
   *
   * The default instance of `$sceDelegate` should work out of the box with little pain.  While you
   * can override it completely to change the behavior of `$sce`, the common case would
   * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting
   * your own trusted and banned resource lists for trusting URLs used for loading AngularTS resources
   * such as templates.  Refer {@link ng.$sceDelegateProvider#trustedResourceUrlList
   * $sceDelegateProvider.trustedResourceUrlList} and {@link
   * ng.$sceDelegateProvider#bannedResourceUrlList $sceDelegateProvider.bannedResourceUrlList}
   */

  /**
   *
   * The `$sceDelegateProvider` provider allows developers to configure the {@link ng.$sceDelegate
   * $sceDelegate service}, used as a delegate for {@link ng.$sce Strict Contextual Escaping (SCE)}.
   *
   * The `$sceDelegateProvider` allows one to get/set the `trustedResourceUrlList` and
   * `bannedResourceUrlList` used to ensure that the URLs used for sourcing AngularTS templates and
   * other script-running URLs are safe (all places that use the `$sce.RESOURCE_URL` context). See
   * {@link ng.$sceDelegateProvider#trustedResourceUrlList
   * $sceDelegateProvider.trustedResourceUrlList} and
   * {@link ng.$sceDelegateProvider#bannedResourceUrlList $sceDelegateProvider.bannedResourceUrlList},
   *
   * For the general details about this service in AngularTS, read the main page for {@link ng.$sce
   * Strict Contextual Escaping (SCE)}.
   *
   * **Example**:  Consider the following case. <a name="example"></a>
   *
   * - your app is hosted at url `http://myapp.example.com/`
   * - but some of your templates are hosted on other domains you control such as
   *   `http://srv01.assets.example.com/`, `http://srv02.assets.example.com/`, etc.
   * - and you have an open redirect at `http://myapp.example.com/clickThru?...`.
   *
   * Here is what a secure configuration for this scenario might look like:
   *
   * ```
   *  angular.module('myApp', []).config(function($sceDelegateProvider) {
   *    $sceDelegateProvider.trustedResourceUrlList([
   *      // Allow same origin resource loads.
   *      'self',
   *      // Allow loading from our assets domain.  Notice the difference between * and **.
   *      'http://srv*.assets.example.com/**'
   *    ]);
   *
   *    // The banned resource URL list overrides the trusted resource URL list so the open redirect
   *    // here is blocked.
   *    $sceDelegateProvider.bannedResourceUrlList([
   *      'http://myapp.example.com/clickThru**'
   *    ]);
   *  });
   * ```
   * Note that an empty trusted resource URL list will block every resource URL from being loaded, and will require
   * you to manually mark each one as trusted with `$sce.trustAsResourceUrl`. However, templates
   * requested by {@link ng.$templateRequest $templateRequest} that are present in
   * {@link ng.$templateCache $templateCache} will not go through this check. If you have a mechanism
   * to populate your templates in that cache at config time, then it is a good idea to remove 'self'
   * from the trusted resource URL lsit. This helps to mitigate the security impact of certain types
   * of issues, like for instance attacker-controlled `ng-includes`.
   */
  class SceDelegateProvider {
    constructor() {
      // Resource URLs can also be trusted by policy.
      /** @type {Array<RegExp | "self">} */
      let trustedResourceUrlList = ["self"];

      /** @type {Array<RegExp | "self">} */
      let bannedResourceUrlList = [];

      /**
       *
       * @param {Array=} value When provided, replaces the trustedResourceUrlList with
       *     the value provided.  This must be an array or null.  A snapshot of this array is used so
       *     further changes to the array are ignored.
       *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
       *     allowed in this array.
       *
       * @return {Array} The currently set trusted resource URL array.
       *
       * @description
       * Sets/Gets the list trusted of resource URLs.
       *
       * The **default value** when no `trustedResourceUrlList` has been explicitly set is `['self']`
       * allowing only same origin resource requests.
       *
       * <div class="alert alert-warning">
       * **Note:** the default `trustedResourceUrlList` of 'self' is not recommended if your app shares
       * its origin with other apps! It is a good idea to limit it to only your application's directory.
       * </div>
       */
      this.trustedResourceUrlList = function (value) {
        if (arguments.length) {
          trustedResourceUrlList = value.map(adjustMatcher);
        }

        return trustedResourceUrlList;
      };

      /**
       *
       * @param {Array=} bannedResourceUrlList When provided, replaces the `bannedResourceUrlList` with
       *     the value provided. This must be an array or null. A snapshot of this array is used so
       *     further changes to the array are ignored.</p><p>
       *     Follow {@link ng.$sce#resourceUrlPatternItem this link} for a description of the items
       *     allowed in this array.</p><p>
       *     The typical usage for the `bannedResourceUrlList` is to **block
       *     [open redirects](http://cwe.mitre.org/data/definitions/601.html)** served by your domain as
       *     these would otherwise be trusted but actually return content from the redirected domain.
       *     </p><p>
       *     Finally, **the banned resource URL list overrides the trusted resource URL list** and has
       *     the final say.
       *
       * @return {Array} The currently set `bannedResourceUrlList` array.
       *
       * @description
       * Sets/Gets the `bannedResourceUrlList` of trusted resource URLs.
       *
       * The **default value** when no trusted resource URL list has been explicitly set is the empty
       * array (i.e. there is no `bannedResourceUrlList`.)
       */
      this.bannedResourceUrlList = function (value) {
        if (arguments.length) {
          bannedResourceUrlList = value.map(adjustMatcher);
        }

        return bannedResourceUrlList;
      };

      this.$get = [
        $injectTokens._injector,
        $injectTokens._sanitizeUri,
        $injectTokens._exceptionHandler,
        /**
         *
         * @param {ng.InjectorService} $injector
         * @param {import("../../core/sanitize/interface.ts").SanitizerFn} $$sanitizeUri
         * @param {ng.ExceptionHandlerService} $exceptionHandler
         * @returns
         */
        function ($injector, $$sanitizeUri, $exceptionHandler) {
          let htmlSanitizer = function () {
            $exceptionHandler(
              $sceMinErr(
                "unsafe",
                "Attempting to use an unsafe value in a safe context.",
              ),
            );
          };

          if ($injector.has("$sanitize")) {
            htmlSanitizer = $injector.get("$sanitize");
          }

          /**
           * @param {string|RegExp} matcher
           * @param {import("../../shared/url-utils/interface.ts").ParsedUrl} parsedUrl
           * @return {boolean}
           */
          function matchUrl(matcher, parsedUrl) {
            if (matcher === "self") {
              return (
                urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl)
              );
            }

            // definitely a regex.  See adjustMatchers()
            return !!(/** @type {RegExp} */ (matcher).exec(parsedUrl.href));
          }

          function isResourceUrlAllowedByPolicy(url) {
            const parsedUrl = urlResolve(url.toString());

            let i,
              j,
              allowed = false;

            // Ensure that at least one item from the trusted resource URL list allows this url.
            for (i = 0, j = trustedResourceUrlList.length; i < j; i++) {
              if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }

            if (allowed) {
              // Ensure that no item from the banned resource URL list has blocked this url.
              for (i = 0, j = bannedResourceUrlList.length; i < j; i++) {
                if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }

            return allowed;
          }

          function generateHolderType(Base) {
            const holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function () {
                return trustedValue;
              };
            };

            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };

            return holderType;
          }

          const trustedValueHolderBase = generateHolderType();

          const byType = {};

          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(
            trustedValueHolderBase,
          );
          byType[SCE_CONTEXTS.URL] = generateHolderType(
            byType[SCE_CONTEXTS.MEDIA_URL],
          );
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(
            byType[SCE_CONTEXTS.URL],
          );

          /**
           * Returns a trusted representation of the parameter for the specified context. This trusted
           * object will later on be used as-is, without any security check, by bindings or directives
           * that require this security context.
           * For instance, marking a string as trusted for the `$sce.HTML` context will entirely bypass
           * the potential `$sanitize` call in corresponding `$sce.HTML` bindings or directives, such as
           * `ng-bind-html`. Note that in most cases you won't need to call this function: if you have the
           * sanitizer loaded, passing the value itself will render all the HTML that does not pose a
           * security risk.
           *
           * See {@link ng.$sceDelegate#getTrusted getTrusted} for the function that will consume those
           * trusted values, and {@link ng.$sce $sce} for general documentation about strict contextual
           * escaping.
           *
           * @param {string} type The context in which this value is safe for use, e.g. `$sce.URL`,
           *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.
           *
           * @param {*} trustedValue The value that should be considered trusted.
           * @return {*} A trusted representation of value, that can be used in the given context.
           */
          function trustAs(type, trustedValue) {
            const Constructor = hasOwn(byType, type) ? byType[type] : null;

            if (!Constructor) {
              $exceptionHandler(
                $sceMinErr(
                  "icontext",
                  "Attempted to trust a value in invalid context. Context: {0}; Value: {1}",
                  type,
                  trustedValue,
                ),
              );

              return undefined;
            }

            if (
              trustedValue === null ||
              isUndefined(trustedValue) ||
              trustedValue === ""
            ) {
              return trustedValue;
            }

            // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting
            // mutable objects, we ensure here that the value passed in is actually a string.
            if (typeof trustedValue !== "string") {
              $exceptionHandler(
                $sceMinErr(
                  "itype",
                  "Attempted to trust a non-string value in a content requiring a string: Context: {0}",
                  type,
                ),
              );

              return undefined;
            }

            const tst = new Constructor(trustedValue);

            return tst;
          }

          /**
           * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs
           * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link
           * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.
           *
           * If the passed parameter is not a value that had been returned by {@link
           * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, it must be returned as-is.
           *
           * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}
           *     call or anything else.
           * @return {*} The `value` that was originally provided to {@link ng.$sceDelegate#trustAs
           *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns
           *     `value` unchanged.
           */
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            }

            return maybeTrusted;
          }

          /**
           * @description
           * Given an object and a security context in which to assign it, returns a value that's safe to
           * use in this context, which was represented by the parameter. To do so, this function either
           * unwraps the safe type it has been given (for instance, a {@link ng.$sceDelegate#trustAs
           * `$sceDelegate.trustAs`} result), or it might try to sanitize the value given, depending on
           * the context and sanitizer availablility.
           *
           * The contexts that can be sanitized are $sce.MEDIA_URL, $sce.URL and $sce.HTML. The first two are available
           * by default, and the third one relies on the `$sanitize` service (which may be loaded through
           * the `ngSanitize` module). Furthermore, for $sce.RESOURCE_URL context, a plain string may be
           * accepted if the resource url policy defined by {@link ng.$sceDelegateProvider#trustedResourceUrlList
           * `$sceDelegateProvider.trustedResourceUrlList`} and {@link ng.$sceDelegateProvider#bannedResourceUrlList
           * `$sceDelegateProvider.bannedResourceUrlList`} accepts that resource.
           *
           * This function will throw if the safe type isn't appropriate for this context, or if the
           * value given cannot be accepted in the context (which might be caused by sanitization not
           * being available, or the value not being recognized as safe).
           *
           * <div class="alert alert-danger">
           * Disabling auto-escaping is extremely dangerous, it usually creates a Cross Site Scripting
           * (XSS) vulnerability in your application.
           * </div>
           *
           * @param {string} type The context in which this value is to be used (such as `$sce.HTML`).
           * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs
           *     `$sceDelegate.trustAs`} call, or anything else (which will not be considered trusted.)
           * @return {*} A version of the value that's safe to use in the given context, or throws an
           *     exception if this is impossible.
           */
          function getTrusted(type, maybeTrusted) {
            if (
              maybeTrusted === null ||
              isUndefined(maybeTrusted) ||
              maybeTrusted === ""
            ) {
              return maybeTrusted;
            }
            const constructor = hasOwn(byType, type) ? byType[type] : null;

            // If maybeTrusted is a trusted class instance or subclass instance, then unwrap and return
            // as-is.
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }

            // If maybeTrusted is a trusted class instance but not of the correct trusted type
            // then unwrap it and allow it to pass through to the rest of the checks
            if (isFunction(maybeTrusted.$$unwrapTrustedValue)) {
              maybeTrusted = maybeTrusted.$$unwrapTrustedValue();
            }

            // If we get here, then we will either sanitize the value or throw an exception.
            if (type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) {
              // we attempt to sanitize non-resource URLs
              return $$sanitizeUri(
                maybeTrusted.toString(),
                type === SCE_CONTEXTS.MEDIA_URL,
              );
            }

            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              }
              $exceptionHandler(
                $sceMinErr(
                  "insecurl",
                  "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}",
                  maybeTrusted.toString(),
                ),
              );

              return undefined;
            } else if (type === SCE_CONTEXTS.HTML) {
              // htmlSanitizer throws its own error when no sanitizer is available.
              return htmlSanitizer();
            }

            // Default error when the $sce service has no way to make the input safe.
            return $exceptionHandler(
              $sceMinErr(
                "unsafe",
                "Attempting to use an unsafe value in a safe context.",
              ),
            );
          }

          return { trustAs, getTrusted, valueOf };
        },
      ];
    }
  }

  function SceProvider() {
    let enabled = true;

    /**
     * @param {boolean=} value If provided, then enables/disables SCE application-wide.
     * @return {boolean} True if SCE is enabled, false otherwise.
     *
     * @description
     * Enables/disables SCE and returns the current value.
     */
    this.enabled = function (value) {
      if (arguments.length) {
        enabled = !!value;
      }

      return enabled;
    };

    this.$get = [
      $injectTokens._parse,
      $injectTokens._sceDelegate,
      /**
       *
       * @param {ng.ParseService} $parse
       * @param $sceDelegate
       * @return {*}
       */
      ($parse, $sceDelegate) => {
        const sce = shallowCopy(SCE_CONTEXTS);

        /**
         * @return {Boolean} True if SCE is enabled, false otherwise.  If you want to set the value, you
         *     have to do it at module config time on {@link ng.$sceProvider $sceProvider}.
         *
         * @description
         * Returns a boolean indicating if SCE is enabled.
         */
        sce.isEnabled = function () {
          return enabled;
        };
        sce.trustAs = $sceDelegate.trustAs;
        sce.getTrusted = $sceDelegate.getTrusted;
        sce.valueOf = $sceDelegate.valueOf;

        if (!enabled) {
          sce.trustAs = sce.getTrusted = function (type, value) {
            return value;
          };
          sce.valueOf = (v) => v;
        }

        /**
         * Converts AngularTS {@link guide/expression expression} into a function.  This is like {@link
         * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it
         * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,
         * *result*)}
         *
         * @param {string} type The SCE context in which this result will be used.
         * @param {string} expr String expression to compile.
         * @return {import("../../core/parse/interface.ts").CompiledExpression} A function which represents the compiled expression:
         *
         *    * `context` – `{object}` – an object against which any expressions embedded in the
         *      strings are evaluated against (typically a scope object).
         *    * `locals` – `{object=}` – local variables context object, useful for overriding values
         *      in `context`.
         */
        sce.parseAs = (type, expr) => {
          const parsed = $parse(expr);

          if (parsed.literal && parsed.constant) {
            return parsed;
          }

          return $parse(expr, (value) => sce.getTrusted(type, value));
        };

        /**
         * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}. As such, returns a
         * wrapped object that represents your value, and the trust you have in its safety for the given
         * context. AngularTS can then use that value as-is in bindings of the specified secure context.
         * This is used in bindings for `ng-bind-html`, `ng-include`, and most `src` attribute
         * interpolations. See {@link ng.$sce $sce} for strict contextual escaping.
         *
         * @param {string} type The context in which this value is safe for use, e.g. `$sce.URL`,
         *     `$sce.RESOURCE_URL`, `$sce.HTML`, `$sce.JS` or `$sce.CSS`.
         *
         * @param {*} value The value that that should be considered trusted.
         * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
         *     in the context you specified.
         */

        /**
         * Shorthand method.  `$sce.trustAsHtml(value)` →
         *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}
         *
         * @param {*} value The value to mark as trusted for `$sce.HTML` context.
         * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
         *     in `$sce.HTML` context (like `ng-bind-html`).
         */

        /**
         * Shorthand method.  `$sce.trustAsCss(value)` →
         *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.CSS, value)`}
         *
         * @param {*} value The value to mark as trusted for `$sce.CSS` context.
         * @return {*} A wrapped version of value that can be used as a trusted variant
         *     of your `value` in `$sce.CSS` context. This context is currently unused, so there are
         *     almost no reasons to use this function so far.
         */

        /**
         * Shorthand method.  `$sce.trustAsUrl(value)` →
         *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}
         *
         * @param {*} value The value to mark as trusted for `$sce.URL` context.
         * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
         *     in `$sce.URL` context. That context is currently unused, so there are almost no reasons
         *     to use this function so far.
         */

        /**
         * Shorthand method.  `$sce.trustAsResourceUrl(value)` →
         *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}
         *
         * @param {*} value The value to mark as trusted for `$sce.RESOURCE_URL` context.
         * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
         *     in `$sce.RESOURCE_URL` context (template URLs in `ng-include`, most `src` attribute
         *     bindings, ...)
         */

        /**
         * Shorthand method.  `$sce.trustAsJs(value)` →
         *     {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}
         *
         * @param {*} value The value to mark as trusted for `$sce.JS` context.
         * @return {*} A wrapped version of value that can be used as a trusted variant of your `value`
         *     in `$sce.JS` context. That context is currently unused, so there are almost no reasons to
         *     use this function so far.
         */

        /**
         * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,
         * takes any input, and either returns a value that's safe to use in the specified context,
         * or throws an exception. This function is aware of trusted values created by the `trustAs`
         * function and its shorthands, and when contexts are appropriate, returns the unwrapped value
         * as-is. Finally, this function can also throw when there is no way to turn `maybeTrusted` in a
         * safe value (e.g., no sanitization is available or possible.)
         *
         * @param {string} type The context in which this value is to be used.
         * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs
         *     `$sce.trustAs`} call, or anything else (which will not be considered trusted.)
         * @return {*} A version of the value that's safe to use in the given context, or throws an
         *     exception if this is impossible.
         */

        /**
         * Shorthand method.  `$sce.getTrustedHtml(value)` →
         *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}
         *
         * @param {*} value The value to pass to `$sce.getTrusted`.
         * @return {*} The return value of `$sce.getTrusted($sce.HTML, value)`
         */

        /**
         * Shorthand method.  `$sce.getTrustedCss(value)` →
         *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}
         *
         * @param {*} value The value to pass to `$sce.getTrusted`.
         * @return {*} The return value of `$sce.getTrusted($sce.CSS, value)`
         */

        /**
         * Shorthand method.  `$sce.getTrustedUrl(value)` →
         *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}
         *
         * @param {*} value The value to pass to `$sce.getTrusted`.
         * @return {*} The return value of `$sce.getTrusted($sce.URL, value)`
         */

        /**
         * Shorthand method.  `$sce.getTrustedResourceUrl(value)` →
         *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}
         *
         * @param {*} value The value to pass to `$sceDelegate.getTrusted`.
         * @return {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`
         */

        /**
         * Shorthand method.  `$sce.getTrustedJs(value)` →
         *     {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}
         *
         * @param {*} value The value to pass to `$sce.getTrusted`.
         * @return {*} The return value of `$sce.getTrusted($sce.JS, value)`
         */

        /**
         * Shorthand method.  `$sce.parseAsHtml(expression string)` →
         *     {@link ng.$sceparseAs `$sce.parseAs($sce.HTML, value)`}
         *
         * @param {string} expression String expression to compile.
         * @return {function(context, locals)} A function which represents the compiled expression:
         *
         *    * `context` – `{object}` – an object against which any expressions embedded in the
         *      strings are evaluated against (typically a scope object).
         *    * `locals` – `{object=}` – local variables context object, useful for overriding values
         *      in `context`.
         */

        /**
         * Shorthand method.  `$sce.parseAsCss(value)` →
         *     {@link ng.$sceparseAs `$sce.parseAs($sce.CSS, value)`}
         *
         * @param {string} expression String expression to compile.
         * @return {function(context, locals)} A function which represents the compiled expression:
         *
         *    * `context` – `{object}` – an object against which any expressions embedded in the
         *      strings are evaluated against (typically a scope object).
         *    * `locals` – `{object=}` – local variables context object, useful for overriding values
         *      in `context`.
         */

        /**
         * Shorthand method.  `$sce.parseAsUrl(value)` →
         *     {@link ng.$sceparseAs `$sce.parseAs($sce.URL, value)`}
         *
         * @param {string} expression String expression to compile.
         * @return {function(context, locals)} A function which represents the compiled expression:
         *
         *    * `context` – `{object}` – an object against which any expressions embedded in the
         *      strings are evaluated against (typically a scope object).
         *    * `locals` – `{object=}` – local variables context object, useful for overriding values
         *      in `context`.
         */

        /**
         * Shorthand method.  `$sce.parseAsResourceUrl(value)` →
         *     {@link ng.$sceparseAs `$sce.parseAs($sce.RESOURCE_URL, value)`}
         *
         * @param {string} expression String expression to compile.
         * @return {function(context, locals)} A function which represents the compiled expression:
         *
         *    * `context` – `{object}` – an object against which any expressions embedded in the
         *      strings are evaluated against (typically a scope object).
         *    * `locals` – `{object=}` – local variables context object, useful for overriding values
         *      in `context`.
         */

        /**
         * Shorthand method.  `$sce.parseAsJs(value)` →
         *     {@link ng.$sceparseAs `$sce.parseAs($sce.JS, value)`}
         *
         * @param {string} expression String expression to compile.
         * @return {function(context, locals)} A function which represents the compiled expression:
         *
         *    * `context` – `{object}` – an object against which any expressions embedded in the
         *      strings are evaluated against (typically a scope object).
         *    * `locals` – `{object=}` – local variables context object, useful for overriding values
         *      in `context`.
         */

        // Shorthand delegations.
        const parse = sce.parseAs;

        const { getTrusted } = sce;

        const { trustAs } = sce;

        entries(SCE_CONTEXTS).forEach(([name, enumValue]) => {
          const lName = name.toLowerCase();

          sce[snakeToCamel(`parse_as_${lName}`)] = function (expr) {
            return parse(enumValue, expr);
          };
          sce[snakeToCamel(`get_trusted_${lName}`)] = function (value) {
            return getTrusted(enumValue, value);
          };
          sce[snakeToCamel(`trust_as_${lName}`)] = function (value) {
            return trustAs(enumValue, value);
          };
        });

        return sce;
      },
    ];
  }

  /*
   * A collection of directives that allows creation of custom event handlers that are defined as
   * AngularTS expressions and are compiled and executed within the current scope.
   */

  /**
   * @type {Record<string, ng.Injectable<any>>}
   */
  const ngEventDirectives = {};

  "click copy cut dblclick focus blur keydown keyup load mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup paste submit touchstart touchend touchmove"
    .split(" ")
    .forEach((eventName) => {
      const directiveName = directiveNormalize(`ng-${eventName}`);

      ngEventDirectives[directiveName] = [
        $injectTokens._parse,
        $injectTokens._exceptionHandler,

        /**
         * @param {ng.ParseService} $parse
         * @param {ng.ExceptionHandlerService} $exceptionHandler
         * @returns
         */
        ($parse, $exceptionHandler) => {
          return createEventDirective(
            $parse,
            $exceptionHandler,
            directiveName,
            eventName,
          );
        },
      ];
    });

  /**
   *
   * @param {ng.ParseService} $parse
   * @param {ng.ExceptionHandlerService} $exceptionHandler
   * @param {string} directiveName
   * @param {string} eventName
   * @returns {ng.Directive}
   */
  function createEventDirective(
    $parse,
    $exceptionHandler,
    directiveName,
    eventName,
  ) {
    return {
      restrict: "A",
      compile(_element, attr) {
        const fn = $parse(attr[directiveName]);

        return (scope, element) => {
          const handler = (event) => {
            try {
              fn(scope, { $event: event });
            } catch (error) {
              $exceptionHandler(error);
            }
          };

          element.addEventListener(eventName, handler);

          scope.$on("$destroy", () =>
            element.removeEventListener(eventName, handler),
          );
        };
      },
    };
  }

  /**
   *
   * @param {ng.ParseService} $parse
   * @param {ng.ExceptionHandlerService} $exceptionHandler
   * @param {ng.WindowService} $window
   * @param {string} directiveName
   * @param {string} eventName
   * @returns {ng.Directive}
   */
  function createWindowEventDirective(
    $parse,
    $exceptionHandler,
    $window,
    directiveName,
    eventName,
  ) {
    return {
      restrict: "A",
      compile(_element, attr) {
        const fn = $parse(attr[directiveName]);

        return (scope) => {
          const handler = (event) => {
            try {
              fn(scope, { $event: event });
            } catch (error) {
              $exceptionHandler(error);
            }
          };

          $window.addEventListener(eventName, handler);

          scope.$on("$destroy", () =>
            $window.removeEventListener(eventName, handler),
          );
        };
      },
    };
  }

  const $compileMinErr$1 = minErr("$compile");

  const SIMPLE_ATTR_NAME = /^\w/;

  const specialAttrHolder = document.createElement("div");

  class Attributes {
    static $nonscope = true;

    /**
     * @param {ng.AnimateService} $animate
     * @param {ng.ExceptionHandlerService} $exceptionHandler
     * @param {*} $sce
     * @param {import("../../shared/noderef.js").NodeRef} [nodeRef]
     * @param {Object} [attributesToCopy]
     */
    constructor($animate, $exceptionHandler, $sce, nodeRef, attributesToCopy) {
      this._$animate = $animate;
      this._$exceptionHandler = $exceptionHandler;
      this._$sce = $sce;

      if (attributesToCopy) {
        const keys = Object.keys(attributesToCopy);

        for (let i = 0, l = keys.length; i < l; i++) {
          const key = keys[i];

          this[key] = attributesToCopy[key];
        }
      } else {
        this.$attr = {};
      }

      /** @type {import("../../shared/noderef.js").NodeRef} */
      this.$nodeRef = nodeRef;
    }

    /** @type {Node|Element} */
    get $$element() {
      return this.$nodeRef.node;
    }

    /**
     * Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or
     * `data-`) to its normalized, camelCase form.
     *
     * Also there is special case for Moz prefix starting with upper case letter.
     *
     * For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}
     *
     * @param {string} name Name to normalize
     */
    $normalize = directiveNormalize;

    /**
     * Adds the CSS class value specified by the classVal parameter to the element. If animations
     * are enabled then an animation will be triggered for the class addition.
     *
     * @param {string} classVal The className value that will be added to the element
     */
    $addClass(classVal) {
      if (classVal && classVal.length > 0) {
        if (hasAnimate(this.$$element)) {
          this._$animate.addClass(
            /** @type {Element} */ (this.$$element),
            classVal,
          );
        } else {
          this.$nodeRef.element.classList.add(classVal);
        }
      }
    }

    /**
     * Removes the CSS class value specified by the classVal parameter from the element. If
     * animations are enabled then an animation will be triggered for the class removal.
     *
     * @param {string} classVal The className value that will be removed from the element
     */
    $removeClass(classVal) {
      if (classVal && classVal.length > 0) {
        if (hasAnimate(this.$$element)) {
          this._$animate.removeClass(
            /** @type {Element} */ (this.$$element),
            classVal,
          );
        } else {
          this.$nodeRef.element.classList.remove(classVal);
        }
      }
    }

    /**
     * Adds and removes the appropriate CSS class values to the element based on the difference
     * between the new and old CSS class values (specified as newClasses and oldClasses).
     *
     * @param {string} newClasses The current CSS className value
     * @param {string} oldClasses The former CSS className value
     */
    $updateClass(newClasses, oldClasses) {
      const toAdd = tokenDifference(newClasses, oldClasses);

      if (toAdd && toAdd.length) {
        if (hasAnimate(this.$$element)) {
          this._$animate.addClass(/** @type {Element }*/ (this.$$element), toAdd);
        } else {
          this.$nodeRef.element.classList.add(...toAdd.trim().split(/\s+/));
        }
      }
      const toRemove = tokenDifference(oldClasses, newClasses);

      if (toRemove && toRemove.length) {
        if (hasAnimate(this.$$element)) {
          this._$animate.removeClass(
            /** @type {Element }*/ (this.$$element),
            toRemove,
          );
        } else {
          this.$nodeRef.element.classList.remove(...toRemove.trim().split(/\s+/));
        }
      }
    }

    /**
     * Set a normalized attribute on the element in a way such that all directives
     * can share the attribute. This function properly handles boolean attributes.
     * @param {string} key Normalized key. (ie ngAttribute)
     * @param {string|boolean|null} value The value to set. If `null` attribute will be deleted.
     * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
     *     Defaults to true.
     * @param {string=} attrName Optional none normalized name. Defaults to key.
     */
    $set(key, value, writeAttr, attrName) {
      // TODO: decide whether or not to throw an error if "class"
      // is set through this function since it may cause $updateClass to
      // become unstable.

      const node = this.$$element;

      const booleanKey = getBooleanAttrName(/** @type {Element}   */ (node), key);

      const aliasedKey = ALIASED_ATTR[key];

      let observer = key;

      if (booleanKey) {
        this.$$element[key] = value;
        attrName = booleanKey;
      } else if (aliasedKey) {
        this[aliasedKey] = value;
        observer = aliasedKey;
      }

      this[key] = value;

      // translate normalized key to actual key
      if (attrName) {
        this.$attr[key] = attrName;
      } else {
        attrName = this.$attr[key];

        if (!attrName) {
          this.$attr[key] = attrName = snakeCase(key, "-");
        }
      }

      const nodeName = this.$nodeRef.node.nodeName.toLowerCase();

      let maybeSanitizedValue;

      // Sanitize img[srcset] values.
      if (nodeName === "img" && key === "srcset") {
        this[key] = maybeSanitizedValue = this.sanitizeSrcset(
          value,
          "$set('srcset', value)",
        );
      } else {
        maybeSanitizedValue = value;
      }

      if (writeAttr !== false) {
        const elem = /** @type {Element} */ (this.$$element);

        if (isNullOrUndefined(maybeSanitizedValue)) {
          elem.removeAttribute(attrName);
          //
        } else if (SIMPLE_ATTR_NAME.test(attrName)) {
          // jQuery skips special boolean attrs treatment in XML nodes for
          // historical reasons and hence AngularTS cannot freely call
          // `.getAttribute(attrName, false) with such attributes. To avoid issues
          // in XHTML, call `removeAttr` in such cases instead.
          // See https://github.com/jquery/jquery/issues/4249
          if (booleanKey && maybeSanitizedValue === false) {
            elem.removeAttribute(attrName);
          } else {
            if (booleanKey) {
              elem.toggleAttribute(
                attrName,
                /** @type {boolean} */ (maybeSanitizedValue),
              );
            } else {
              elem.setAttribute(
                attrName,
                /** @type {string} */ (maybeSanitizedValue),
              );
            }
          }
        } else {
          this.setSpecialAttr(this.$$element, attrName, maybeSanitizedValue);
        }
      }

      // fire observers
      const { $$observers } = this;

      if ($$observers && $$observers[observer]) {
        $$observers[observer].forEach((fn) => {
          try {
            fn(maybeSanitizedValue);
          } catch (err) {
            this._$exceptionHandler(err);
          }
        });
      }
    }

    /**
     * Observes an interpolated attribute.
     * 
     * The observer function will be invoked once during the next `$digest` following
     * compilation. The observer is then invoked whenever the interpolated value
     * changes.
     *
     * @param {string} key Normalized key. (ie ngAttribute) .
     * @param {any} fn Function that will be called whenever
              the interpolated value of the attribute changes.
    *        See the {@link guide/interpolation#how-text-and-attribute-bindings-work Interpolation
    *        guide} for more info.
    * @returns {function()} Returns a deregistration function for this observer.
    */
    $observe(key, fn) {
      const $$observers =
        this.$$observers || (this.$$observers = Object.create(null));

      const listeners = $$observers[key] || ($$observers[key] = []);

      listeners.push(fn);

      if (!listeners.$$inter && hasOwn(this, key) && !isUndefined(this[key])) {
        // no one registered attribute interpolation function, so lets call it manually
        fn(this[key]);
      }

      return function () {
        arrayRemove(listeners, fn);
      };
    }

    setSpecialAttr(element, attrName, value) {
      // Attributes names that do not start with letters (such as `(click)`) cannot be set using `setAttribute`
      // so we have to jump through some hoops to get such an attribute
      // https://github.com/angular/angular.js/pull/13318
      specialAttrHolder.innerHTML = `<span ${attrName}>`;
      const { attributes } = /** @type {Element} */ (
        specialAttrHolder.firstChild
      );

      const attribute = attributes[0];

      // We have to remove the attribute from its container element before we can add it to the destination element
      attributes.removeNamedItem(attribute.name);
      attribute.value = value;
      element.attributes.setNamedItem(attribute);
    }

    /**
     *
     * @param {unknown} value
     * @param {string} invokeType
     * @returns {unknown}
     */
    sanitizeSrcset(value, invokeType) {
      let i;

      if (!value) {
        return value;
      }

      if (!isString(value)) {
        throw $compileMinErr$1(
          "srcset",
          'Can\'t pass trusted values to `{0}`: "{1}"',
          invokeType,
          /** @type {Object} */ (value).toString(),
        );
      }

      // Such values are a bit too complex to handle automatically inside $sce.
      // Instead, we sanitize each of the URIs individually, which works, even dynamically.

      // It's not possible to work around this using `$sce.trustAsMediaUrl`.
      // If you want to programmatically set explicitly trusted unsafe URLs, you should use
      // `$sce.trustAsHtml` on the whole `img` tag and inject it into the DOM using the
      // `ng-bind-html` directive.

      let result = "";

      // first check if there are spaces because it's not the same pattern
      const trimmedSrcset = trim(value);

      //                (   999x   ,|   999w   ,|   ,|,   )
      const srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;

      const pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;

      // split srcset into tuple of uri and descriptor except for the last item
      const rawUris = trimmedSrcset.split(pattern);

      // for each tuples
      const nbrUrisWith2parts = Math.floor(rawUris.length / 2);

      for (i = 0; i < nbrUrisWith2parts; i++) {
        const innerIdx = i * 2;

        // sanitize the uri
        result += this._$sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
        // add the descriptor
        result += ` ${trim(rawUris[innerIdx + 1])}`;
      }

      // split the last item into uri and descriptor
      const lastTuple = trim(rawUris[i * 2]).split(/\s/);

      // sanitize the last uri
      result += this._$sce.getTrustedMediaUrl(trim(lastTuple[0]));

      // and add the last descriptor if any
      if (lastTuple.length === 2) {
        result += ` ${trim(lastTuple[1])}`;
      }

      return result.replace(/unsafe:unsafe/g, "unsafe");
    }
  }

  /**
   * Computes the difference between two space-separated token strings.
   *
   * @param {string} str1 - The first string containing space-separated tokens.
   * @param {string} str2 - The second string containing space-separated tokens.
   * @returns {string} A string containing tokens that are in str1 but not in str2, separated by spaces.
   *
   */
  function tokenDifference(str1, str2) {
    const tokens1 = new Set(str1.split(/\s+/));

    const tokens2 = new Set(str2.split(/\s+/));

    const difference = Array.from(tokens1).filter((token) => !tokens2.has(token));

    return difference.join(" ");
  }

  /**
   * @param {string} source - the name of the attribute to be observed
   * @param {string} prop - the scope property to be updated with attribute value
   * @returns {ng.Directive}
   */
  function ngObserveDirective(source, prop) {
    return {
      restrict: "A",
      compile: () => (scope, element) => {
        if (prop === "") {
          prop = source;
        }
        const normalized = kebabToCamel(prop);

        if (!scope[normalized]) {
          scope[normalized] = element.getAttribute(source);
        }

        const observer = new MutationObserver((mutations) => {
          const mutation = mutations[0];

          const newValue = /** @type {HTMLElement} */ (
            mutation.target
          ).getAttribute(source);

          if (scope[normalized] !== newValue) {
            scope[normalized] = newValue;
          }
        });

        observer.observe(element, {
          attributes: true,
          attributeFilter: [source],
        });

        scope.$on("$destroy", () => {
          observer.disconnect();
        });
      },
    };
  }

  const $compileMinErr = minErr("$compile");

  const EXCLUDED_DIRECTIVES = ["ngIf", "ngRepeat"];

  const ALL_OR_NOTHING_ATTRS = ["ngSrc", "ngSrcset", "src", "srcset"];

  const REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;

  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
  // The assumption is that future DOM event attribute names will begin with
  // 'on' and be composed of only English letters.
  const EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;

  const valueFn = (value) => () => value;

  const DirectiveSuffix = "Directive";

  class CompileProvider {
    /* @ignore */ static $inject = [$injectTokens._provide, $injectTokens._sanitizeUriProvider];

    /**
     * @param {import('../../interface.ts').Provider} $provide
     * @param {import('../sanitize/sanitize-uri.js').SanitizeUriProvider} $$sanitizeUriProvider
     */
    constructor($provide, $$sanitizeUriProvider) {
      const hasDirectives = {};

      const bindingCache = Object.create(null);

      /**
       * @param {ng.Scope} scope
       * @param {string} directiveName
       * @param {boolean} isController
       * @returns {Object} a configuration object for attribute bindings
       */
      function parseIsolateBindings(scope, directiveName, isController) {
        const LOCAL_REGEXP = /^([@&]|[=<]())(\??)\s*([\w$]*)$/;

        const bindings = Object.create(null);

        entries(scope).forEach(([scopeName, definition]) => {
          definition = definition.trim();

          if (definition in bindingCache) {
            bindings[scopeName] = bindingCache[definition];

            return;
          }
          const match = definition.match(LOCAL_REGEXP);

          if (!match) {
            throw $compileMinErr(
              "iscp",
              "Invalid {3} for directive '{0}'." +
                " Definition: {... {1}: '{2}' ...}",
              directiveName,
              scopeName,
              definition,
              isController
                ? "controller bindings definition"
                : "isolate scope definition",
            );
          }

          bindings[scopeName] = {
            mode: match[1][0],
            collection: match[2] === "*",
            optional: match[3] === "?",
            attrName: match[4] || scopeName,
          };

          if (match[4]) {
            bindingCache[definition] = bindings[scopeName];
          }
        });

        return bindings;
      }

      function parseDirectiveBindings(directive, directiveName) {
        const bindings = {
          isolateScope: null,
          bindToController: null,
        };

        if (isObject(directive.scope)) {
          if (directive.bindToController === true) {
            bindings.bindToController = parseIsolateBindings(
              directive.scope,
              directiveName,
              true,
            );
            bindings.isolateScope = {};
          } else {
            bindings.isolateScope = parseIsolateBindings(
              directive.scope,
              directiveName,
              false,
            );
          }
        }

        if (isObject(directive.bindToController)) {
          bindings.bindToController = parseIsolateBindings(
            directive.bindToController,
            directiveName,
            true,
          );
        }

        if (bindings.bindToController && !directive.controller) {
          // There is no controller
          throw $compileMinErr(
            "noctrl",
            "Cannot bind to controller without directive '{0}'s controller.",
            directiveName,
          );
        }

        return bindings;
      }

      function getDirectiveRequire(directive) {
        const require =
          directive.require || (directive.controller && directive.name);

        if (!isArray(require) && isObject(require)) {
          const entryList = entries(require);

          for (let i = 0, len = entryList.length; i < len; i++) {
            const [key, value] = entryList[i];

            const match = value.match(REQUIRE_PREFIX_REGEXP);

            if (!match) continue; // safety check if match fails

            const name = value.substring(match[0].length);

            if (!name) {
              require[key] = match[0] + key;
            }
          }
        }

        return require;
      }

      function getDirectiveRestrict(restrict, name) {
        if (restrict && !(isString(restrict) && /[EA]/.test(restrict))) {
          throw $compileMinErr(
            "badrestrict",
            "Restrict property '{0}' of directive '{1}' is invalid",
            restrict,
            name,
          );
        }

        // Default is element or attribute
        return restrict || "EA";
      }

      /**
       * Register a new directive with the compiler.
       *
       * @param {string|Object} name Name of the directive in camel-case (i.e. `ngBind` which will match
       *    as `ng-bind`), or an object map of directives where the keys are the names and the values
       *    are the factories.
       * @param {Function|Array} directiveFactory An injectable directive factory function. See the
       *    {@link guide/directive directive guide} and the {@link $compile compile API} for more info.
       * @returns {CompileProvider} Self for chaining.
       */
      this.directive = function registerDirective(name, directiveFactory) {
        assertArg(name, "name");
        assertNotHasOwnProperty(name, "directive");

        if (isString(name)) {
          assertValidDirectiveName(name);
          assertArg(directiveFactory, "directiveFactory");

          if (!hasOwn(hasDirectives, name)) {
            hasDirectives[name] = [];
            $provide.factory(name + DirectiveSuffix, [
              $injectTokens._injector,
              $injectTokens._exceptionHandler,
              /**
               * @param {ng.InjectorService} $injector
               * @param {ng.ExceptionHandlerService} $exceptionHandler
               */
              function ($injector, $exceptionHandler) {
                const directives = [];

                for (let i = 0, l = hasDirectives[name].length; i < l; i++) {
                  const directiveFactoryInstance = hasDirectives[name][i];

                  try {
                    let directive = $injector.invoke(directiveFactoryInstance);

                    if (isFunction(directive)) {
                      directive = { compile: valueFn(directive) };
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }

                    directive.priority = directive.priority || 0;
                    directive.index = i;
                    directive.name = directive.name || name;
                    directive.require = getDirectiveRequire(directive);
                    directive.restrict = getDirectiveRestrict(
                      directive.restrict,
                      name,
                    );

                    directives.push(directive);
                  } catch (err) {
                    $exceptionHandler(err);
                  }
                }

                return directives;
              },
            ]);
          }
          hasDirectives[name].push(directiveFactory);
        } else {
          entries(name).forEach(([k, v]) => registerDirective(k, v));
        }

        return this;
      };

      /**
       * @param {string|Object} name Name of the component in camelCase (i.e. `myComp` which will match `<my-comp>`),
       *    or an object map of components where the keys are the names and the values are the component definition objects.
       * @param {import("../../interface.ts").Component} options Component definition object (a simplified
       *    {directive definition object}),
       *    with the following properties (all optional):
       *
       *    - `controller` – `{(string|function()=}` – controller constructor function that should be
       *      associated with newly created scope or the name of a {controller} if passed as a string. An empty `noop` function by default.
       *    - `controllerAs` – `{string=}` – identifier name for to reference the controller in the component's scope.
       *      If present, the controller will be published to scope under the `controllerAs` name.
       *      If not present, this will default to be `$ctrl`.
       *    - `template` – `{string=|function()=}` – html template as a string or a function that
       *      returns an html template as a string which should be used as the contents of this component.
       *      Empty string by default.
       *
       *      If `template` is a function, then it is {injected} with
       *      the following locals:
       *
       *      - `$element` - Current element
       *      - `$attrs` - Current attributes object for the element
       *
       *    - `templateUrl` – `{string=|function()=}` – path or function that returns a path to an html
       *      template that should be used  as the contents of this component.
       *
       *      If `templateUrl` is a function, then it is {injected} with
       *      the following locals:
       *
       *      - `$element` - Current element
       *      - `$attrs` - Current attributes object for the element
       *
       *    - `bindings` – `{object=}` – defines bindings between DOM attributes and component properties.
       *      Component properties are always bound to the component controller and not to the scope.
       *      See {`bindToController`}.
       *    - `transclude` – `{boolean=}` – whether {content transclusion} is enabled.
       *      Disabled by default.
       *    - `require` - `{Object<string, string>=}` - requires the controllers of other directives and binds them to
       *      this component's controller. The object keys specify the property names under which the required
       *      controllers (object values) will be bound. See {`require`}.
       *    - `$...` – additional properties to attach to the directive factory function and the controller
       *      constructor function. (This is used by the component router to annotate)
       *
       * @returns {CompileProvider} the compile provider itself, for chaining of function calls.
       */
      this.component = function (name, options) {
        if (!isString(name)) {
          entries(name).forEach(([key, val]) => this.component(key, val));

          return this;
        }

        const controller =
          options.controller ||
          function () {
            /* empty */
          };

        function factory($injector) {
          function makeInjectable(fn) {
            if (isFunction(fn) || isArray(fn)) {
              return function (tElement, tAttrs) {
                // eslint-disable-next-line no-invalid-this
                return $injector.invoke(fn, this, {
                  $element: tElement,
                  $attrs: tAttrs,
                });
              };
            }

            return fn;
          }

          const template =
            !options.template && !options.templateUrl ? "" : options.template;

          const ddo = {
            controller,
            controllerAs:
              identifierForController(options.controller) ||
              options.controllerAs ||
              "$ctrl",
            template: makeInjectable(template),
            templateUrl: makeInjectable(options.templateUrl),
            transclude: options.transclude,
            scope: {},
            bindToController: options.bindings || {},
            restrict: "E",
            require: options.require,
          };

          // Copy annotations (starting with $) over to the DDO
          entries(options).forEach(([key, val]) => {
            if (key.charAt(0) === "$") {
              ddo[key] = val;
            }
          });

          return ddo;
        }

        // Copy any annotation properties (starting with $) over to the factory and controller constructor functions
        // These could be used by libraries such as the new component router
        entries(options).forEach(([key, val]) => {
          if (key.charAt(0) === "$") {
            factory[key] = val;

            // Don't try to copy over annotations to named controller
            if (isFunction(controller)) {
              controller[key] = val;
            }
          }
        });

        factory.$inject = [$injectTokens._injector];

        return this.directive(name, factory);
      };

      /**
       * Retrieves or overrides the default regular expression that is used for determining trusted safe
       * urls during a[href] sanitization.
       *
       * The sanitization is a security measure aimed at preventing XSS attacks via html links.
       *
       * Any url about to be assigned to a[href] via data-binding is first normalized and turned into
       * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationTrustedUrlList`
       * regular expression. If a match is found, the original url is written into the dom. Otherwise,
       * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
       *
       * @param {RegExp=} regexp New regexp to trust urls with.
       * @returns {RegExp|import('../sanitize/sanitize-uri.js').SanitizeUriProvider} Current RegExp if called without value or self for
       *    chaining otherwise.
       */
      this.aHrefSanitizationTrustedUrlList = function (regexp) {
        if (isDefined(regexp)) {
          $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp);

          return undefined;
        }

        return $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList();
      };

      /**
       * Retrieves or overrides the default regular expression that is used for determining trusted safe
       * urls during img[src] sanitization.
       *
       * The sanitization is a security measure aimed at prevent XSS attacks via html links.
       *
       * Any url about to be assigned to img[src] via data-binding is first normalized and turned into
       * an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationTrustedUrlList`
       * regular expression. If a match is found, the original url is written into the dom. Otherwise,
       * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.
       *
       * @param {RegExp=} regexp New regexp to trust urls with.
       * @returns {RegExp|import('../sanitize/sanitize-uri.js').SanitizeUriProvider} Current RegExp if called without value or self for
       *    chaining otherwise.
       */
      this.imgSrcSanitizationTrustedUrlList = function (regexp) {
        if (isDefined(regexp)) {
          $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp);

          return undefined;
        }

        return $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();
      };

      /**
       * @param {boolean=} enabled update the strictComponentBindingsEnabled state if provided,
       * otherwise return the current strictComponentBindingsEnabled state.
       * @returns {*} current value if used as getter or itself (chaining) if used as setter
       *
       * Call this method to enable / disable the strict component bindings check. If enabled, the
       * compiler will enforce that all scope / controller bindings of a
       * {@link $compileProvider#directive directive} / {@link $compileProvider#component component}
       * that are not set as optional with `?`, must be provided when the directive is instantiated.
       * If not provided, the compiler will throw the
       * {@link error/$compile/missingattr $compile:missingattr error}.
       *
       * The default value is false.
       */
      let strictComponentBindingsEnabled = false;

      this.strictComponentBindingsEnabled = function (enabled) {
        if (isDefined(enabled)) {
          strictComponentBindingsEnabled = enabled;

          return this;
        }

        return strictComponentBindingsEnabled;
      };

      /**
       * The security context of DOM Properties.
       */
      const PROP_CONTEXTS = Object.create(null);

      /**
       * Defines the security context for DOM properties bound by ng-prop-*.
       *
       * @param {string} elementName The element name or '*' to match any element.
       * @param {string} propertyName The DOM property name.
       * @param {string} ctx The {@link _$sce} security context in which this value is safe for use, e.g. `$sce.URL`
       * @returns {object} `this` for chaining
       */
      this.addPropertySecurityContext = function (
        elementName,
        propertyName,
        ctx,
      ) {
        const key = `${elementName.toLowerCase()}|${propertyName.toLowerCase()}`;

        if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) {
          throw $compileMinErr(
            "ctxoverride",
            "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.",
            elementName,
            propertyName,
            PROP_CONTEXTS[key],
            ctx,
          );
        }

        PROP_CONTEXTS[key] = ctx;

        return this;
      };

      /* Default property contexts.
       *
       * Copy of https://github.com/angular/angular/blob/6.0.6/packages/compiler/src/schema/dom_security_schema.ts#L31-L58
       * Changing:
       * - SecurityContext.* => SCE_CONTEXTS/$sce.*
       * - STYLE => CSS
       * - various URL => MEDIA_URL
       * - *|formAction, form|action URL => RESOURCE_URL (like the attribute)
       */
      (function registerNativePropertyContexts() {
        function registerContext(ctx, values) {
          values.forEach((v) => {
            PROP_CONTEXTS[v.toLowerCase()] = ctx;
          });
        }

        registerContext(SCE_CONTEXTS.HTML, [
          "iframe|srcdoc",
          "*|innerHTML",
          "*|outerHTML",
        ]);
        registerContext(SCE_CONTEXTS.CSS, ["*|style"]);
        registerContext(SCE_CONTEXTS.URL, [
          "area|href",
          "area|ping",
          "a|href",
          "a|ping",
          "blockquote|cite",
          "body|background",
          "del|cite",
          "input|src",
          "ins|cite",
          "q|cite",
        ]);
        registerContext(SCE_CONTEXTS.MEDIA_URL, [
          "audio|src",
          "img|src",
          "img|srcset",
          "source|src",
          "source|srcset",
          "track|src",
          "video|src",
          "video|poster",
        ]);
        registerContext(SCE_CONTEXTS.RESOURCE_URL, [
          "*|formAction",
          "applet|code",
          "applet|codebase",
          "base|href",
          "embed|src",
          "frame|src",
          "form|action",
          "head|profile",
          "html|manifest",
          "iframe|src",
          "link|href",
          "media|src",
          "object|codebase",
          "object|data",
          "script|src",
        ]);
      })();

      this.$get = [
        $injectTokens._injector,
        $injectTokens._interpolate,
        $injectTokens._exceptionHandler,
        $injectTokens._templateRequest,
        $injectTokens._parse,
        $injectTokens._controller,
        $injectTokens._rootScope,
        $injectTokens._sce,
        $injectTokens._animate,
        /**
         * @param {ng.InjectorService} $injector
         * @param {ng.InterpolateService} $interpolate
         * @param {ng.ExceptionHandlerService} $exceptionHandler
         * @param {ng.TemplateRequestService} $templateRequest
         * @param {ng.ParseService} $parse
         * @param {*} $controller
         * @param {ng.Scope} $rootScope
         * @param {*} $sce
         * @param {ng.AnimateService} $animate
         * @returns
         */
        function (
          $injector,
          $interpolate,
          $exceptionHandler,
          $templateRequest,
          $parse,
          $controller,
          $rootScope,
          $sce,
          $animate,
        ) {
          // The onChanges hooks should all be run together in a single digest
          // When changes occur, the call to trigger their hooks will be added to this queue
          let onChangesQueue;

          // This function is called in a $postUpdate to trigger all the onChanges hooks in a single digest
          function flushOnChangesQueue() {
            for (let i = 0, ii = onChangesQueue.length; i < ii; ++i) {
              try {
                onChangesQueue[i]();
              } catch (err) {
                $exceptionHandler(err);
              }
            }
            // Reset the queue to trigger a new schedule next time there is a change
            onChangesQueue = undefined;
          }

          const startSymbol = $interpolate.startSymbol();

          const endSymbol = $interpolate.endSymbol();

          /** @type {(string) => string} */
          const denormalizeTemplate =
            startSymbol === "{{" && endSymbol === "}}"
              ? (x) => x
              : (x) => x.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);

          const NG_PREFIX_BINDING = /^ng(Attr|Prop|On|Observe|Window)([A-Z].*)$/;

          return compile;

          /**
           * @type {ng.CompileService}
           */
          function compile(
            element,
            transcludeFn,
            maxPriority,
            ignoreDirective,
            previousCompileContext,
          ) {
            /** @type {NodeRef | null } */
            let nodeRef = new NodeRef(element);

            /**
             * The composite link function is a composite of individual node linking functions.
             * It will be invoke by the public link function below.
             * @type {ng.CompositeLinkFn}
             */
            let compositeLinkFn = compileNodes(
              nodeRef,
              transcludeFn,
              maxPriority,
              ignoreDirective,
              previousCompileContext,
            );

            let namespace = null;

            return publicLinkFn;

            /** @type {ng.PublicLinkFn} */
            function publicLinkFn(scope, cloneConnectFn, options) {
              if (!nodeRef) {
                throw $compileMinErr(
                  "multilink",
                  "This element has already been linked.",
                );
              }

              assertArg(scope, "scope");

              // could be empty nodelist
              if (nodeRef._element) {
                setScope(nodeRef._element, scope);
              }

              if (
                previousCompileContext &&
                previousCompileContext.needsNewScope
              ) {
                // A parent directive did a replace and a directive on this element asked
                // for transclusion, which caused us to lose a layer of element on which
                // we could hold the new transclusion scope, so we will create it manually
                // here.
                scope = scope.$parent.$new();
              }

              options = options || {};
              let { parentBoundTranscludeFn } = options;

              const { transcludeControllers, futureParentElement } = options;

              // When `parentBoundTranscludeFn` is passed, it is a
              // `controllersBoundTransclude` function (it was previously passed
              // as `transclude` to directive.link) so we must unwrap it to get
              // its `boundTranscludeFn`
              if (
                parentBoundTranscludeFn &&
                parentBoundTranscludeFn.$$boundTransclude
              ) {
                parentBoundTranscludeFn =
                  parentBoundTranscludeFn.$$boundTransclude;
              }

              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              /** @type {NodeRef} */
              let $linkNode;

              if (namespace !== "html") {
                // When using a directive with replace:true and templateUrl the jqCompileNodes
                // (or a child element inside of them)
                // might change, so we need to recreate the namespace adapted compileNodes
                // for call to the link function.
                // Note: This will already clone the nodes...
                const fragment = createElementFromHTML("<div></div>");

                fragment.append(nodeRef.node);
                const wrappedTemplate = wrapTemplate(
                  namespace,
                  fragment.innerHTML,
                );

                $linkNode = new NodeRef(wrappedTemplate[0]);
              } else if (cloneConnectFn) {
                $linkNode = nodeRef._clone();
              } else {
                $linkNode = nodeRef;
              }

              if (transcludeControllers) {
                for (const controllerName in transcludeControllers) {
                  assertArg($linkNode.element, "element");
                  setCacheData(
                    $linkNode.element,
                    `$${controllerName}Controller`,
                    transcludeControllers[controllerName].instance,
                  );
                }
              }

              if (cloneConnectFn) {
                cloneConnectFn($linkNode.dom, scope);
              }

              if (compositeLinkFn) {
                compositeLinkFn(scope, $linkNode, parentBoundTranscludeFn);
              }

              if (!cloneConnectFn) {
                nodeRef = compositeLinkFn = null;
              }

              return $linkNode._getAll();
            }
          }

          function detectNamespaceForChildElements(parentElement) {
            // TODO: Make this detect MathML as well...
            const node = parentElement;

            if (!node) {
              return "html";
            }

            return getNodeName(node) !== "foreignobject" &&
              toString.call(node).match(/SVG/)
              ? "svg"
              : "html";
          }

          /**
           * Compile function matches each node in nodeList against the directives. Once all directives
           * for a particular node are collected their compile functions are executed. The compile
           * functions return values - the linking functions - are combined into a composite linking
           * function, which is a linking function for the node.
           *
           * @param {NodeRef} nodeRefList a node or an array of nodes or NodeList to compile
           * @param {*} transcludeFn A linking function, where the
           *        scope argument is auto-generated to the new child of the transcluded parent scope.
           * @param {number=} [maxPriority] Max directive priority.
           * @param {*} [ignoreDirective]
           * @param {*} [previousCompileContext]
           * @returns {ng.CompositeLinkFn} A composite linking function of all of the matched directives or null.
           */
          function compileNodes(
            nodeRefList,
            transcludeFn,
            maxPriority,
            ignoreDirective,
            previousCompileContext,
          ) {
            /**
             * Aggregates for the composite linking function, where a node in a node list is mapped
             * to a corresponding link function. For single elements, the node should be mapped to
             * a single node link function.
             * @type {ng.LinkFnMapping[]}
             */
            const linkFnsList = []; // An array to hold node indices and their linkFns

            let nodeLinkFnFound;

            let linkFnFound = false;

            for (let i = 0; i < nodeRefList.size; i++) {
              const attrs = new Attributes($animate, $exceptionHandler, $sce);

              const directives = collectDirectives(
                /** @type Element */ (nodeRefList._getIndex(i)),
                attrs,
                i === 0 ? maxPriority : undefined,
                ignoreDirective,
              );

              /** @type {ng.NodeLinkFnCtx} */
              let nodeLinkFnCtx;

              if (directives.length) {
                nodeLinkFnCtx = applyDirectivesToNode(
                  directives,
                  nodeRefList._getIndex(i),
                  attrs,
                  transcludeFn,
                  null,
                  [],
                  [],
                  Object.assign({}, previousCompileContext, {
                    index: i,
                    parentNodeRef: nodeRefList,
                    ctxNodeRef: nodeRefList,
                  }),
                );
              }

              let childLinkFn;

              const nodeLinkFn = nodeLinkFnCtx?.nodeLinkFn;

              const { childNodes } = nodeRefList._getIndex(i);

              if (
                (nodeLinkFn && nodeLinkFnCtx.terminal) ||
                !childNodes ||
                !childNodes.length
              ) {
                childLinkFn = null;
              } else {
                const transcluded = nodeLinkFn
                  ? (nodeLinkFnCtx.transcludeOnThisElement ||
                      !nodeLinkFnCtx.templateOnThisElement) &&
                    nodeLinkFnCtx.transclude
                  : transcludeFn;

                // recursive call
                const childNodeRef = new NodeRef(childNodes);

                childLinkFn = compileNodes(childNodeRef, transcluded);
              }

              if (nodeLinkFn || childLinkFn) {
                linkFnsList.push({
                  index: i,
                  nodeLinkFnCtx,
                  childLinkFn,
                });
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }

              // use the previous context only for the first element in the virtual group
              previousCompileContext = null;
            }

            // return a composite linking function if we have found anything, null otherwise
            return linkFnFound ? compositeLinkFn : null;

            /**
             * The composite link function links all the individual nodes
             *
             * @param {ng.Scope} scope
             * @param {NodeRef} nodeRef
             * @param {*} [parentBoundTranscludeFn]
             */
            function compositeLinkFn(scope, nodeRef, parentBoundTranscludeFn) {
              assertArg(nodeRef, "nodeRef");
              let stableNodeList = [];

              if (nodeLinkFnFound) {
                // create a stable copy of the nodeList, only copying elements with linkFns
                const stableLength = nodeRef._isList ? nodeRef.nodes.length : 1;

                stableNodeList = new Array(stableLength);
                // create a sparse array by only copying the elements which have a linkFn
                linkFnsList.forEach((val) => {
                  const idx = val.index;

                  if (idx === 0) {
                    stableNodeList[idx] = nodeRef._isList
                      ? nodeRef.nodes[idx]
                      : nodeRef.node;
                  } else {
                    if (nodeRefList._getIndex(idx)) {
                      stableNodeList[idx] = nodeRef.nodes[idx];
                    }
                  }
                });
              } else {
                if (nodeRef._isList) {
                  nodeRef.nodes.forEach((elem) => stableNodeList.push(elem));
                } else {
                  stableNodeList.push(nodeRef.node);
                }
              }

              linkFnsList.forEach(({ index, nodeLinkFnCtx, childLinkFn }) => {
                const node = stableNodeList[index];

                node.stable = true;
                let childScope;

                let childBoundTranscludeFn;

                if (nodeLinkFnCtx?.nodeLinkFn) {
                  childScope = nodeLinkFnCtx.newScope ? scope.$new() : scope;

                  if (nodeLinkFnCtx.transcludeOnThisElement) {
                    // bind proper scope for the translusion function
                    childBoundTranscludeFn = createBoundTranscludeFn(
                      scope,
                      nodeLinkFnCtx.transclude,
                      parentBoundTranscludeFn,
                    );
                  } else if (
                    !nodeLinkFnCtx.templateOnThisElement &&
                    parentBoundTranscludeFn
                  ) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(
                      scope,
                      transcludeFn,
                    );
                  } else {
                    childBoundTranscludeFn = null;
                  }

                  // attach new scope to element
                  if (nodeLinkFnCtx?.newScope) {
                    setScope(node, childScope);
                  }
                  // @ts-ignore
                  nodeLinkFnCtx.nodeLinkFn(
                    // @ts-ignore
                    childLinkFn,
                    childScope,
                    node,
                    childBoundTranscludeFn,
                  );
                } else if (childLinkFn) {
                  childLinkFn(
                    scope,
                    new NodeRef(node.childNodes),
                    parentBoundTranscludeFn,
                  );
                }
              });
            }
          }

          /**
           * Prebinds the transclusion function to a scope
           * @param {ng.Scope} scope
           * @param {*} transcludeFn
           * @param {*} previousBoundTranscludeFn
           * @returns {ng.BoundTranscludeFn}
           */
          function createBoundTranscludeFn(
            scope,
            transcludeFn,
            previousBoundTranscludeFn,
          ) {
            function boundTranscludeFn(
              transcludedScope,
              cloneFn,
              controllers,
              futureParentElement,
              containingScope,
            ) {
              if (!transcludedScope) {
                transcludedScope = scope.$transcluded(containingScope);
                transcludedScope.$$transcluded = true;
              }

              const transcludeRes = transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement,
              });

              return transcludeRes;
            }

            // We need  to attach the transclusion slots onto the `boundTranscludeFn`
            // so that they are available inside the `controllersBoundTransclude` function
            const boundSlots = (boundTranscludeFn.$$slots = Object.create(null));

            for (const slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(
                  scope,
                  transcludeFn.$$slots[slotName],
                  previousBoundTranscludeFn,
                );
              } else {
                boundSlots[slotName] = null;
              }
            }

            return boundTranscludeFn;
          }

          /**
           * Looks for directives on the given node and adds them to the directive collection which is
           * sorted.
           *
           * @param {Element} node Node to search.
           * @param {Attributes|any} attrs The shared attrs object which is used to populate the normalized attributes.
           * @param {number=} maxPriority Max directive priority.
           * @param {string} [ignoreDirective]
           * @return {import('../../interface.ts').Directive[]} An array to which the directives are added to. This array is sorted before the function returns.
           */
          function collectDirectives(node, attrs, maxPriority, ignoreDirective) {
            /**
             * @type {ng.Directive[]}
             */
            const directives = [];

            const { nodeType } = node;

            const attrsMap = attrs.$attr;

            let nodeName;

            switch (nodeType) {
              case NodeType._ELEMENT_NODE /* Element */:
                nodeName = node.nodeName.toLowerCase();

                if (ignoreDirective !== directiveNormalize(nodeName)) {
                  // use the node name: <directive>
                  addDirective(
                    directives,
                    directiveNormalize(nodeName),
                    "E",
                    maxPriority,
                  );
                }

                // iterate over the attributes
                for (let j = 0; j < node.attributes?.length; j++) {
                  let isNgAttr = false;

                  let isNgProp = false;

                  let isNgEvent = false;

                  let isNgObserve = false;

                  let isWindow = false;

                  const attr = node.attributes[j];

                  let { name } = attr;

                  const { value } = attr;

                  let nName = directiveNormalize(name.toLowerCase());

                  // Support ng-attr-*, ng-prop-* and ng-on-*
                  const ngPrefixMatch = nName.match(NG_PREFIX_BINDING);

                  if (ngPrefixMatch) {
                    isNgAttr = ngPrefixMatch[1] === "Attr";
                    isNgProp = ngPrefixMatch[1] === "Prop";
                    isNgEvent = ngPrefixMatch[1] === "On";
                    isNgObserve = ngPrefixMatch[1] === "Observe";
                    isWindow = ngPrefixMatch[1] === "Window";

                    // Normalize the non-prefixed name
                    name = name
                      .replace(PREFIX_REGEXP, "")
                      .toLowerCase()
                      .substring(4 + ngPrefixMatch[1].length)
                      .replace(/_(.)/g, (match, letter) => letter.toUpperCase());
                  }

                  if (isNgProp || isNgEvent || isWindow) {
                    attrs[nName] = value;
                    attrsMap[nName] = attr.name;

                    if (isNgProp) {
                      addPropertyDirective(node, directives, nName, name);
                    } else if (isNgEvent) {
                      directives.push(
                        createEventDirective(
                          $parse,
                          $exceptionHandler,
                          nName,
                          name,
                        ),
                      );
                    } else {
                      // isWindow
                      directives.push(
                        createWindowEventDirective(
                          $parse,
                          $exceptionHandler,
                          window,
                          nName,
                          name,
                        ),
                      );
                    }
                  } else if (isNgObserve) {
                    directives.push(ngObserveDirective(name, value));
                  } else {
                    // Update nName for cases where a prefix was removed
                    // NOTE: the .toLowerCase() is unnecessary and causes https://github.com/angular/angular.js/issues/16624 for ng-attr-*
                    nName = directiveNormalize(name.toLowerCase());
                    attrsMap[nName] = name;

                    if (isNgAttr || !hasOwn(attrs, nName)) {
                      attrs[nName] = value;

                      if (getBooleanAttrName(node, nName)) {
                        attrs[nName] = true; // presence means true
                      }
                    }

                    addAttrInterpolateDirective(
                      node,
                      directives,
                      value,
                      nName,
                      isNgAttr,
                    );

                    if (nName !== ignoreDirective) {
                      addDirective(directives, nName, "A", maxPriority);
                    }
                  }
                }

                if (
                  nodeName === "input" &&
                  node.getAttribute("type") === "hidden"
                ) {
                  // Hidden input elements can have strange behaviour when navigating back to the page
                  // This tells the browser not to try to cache and reinstate previous values
                  node.setAttribute("autocomplete", "off");
                }

                break;
              case NodeType._TEXT_NODE:
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
            }

            directives.sort(byPriority);

            return directives;
          }

          /**
           * A function generator that is used to support both eager and lazy compilation
           * linking function.
           * @param eager
           * @param {NodeList|Node} nodes
           * @param transcludeFn
           * @param maxPriority
           * @param ignoreDirective
           * @param previousCompileContext
           * @returns {ng.PublicLinkFn|ng.TranscludeFn}
           */
          function compilationGenerator(
            eager,
            nodes,
            transcludeFn,
            maxPriority,
            ignoreDirective,
            previousCompileContext,
          ) {
            let compiled;

            if (eager) {
              return /** @type {ng.PublicLinkFn} */ (
                compile(
                  nodes,
                  transcludeFn,
                  maxPriority,
                  ignoreDirective,
                  previousCompileContext,
                )
              );
            }

            function lazyCompilation() {
              if (!compiled) {
                compiled = compile(
                  nodes,
                  transcludeFn,
                  maxPriority,
                  ignoreDirective,
                  previousCompileContext,
                );

                nodes = transcludeFn = previousCompileContext = null;
              }

              /* eslint-disable no-invalid-this */
              const ctx = this;

              return compiled.apply(ctx, arguments);
            }

            return /** @type {ng.PublicLinkFn} */ (lazyCompilation);
          }

          /**
           * Once the directives have been collected, their compile functions are executed. This method
           * is responsible for inlining directive templates as well as terminating the application
           * of the directives if the terminal directive has been reached.
           *
           * @param {Array} directives Array of collected directives to execute their compile function.
           *        this needs to be pre-sorted by priority order.
           * @param {Node | Element} compileNode  DOM node to apply the compile functions to
           * @param {Attributes} templateAttrs The shared attribute function
           * @param {ng.TranscludeFn} transcludeFn
           * @param {Object=} originalReplaceDirective An optional directive that will be ignored when
           *                                           compiling the transclusion.
           * @param {Array.<Function>} [preLinkFns]
           * @param {Array.<Function>} [postLinkFns]
           * @param {Object} [previousCompileContext] Context used for previous compilation of the current
           *                                        node
           * @returns {ng.NodeLinkFnCtx} node link function
           */
          function applyDirectivesToNode(
            directives,
            compileNode,
            templateAttrs,
            transcludeFn,
            originalReplaceDirective,
            preLinkFns,
            postLinkFns,
            previousCompileContext,
          ) {
            previousCompileContext = previousCompileContext || {};

            let terminalPriority = -Number.MAX_VALUE;

            let terminal = false;

            let {
              newScopeDirective,
              controllerDirectives,
              newIsolateScopeDirective,
              templateDirective,
              nonTlbTranscludeDirective,
              hasElementTranscludeDirective,
            } = previousCompileContext;

            const { ctxNodeRef, parentNodeRef } = previousCompileContext;

            let hasTranscludeDirective = false;

            let hasTemplate = false;

            let compileNodeRef = new NodeRef(compileNode);

            const { index } = previousCompileContext;

            templateAttrs.$nodeRef = compileNodeRef;
            let directive;

            let directiveName;

            let $template;

            let replaceDirective = originalReplaceDirective;

            /** @type {ng.TranscludeFn} */
            let childTranscludeFn = transcludeFn;

            let didScanForMultipleTransclusion = false;

            let mightHaveMultipleTransclusionError = false;

            let directiveValue;

            /**
             * Links all the directives of a single node.
             * @type {ng.NodeLinkFn}
             */
            // @ts-ignore
            let nodeLinkFn = function (
              childLinkFn,
              scope,
              linkNode,
              boundTranscludeFn,
            ) {
              let i;

              let ii;

              let isolateScope;

              let controllerScope;

              let elementControllers;

              let scopeToChild = scope;

              /** @type {NodeRef} */
              let $element;

              /** @type {Attributes} */
              let attrs;

              let scopeBindingInfo;

              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$nodeRef;
              } else {
                $element = new NodeRef(linkNode);
                attrs = new Attributes(
                  $animate,
                  $exceptionHandler,
                  $sce,
                  $element,
                  templateAttrs,
                );
              }

              controllerScope = scope;

              if (newIsolateScopeDirective) {
                isolateScope = scope.$newIsolate();
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }

              if (boundTranscludeFn) {
                // track `boundTranscludeFn` so it can be unwrapped if `transcludeFn`
                // is later passed as `parentBoundTranscludeFn` to `publicLinkFn`
                /** @type {any} */
                const newTrancludeFn = /** @type {any} */ (
                  controllersBoundTransclude
                );

                newTrancludeFn.$$boundTransclude = boundTranscludeFn;
                // expose the slots on the `$transclude` function
                newTrancludeFn.isSlotFilled = function (slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
                transcludeFn = newTrancludeFn;
              }

              if (controllerDirectives) {
                elementControllers = setupControllers(
                  $element,
                  attrs,
                  transcludeFn,
                  controllerDirectives,
                  isolateScope,
                  scope,
                  newIsolateScopeDirective,
                );
              }

              if (newIsolateScopeDirective) {
                isolateScope.$target.$$isolateBindings =
                  newIsolateScopeDirective.$$isolateBindings;
                scopeBindingInfo = initializeDirectiveBindings(
                  scope,
                  attrs,
                  isolateScope,
                  isolateScope.$$isolateBindings,
                  newIsolateScopeDirective,
                );

                if (scopeBindingInfo.removeWatches) {
                  isolateScope.$on("$destroy", scopeBindingInfo.removeWatches);
                }
              }

              // Initialize bindToController bindings
              for (const name in elementControllers) {
                const controllerDirective = controllerDirectives[name];

                const controller = elementControllers[name];

                const bindings = controllerDirective.$$bindings.bindToController;

                // Controller instance is bound to the scope
                const controllerInstance = controller();

                controller.instance = controllerScope.$new(controllerInstance);
                setCacheData(
                  $element.node,
                  `$${controllerDirective.name}Controller`,
                  controller.instance,
                );
                controller.bindingInfo = initializeDirectiveBindings(
                  controllerScope,
                  attrs,
                  controller.instance,
                  bindings,
                  controllerDirective,
                );
              }

              // Bind the required controllers to the controller, if `require` is an object and `bindToController` is truthy
              if (controllerDirectives) {
                entries(controllerDirectives).forEach(
                  ([name, controllerDirective]) => {
                    const { require } = controllerDirective;

                    if (
                      controllerDirective.bindToController &&
                      !isArray(require) &&
                      isObject(require)
                    ) {
                      extend(
                        elementControllers[name].instance,
                        getControllers(
                          name,
                          require,
                          $element.element,
                          elementControllers,
                        ),
                      );
                    }
                  },
                );
              }

              // Handle the init and destroy lifecycle hooks on all controllers that have them
              if (elementControllers) {
                Object.values(elementControllers).forEach((controller) => {
                  const controllerInstance = controller.instance;

                  if (isFunction(controllerInstance.$onChanges)) {
                    try {
                      controllerInstance.$onChanges(
                        controller.bindingInfo.initialChanges,
                      );
                    } catch (err) {
                      $exceptionHandler(err);
                    }
                  }

                  if (isFunction(controllerInstance.$onInit)) {
                    try {
                      controllerInstance.$target.$onInit();
                    } catch (err) {
                      $exceptionHandler(err);
                    }
                  }

                  if (isFunction(controllerInstance.$onDestroy)) {
                    controllerScope.$on("$destroy", () => {
                      controllerInstance.$onDestroy();
                    });
                  }
                });
              }

              // PRELINKING
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                const preLinkFn = /** @type {any} */ (preLinkFns[i]);

                const controllers =
                  preLinkFn.require &&
                  getControllers(
                    preLinkFn.directiveName,
                    preLinkFn.require,
                    $element.element,
                    elementControllers,
                  );

                // invoke link function
                try {
                  preLinkFn(
                    preLinkFn.isolateScope ? isolateScope : scope,
                    $element.node, // Prelink functions accept a Node
                    attrs,
                    controllers,
                    transcludeFn,
                  );
                } catch (err) {
                  $exceptionHandler(err);
                }
              }

              // RECURSION
              // We only pass the isolate scope, if the isolate directive has a template,
              // otherwise the child elements do not belong to the isolate directive.

              if (
                newIsolateScopeDirective &&
                (newIsolateScopeDirective.template ||
                  newIsolateScopeDirective.templateUrl === null)
              ) {
                scopeToChild = isolateScope;
              }

              if (
                childLinkFn &&
                linkNode &&
                linkNode.childNodes &&
                linkNode.childNodes.length
              ) {
                childLinkFn(
                  scopeToChild,
                  new NodeRef(linkNode.childNodes),
                  boundTranscludeFn,
                );
              }

              // POSTLINKING
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                const postLinkFn = /** @type {any} */ (postLinkFns[i]);

                const controllers =
                  postLinkFn.require &&
                  getControllers(
                    postLinkFn.directiveName,
                    postLinkFn.require,
                    /** @type {Element} */ ($element.node),
                    elementControllers,
                  );

                // invoke link function
                try {
                  if (postLinkFn.isolateScope) {
                    setIsolateScope($element.element, isolateScope);
                  }

                  postLinkFn(
                    postLinkFn.isolateScope ? isolateScope : scope,
                    $element.node,
                    attrs,
                    controllers,
                    transcludeFn,
                  );
                } catch (err) {
                  $exceptionHandler(err);
                }
              }

              if (elementControllers) {
                // Trigger $postLink lifecycle hooks
                Object.values(elementControllers).forEach((controller) => {
                  const controllerInstance = controller.instance;

                  if (isFunction(controllerInstance.$postLink)) {
                    controllerInstance.$postLink();
                  }
                });
              }

              // This is the function that is injected as `$transclude` or
              // the fifth parameter to the link function.
              // Example: function link (scope, element, attrs, ctrl, transclude) {}
              // Note: all arguments are optional!
              function controllersBoundTransclude(
                scopeParam,
                cloneAttachFn,
                futureParentElement,
                slotName,
              ) {
                let transcludeControllers;

                // No scope passed in:
                if (!isScope(scopeParam)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scopeParam;
                  scopeParam = undefined;
                }

                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }

                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective
                    ? $element.node.parentElement
                    : $element.node;
                }

                if (slotName) {
                  // slotTranscludeFn can be one of three things:
                  //  * a transclude function - a filled slot
                  //  * `null` - an optional slot that was not filled
                  //  * `undefined` - a slot that was not declared (i.e. invalid)
                  const slotTranscludeFn = boundTranscludeFn.$$slots[slotName];

                  if (slotTranscludeFn) {
                    return slotTranscludeFn(
                      scopeParam,
                      cloneAttachFn,
                      transcludeControllers,
                      futureParentElement,
                      scopeToChild,
                    );
                  }

                  if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr(
                      "noslot",
                      'No parent directive that requires a transclusion with slot name "{0}". ' +
                        "Element: {1}",
                      slotName,
                      startingTag($element.element),
                    );
                  }

                  return undefined;
                } else {
                  return boundTranscludeFn(
                    scopeParam,
                    cloneAttachFn,
                    transcludeControllers,
                    futureParentElement,
                    scopeToChild,
                  );
                }
              }
            };

            // executes all directives on the current element
            for (let i = 0, ii = directives.length; i < ii; i++) {
              directive = directives[i];

              if (terminalPriority > directive.priority) {
                break; // prevent further processing of directives
              }

              directiveValue = directive.scope;

              if (directiveValue) {
                // skip the check for directives with async templates, we'll check the derived sync
                // directive when the template arrives
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    // This directive is trying to add an isolated scope.
                    // Check that there is no scope of any kind already
                    assertNoDuplicate(
                      "new/isolated scope",
                      newIsolateScopeDirective || newScopeDirective,
                      directive,
                      compileNodeRef,
                    );
                    newIsolateScopeDirective = directive;
                  } else {
                    // This directive is trying to add a child scope.
                    // Check that there is no isolated scope already
                    assertNoDuplicate(
                      "new/isolated scope",
                      newIsolateScopeDirective,
                      directive,
                      compileNodeRef,
                    );
                  }
                }

                newScopeDirective = newScopeDirective || directive;
              }

              directiveName = directive.name;

              // If we encounter a condition that can result in transclusion on the directive,
              // then scan ahead in the remaining directives for others that may cause a multiple
              // transclusion error to be thrown during the compilation process.  If a matching directive
              // is found, then we know that when we encounter a transcluded directive, we need to eagerly
              // compile the `transclude` function rather than doing it lazily in order to throw
              // exceptions at the correct time
              const hasReplacedTemplate =
                directive.replace &&
                (directive.templateUrl || directive.template);

              const shouldTransclude =
                directive.transclude &&
                !EXCLUDED_DIRECTIVES.includes(directive.name);

              if (
                !didScanForMultipleTransclusion &&
                (hasReplacedTemplate || shouldTransclude)
              ) {
                let candidateDirective;

                for (
                  let scanningIndex = i + 1;
                  (candidateDirective = directives[scanningIndex++]);

                ) {
                  if (
                    (candidateDirective.transclude &&
                      !EXCLUDED_DIRECTIVES.includes(candidateDirective.name)) ||
                    (candidateDirective.replace &&
                      (candidateDirective.templateUrl ||
                        candidateDirective.template))
                  ) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }

                didScanForMultipleTransclusion = true;
              }

              if (!directive.templateUrl && directive.controller) {
                controllerDirectives =
                  controllerDirectives || Object.create(null);
                assertNoDuplicate(
                  `'${directiveName}' controller`,
                  controllerDirectives[directiveName],
                  directive,
                  compileNodeRef,
                );
                controllerDirectives[directiveName] = directive;
              }

              directiveValue = directive.transclude;

              if (directiveValue) {
                hasTranscludeDirective = true;

                // Special case ngIf and ngRepeat so that we don't complain about duplicate transclusion.
                // This option should only be used by directives that know how to safely handle element transclusion,
                // where the transcluded nodes are added or replaced after linking.
                if (!EXCLUDED_DIRECTIVES.includes(directive.name)) {
                  assertNoDuplicate(
                    "transclusion",
                    nonTlbTranscludeDirective,
                    directive,
                    compileNodeRef,
                  );
                  nonTlbTranscludeDirective = directive;
                }

                if (directiveValue === "element") {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = compileNodeRef;
                  compileNodeRef = new NodeRef(document.createComment(""));
                  templateAttrs.$nodeRef = compileNodeRef;
                  compileNode = compileNodeRef.node;
                  ctxNodeRef.node = compileNode;
                  replaceWith(
                    new NodeRef($template._element),
                    compileNode,
                    index,
                  );

                  // @ts-ignore
                  childTranscludeFn = compilationGenerator(
                    mightHaveMultipleTransclusionError,
                    $template._element,
                    transcludeFn,
                    terminalPriority,
                    replaceDirective && replaceDirective.name,
                    {
                      // Don't pass in:
                      // - controllerDirectives - otherwise we'll create duplicates controllers
                      // - newIsolateScopeDirective or templateDirective - combining templates with
                      //   element transclusion doesn't make sense.
                      //
                      // We need only nonTlbTranscludeDirective so that we prevent putting transclusion
                      // on the same element more than once.
                      nonTlbTranscludeDirective,
                    },
                  );
                } else {
                  const slots = Object.create(null);

                  let nodes;

                  if (!isObject(directiveValue)) {
                    //
                    // Clone childnodes before clearing contents on transcluded directives
                    nodes = compileNode.cloneNode(true).childNodes;
                  } else {
                    // We have transclusion slots,
                    // collect them up, compile them and store their transclusion functions
                    nodes = document.createDocumentFragment();

                    const slotMap = Object.create(null);

                    const filledSlots = Object.create(null);

                    // Parse the element selectors
                    entries(directiveValue).forEach(
                      ([slotName, elementSelector]) => {
                        // If an element selector starts with a ? then it is optional
                        const optional = elementSelector.charAt(0) === "?";

                        elementSelector = optional
                          ? elementSelector.substring(1)
                          : elementSelector;

                        slotMap[elementSelector] = slotName;

                        // We explicitly assign `null` since this implies that a slot was defined but not filled.
                        // Later when calling boundTransclusion functions with a slot name we only error if the
                        // slot is `undefined`
                        slots[slotName] = null;

                        // filledSlots contains `true` for all slots that are either optional or have been
                        // filled. This is used to check that we have not missed any required slots
                        filledSlots[slotName] = optional;
                      },
                    );

                    // Add the matching elements into their slot
                    compileNodeRef.element.childNodes.forEach((node) => {
                      const slotName =
                        slotMap[
                          directiveNormalize(
                            getNodeName(/** @type {Element} */ (node)),
                          )
                        ];

                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] =
                          slots[slotName] || document.createDocumentFragment();
                        slots[slotName].appendChild(node);
                      } else {
                        nodes.appendChild(node);
                      }
                    });

                    // Check for required slots that were not filled
                    entries(filledSlots).forEach(([slotName, filled]) => {
                      if (!filled) {
                        throw $compileMinErr(
                          "reqslot",
                          "Required transclusion slot `{0}` was not filled.",
                          slotName,
                        );
                      }
                    });

                    for (const slotName in slots) {
                      if (slots[slotName]) {
                        // Only define a transclusion function if the slot was filled
                        const slotCompileNodes = slots[slotName].childNodes;

                        slots[slotName] = compilationGenerator(
                          mightHaveMultipleTransclusionError,
                          slotCompileNodes,
                          transcludeFn,
                        );
                      }
                    }

                    nodes = nodes.childNodes;
                  }

                  emptyElement(/** @type {Element} */ (compileNode)); // clear contents on transcluded directives

                  // lazily compile transcluded template and generate a transcluded link function
                  // @ts-ignore
                  childTranscludeFn = compilationGenerator(
                    mightHaveMultipleTransclusionError,
                    nodes,
                    transcludeFn,
                    undefined,
                    undefined,
                    {
                      needsNewScope:
                        directive.$$isolateScope || directive.$$newScope,
                    },
                  );
                  childTranscludeFn.$$slots = slots;
                }
              }

              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate(
                  "template",
                  templateDirective,
                  directive,
                  compileNodeRef,
                );
                templateDirective = directive;

                directiveValue = isFunction(directive.template)
                  ? directive.template(compileNodeRef.node, templateAttrs)
                  : directive.template;

                directiveValue = denormalizeTemplate(directiveValue);

                if (directive.replace) {
                  replaceDirective = directive;

                  if (isTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(
                      wrapTemplate(
                        directive.templateNamespace,
                        trim(directiveValue),
                      ),
                    );
                  }

                  if (isString($template)) {
                    $template = Array.from(
                      createNodelistFromHTML($template),
                    ).filter((x) => x.nodeType === NodeType._ELEMENT_NODE);
                  }
                  compileNode = $template[0];

                  if (
                    $template.length !== 1 ||
                    compileNode.nodeType !== NodeType._ELEMENT_NODE
                  ) {
                    throw $compileMinErr(
                      "tplrt",
                      "Template for directive '{0}' must have exactly one root element. {1}",
                      directiveName,
                      "",
                    );
                  }

                  replaceWith(compileNodeRef, compileNode);

                  if (parentNodeRef) {
                    /** @type {NodeRef} */ (parentNodeRef)._setIndex(
                      index,
                      compileNode,
                    );
                  }

                  const newTemplateAttrs = { $attr: {} };

                  // combine directives from the original node and from the template:
                  // - take the array of directives for this element
                  // - split it into two parts, those that already applied (processed) and those that weren't (unprocessed)
                  // - collect directives from the template and sort them by priority
                  // - combine directives as: processed + template + unprocessed
                  const templateDirectives = collectDirectives(
                    /** @type {Element} */ (compileNode),
                    newTemplateAttrs,
                  );

                  const unprocessedDirectives = directives.splice(
                    i + 1,
                    directives.length - (i + 1),
                  );

                  if (newIsolateScopeDirective || newScopeDirective) {
                    // The original directive caused the current element to be replaced but this element
                    // also needs to have a new scope, so we need to tell the template directives
                    // that they would need to get their scope from further up, if they require transclusion
                    markDirectiveScope(
                      templateDirectives,
                      newIsolateScopeDirective,
                      newScopeDirective,
                    );
                  }
                  directives = directives
                    .concat(templateDirectives)
                    .concat(unprocessedDirectives);

                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

                  ii = directives.length;
                } else {
                  if (compileNodeRef._isElement()) {
                    compileNodeRef.element.innerHTML = directiveValue;
                  }
                }
              }

              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate(
                  "template",
                  templateDirective,
                  directive,
                  compileNodeRef,
                );
                templateDirective = directive;

                if (directive.replace) {
                  replaceDirective = directive;
                }
                // @ts-ignore
                nodeLinkFn = compileTemplateUrl(
                  directives.splice(i, directives.length - i),
                  compileNodeRef,
                  templateAttrs,
                  /** @type {Element} */ (compileNode),
                  hasTranscludeDirective && childTranscludeFn,
                  preLinkFns,
                  postLinkFns,
                  {
                    index,
                    controllerDirectives,
                    newScopeDirective:
                      newScopeDirective !== directive && newScopeDirective,
                    newIsolateScopeDirective,
                    templateDirective,
                    nonTlbTranscludeDirective,
                    futureParentElement:
                      previousCompileContext.futureParentElement,
                  },
                );
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  /** @type {ng.PublicLinkFn} */
                  const linkFn = directive.compile(
                    compileNodeRef._getAny(),
                    templateAttrs,
                    childTranscludeFn,
                  );

                  const context = directive.$$originalDirective || directive;

                  if (isFunction(linkFn)) {
                    addLinkFns(null, bind(context, linkFn));
                  } else if (linkFn) {
                    addLinkFns(
                      bind(context, linkFn.pre),
                      bind(context, linkFn.post),
                    );
                  }
                } catch (err) {
                  $exceptionHandler(err);
                }
              }

              if (directive.terminal) {
                terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }

            previousCompileContext.hasElementTranscludeDirective =
              hasElementTranscludeDirective;

            // might be normal or delayed nodeLinkFn depending on if templateUrl is present
            return {
              nodeLinkFn,
              terminal,
              transclude: childTranscludeFn,
              transcludeOnThisElement: hasTranscludeDirective,
              templateOnThisElement: hasTemplate,
              newScope: newScopeDirective && newScopeDirective.scope === true,
            };

            /// /////////////////
            function addLinkFns(pre, post) {
              if (pre) {
                pre.require = directive.require;
                pre.directiveName = directiveName;

                if (
                  newIsolateScopeDirective === directive ||
                  directive.$$isolateScope
                ) {
                  pre = cloneAndAnnotateFn(pre, { isolateScope: true });
                }
                preLinkFns.push(pre);
              }

              if (post) {
                post.require = directive.require;
                post.directiveName = directiveName;

                if (
                  newIsolateScopeDirective === directive ||
                  directive.$$isolateScope
                ) {
                  post = cloneAndAnnotateFn(post, { isolateScope: true });
                }
                postLinkFns.push(post);
              }
            }
          }

          /**
           *
           * @param {string} directiveName
           * @param {string | Array<any> | Record<string, any>} require
           * @param {Element} $element
           * @param {*} elementControllers
           * @returns
           */
          function getControllers(
            directiveName,
            require,
            $element,
            elementControllers,
          ) {
            let value;

            if (isString(require)) {
              const match = require.match(REQUIRE_PREFIX_REGEXP);

              const name = require.substring(match[0].length);

              const inheritType = match[1] || match[3];

              const optional = match[2] === "?";

              // If only parents then start at the parent element
              if (inheritType === "^^") {
                if ($element.parentElement) {
                  $element = $element.parentElement;
                } else {
                  $element = undefined;
                }
                // Otherwise attempt getting the controller from elementControllers in case
                // the element is transcluded (and has no data) and to avoid .data if possible
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }

              if (!value) {
                const dataName = `$${name}Controller`;

                if (
                  inheritType === "^^" &&
                  $element &&
                  $element.nodeType === NodeType._DOCUMENT_NODE
                ) {
                  // inheritedData() uses the documentElement when it finds the document, so we would
                  // require from the element itself.
                  value = null;
                } else {
                  value = $element
                    ? inheritType
                      ? getInheritedData($element, dataName)
                      : getCacheData($element, dataName)
                    : undefined;
                }
              }

              if (!value && !optional) {
                throw $compileMinErr(
                  "ctreq",
                  "Controller '{0}', required by directive '{1}', can't be found!",
                  name,
                  directiveName,
                );
              }
            } else if (isArray(require)) {
              value = [];

              for (let i = 0, ii = require.length; i < ii; i++) {
                value[i] = getControllers(
                  directiveName,
                  require[i],
                  $element,
                  elementControllers,
                );
              }
            } else if (isObject(require)) {
              value = {};
              entries(require).forEach(([property, controller]) => {
                value[property] = getControllers(
                  directiveName,
                  controller,
                  $element,
                  elementControllers,
                );
              });
            }

            return value || null;
          }

          /**
           * @param {NodeRef} $element
           * @param attrs
           * @param transcludeFn
           * @param controllerDirectives
           * @param isolateScope
           * @param scope
           * @param newIsolateScopeDirective
           * @returns {any}
           */
          function setupControllers(
            $element,
            attrs,
            transcludeFn,
            controllerDirectives,
            isolateScope,
            scope,
            newIsolateScopeDirective,
          ) {
            const elementControllers = Object.create(null);

            for (const controllerKey in controllerDirectives) {
              const directive = controllerDirectives[controllerKey];

              const locals = {
                $scope:
                  directive === newIsolateScopeDirective ||
                  directive.$$isolateScope
                    ? isolateScope
                    : scope,
                $element: $element.node,
                $attrs: attrs,
                $transclude: transcludeFn,
              };

              let { controller } = directive;

              if (controller === "@") {
                controller = attrs[directive.name];
              }

              const controllerInstance = $controller(
                controller,
                locals,
                true,
                directive.controllerAs,
              );

              // For directives with element transclusion the element is a comment.
              // In this case .data will not attach any data.
              // Instead, we save the controllers for the element in a local hash and attach to .data
              // later, once we have the actual element.
              elementControllers[directive.name] = controllerInstance;

              if ($element._isElement()) {
                setCacheData(
                  $element.element,
                  `$${directive.name}Controller`,
                  controllerInstance.instance,
                );
              }
            }

            return elementControllers;
          }

          // Depending upon the context in which a directive finds itself it might need to have a new isolated
          // or child scope created. For instance:
          // * if the directive has been pulled into a template because another directive with a higher priority
          // asked for element transclusion
          // * if the directive itself asks for transclusion but it is at the root of a template and the original
          // element was replaced. See https://github.com/angular/angular.js/issues/12936
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (let j = 0, jj = directives.length; j < jj; j++) {
              directives[j] = inherit$1(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope,
              });
            }
          }

          /**
           * looks up the directive and decorates it with exception handling and proper parameters. We
           * call this the boundDirective.
           *
           * @param {string} name name of the directive to look up.
           * @param {string} location The directive must be found in specific format.
           *   String containing any of these characters:
           *
           *   * `E`: element name
           *   * `A': attribute
           * @returns {boolean} true if directive was added.
           */
          function addDirective(tDirectives, name, location, maxPriority) {
            let match = false;

            if (hasOwn(hasDirectives, name)) {
              for (
                let directive,
                  directives = $injector.get(name + DirectiveSuffix),
                  i = 0,
                  ii = directives.length;
                i < ii;
                i++
              ) {
                directive = directives[i];

                if (
                  (isUndefined(maxPriority) ||
                    maxPriority > directive.priority) &&
                  directive.restrict.indexOf(location) !== -1
                ) {
                  if (!directive.$$bindings) {
                    const bindings = (directive.$$bindings =
                      parseDirectiveBindings(directive, directive.name));

                    if (isObject(bindings.isolateScope)) {
                      directive.$$isolateBindings = bindings.isolateScope;
                    }
                  }
                  tDirectives.push(directive);
                  match = directive;
                }
              }
            }

            return match;
          }

          /**
           * When the element is replaced with HTML template then the new attributes
           * on the template need to be merged with the existing attributes in the DOM.
           * The desired effect is to have both of the attributes present.
           *
           * @param {object} dst destination attributes (original DOM)
           * @param {object} src source attributes (from the directive template)
           */
          function mergeTemplateAttributes(dst, src) {
            const srcAttr = src.$attr;

            const dstAttr = dst.$attr;

            // reapply the old attributes to the new element
            entries(dst).forEach(([key, value]) => {
              if (key[0] !== "$" && key[0] !== "_") {
                if (src[key] && src[key] !== value) {
                  if (value.length) {
                    value += (key === "style" ? ";" : " ") + src[key];
                  } else {
                    value = src[key];
                  }
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });

            // copy the new attributes on the old attrs object
            entries(src).forEach(([key, value]) => {
              // Check if we already set this attribute in the loop above.
              // `dst` will never contain hasOwnProperty as DOM parser won't let it.
              // You will get an "InvalidCharacterError: DOM Exception 5" error if you
              // have an attribute like "has-own-property" or "data-has-own-property", etc.
              if (!hasOwn(dst, key) && key.charAt(0) !== "$") {
                dst[key] = value;

                if (key !== "class" && key !== "style") {
                  dstAttr[key] = srcAttr[key];
                }
              }
            });
          }

          /**
           *
           * @param {ng.Directive[]} directives
           * @param {NodeRef} $compileNode
           * @param {Attributes} tAttrs
           * @param {Element} $rootElement
           * @param {*} childTranscludeFn
           * @param {Array} preLinkFns
           * @param {Array} postLinkFns
           * @param {*} previousCompileContext
           * @returns
           */
          function compileTemplateUrl(
            directives,
            $compileNode,
            tAttrs,
            $rootElement,
            childTranscludeFn,
            preLinkFns,
            postLinkFns,
            previousCompileContext,
          ) {
            let linkQueue = [];

            /** @type {any} */
            let afterTemplateNodeLinkFn;

            let afterTemplateChildLinkFn;

            let afterTemplateNodeLinkFnCtx;

            const beforeTemplateCompileNode = $compileNode._getAny();

            const origAsyncDirective = directives.shift();

            const derivedSyncDirective = inherit$1(origAsyncDirective, {
              templateUrl: null,
              transclude: null,
              replace: null,
              $$originalDirective: origAsyncDirective,
            });

            /** @type {string} */
            let templateUrl;

            if (isFunction(origAsyncDirective.templateUrl)) {
              templateUrl =
                /** @type { ((element: Element, tAttrs: Attributes) => string) } */ (
                  origAsyncDirective.templateUrl
                )($compileNode.element, tAttrs);
            } else {
              // eslint-disable-next-line prefer-destructuring
              templateUrl = /** @type {string} */ (
                origAsyncDirective.templateUrl
              );
            }
            const { templateNamespace } = origAsyncDirective;

            emptyElement($compileNode.element);

            $templateRequest(templateUrl)
              .then((content) => {
                /** @type {Element} */
                let compileNode;

                let tempTemplateAttrs;

                let $template;

                let childBoundTranscludeFn;

                content = denormalizeTemplate(content);

                if (origAsyncDirective.replace) {
                  if (isTextNode(content)) {
                    $template = [];
                  } else if (isString(content)) {
                    $template = Array.from(
                      createNodelistFromHTML(content),
                    ).filter(
                      (node) =>
                        node.nodeType !== NodeType._COMMENT_NODE &&
                        node.nodeType !== NodeType._TEXT_NODE,
                    );
                  } else {
                    $template = removeComments(
                      wrapTemplate(templateNamespace, trim(content)),
                    );
                  }
                  compileNode = $template[0];

                  if (
                    $template.length !== 1 ||
                    compileNode.nodeType !== NodeType._ELEMENT_NODE
                  ) {
                    throw $compileMinErr(
                      "tplrt",
                      "Template for directive '{0}' must have exactly one root element. {1}",
                      origAsyncDirective.name,
                      templateUrl,
                    );
                  }

                  tempTemplateAttrs = { $attr: {} };

                  replaceWith(
                    $compileNode,
                    compileNode,
                    previousCompileContext.index,
                  );

                  const templateDirectives = collectDirectives(
                    compileNode,
                    tempTemplateAttrs,
                  );

                  if (isObject(origAsyncDirective.scope)) {
                    // the original directive that caused the template to be loaded async required
                    // an isolate scope
                    markDirectiveScope(templateDirectives, true);
                  }
                  directives = templateDirectives.concat(directives);

                  mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                } else {
                  compileNode = /** @type {Element} */ (
                    beforeTemplateCompileNode
                  );
                  $compileNode.element.innerHTML = content;
                }

                directives.unshift(derivedSyncDirective);
                afterTemplateNodeLinkFnCtx = applyDirectivesToNode(
                  directives,
                  compileNode,
                  tAttrs,
                  childTranscludeFn,
                  origAsyncDirective,
                  preLinkFns,
                  postLinkFns,
                  { ...previousCompileContext, ctxNodeRef: $compileNode },
                );

                afterTemplateNodeLinkFn = afterTemplateNodeLinkFnCtx?.nodeLinkFn;

                if ($rootElement) {
                  entries($rootElement).forEach(([i, node]) => {
                    if (node === compileNode) {
                      $rootElement[i] = $compileNode;
                    }
                  });
                }
                afterTemplateChildLinkFn = compileNodes(
                  new NodeRef($compileNode._getAny().childNodes),
                  childTranscludeFn,
                );

                while (linkQueue.length) {
                  const scope = linkQueue.shift();

                  const beforeTemplateLinkNode = linkQueue.shift();

                  const boundTranscludeFn = linkQueue.shift();

                  let linkNode = $compileNode._getAny();

                  if (scope.$$destroyed) {
                    continue;
                  }

                  if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                    const oldClasses = beforeTemplateLinkNode.className;

                    if (
                      !(
                        previousCompileContext.hasElementTranscludeDirective &&
                        origAsyncDirective.replace
                      )
                    ) {
                      // it was cloned therefore we have to clone as well.
                      linkNode = compileNode.cloneNode(true);
                      beforeTemplateLinkNode.appendChild(linkNode);
                    }

                    // Copy in CSS classes from original node
                    try {
                      if (oldClasses !== "") {
                        $compileNode.element.classList.forEach((cls) =>
                          beforeTemplateLinkNode.classList.add(cls),
                        );
                      }
                    } catch {
                      // ignore, since it means that we are trying to set class on
                      // SVG element, where class name is read-only.
                    }
                  }

                  if (afterTemplateNodeLinkFnCtx.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(
                      scope,
                      afterTemplateNodeLinkFnCtx.transclude,
                      boundTranscludeFn,
                    );
                  } else {
                    childBoundTranscludeFn = boundTranscludeFn;
                  }

                  afterTemplateNodeLinkFn(
                    afterTemplateChildLinkFn,
                    scope,
                    linkNode,
                    childBoundTranscludeFn,
                  );
                }
                linkQueue = null;
              })
              .catch((error) => {
                if (isError(error)) {
                  $exceptionHandler(error);
                } else {
                  $exceptionHandler(new Error(error));
                }
              });

            return function delayedNodeLinkFn(
              _ignoreChildLinkFn,
              scope,
              node,
              rootElement,
              boundTranscludeFn,
            ) {
              let childBoundTranscludeFn = boundTranscludeFn;

              if (scope.$$destroyed) {
                return;
              }

              if (linkQueue) {
                linkQueue.push(scope, node, rootElement);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(
                    scope,
                    afterTemplateNodeLinkFn.transclude,
                    boundTranscludeFn,
                  );
                }
                afterTemplateNodeLinkFn(
                  afterTemplateChildLinkFn,
                  scope,
                  node,
                  rootElement,
                  childBoundTranscludeFn,
                );
              }
            };
          }

          /**
           * Sorting function for bound directives.
           */
          function byPriority(a, b) {
            const diff = b.priority - a.priority;

            if (diff !== 0) {
              return diff;
            }

            if (a.name !== b.name) {
              return a.name < b.name ? -1 : 1;
            }

            return a.index - b.index;
          }

          function assertNoDuplicate(
            what,
            previousDirective,
            directive,
            element,
          ) {
            if (previousDirective) {
              throw $compileMinErr(
                "multidir",
                "Multiple directives [{0}, {1}] asking for {3} on: {4}",
                previousDirective.name,
                directive.name,
                what,
                startingTag(/** @tupe {NodeRef} */ element._getAny()),
              );
            }
          }

          function addTextInterpolateDirective(directives, text) {
            const interpolateFn = $interpolate(text, true);

            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: () => (scope, node) => {
                  interpolateFn.expressions.forEach((x) => {
                    scope.$watch(x, () => {
                      const res = interpolateFn(deProxy(scope));

                      switch (node.nodeType) {
                        case 1:
                          node.innerHTML = res;
                          break;
                        default:
                          node.nodeValue = res;
                      }
                    });
                  });
                },
              });
            }
          }

          /**
           * @param {string} type
           * @param {string} template
           * @returns
           */
          function wrapTemplate(type, template) {
            type = (type || "html").toLowerCase();
            switch (type) {
              case "svg":
              case "math": {
                const wrapper =
                  /** @type {HTMLDivElement} */ document.createElement("div");

                wrapper.innerHTML = `<${type}>${template}</${type}>`;

                return wrapper.childNodes[0].childNodes;
              }
              default:
                return template;
            }
          }

          function getTrustedAttrContext(nodeName, attrNormalizedName) {
            if (attrNormalizedName === "srcdoc") {
              return $sce.HTML;
            }

            // All nodes with src attributes require a RESOURCE_URL value, except for
            // img and various html5 media nodes, which require the MEDIA_URL context.
            if (attrNormalizedName === "src" || attrNormalizedName === "ngSrc") {
              if (
                ["img", "video", "audio", "source", "track"].indexOf(nodeName) ===
                -1
              ) {
                return $sce.RESOURCE_URL;
              }

              return $sce.MEDIA_URL;
            }

            if (attrNormalizedName === "xlinkHref") {
              // Some xlink:href are okay, most aren't
              if (nodeName === "image") {
                return $sce.MEDIA_URL;
              }

              if (nodeName === "a") {
                return $sce.URL;
              }

              return $sce.RESOURCE_URL;
            }

            if (
              // Formaction
              (nodeName === "form" && attrNormalizedName === "action") ||
              // If relative URLs can go where they are not expected to, then
              // all sorts of trust issues can arise.
              (nodeName === "base" && attrNormalizedName === "href") ||
              // links can be stylesheets or imports, which can run script in the current origin
              (nodeName === "link" && attrNormalizedName === "href")
            ) {
              return $sce.RESOURCE_URL;
            }

            if (
              nodeName === "a" &&
              (attrNormalizedName === "href" || attrNormalizedName === "ngHref")
            ) {
              return $sce.URL;
            }

            return undefined;
          }

          function getTrustedPropContext(nodeName, propNormalizedName) {
            const prop = propNormalizedName.toLowerCase();

            return (
              PROP_CONTEXTS[`${nodeName}|${prop}`] || PROP_CONTEXTS[`*|${prop}`]
            );
          }

          function sanitizeSrcset(value, invokeType) {
            if (!value) {
              return value;
            }

            if (!isString(value)) {
              throw $compileMinErr(
                "srcset",
                'Can\'t pass trusted values to `{0}`: "{1}"',
                invokeType,
                /** @type {unknown} */ (value).toString(),
              );
            }

            // Such values are a bit too complex to handle automatically inside $sce.
            // Instead, we sanitize each of the URIs individually, which works, even dynamically.
            // It's not possible to work around this using `$sce.trustAsMediaUrl`.
            // If you want to programmatically set explicitly trusted unsafe URLs, you should use
            // `$sce.trustAsHtml` on the whole `img` tag and inject it into the DOM using the
            // `ng-bind-html` directive.
            let result = "";

            // first check if there are spaces because it's not the same pattern
            const trimmedSrcset = trim(value);

            //                (   999x   ,|   999w   ,|   ,|,   )
            const srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;

            const pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;

            // split srcset into tuple of uri and descriptor except for the last item
            const rawUris = trimmedSrcset.split(pattern);

            // for each tuples
            const nbrUrisWith2parts = Math.floor(rawUris.length / 2);

            let i;

            for (i = 0; i < nbrUrisWith2parts; i++) {
              const innerIdx = i * 2;

              // sanitize the uri
              result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx]));
              // add the descriptor
              result += ` ${trim(rawUris[innerIdx + 1])}`;
            }

            // split the last item into uri and descriptor
            const lastTuple = trim(rawUris[i * 2]).split(/\s/);

            // sanitize the last uri
            result += $sce.getTrustedMediaUrl(trim(lastTuple[0]));

            // and add the last descriptor if any
            if (lastTuple.length === 2) {
              result += ` ${trim(lastTuple[1])}`;
            }

            return result;
          }

          function addPropertyDirective(node, directives, attrName, propName) {
            if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) {
              throw $compileMinErr(
                "nodomevents",
                "Property bindings for HTML DOM event properties are disallowed",
              );
            }

            const nodeName = getNodeName(node);

            const trustedContext = getTrustedPropContext(nodeName, propName);

            let sanitizer = (x) => x;

            // Sanitize img[srcset] + source[srcset] values.
            if (
              propName === "srcset" &&
              (nodeName === "img" || nodeName === "source")
            ) {
              sanitizer = (value) =>
                sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset");
            } else if (trustedContext) {
              sanitizer = $sce.getTrusted.bind($sce, trustedContext);
            }

            directives.push({
              priority: 100,
              compile: function ngPropCompileFn(_, attr) {
                const ngPropGetter = $parse(attr[attrName]);

                return {
                  pre: function ngPropPreLinkFn(scope, $element) {
                    function applyPropValue() {
                      const propValue = ngPropGetter(scope);

                      $element[propName] = sanitizer(propValue);
                    }

                    applyPropValue();
                    scope.$watch(propName, applyPropValue);
                    scope.$watch(attr[attrName], (val) => {
                      $sce.valueOf(val);
                      applyPropValue();
                    });
                  },
                };
              },
            });
          }

          function addAttrInterpolateDirective(
            node,
            directives,
            value,
            name,
            isNgAttr,
          ) {
            const nodeName = getNodeName(node);

            const trustedContext = getTrustedAttrContext(nodeName, name);

            const mustHaveExpression = !isNgAttr;

            const allOrNothing = ALL_OR_NOTHING_ATTRS.includes(name) || isNgAttr;

            let interpolateFn = $interpolate(
              value,
              mustHaveExpression,
              trustedContext,
              allOrNothing,
            );

            // no interpolation found -> ignore
            if (!interpolateFn) {
              return;
            }

            if (name === "multiple" && nodeName === "select") {
              throw $compileMinErr(
                "selmulti",
                "Binding to the 'multiple' attribute is not supported. Element: {0}",
                startingTag(node.outerHTML),
              );
            }

            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
              throw $compileMinErr(
                "nodomevents",
                "Interpolations for HTML DOM event attributes are disallowed",
              );
            }

            directives.push({
              priority: 100,
              compile() {
                return {
                  pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    const $$observers =
                      attr.$$observers ||
                      (attr.$$observers = Object.create(null));

                    // If the attribute has changed since last $interpolate()ed
                    const newValue = attr[name];

                    if (newValue !== value) {
                      // we need to interpolate again since the attribute value has been updated
                      // (e.g. by another directive's compile function)
                      // ensure unset/empty values make interpolateFn falsy
                      interpolateFn =
                        newValue &&
                        $interpolate(
                          newValue,
                          true,
                          trustedContext,
                          allOrNothing,
                        );
                      value = newValue;
                    }

                    // if attribute was updated so that there is no interpolation going on we don't want to
                    // register any observers
                    if (!interpolateFn) {
                      return;
                    }

                    // initialize attr object so that it's ready in case we need the value for isolate
                    // scope initialization, otherwise the value would not be available from isolate
                    // directive's linking fn during linking phase
                    attr[name] = interpolateFn(scope);

                    ($$observers[name] || ($$observers[name] = [])).$$inter =
                      true;
                    interpolateFn.expressions.forEach((x) => {
                      const targetScope =
                        (attr.$$observers && attr.$$observers[name].$$scope) ||
                        scope;

                      targetScope.$watch(x, () => {
                        const newInterpolatedValue = interpolateFn(scope);

                        // special case for class attribute addition + removal
                        // so that class changes can tap into the animation
                        // hooks provided by the $animate service. Be sure to
                        // skip animations when the first digest occurs (when
                        // both the new and the old values are the same) since
                        // the CSS classes are the non-interpolated values
                        if (name === "class") {
                          attr.$updateClass(
                            newInterpolatedValue,
                            attr.$$element.classList.value,
                          );
                        } else {
                          attr.$set(
                            name,
                            name === "srcset"
                              ? $sce.getTrustedMediaUrl(newInterpolatedValue)
                              : newInterpolatedValue,
                          );
                        }
                      });
                    });

                    if (interpolateFn.expressions.length === 0) {
                      attr.$set(
                        name,
                        name === "srcset"
                          ? $sce.getTrustedMediaUrl(newValue)
                          : newValue,
                      );
                    }
                  },
                };
              },
            });
          }

          /**
           *
           * @param {NodeRef} elementsToRemove The JQLite element which we are going to replace. We keep
           *                                  the shell, but replace its DOM node reference.
           * @param {Node} newNode The new DOM node.
           * @param {number} [index] Parent node index.
           */
          function replaceWith(elementsToRemove, newNode, index) {
            const firstElementToRemove = elementsToRemove._getAny();

            // const removeCount = elementsToRemove.length;
            const parent = firstElementToRemove.parentNode;

            if (parent) {
              if (isDefined(index)) {
                const oldChild = parent.childNodes[index];

                if (oldChild) {
                  parent.replaceChild(newNode, oldChild);
                }
              } else {
                parent.insertBefore(newNode, parent.firstChild);
                //parent.append(newNode);
              }
            }

            // Append all the `elementsToRemove` to a fragment. This will...
            // - remove them from the DOM
            // - allow them to still be traversed with .nextSibling
            // - allow a single fragment.qSA to fetch all elements being removed
            const fragment = document.createDocumentFragment();

            elementsToRemove._collection().forEach((element) => {
              fragment.appendChild(element);
            });

            elementsToRemove.node = newNode;
          }

          function cloneAndAnnotateFn(fn, annotation) {
            return extend(
              function () {
                return fn.apply(null, arguments);
              },
              fn,
              annotation,
            );
          }

          function strictBindingsCheck(attrName, directiveName) {
            if (strictComponentBindingsEnabled) {
              throw $compileMinErr(
                "missingattr",
                "Attribute '{0}' of '{1}' is non-optional and must be set!",
                attrName,
                directiveName,
              );
            }
          }

          // Set up $watches for isolate scope and controller bindings.
          /**
           *
           * @param {ng.Scope} scope
           * @param {*} attrs
           * @param {ng.Scope}  destination - child scope or isolate scope
           * @param {*} bindings
           * @param {*} directive
           * @returns
           */
          function initializeDirectiveBindings(
            scope,
            attrs,
            destination,
            bindings,
            directive,
          ) {
            const removeWatchCollection = [];

            const initialChanges = {};

            let changes;

            if (bindings) {
              entries(bindings).forEach(([scopeName, definition]) => {
                const {
                  attrName,
                  optional,
                  mode, // @, =, <, or &
                } = definition;

                let lastValue;

                let parentGet;

                let parentSet;

                let compare;

                let removeWatch;

                let firstCall = true;

                let firstChange = true;

                switch (mode) {
                  case "@":
                    if (!optional && !hasOwn(attrs, attrName)) {
                      strictBindingsCheck(attrName, directive.name);
                      destination[scopeName] = attrs[attrName] = undefined;
                    }

                    removeWatch = attrs.$observe(attrName, (value) => {
                      if (isString(value) || isBoolean(value)) {
                        recordChanges(scopeName, value, firstChange);

                        destination[scopeName] = value;

                        if (firstCall) {
                          firstCall = false;
                        } else {
                          triggerOnChangesHook();
                          firstChange = false;
                        }
                      }
                    });
                    attrs.$$observers[attrName].$$scope = scope;
                    lastValue = attrs[attrName];

                    if (isString(lastValue)) {
                      // If the attribute has been provided then we trigger an interpolation to ensure
                      // the value is there for use in the link fn
                      destination[scopeName] = $interpolate(lastValue)(scope);
                    } else if (isBoolean(lastValue)) {
                      // If the attributes is one of the BOOLEAN_ATTR then AngularTS will have converted
                      // the value to boolean rather than a string, so we special case this situation
                      destination[scopeName] = lastValue;
                    }

                    /**
                     * @type {import("./inteface.ts").SimpleChange}
                     */
                    initialChanges[scopeName] = {
                      currentValue: destination[scopeName],
                      firstChange: true,
                    };
                    removeWatchCollection.push(removeWatch);
                    break;

                  case "=": {
                    if (!hasOwn(attrs, attrName)) {
                      if (optional) {
                        break;
                      }
                      strictBindingsCheck(attrName, directive.name);
                      attrs[attrName] = undefined;
                    }

                    if (optional && !attrs[attrName]) {
                      break;
                    }

                    parentGet = $parse(attrs[attrName]);

                    if (parentGet.literal) {
                      compare = equals$1;
                    } else {
                      compare = simpleCompare;
                    }

                    parentSet =
                      parentGet.assign ||
                      function () {
                        // reset the change, or we will throw this exception on every $digest
                        lastValue = destination.$target[scopeName] =
                          parentGet(scope);
                        throw $compileMinErr(
                          "nonassign",
                          "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                          attrs[attrName],
                          attrName,
                          directive.name,
                        );
                      };
                    // store the value that the parent scope had after the last check:
                    lastValue = destination.$target[scopeName] = parentGet(
                      scope.$target,
                    );
                    const parentValueWatch = function parentValueWatch(
                      parentValue,
                    ) {
                      if (!compare(parentValue, destination[scopeName])) {
                        // we are out of sync and need to copy
                        if (!compare(parentValue, lastValue)) {
                          // parent changed and it has precedence
                          destination[scopeName] = parentValue;
                        } else {
                          // if the parent can be assigned then do so
                          parentSet(
                            scope,
                            (parentValue = destination[scopeName]),
                          );
                        }
                      }
                      lastValue = parentValue;

                      return lastValue;
                    };

                    parentValueWatch.$stateful = true;

                    if (definition.collection) {
                      removeWatch = scope.$watch(
                        attrs[attrName],
                        parentValueWatch,
                      );
                    } else {
                      if (attrs[attrName]) {
                        const expr = attrs[attrName];

                        // make it lazy as we dont want to trigger the two way data binding at this point
                        scope.$watch(
                          expr,
                          (val) => {
                            const res = $parse(attrs[attrName], parentValueWatch);

                            if (val) {
                              if (parentGet.literal) {
                                scope.$target[attrName] = val;
                              } else {
                                scope[attrName] = val;
                              }
                              res(scope);
                            } else {
                              scope[attrName] = scope[attrs[attrName]];
                            }
                          },
                          true,
                        );
                      }

                      removeWatch = destination.$watch(
                        attrName,
                        (val) => {
                          if (
                            val === lastValue &&
                            !isUndefined(attrs[attrName])
                          ) {
                            return;
                          }

                          if (
                            (!!parentGet.inputs && !parentGet.literal) ||
                            (isUndefined(attrs[attrName]) && isDefined(val))
                          ) {
                            destination.$target[attrName] = lastValue;
                            throw $compileMinErr(
                              "nonassign",
                              "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!",
                              attrs[attrName],
                              attrName,
                              directive.name,
                            );
                          } else {
                            // manually set the handler to avoid watch cycles
                            if (isObject(val)) {
                              entries(val).forEach(([key, value]) => {
                                scope.$target[key] = value;
                              });
                            } else {
                              parentSet(scope.$target, (lastValue = val));
                              scope.$handler.watchers
                                .get(attrs[attrName])
                                ?.forEach((watchFn) => {
                                  watchFn.listenerFn(val, scope.$target);
                                });
                            }
                          }
                        },
                        true,
                      );
                    }
                    removeWatchCollection.push(removeWatch);
                    break;
                  }

                  case "<":
                    if (!hasOwn(attrs, attrName)) {
                      if (optional) {
                        break;
                      }
                      strictBindingsCheck(attrName, directive.name);
                      attrs[attrName] = undefined;
                    }

                    if (optional && !attrs[attrName]) {
                      break;
                    }

                    parentGet = $parse(attrs[attrName]);

                    destination.$target[scopeName] = parentGet(scope.$target);
                    /** @type {import("./inteface.ts").SimpleChange} */
                    initialChanges[scopeName] = {
                      currentValue: destination.$target[scopeName],
                      firstChange,
                    };
                    scope.$target.attrs = attrs;

                    if (attrs[attrName]) {
                      removeWatch = scope.$watch(
                        attrs[attrName],
                        (val) => {
                          destination.$target[scopeName] = val;
                          recordChanges(scopeName, val, firstChange);

                          if (firstChange) {
                            firstChange = false;
                          }
                        },
                        true,
                      );
                      removeWatchCollection.push(removeWatch);
                    }
                    break;

                  case "&":
                    if (!optional && !hasOwn(attrs, attrName)) {
                      strictBindingsCheck(attrName, directive.name);
                    }
                    // Don't assign Object.prototype method to scope
                    parentGet = hasOwn(attrs, attrName)
                      ? $parse(attrs[attrName])
                      : () => {
                          /* empty */
                        };

                    // Don't assign noop to destination if expression is not valid
                    if (
                      parentGet.toString() ===
                        (() => {
                          /* empty */
                        }).toString() &&
                      optional
                    ) {
                      break;
                    }

                    destination.$target[scopeName] = function (locals) {
                      return parentGet(scope.$target, locals);
                    };

                    break;
                }
              });
            }

            function recordChanges(key, currentValue, initial) {
              if (isFunction(destination.$onChanges)) {
                // If we have not already scheduled the top level onChangesQueue handler then do so now
                if (!onChangesQueue) {
                  scope.$postUpdate(flushOnChangesQueue);
                  onChangesQueue = [];
                }

                // If we have not already queued a trigger of onChanges for this controller then do so now
                if (!changes) {
                  changes = {};
                  onChangesQueue.push(triggerOnChangesHook);
                }
                // Store this change
                changes[key] = {
                  currentValue,
                  firstChange: initial,
                };
              }
            }

            function triggerOnChangesHook() {
              destination.$onChanges &&
                changes &&
                destination.$onChanges(changes);
              // Now clear the changes so that we schedule onChanges when more changes arrive
              changes = undefined;
            }

            return {
              initialChanges,
              removeWatches:
                removeWatchCollection.length &&
                function removeWatches() {
                  for (
                    let i = 0, ii = removeWatchCollection.length;
                    i < ii;
                    ++i
                  ) {
                    removeWatchCollection[i]();
                  }
                },
            };
          }
        },
      ];
    }
  }

  function removeComments(jqNodes) {
    let i = jqNodes.length;

    if (i <= 1) {
      return jqNodes;
    }

    while (i--) {
      const node = jqNodes[i];

      if (
        node.nodeType === NodeType._COMMENT_NODE ||
        (node.nodeType === NodeType._TEXT_NODE && node.nodeValue.trim() === "")
      ) {
        [].splice.call(jqNodes, i, 1);
      }
    }

    return jqNodes;
  }

  /**
   * @param {String} name
   * @returns {void}
   */
  function assertValidDirectiveName(name) {
    const letter = name.charAt(0);

    if (!letter || letter !== letter.toLowerCase()) {
      throw $compileMinErr(
        "baddir",
        "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter",
        name,
      );
    }

    if (name !== name.trim()) {
      throw $compileMinErr(
        "baddir",
        "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces",
        name,
      );
    }
  }

  /**
   * @type {{
   *   $nonscope: boolean,
   *   $addControl: Function,
   *   $getControls: () => any[],
   *   $$renameControl: Function,
   *   $removeControl: Function,
   *   $setValidity: Function | ((key: any, isValid: boolean, control: any) => any),
   *   $setDirty: Function,
   *   $setPristine: Function,
   *   $setSubmitted: Function,
   *   $$setSubmitted: Function
   * }}
   */
  const nullFormCtrl = {
    $nonscope: true,
    $addControl: () => {
      /* empty */
    },
    $getControls: () => [],
    $$renameControl: (control, name) => {
      control.$name = name;
    },
    $removeControl: () => {
      /* empty */
    },
    $setValidity: () => {
      /* empty */
    },
    $setDirty: () => {
      /* empty */
    },
    $setPristine: () => {
      /* empty */
    },
    $setSubmitted: () => {
      /* empty */
    },
    $$setSubmitted: () => {
      /* empty */
    },
  };

  const PENDING_CLASS = "ng-pending";
  const SUBMITTED_CLASS = "ng-submitted";

  /**
   * @property {boolean} $dirty True if user has already interacted with the form.
   * @property {boolean} $valid True if all of the containing forms and controls are valid.
   * @property {boolean} $invalid True if at least one containing control or form is invalid.
   * @property {boolean} $submitted True if user has submitted the form even if its invalid.
   *
   * @property {Object} $pending An object hash, containing references to controls or forms with
   *  pending validators, where:
   *
   *  - keys are validations tokens (error names).
   *  - values are arrays of controls or forms that have a pending validator for the given error name.
   *
   * See {@link form.FormController#$error $error} for a list of built-in validation tokens.
   *
   * @property {Object} $error An object hash, containing references to controls or forms with failing
   *  validators, where:
   *
   *  - keys are validation tokens (error names),
   *  - values are arrays of controls or forms that have a failing validator for the given error name.
   *
   *  Built-in validation tokens:
   *  - `email`
   *  - `max`
   *  - `maxlength`
   *  - `min`
   *  - `minlength`
   *  - `number`
   *  - `pattern`
   *  - `required`
   *  - `url`
   *  - `date`
   *  - `datetimelocal`
   *  - `time`
   *  - `week`
   *  - `month`
   *
   * @description
   * `FormController` keeps track of all its controls and nested forms as well as the state of them,
   * such as being valid/invalid or dirty/pristine.
   *
   * Each {@link ng.directive:form form} directive creates an instance
   * of `FormController`.
   *
   */
  // asks for $scope to fool the BC controller module

  class FormController {
    static $nonscope = true;
    /* @ignore */ static $inject = [
      "$element",
      "$attrs",
      "$scope",
      "$animate",
      "$interpolate",
    ];

    /**
     * @param {Element} $element
     * @param {ng.Attributes} $attrs
     * @param {ng.Scope} $scope
     * @param {ng.AnimateService} $animate
     * @param {ng.InterpolateService} $interpolate
     */
    constructor($element, $attrs, $scope, $animate, $interpolate) {
      this.$$controls = [];

      this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope);

      /**
       * @property {boolean} $dirty True if user has already interacted with the form.
       */
      this.$dirty = false;

      /**
       * @propertys {boolean} $pristine - True if user has not interacted with the form yet.s
       */
      this.$pristine = true;
      this.$valid = true;
      this.$invalid = false;
      this.$submitted = false;
      /** @type {FormController|Object} */
      this.$$parentForm = nullFormCtrl;

      this.$$element = $element;
      this.$$animate = $animate;
      this.$error = {};
      this.$$success = {};
      this.$pending = undefined;
      this.$$classCache = {};
      const isValid = this.$$element.classList.contains(VALID_CLASS);

      this.$$classCache[VALID_CLASS] = isValid;
      this.$$classCache[INVALID_CLASS] = !isValid;
    }

    /**
     * Rollback all form controls pending updates to the `$modelValue`.
     *
     * Updates may be pending by a debounced event or because the input is waiting for a some future
     * event defined in `ng-model-options`. This method is typically needed by the reset button of
     * a form that uses `ng-model-options` to pend updates.
     */
    $rollbackViewValue() {
      this.$$controls.forEach((control) => {
        control.$rollbackViewValue();
      });
    }

    /**
     * Commit all form controls pending updates to the `$modelValue`.
     *
     * Updates may be pending by a debounced event or because the input is waiting for a some future
     * event defined in `ng-model-options`. This method is rarely needed as `NgModelController`
     * usually handles calling this in response to input events.
     */
    $commitViewValue() {
      this.$$controls.forEach((control) => {
        control.$commitViewValue();
      });
    }

    /**
     * Register a control with the form. Input elements using ngModelController do this automatically
     * when they are linked.
     *
     * Note that the current state of the control will not be reflected on the new parent form. This
     * is not an issue with normal use, as freshly compiled and linked controls are in a `$pristine`
     * state.
     *
     * However, if the method is used programmatically, for example by adding dynamically created controls,
     * or controls that have been previously removed without destroying their corresponding DOM element,
     * it's the developers responsibility to make sure the current state propagates to the parent form.
     *
     * For example, if an input control is added that is already `$dirty` and has `$error` properties,
     * calling `$setDirty()` and `$validate()` afterwards will propagate the state to the parent form.
     */
    $addControl(control) {
      // Breaking change - before, inputs whose name was "hasOwnProperty" were quietly ignored
      // and not added to the scope.  Now we throw an error.
      assertNotHasOwnProperty(control.$name, "input");
      this.$$controls.push(control);

      if (control.$name) {
        this[control.$name] = control;
      }
      control.$target.$$parentForm = this;
    }

    /**
     * This method returns a **shallow copy** of the controls that are currently part of this form.
     * The controls can be instances of {@link form.FormController `FormController`}
     * ({@link ngForm "child-forms"}) and of {@link ngModel.NgModelController `NgModelController`}.
     * If you need access to the controls of child-forms, you have to call `$getControls()`
     * recursively on them.
     * This can be used for example to iterate over all controls to validate them.
     *
     * The controls can be accessed normally, but adding to, or removing controls from the array has
     * no effect on the form. Instead, use {@link form.FormController#$addControl `$addControl()`} and
     * {@link form.FormController#$removeControl `$removeControl()`} for this use-case.
     * Likewise, adding a control to, or removing a control from the form is not reflected
     * in the shallow copy. That means you should get a fresh copy from `$getControls()` every time
     * you need access to the controls.
     */
    $getControls() {
      return shallowCopy(this.$$controls);
    }

    // Private API: rename a form control
    $$renameControl(control, newName) {
      const oldName = control.$name;

      if (this[oldName] === control) {
        delete this[oldName];
      }
      this[newName] = control;
      control.$name = newName;
    }

    /**
     * Deregister a control from the form.
     *
     * Input elements using ngModelController do this automatically when they are destroyed.
     *
     * Note that only the removed control's validation state (`$errors`etc.) will be removed from the
     * form. `$dirty`, `$submitted` states will not be changed, because the expected behavior can be
     * different from case to case. For example, removing the only `$dirty` control from a form may or
     * may not mean that the form is still `$dirty`.
     */
    $removeControl(control) {
      if (control.$name && this[control.$name] === control) {
        delete this[control.$name];
      }
      this.$pending &&
        Object.keys(this.$pending).forEach((name) => {
          this.$setValidity(name, null, control);
        });
      this.$error &&
        Object.keys(this.$error).forEach((name) => {
          this.$setValidity(name, null, control);
        });
      this.$$success &&
        Object.keys(this.$$success).forEach((name) => {
          this.$setValidity(name, null, control);
        });

      arrayRemove(this.$$controls, control);

      control.$target.$$parentForm = nullFormCtrl;
    }

    /**
     * Sets the form to a dirty state.
     *
     * This method can be called to add the 'ng-dirty' class and set the form to a dirty
     * state (ng-dirty class). This method will also propagate to parent forms.
     */
    $setDirty() {
      if (hasAnimate(this.$$element)) {
        this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
        this.$$animate.addClass(this.$$element, DIRTY_CLASS);
      } else {
        // Fallback for non-animated environments
        this.$$element.classList.remove(PRISTINE_CLASS);
        this.$$element.classList.add(DIRTY_CLASS);
      }
      this.$dirty = true;
      this.$pristine = false;
      this.$$parentForm.$setDirty();
    }

    /**
     * Sets the form to its pristine state.
     *
     * This method sets the form's `$pristine` state to true, the `$dirty` state to false, removes
     * the `ng-dirty` class and adds the `ng-pristine` class. Additionally, it sets the `$submitted`
     * state to false.
     *
     * This method will also propagate to all the controls contained in this form.
     *
     * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after
     * saving or resetting it.
     */
    $setPristine() {
      if (hasAnimate(this.$$element)) {
        this.$$animate.setClass(
          this.$$element,
          PRISTINE_CLASS,
          `${DIRTY_CLASS} ${SUBMITTED_CLASS}`,
        );
      } else {
        // Fallback for non-animated environments
        this.$$element.classList.remove(DIRTY_CLASS, SUBMITTED_CLASS);
        this.$$element.classList.add(PRISTINE_CLASS);
      }

      this.$dirty = false;
      this.$pristine = true;
      this.$submitted = false;
      this.$$controls.forEach((control) => {
        control.$setPristine();
      });
    }

    /**
     * Sets the form to its untouched state.
     *
     * This method can be called to remove the 'ng-touched' class and set the form controls to their
     * untouched state (ng-untouched class).
     *
     * Setting a form controls back to their untouched state is often useful when setting the form
     * back to its pristine state.
     */
    $setUntouched() {
      this.$$controls.forEach((control) => {
        control.$setUntouched();
      });
    }

    /**
     * Sets the form to its `$submitted` state. This will also set `$submitted` on all child and
     * parent forms of the form.
     */
    $setSubmitted() {
      /** @type {FormController} */
      let rootForm = this;

      while (rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl) {
        rootForm = rootForm.$$parentForm;
      }
      rootForm.$$setSubmitted();
    }

    $$setSubmitted() {
      if (hasAnimate(this.$$element)) {
        this.$$animate.addClass(this.$$element, SUBMITTED_CLASS);
      } else {
        this.$$element.classList.add(SUBMITTED_CLASS);
      }
      this.$submitted = true;
      this.$$controls.forEach((control) => {
        if (control.$$setSubmitted) {
          control.$$setSubmitted();
        }
      });
    }

    set(object, property, controller) {
      const list = object[property];

      if (!list) {
        object = deProxy(object);
        object[property] = [controller];
      } else {
        const index = list.indexOf(controller);

        if (index === -1) {
          list.push(controller);
        }
      }
    }

    unset(object, property, controller) {
      const list = object[property];

      if (!list) {
        return;
      }
      const index = arrayRemove(list, controller);

      if (index === -1) {
        arrayRemove(list, controller.$target);
      }

      if (list.length === 0) {
        delete object[property];
      }
    }

    /**
     * Change the validity state of the form, and notify the parent form (if any).
     *
     * Application developers will rarely need to call this method directly. It is used internally, by
     * {@link ngModel.NgModelController#$setValidity NgModelController.$setValidity()}, to propagate a
     * control's validity state to the parent `FormController`.
     *
     * @param {string} validationErrorKey Name of the validator. The `validationErrorKey` will be
     *        assigned to either `$error[validationErrorKey]` or `$pending[validationErrorKey]` (for
     *        unfulfilled `$asyncValidators`), so that it is available for data-binding. The
     *        `validationErrorKey` should be in camelCase and will get converted into dash-case for
     *        class name. Example: `myError` will result in `ng-valid-my-error` and
     *        `ng-invalid-my-error` classes and can be bound to as `{{ someForm.$error.myError }}`.
     * @param {boolean} state Whether the current state is valid (true), invalid (false), pending
     *        (undefined),  or skipped (null). Pending is used for unfulfilled `$asyncValidators`.
     *        Skipped is used by AngularTS when validators do not run because of parse errors and when
     *        `$asyncValidators` do not run because any of the `$validators` failed.
     * @param {import("../model/model.js").NgModelController | FormController} controller - The controller whose validity state is
     *        triggering the change.
     */
    $setValidity(validationErrorKey, state, controller) {
      const that = this;

      if (isUndefined(state)) {
        createAndSet(this, "$pending", validationErrorKey, controller);
      } else {
        unsetAndCleanup(this, "$pending", validationErrorKey, controller);
      }

      if (!isBoolean(state)) {
        this.unset(this.$error, validationErrorKey, controller);
        this.unset(this.$$success, validationErrorKey, controller);
      } else if (state) {
        this.unset(this.$error, validationErrorKey, controller);
        this.set(this.$$success, validationErrorKey, controller);
      } else {
        this.set(this.$error, validationErrorKey, controller);
        this.unset(this.$$success, validationErrorKey, controller);
      }

      if (this.$pending) {
        cachedToggleClass(this, PENDING_CLASS, true);
        this.$valid = this.$invalid = undefined;
        toggleValidationCss(this, "", null);
      } else {
        cachedToggleClass(this, PENDING_CLASS, false);
        this.$valid = isObjectEmpty(this.$error);
        this.$invalid = !this.$valid;
        toggleValidationCss(this, "", this.$valid);
      }

      // re-read the state as the set/unset methods could have
      // combined state in this.$error[validationError] (used for forms),
      // where setting/unsetting only increments/decrements the value,
      // and does not replace it.
      let combinedState;

      if (this.$pending && this.$pending[validationErrorKey]) {
        combinedState = undefined;
      } else if (this.$error[validationErrorKey]) {
        combinedState = false;
      } else if (this.$$success[validationErrorKey]) {
        combinedState = true;
      } else {
        combinedState = null;
      }

      toggleValidationCss(this, validationErrorKey, combinedState);
      this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
      function createAndSet(ctrl, name, value, controllerParam) {
        if (!ctrl[name]) {
          ctrl[name] = {};
        }
        that.set(ctrl[name], value, controllerParam);
      }

      function unsetAndCleanup(ctrl, name, value, controllerParam) {
        if (ctrl[name]) {
          that.unset(ctrl[name], value, controllerParam);
        }

        if (isObjectEmpty(ctrl[name])) {
          ctrl[name] = undefined;
        }
      }

      function cachedToggleClass(ctrl, className, switchValue) {
        if (switchValue && !ctrl.$$classCache[className]) {
          ctrl.$$animate.addClass(ctrl.$$element, className);
          ctrl.$$classCache[className] = true;
        } else if (!switchValue && ctrl.$$classCache[className]) {
          ctrl.$$animate.removeClass(ctrl.$$element, className);
          ctrl.$$classCache[className] = false;
        }
      }

      function toggleValidationCss(ctrl, validationErrorKeyParam, isValid) {
        validationErrorKeyParam = validationErrorKeyParam
          ? `-${snakeCase(validationErrorKeyParam, "-")}`
          : "";

        cachedToggleClass(
          ctrl,
          VALID_CLASS + validationErrorKeyParam,
          isValid === true,
        );
        cachedToggleClass(
          ctrl,
          INVALID_CLASS + validationErrorKeyParam,
          isValid === false,
        );
      }
    }
  }

  /**
   * Helper directive that makes it possible to create control groups inside a
   * {@link ng.directive:form `form`} directive.
   * These "child forms" can be used, for example, to determine the validity of a sub-group of
   * controls.
   *
   * <div class="alert alert-danger">
   * **Note**: `ngForm` cannot be used as a replacement for `<form>`, because it lacks its
   * [built-in HTML functionality](https://html.spec.whatwg.org/#the-form-element).
   * Specifically, you cannot submit `ngForm` like a `<form>` tag. That means,
   * you cannot send data to the server with `ngForm`, or integrate it with
   * {@link ng.directive:ngSubmit `ngSubmit`}.
   * </div>
   *
   * @param {string=} ngForm|name Name of the form. If specified, the form controller will
   *                              be published into the related scope, under this name.
   *
   */

  /**
   * Directive that instantiates
   * {@link form.FormController FormController}.
   *
   * If the `name` attribute is specified, the form controller is published onto the current scope under
   * this name.
   *
   * ## Alias: {@link ng.directive:ngForm `ngForm`}
   *
   * In AngularTS, forms can be nested. This means that the outer form is valid when all of the child
   * forms are valid as well. However, browsers do not allow nesting of `<form>` elements, so
   * AngularTS provides the {@link ng.directive:ngForm `ngForm`} directive, which behaves identically to
   * `form` but can be nested. Nested forms can be useful, for example, if the validity of a sub-group
   * of controls needs to be determined.
   *
   * ## CSS classes
   *  - `ng-valid` is set if the form is valid.
   *  - `ng-invalid` is set if the form is invalid.
   *  - `ng-pending` is set if the form is pending.
   *  - `ng-pristine` is set if the form is pristine.
   *  - `ng-dirty` is set if the form is dirty.
   *  - `ng-submitted` is set if the form was submitted.
   *
   * Keep in mind that ngAnimate can detect each of these classes when added and removed.
   *
   *
   * ## Submitting a form and preventing the default action
   *
   * Since the role of forms in client-side AngularTS applications is different than in classical
   * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
   * page reload that sends the data to the server. Instead some javascript logic should be triggered
   * to handle the form submission in an application-specific way.
   *
   * For this reason, AngularTS prevents the default action (form submission to the server) unless the
   * `<form>` element has an `action` attribute specified.
   *
   * You can use one of the following two ways to specify what javascript method should be called when
   * a form is submitted:
   *
   * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
   * - {@link ng.directive:ngClick ngClick} directive on the first
   *  button or input field of type submit (input[type=submit])
   *
   * To prevent double execution of the handler, use only one of the {@link ng.directive:ngSubmit ngSubmit}
   * or {@link ng.directive:ngClick ngClick} directives.
   * This is because of the following form submission rules in the HTML specification:
   *
   * - If a form has only one input field then hitting enter in this field triggers form submit
   * (`ngSubmit`)
   * - if a form has 2+ input fields and no buttons or input[type=submit] then hitting enter
   * doesn't trigger submit
   * - if a form has one or more input fields and one or more buttons or input[type=submit] then
   * hitting enter in any of the input fields will trigger the click handler on the *first* button or
   * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)
   *
   * Any pending `ngModelOptions` changes will take place immediately when an enclosing form is
   * submitted. Note that `ngClick` events will occur before the model is updated. Use `ngSubmit`
   * to have access to the updated model.
   *
   * @animations
   * Animations in ngForm are triggered when any of the associated CSS classes are added and removed.
   * These classes are: `.ng-pristine`, `.ng-dirty`, `.ng-invalid` and `.ng-valid` as well as any
   * other validations that are performed within the form. Animations in ngForm are similar to how
   * they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well
   * as JS animations.
   *
   * @param {string=} isNgForm Name of the form. If specified, the form controller will be published into
   *                       related scope, under this name.
   */
  const formDirectiveFactory = function (isNgForm) {
    return [
      "$parse",
      function ($parse) {
        return {
          name: "form",
          restrict: isNgForm ? "EA" : "E",
          require: ["form", "^^?form"], // first is the form's own ctrl, second is an optional parent form
          controller: FormController,
          compile: function ngFormCompile(formElement, attr) {
            // Setup initial state of the control
            formElement.classList.add(PRISTINE_CLASS, VALID_CLASS);

            const nameAttr = attr.name
              ? "name"
              : isNgForm && attr.ngForm
                ? "ngForm"
                : false;

            return {
              pre: function ngFormPreLink(
                scope,
                formElementParam,
                attrParam,
                ctrls,
              ) {
                const controller = ctrls[0];

                // if `action` attr is not present on the form, prevent the default action (submission)
                if (!("action" in attrParam)) {
                  // we can't use jq events because if a form is destroyed during submission the default
                  // action is not prevented. see #1238
                  //
                  // IE 9 is not affected because it doesn't fire a submit event and try to do a full
                  // page reload if the form was destroyed by submission of the form via a click handler
                  // on a button in the form. Looks like an IE9 specific bug.
                  const handleFormSubmission = function (event) {
                    controller.$commitViewValue();
                    controller.$setSubmitted();
                    event.preventDefault();
                  };

                  formElementParam.addEventListener(
                    "submit",
                    handleFormSubmission,
                  );

                  // unregister the preventDefault listener so that we don't not leak memory but in a
                  // way that will achieve the prevention of the default action.
                  formElementParam.addEventListener("$destroy", () => {
                    setTimeout(
                      () => {
                        formElementParam.removeEventListener(
                          "submit",
                          handleFormSubmission,
                        );
                      },
                      0,
                      false,
                    );
                  });
                }

                const parentFormCtrl = ctrls[1] || controller.$$parentForm;

                parentFormCtrl.$addControl(controller);

                const setter = nameAttr
                  ? getSetter(controller.$name)
                  : () => {
                      /* empty */
                    };

                if (nameAttr) {
                  setter(scope, controller);
                  attrParam.$observe(nameAttr, (newValue) => {
                    if (controller.$name === newValue) return;
                    scope.$target[controller.$name] = undefined;
                    controller.$$parentForm.$$renameControl(controller, newValue);

                    if (
                      scope.$target !== controller.$$parentForm &&
                      controller.$$parentForm !== nullFormCtrl
                    ) ; else {
                      scope.$target[newValue] = controller;
                    }
                  });
                }
                formElementParam.addEventListener("$destroy", () => {
                  controller.$target.$$parentForm.$removeControl(controller);
                  setter(scope, undefined);
                  extend(controller, nullFormCtrl); // stop propagating child destruction handlers upwards
                });
              },
            };
          },
        };
        function getSetter(expression) {
          if (expression === "") {
            // create an assignable expression, so forms with an empty name can be renamed later
            return $parse('this[""]').assign;
          }

          return (
            $parse(expression).assign ||
            (() => {
              /* empty */
            })
          );
        }
      },
    ];
  };

  const formDirective = formDirectiveFactory();
  const ngFormDirective = formDirectiveFactory("ngForm");

  const DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;

  /**
   * @typedef {Object} ModelOptionsConfig
   * @property {string} [updateOn] - A string specifying which events the input should be bound to. Multiple events can be set using a space-delimited list. The special event 'default' matches the default events belonging to the control.
   * @property {number|Object.<string, number>} [debounce] - An integer specifying the debounce time in milliseconds. A value of 0 triggers an immediate update. If an object is supplied, custom debounce values can be set for each event.
   * @property {boolean} [allowInvalid] - Indicates whether the model can be set with values that did not validate correctly. Defaults to false, which sets the model to undefined on validation failure.
   * @property {boolean} [getterSetter] - Determines whether to treat functions bound to `ngModel` as getters/setters. Defaults to false.
   * @property {boolean} [updateOnDefault]
   */

  class NgModelOptionsController {
    static $nonscope = true;
    /* @ignore */ static $inject = [$injectTokens._attrs, $injectTokens._scope];

    /**
     * @param {ng.Attributes} $attrs
     * @param {ng.Scope} $scope
     */
    constructor($attrs, $scope) {
      this.$$attrs = $attrs;
      this.$$scope = $scope;
      /** @type {NgModelOptionsController?} */
      this.parentCtrl;
    }

    $onInit() {
      const parentOptions = this.parentCtrl
        ? this.parentCtrl.$options
        : defaultModelOptions;

      const modelOptionsDefinition = this.$$scope.$eval(
        this.$$attrs.ngModelOptions,
      );

      this.$options = parentOptions.createChild(modelOptionsDefinition);
    }
  }

  /**
   * @description
   * A container for the options set by the {@link ngModelOptions} directive
   */
  class ModelOptions {
    static $nonscope = true;

    /**
     * @param {ModelOptionsConfig} options
     */
    constructor(options) {
      /** @type {ModelOptionsConfig} */
      this.$$options = options;
    }

    /**
     * Returns the value of the given option
     * @param {string} name the name of the option to retrieve
     * @returns {string|boolean|number|Object.<string, number>} the value of the option   *
     */
    getOption(name) {
      return this.$$options[name];
    }

    /**
     * @param {ModelOptionsConfig} options a hash of options for the new child that will override the parent's options
     * @return {ModelOptions} a new `ModelOptions` object initialized with the given options.
     */
    createChild(options) {
      let inheritAll = false;

      // make a shallow copy
      options = Object.assign({}, options);

      // Inherit options from the parent if specified by the value `"$inherit"`
      entries(options).forEach(([key, option]) => {
        if (option === "$inherit") {
          if (key === "*") {
            inheritAll = true;
          } else {
            options[key] = this.$$options[key];

            // `updateOn` is special so we must also inherit the `updateOnDefault` option
            if (key === "updateOn") {
              options.updateOnDefault = this.$$options.updateOnDefault;
            }
          }
        } else if (key === "updateOn") {
          // If the `updateOn` property contains the `default` event then we have to remove
          // it from the event list and set the `updateOnDefault` flag.
          options.updateOnDefault = false;
          options[key] = trim(
            /** @type {string} */ (option).replace(DEFAULT_REGEXP, () => {
              options.updateOnDefault = true;

              return " ";
            }),
          );
        }
      }, this);

      if (inheritAll) {
        // We have a property of the form: `"*": "$inherit"`
        delete options["*"];
        defaults$1(options, this.$$options);
      }

      // Finally add in any missing defaults
      defaults$1(options, defaultModelOptions.$$options);

      return new ModelOptions(options);
    }
  }

  const defaultModelOptions = new ModelOptions({
    updateOn: "",
    updateOnDefault: true,
    debounce: 0,
    getterSetter: false,
    allowInvalid: false,
  });

  /**
   * @returns {ng.Directive}
   */
  function ngModelOptionsDirective() {
    return {
      restrict: "A",
      // ngModelOptions needs to run before ngModel and input directives
      priority: 10,
      require: { parentCtrl: "?^^ngModelOptions" },
      bindToController: true,
      controller: NgModelOptionsController,
    };
  }

  // shallow copy over values from `src` that are not already specified on `dst`
  function defaults$1(dst, src) {
    keys(src).forEach((key) => {
      if (!isDefined(dst[key])) {
        dst[key] = src[key];
      }
    });
  }

  const ngModelMinErr = minErr("ngModel");

  /**
   * 
   * @property {*} $viewValue The actual value from the control's view.
   *
   * @property {*} $modelValue The value in the model that the control is bound to.
   * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever
   *  the control updates the ngModelController with a new `$viewValue` from the DOM, usually via user input.
   *
   * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever
      the bound ngModel expression changes programmatically. The `$formatters` are not called when the
      value of the control is changed by user interaction.
   *
   * @property {Object.<string, (string, string) => boolean>} $validators A collection of validators that are applied whenever the model value changes. 
   * The key value within the object refers to the name of the validator while the function refers to the validation operation. 
   * The validation operation is provided with the model value as an argument and must return a true or false value depending on the response of that validation.
   *
   * @property {Object.<string, function(string, string) => Promise>} $asyncValidators A collection of validations that are expected to perform an asynchronous validation (e.g. a HTTP request).
   *  The validation function that is provided is expected to return a promise when it is run during the model validation process
   *
   * @property {Array.<Function>} $viewChangeListeners Array of functions to execute whenever
   *     a change to {@link ngModel.NgModelController#$viewValue `$viewValue`} has caused a change
   *     to {@link ngModel.NgModelController#$modelValue `$modelValue`}.
   *     It is called with no arguments, and its return value is ignored.
   *     This can be used in place of additional $watches against the model value.
   *
   * @property {Object} $error An object hash with all failing validator ids as keys.
   * @property {Object} $pending An object hash with all pending validator ids as keys.
   *
   * @property {boolean} $untouched True if control has not lost focus yet.
   * @property {boolean} $touched True if control has lost focus.
   * @property {boolean} $pristine True if user has not interacted with the control yet.
   * @property {boolean} $dirty True if user has already interacted with the control.
   * @property {boolean} $valid True if there is no error.
   * @property {boolean} $invalid True if at least one error on the control.
   * @property {string} $name The name attribute of the control.
   */

  class NgModelController {
    static $nonscope = true;
    /* @ignore */ static $inject = [
      "$scope",
      $injectTokens._exceptionHandler,
      "$attrs",
      "$element",
      $injectTokens._parse,
      $injectTokens._animate,
      $injectTokens._interpolate,
    ];

    /**
     * @param {ng.Scope} $scope
     * @param {ng.ExceptionHandlerService} $exceptionHandler
     * @param {ng.Attributes} $attr
     * @param {Element} $element
     * @param {ng.ParseService} $parse
     * @param {ng.AnimateService} $animate
     * @param {ng.InterpolateService} $interpolate
     */
    constructor(
      $scope,
      $exceptionHandler,
      $attr,
      $element,
      $parse,
      $animate,
      $interpolate,
    ) {
      /** @type {any} The actual value from the control's view  */
      this.$viewValue = Number.NaN;

      /** @type {any} The value in the model that the control is bound to. */
      this.$modelValue = Number.NaN;
      /** @type {any} */
      this.$$rawModelValue = undefined; // stores the parsed modelValue / model set from scope regardless of validity.

      /** @type {any} */
      this.$validators = {};

      /** @type {any} */
      this.$asyncValidators = {};

      /** @type {Array<any>} */
      this.$parsers = [];

      /** @type {Array<any>} */
      this.$formatters = [];

      /** @type {Array<any>} */
      this.$viewChangeListeners = [];

      /** @type {boolean} */
      this.$untouched = true;

      /** @type {boolean} */
      this.$touched = false;

      /** @type {boolean} */
      this.$pristine = true;

      /** @type {boolean} */
      this.$dirty = false;

      /** @type {boolean} */
      this.$valid = true;

      /** @type {boolean} */
      this.$invalid = false;

      this.$error = {}; // keep invalid keys here
      this.$$success = {}; // keep valid keys here
      this.$pending = undefined; // keep pending keys here
      this.$name = $interpolate($attr.name || "", false)($scope);
      this.$$parentForm = nullFormCtrl;
      this.$options = defaultModelOptions;
      this.$$updateEvents = "";
      // Attach the correct context to the event handler function for updateOn
      this.$$updateEventHandler = this.$$updateEventHandler.bind(this);

      this.$$parsedNgModel = $parse($attr.ngModel);
      this.$$parsedNgModelAssign = this.$$parsedNgModel.assign;

      /**
       * @type {import("../../core/parse/interface.ts").CompiledExpression |
       *        (function(ng.Scope): any)}
       */
      this.$$ngModelGet = this.$$parsedNgModel;
      this.$$ngModelSet = this.$$parsedNgModelAssign;
      this.$$pendingDebounce = null;
      this.$$parserValid = undefined;

      /** @type {string} */
      this.$$parserName = "parse";

      /** @type {number} */
      this.$$currentValidationRunId = 0;

      /** @type {ng.Scope} */
      this.$$scope = $scope; // attempt to bind to nearest controller if present
      this.$$attr = $attr;
      this.$$element = $element;
      this.$$animate = $animate;
      this.$$parse = $parse;
      this.$$exceptionHandler = $exceptionHandler;

      this.$$hasNativeValidators = false;

      this.$$classCache = {};
      const isValid = this.$$element.classList.contains(VALID_CLASS);

      this.$$classCache[VALID_CLASS] = isValid;
      this.$$classCache[INVALID_CLASS] = !isValid;

      this.$$eventRemovers = new Set();

      setupModelWatcher(this);
    }

    set(object, property) {
      object[property] = true;
    }

    unset(object, property) {
      delete object[property];
    }

    $setValidity(validationErrorKey, state) {
      const that = this;

      function createAndSet(ctrl, name, value) {
        if (!ctrl[name]) {
          ctrl[name] = {};
        }
        that.set(ctrl[name], value);
      }

      function unsetAndCleanup(ctrl, name, value) {
        if (ctrl[name]) {
          that.unset(ctrl[name], value);
        }

        if (isObjectEmpty(ctrl[name])) {
          ctrl[name] = undefined;
        }
      }

      function cachedToggleClass(ctrl, className, switchValue) {
        if (switchValue && !ctrl.$$classCache[className]) {
          if (hasAnimate(ctrl.$$element)) {
            ctrl.$$animate.addClass(ctrl.$$element, className);
          } else {
            ctrl.$$element.classList.add(className);
          }

          ctrl.$$classCache[className] = true;
        } else if (!switchValue && ctrl.$$classCache[className]) {
          if (hasAnimate(ctrl.$$element)) {
            ctrl.$$animate.removeClass(ctrl.$$element, className);
          } else {
            ctrl.$$element.classList.remove(className);
          }
          ctrl.$$classCache[className] = false;
        }
      }

      function toggleValidationCss(ctrl, validationErrorKeyParam, isValid) {
        validationErrorKeyParam = validationErrorKeyParam
          ? `-${snakeCase(validationErrorKeyParam, "-")}`
          : "";

        cachedToggleClass(
          ctrl,
          VALID_CLASS + validationErrorKeyParam,
          isValid === true,
        );
        cachedToggleClass(
          ctrl,
          INVALID_CLASS + validationErrorKeyParam,
          isValid === false,
        );
      }

      if (isUndefined(state)) {
        createAndSet(this, "$pending", validationErrorKey);
      } else {
        unsetAndCleanup(this, "$pending", validationErrorKey);
      }

      if (!isBoolean(state)) {
        delete this.$error[validationErrorKey];
        delete this.$$success[validationErrorKey];
      } else if (state) {
        delete this.$error[validationErrorKey];
        this.set(this.$$success, validationErrorKey);
      } else {
        this.set(this.$error, validationErrorKey);
        delete this.$$success[validationErrorKey];
      }

      if (this.$pending) {
        cachedToggleClass(this, PENDING_CLASS, true);
        this.$valid = this.$invalid = undefined;
        toggleValidationCss(this, "", null);
      } else {
        cachedToggleClass(this, PENDING_CLASS, false);
        this.$valid = isObjectEmpty(this.$error);
        this.$invalid = !this.$valid;
        toggleValidationCss(this, "", this.$valid);
      }

      // re-read the state as the set/unset methods could have
      // combined state in this.$error[validationError] (used for forms),
      // where setting/unsetting only increments/decrements the value,
      // and does not replace it.
      let combinedState;

      if (this.$pending && this.$pending[validationErrorKey]) {
        combinedState = undefined;
      } else if (this.$error[validationErrorKey]) {
        combinedState = false;
      } else if (this.$$success[validationErrorKey]) {
        combinedState = true;
      } else {
        combinedState = null;
      }

      toggleValidationCss(this, validationErrorKey, combinedState);
      this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
    }

    $$initGetterSetters() {
      if (this.$options.getOption("getterSetter")) {
        const invokeModelGetter = this.$$parse(`${this.$$attr.ngModel}()`);

        const invokeModelSetter = this.$$parse(`${this.$$attr.ngModel}($$$p)`);

        this.$$ngModelGet = ($scope) => {
          let modelValue = this.$$parsedNgModel($scope);

          if (isFunction(modelValue)) {
            modelValue = invokeModelGetter($scope);
          }

          return modelValue;
        };
        this.$$ngModelSet = ($scope, newValue) => {
          if (isFunction(this.$$parsedNgModel($scope))) {
            invokeModelSetter($scope, { $$$p: newValue });
          } else {
            this.$$parsedNgModelAssign($scope, newValue);
          }
        };
      } else if (!this.$$parsedNgModel.assign) {
        throw ngModelMinErr(
          "nonassign",
          "Expression '{0}' is non-assignable. Element: {1}",
          this.$$attr.ngModel,
          startingTag(this.$$element),
        );
      }
    }

    /**
     * Called when the view needs to be updated. It is expected that the user of the ng-model
     * directive will implement this method.
     *
     * The `$render()` method is invoked in the following situations:
     *
     * * `$rollbackViewValue()` is called.  If we are rolling back the view value to the last
     *   committed value then `$render()` is called to update the input control.
     * * The value referenced by `ng-model` is changed programmatically and both the `$modelValue` and
     *   the `$viewValue` are different from last time.
     *
     * Since `ng-model` does not do a deep watch, `$render()` is only invoked if the values of
     * `$modelValue` and `$viewValue` are actually different from their previous values. If `$modelValue`
     * or `$viewValue` are objects (rather than a string or number) then `$render()` will not be
     * invoked if you only change a property on the objects.
     */
    $render() {
      /* empty */
    }

    /**
     * This is called when we need to determine if the value of an input is empty.
     *
     * For instance, the required directive does this to work out if the input has data or not.
     *
     * The default `$isEmpty` function checks whether the value is `undefined`, `''`, `null` or `NaN`.
     *
     * You can override this for input directives whose concept of being empty is different from the
     * default. The `checkboxInputType` directive does this because in its case a value of `false`
     * implies empty.
     *
     * @param {*} value The value of the input to check for emptiness.
     * @returns {boolean} True if `value` is "empty".
     */
    $isEmpty(value) {
      return (
        isUndefined(value) ||
        value === "" ||
        value === null ||
        Number.isNaN(value)
      );
    }

    $$updateEmptyClasses(value) {
      if (this.$isEmpty(value)) {
        if (hasAnimate(this.$$element)) {
          this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS);
          this.$$animate.addClass(this.$$element, EMPTY_CLASS);
        } else {
          this.$$element.classList.remove(NOT_EMPTY_CLASS);
          this.$$element.classList.add(EMPTY_CLASS);
        }
      } else {
        if (hasAnimate(this.$$element)) {
          this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
          this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS);
        } else {
          this.$$element.classList.remove(EMPTY_CLASS);
          this.$$element.classList.add(NOT_EMPTY_CLASS);
        }
      }
    }

    /**
     * Sets the control to its pristine state.
     *
     * This method can be called to remove the `ng-dirty` class and set the control to its pristine
     * state (`ng-pristine` class). A model is considered to be pristine when the control
     * has not been changed from when first compiled.
     */
    $setPristine() {
      this.$dirty = false;
      this.$pristine = true;

      if (!this.$$element) return;

      if (hasAnimate(this.$$element)) {
        this.$$animate.removeClass(this.$$element, EMPTY_CLASS);
        this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
      } else {
        this.$$element.classList.remove(EMPTY_CLASS);
        this.$$element.classList.add(PRISTINE_CLASS);
      }
    }

    /**
     * Sets the control to its dirty state.
     *
     * This method can be called to remove the `ng-pristine` class and set the control to its dirty
     * state (`ng-dirty` class). A model is considered to be dirty when the control has been changed
     * from when first compiled.
     */
    $setDirty() {
      this.$dirty = true;
      this.$pristine = false;

      if (hasAnimate(this.$$element)) {
        this.$$animate.removeClass(this.$$element, PRISTINE_CLASS);
        this.$$animate.addClass(this.$$element, DIRTY_CLASS);
      } else {
        this.$$element.classList.remove(PRISTINE_CLASS);
        this.$$element.classList.add(DIRTY_CLASS);
      }
      this.$$parentForm.$setDirty();
    }

    /**
     * Sets the control to its untouched state.
     *
     * This method can be called to remove the `ng-touched` class and set the control to its
     * untouched state (`ng-untouched` class). Upon compilation, a model is set as untouched
     * by default, however this function can be used to restore that state if the model has
     * already been touched by the user.
     */
    $setUntouched() {
      this.$touched = false;
      this.$untouched = true;

      if (hasAnimate(this.$$element)) {
        this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
      } else {
        this.$$element.classList.remove(TOUCHED_CLASS);
        this.$$element.classList.add(UNTOUCHED_CLASS);
      }
    }

    /**
     * Sets the control to its touched state.
     *
     * This method can be called to remove the `ng-untouched` class and set the control to its
     * touched state (`ng-touched` class). A model is considered to be touched when the user has
     * first focused the control element and then shifted focus away from the control (blur event).
     */
    $setTouched() {
      this.$touched = true;
      this.$untouched = false;

      if (hasAnimate(this.$$element)) {
        this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
      } else {
        this.$$element.classList.remove(UNTOUCHED_CLASS);
        this.$$element.classList.add(TOUCHED_CLASS);
      }
    }

    /**
     * Cancel an update and reset the input element's value to prevent an update to the `$modelValue`,
     * which may be caused by a pending debounced event or because the input is waiting for some
     * future event.
     *
     * If you have an input that uses `ng-model-options` to set up debounced updates or updates that
     * depend on special events such as `blur`, there can be a period when the `$viewValue` is out of
     * sync with the ngModel's `$modelValue`.
     *
     * In this case, you can use `$rollbackViewValue()` to manually cancel the debounced / future update
     * and reset the input to the last committed view value.
     *
     * It is also possible that you run into difficulties if you try to update the ngModel's `$modelValue`
     * programmatically before these debounced/future events have resolved/occurred, because AngularTS's
     * dirty checking mechanism is not able to tell whether the model has actually changed or not.
     *
     * The `$rollbackViewValue()` method should be called before programmatically changing the model of an
     * input which may have such events pending. This is important in order to make sure that the
     * input field will be updated with the new model value and any pending operations are cancelled.
     *
     * @example
     * <example name="ng-model-cancel-update" module="cancel-update-example">
     *   <file name="app.js">
     *     angular.module('cancel-update-example', [])
     *
     *     .controller('CancelUpdateController', ['$scope', function($scope) {
     *       $scope.model = {value1: '', value2: ''};
     *
     *       $scope.setEmpty = function(e, value, rollback) {
     *         if (e.keyCode === 27) {
     *           e.preventDefault();
     *           if (rollback) {
     *             $scope.myForm[value].$rollbackViewValue();
     *           }
     *           $scope.model[value] = '';
     *         }
     *       };
     *     }]);
     *   </file>
     *   <file name="index.html">
     *     <div ng-controller="CancelUpdateController">
     *       <p>Both of these inputs are only updated if they are blurred. Hitting escape should
     *       empty them. Follow these steps and observe the difference:</p>
     *       <ol>
     *         <li>Type something in the input. You will see that the model is not yet updated</li>
     *         <li>Press the Escape key.
     *           <ol>
     *             <li> In the first example, nothing happens, because the model is already '', and no
     *             update is detected. If you blur the input, the model will be set to the current view.
     *             </li>
     *             <li> In the second example, the pending update is cancelled, and the input is set back
     *             to the last committed view value (''). Blurring the input does nothing.
     *             </li>
     *           </ol>
     *         </li>
     *       </ol>
     *
     *       <form name="myForm" ng-model-options="{ updateOn: 'blur' }">
     *         <div>
     *           <p id="inputDescription1">Without $rollbackViewValue():</p>
     *           <input name="value1" aria-describedby="inputDescription1" ng-model="model.value1"
     *                  ng-keydown="setEmpty($event, 'value1')">
     *           value1: "{{ model.value1 }}"
     *         </div>
     *
     *         <div>
     *           <p id="inputDescription2">With $rollbackViewValue():</p>
     *           <input name="value2" aria-describedby="inputDescription2" ng-model="model.value2"
     *                  ng-keydown="setEmpty($event, 'value2', true)">
     *           value2: "{{ model.value2 }}"
     *         </div>
     *       </form>
     *     </div>
     *   </file>
         <file name="style.css">
            div {
              display: table-cell;
            }
            div:nth-child(1) {
              padding-right: 30px;
            }

          </file>
     * </example>
     */
    $rollbackViewValue() {
      clearTimeout(this.$$pendingDebounce);
      this.$viewValue = this.$$lastCommittedViewValue;
      this.$render();
    }

    /**
     * Runs each of the registered validators (first synchronous validators and then
     * asynchronous validators).
     * If the validity changes to invalid, the model will be set to `undefined`,
     * unless {@link ngModelOptions `ngModelOptions.allowInvalid`} is `true`.
     * If the validity changes to valid, it will set the model to the last available valid
     * `$modelValue`, i.e. either the last parsed value or the last value set from the scope.
     */
    $validate() {
      // ignore $validate before model is initialized
      if (isNumberNaN(this.$modelValue)) {
        return;
      }

      const viewValue = this.$$lastCommittedViewValue;

      // Note: we use the $$rawModelValue as $modelValue might have been
      // set to undefined during a view -> model update that found validation
      // errors. We can't parse the view here, since that could change
      // the model although neither viewValue nor the model on the scope changed
      const modelValue = this.$$rawModelValue;

      const prevValid = this.$valid;

      const prevModelValue = this.$modelValue;

      const allowInvalid = this.$options.getOption("allowInvalid");

      const that = this;

      this.$$runValidators(modelValue, viewValue, (allValid) => {
        // If there was no change in validity, don't update the model
        // This prevents changing an invalid modelValue to undefined
        if (!allowInvalid && prevValid !== allValid) {
          // Note: Don't check this.$valid here, as we could have
          // external validators (e.g. calculated on the server),
          // that just call $setValidity and need the model value
          // to calculate their validity.
          that.$modelValue = allValid ? modelValue : undefined;

          if (that.$modelValue !== prevModelValue) {
            that.$$writeModelToScope();
          }
        }
      });
    }

    $$runValidators(modelValue, viewValue, doneCallback) {
      this.$$currentValidationRunId++;
      const localValidationRunId = this.$$currentValidationRunId;

      const that = this;

      // check parser error
      if (!processParseErrors()) {
        validationDone(false);

        return;
      }

      if (!processSyncValidators()) {
        validationDone(false);

        return;
      }
      processAsyncValidators();

      function processParseErrors() {
        const errorKey = that.$$parserName;

        if (isUndefined(that.$$parserValid)) {
          setValidity(errorKey, null);
        } else {
          if (!that.$$parserValid) {
            keys(that.$validators).forEach((name) => {
              setValidity(name, null);
            });
            keys(that.$asyncValidators).forEach((name) => {
              setValidity(name, null);
            });
          }

          // Set the parse error last, to prevent unsetting it, should a $validators key == parserName
          setValidity(errorKey, that.$$parserValid);

          return that.$$parserValid;
        }

        return true;
      }

      function processSyncValidators() {
        let syncValidatorsValid = true;

        entries(that.$validators).forEach(([name, validator]) => {
          const result = Boolean(validator(modelValue, viewValue));

          syncValidatorsValid = syncValidatorsValid && result;
          setValidity(name, result);
        });

        if (!syncValidatorsValid) {
          keys(that.$asyncValidators).forEach((name) => {
            setValidity(name, null);
          });

          return false;
        }

        return true;
      }

      function processAsyncValidators() {
        const validatorPromises = [];

        let allValid = true;

        entries(that.$asyncValidators).forEach(([name, validator]) => {
          const promise = validator(modelValue, viewValue);

          if (!isPromiseLike(promise)) {
            throw ngModelMinErr(
              "nopromise",
              "Expected asynchronous validator to return a promise but got '{0}' instead.",
              promise,
            );
          }
          setValidity(name, undefined);
          validatorPromises.push(
            promise.then(
              () => {
                setValidity(name, true);
              },
              () => {
                allValid = false;
                setValidity(name, false);
              },
            ),
          );
        });

        if (!validatorPromises.length) {
          validationDone(true);
        } else {
          Promise.all(validatorPromises).then(
            () => {
              validationDone(allValid);
            },
            () => {
              /* empty */
            },
          );
        }
      }

      function setValidity(name, isValid) {
        if (localValidationRunId === that.$$currentValidationRunId) {
          that.$setValidity(name, isValid);
        }
      }

      function validationDone(allValid) {
        if (localValidationRunId === that.$$currentValidationRunId) {
          doneCallback(allValid);
        }
      }
    }

    /**
     * Commit a pending update to the `$modelValue`.
     *
     * Updates may be pending by a debounced event or because the input is waiting for a some future
     * event defined in `ng-model-options`. this method is rarely needed as `NgModelController`
     * usually handles calling this in response to input events.
     */
    $commitViewValue() {
      clearTimeout(this.$$pendingDebounce);

      // If the view value has not changed then we should just exit, except in the case where there is
      // a native validator on the element. In this case the validation state may have changed even though
      // the viewValue has stayed empty.
      if (
        this.$$lastCommittedViewValue === this.$viewValue &&
        (this.$viewValue !== "" || !this.$$hasNativeValidators)
      ) {
        return;
      }

      if (
        this.$$lastCommittedViewValue === undefined &&
        Number.isNaN(this.$viewValue)
      ) {
        return;
      }

      this.$$updateEmptyClasses(this.$viewValue);
      this.$$lastCommittedViewValue = this.$viewValue;

      // change to dirty
      if (this.$pristine) {
        this.$setDirty();
      }
      this.$$parseAndValidate();
    }

    $$parseAndValidate() {
      let modelValue = this.$$lastCommittedViewValue;

      const that = this;

      this.$$parserValid = isUndefined(modelValue) ? undefined : true;

      // Reset any previous parse error
      this.$setValidity(this.$$parserName, null);
      this.$$parserName = "parse";

      if (this.$$parserValid) {
        for (let i = 0; i < this.$parsers.length; i++) {
          modelValue = this.$parsers[i](modelValue);

          if (isUndefined(modelValue)) {
            this.$$parserValid = false;
            break;
          }
        }
      }

      if (isNumberNaN(this.$modelValue)) {
        // this.$modelValue has not been touched yet...
        // @ts-ignore
        this.$modelValue = this.$$ngModelGet(this.$$scope);
      }
      const prevModelValue = this.$modelValue;

      const allowInvalid = this.$options.getOption("allowInvalid");

      this.$$rawModelValue = modelValue;

      if (allowInvalid) {
        this.$modelValue = modelValue;
        writeToModelIfNeeded();
      }

      // Pass the $$lastCommittedViewValue here, because the cached viewValue might be out of date.
      // This can happen if e.g. $setViewValue is called from inside a parser
      this.$$runValidators(
        modelValue,
        this.$$lastCommittedViewValue,
        (allValid) => {
          if (!allowInvalid) {
            // Note: Don't check this.$valid here, as we could have
            // external validators (e.g. calculated on the server),
            // that just call $setValidity and need the model value
            // to calculate their validity.
            // if (that.$modelValue ?? that.$modelValue[isProxySymbol]) {
            //   delete that.$modelValue;
            // }
            that.$modelValue = allValid ? modelValue : undefined;
            writeToModelIfNeeded();
          }
        },
      );

      function writeToModelIfNeeded() {
        // intentional loose equality
        // eslint-disable-next-line eqeqeq
        if (that.$modelValue != prevModelValue) {
          that.$$writeModelToScope();
        }
      }
    }

    $$writeModelToScope() {
      this.$$ngModelSet(this.$$scope, this.$modelValue);
      Object.values(this.$viewChangeListeners).forEach((listener) => {
        try {
          listener();
        } catch (err) {
          this.$$exceptionHandler(err);
        }
      }, this);
    }

    /**
     * Update the view value.
     *
     * This method should be called when a control wants to change the view value; typically,
     * this is done from within a DOM event handler. For example, the {@link ng.directive:input input}
     * directive calls it when the value of the input changes and {@link ng.directive:select select}
     * calls it when an option is selected.
     *
     * When `$setViewValue` is called, the new `value` will be staged for committing through the `$parsers`
     * and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged
     * value is sent directly for processing through the `$parsers` pipeline. After this, the `$validators` and
     * `$asyncValidators` are called and the value is applied to `$modelValue`.
     * Finally, the value is set to the **expression** specified in the `ng-model` attribute and
     * all the registered change listeners, in the `$viewChangeListeners` list are called.
     *
     * In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`
     * and the `default` trigger is not listed, all those actions will remain pending until one of the
     * `updateOn` events is triggered on the DOM element.
     * All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}
     * directive is used with a custom debounce for this particular event.
     * Note that a `$digest` is only triggered once the `updateOn` events are fired, or if `debounce`
     * is specified, once the timer runs out.
     *
     * When used with standard inputs, the view value will always be a string (which is in some cases
     * parsed into another type, such as a `Date` object for `input[date]`.)
     * However, custom controls might also pass objects to this method. In this case, we should make
     * a copy of the object before passing it to `$setViewValue`. This is because `ngModel` does not
     * perform a deep watch of objects, it only looks for a change of identity. If you only change
     * the property of the object then ngModel will not realize that the object has changed and
     * will not invoke the `$parsers` and `$validators` pipelines. For this reason, you should
     * not change properties of the copy once it has been passed to `$setViewValue`.
     * Otherwise you may cause the model value on the scope to change incorrectly.
     *
     * <div class="alert alert-info">
     * In any case, the value passed to the method should always reflect the current value
     * of the control. For example, if you are calling `$setViewValue` for an input element,
     * you should pass the input DOM value. Otherwise, the control and the scope model become
     * out of sync. It's also important to note that `$setViewValue` does not call `$render` or change
     * the control's DOM value in any way. If we want to change the control's DOM value
     * programmatically, we should update the `ngModel` scope expression. Its new value will be
     * picked up by the model controller, which will run it through the `$formatters`, `$render` it
     * to update the DOM, and finally call `$validate` on it.
     * </div>
     *
     * @param {*} value value from the view.
     * @param {string} [trigger] Event that triggered the update.
     */
    $setViewValue(value, trigger) {
      this.$viewValue = value;

      if (this.$options?.getOption("updateOnDefault")) {
        this.$$debounceViewValueCommit(trigger);
      }
    }

    $$debounceViewValueCommit(trigger) {
      let debounceDelay = this.$options.getOption("debounce");

      if (isNumber(debounceDelay[trigger])) {
        debounceDelay = debounceDelay[trigger];
      } else if (
        isNumber(
          /** @type {Object.<string, number>} */ (debounceDelay).default,
        ) &&
        /** @type {string} */ (this.$options.getOption("updateOn")).indexOf(
          trigger,
        ) === -1
      ) {
        debounceDelay = /** @type {Object.<string, number>} */ (debounceDelay)
          .default;
      } else if (isNumber(debounceDelay["*"])) {
        debounceDelay = debounceDelay["*"];
      }

      clearTimeout(this.$$pendingDebounce);
      const that = this;

      if (/** @type {number} */ (debounceDelay) > 0) {
        // this fails if debounceDelay is an object
        this.$$pendingDebounce = setTimeout(() => {
          that.$commitViewValue();
        }, /** @type {number} */ (debounceDelay));
      } else {
        this.$commitViewValue();
      }
    }

    /**
     *
     * Override the current model options settings programmatically.
     *
     * The previous `ModelOptions` value will not be modified. Instead, a
     * new `ModelOptions` object will inherit from the previous one overriding
     * or inheriting settings that are defined in the given parameter.
     *
     * See {@link ngModelOptions} for information about what options can be specified
     * and how model option inheritance works.
     *
     * <div class="alert alert-warning">
     * **Note:** this function only affects the options set on the `ngModelController`,
     * and not the options on the {@link ngModelOptions} directive from which they might have been
     * obtained initially.
     * </div>
     *
     * <div class="alert alert-danger">
     * **Note:** it is not possible to override the `getterSetter` option.
     * </div>
     *
     * @param {Object} options a hash of settings to override the previous options
     *
     */
    $overrideModelOptions(options) {
      this.$$removeAllEventListeners();
      this.$options = this.$options.createChild(options);
      this.$$updateEvents = this.$options.$$options.updateOn;
      this.$$setUpdateOnEvents();
    }

    /**
     * Runs the model -> view pipeline on the current
     * {@link ngModel.NgModelController#$modelValue $modelValue}.
     *
     * The following actions are performed by this method:
     *
     * - the `$modelValue` is run through the {@link ngModel.NgModelController#$formatters $formatters}
     * and the result is set to the {@link ngModel.NgModelController#$viewValue $viewValue}
     * - the `ng-empty` or `ng-not-empty` class is set on the element
     * - if the `$viewValue` has changed:
     *   - {@link ngModel.NgModelController#$render $render} is called on the control
     *   - the {@link ngModel.NgModelController#$validators $validators} are run and
     *   the validation status is set.
     *
     * This method is called by ngModel internally when the bound scope value changes.
     * Application developers usually do not have to call this function themselves.
     *
     * This function can be used when the `$viewValue` or the rendered DOM value are not correctly
     * formatted and the `$modelValue` must be run through the `$formatters` again.
     *
     * @example
     * Consider a text input with an autocomplete list (for fruit), where the items are
     * objects with a name and an id.
     * A user enters `ap` and then selects `Apricot` from the list.
     * Based on this, the autocomplete widget will call `$setViewValue({name: 'Apricot', id: 443})`,
     * but the rendered value will still be `ap`.
     * The widget can then call `ctrl.$processModelValue()` to run the model -> view
     * pipeline again, which formats the object to the string `Apricot`,
     * then updates the `$viewValue`, and finally renders it in the DOM.
     *
     * <example module="inputExample" name="ng-model-process">
       <file name="index.html">
        <div ng-controller="inputController" style="display: flex;">
          <div style="margin-right: 30px;">
            Search Fruit:
            <basic-autocomplete items="items" on-select="selectedFruit = item"></basic-autocomplete>
          </div>
          <div>
            Model:<br>
            <pre>{{selectedFruit | json}}</pre>
          </div>
        </div>
       </file>
       <file name="app.js">
        angular.module('inputExample', [])
          .controller('inputController', function($scope) {
            $scope.items = [
              {name: 'Apricot', id: 443},
              {name: 'Clementine', id: 972},
              {name: 'Durian', id: 169},
              {name: 'Jackfruit', id: 982},
              {name: 'Strawberry', id: 863}
            ];
          })
          .component('basicAutocomplete', {
            bindings: {
              items: '<',
              onSelect: '&'
            },
            templateUrl: 'autocomplete.html',
            controller: function($element, $scope) {
              let that = this;
              let ngModel;

              that.$postLink = function() {
                ngModel = $element.querySelectorAll('input').controller('ngModel');

                ngModel.$formatters.push(function(value) {
                  return (value && value.name) || value;
                });

                ngModel.$parsers.push(function(value) {
                  let match = value;
                  for (let i = 0; i < that.items.length; i++) {
                    if (that.items[i].name === value) {
                      match = that.items[i];
                      break;
                    }
                  }

                  return match;
                });
              };

              that.selectItem = function(item) {
                ngModel.$setViewValue(item);
                ngModel.$processModelValue();
                that.onSelect({item: item});
              };
            }
          });
       </file>
       <file name="autocomplete.html">
         <div>
           <input type="search" ng-model="$ctrl.searchTerm" />
           <ul>
             <li ng-repeat="item in $ctrl.items | filter:$ctrl.searchTerm">
               <button ng-click="$ctrl.selectItem(item)">{{ item.name }}</button>
             </li>
           </ul>
         </div>
       </file>
     * </example>
     *
     */
    $processModelValue() {
      const viewValue = this.$$format();

      if (this.$viewValue !== viewValue) {
        this.$$updateEmptyClasses(viewValue);
        this.$viewValue = this.$$lastCommittedViewValue = viewValue;
        this.$render();
        // It is possible that model and view value have been updated during render
        this.$$runValidators(this.$modelValue, this.$viewValue, () => {
          /* empty */
        });
      }
    }

    /**
     * This method is called internally to run the $formatters on the $modelValue
     */
    $$format() {
      const formatters = this.$formatters;

      let idx = formatters.length;

      let viewValue = this.$modelValue;

      while (idx--) {
        viewValue = formatters[idx](viewValue);
      }

      return viewValue;
    }

    /**
     * This method is called internally when the bound scope value changes.
     */
    $$setModelValue(modelValue) {
      this.$modelValue = this.$$rawModelValue = modelValue;
      this.$$parserValid = undefined;
      this.$processModelValue();
    }

    $$removeAllEventListeners() {
      this.$$eventRemovers.forEach((removeCallback) => removeCallback());
      this.$$eventRemovers.clear();
    }

    $$setUpdateOnEvents() {
      if (this.$$updateEvents) {
        this.$$updateEvents.split(" ").forEach((ev) => {
          this.$$element.addEventListener(ev, this.$$updateEventHandler);
          this.$$eventRemovers.add(() =>
            this.$$element.removeEventListener(ev, this.$$updateEventHandler),
          );
        });
      }

      this.$$updateEvents = /** @type {string} */ (
        this.$options.getOption("updateOn")
      );

      if (this.$$updateEvents) {
        this.$$updateEvents.split(" ").forEach((ev) => {
          this.$$element.addEventListener(ev, this.$$updateEventHandler);
          this.$$eventRemovers.add(() =>
            this.$$element.removeEventListener(ev, this.$$updateEventHandler),
          );
        });
      }
    }

    $$updateEventHandler(ev) {
      this.$$debounceViewValueCommit(ev && ev.type);
    }
  }

  function setupModelWatcher(ctrl) {
    // model -> value
    // Note: we cannot use a normal scope.$watch as we want to detect the following:
    // 1. scope value is 'a'
    // 2. user enters 'b'
    // 3. ng-change kicks in and reverts scope value to 'a'
    //    -> scope value did not change since the last digest as
    //       ng-change executes in apply phase
    // 4. view should be changed back to 'a'
    ctrl.$$scope.$watch("value", () => {
      const modelValue = ctrl.$$ngModelGet(ctrl.$$scope);

      // if scope model value and ngModel value are out of sync
      // This cannot be moved to the action function, because it would not catch the
      // case where the model is changed in the ngChange function or the model setter
      if (
        modelValue !== ctrl.$modelValue &&
        // checks for NaN is needed to allow setting the model to NaN when there's an asyncValidator

        (!Number.isNaN(ctrl.$modelValue) || !Number.isNaN(modelValue))
      ) {
        ctrl.$$setModelValue(modelValue);
      }
    });
  }

  function ngModelDirective() {
    return {
      restrict: "A",
      require: ["ngModel", "^?form", "^?ngModelOptions"],
      controller: NgModelController,
      // Prelink needs to run before any input directive
      // so that we can set the NgModelOptions in NgModelController
      // before anyone else uses it.
      priority: 1,
      compile:
        /** @param {Element} element  */
        (element) => {
          // Setup initial state of the control
          element.classList.add(PRISTINE_CLASS, UNTOUCHED_CLASS, VALID_CLASS);

          return {
            pre: (scope, _element, attr, ctrls) => {
              const modelCtrl = ctrls[0];

              const formCtrl = ctrls[1] || modelCtrl.$$parentForm;

              const optionsCtrl = ctrls[2];

              if (optionsCtrl) {
                modelCtrl.$options = optionsCtrl.$options;
              }
              modelCtrl.$$initGetterSetters();

              // notify others, especially parent forms
              formCtrl.$addControl(modelCtrl);

              attr.$observe("name", (newValue) => {
                if (modelCtrl.$name !== newValue) {
                  modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                }
              });
              const deregisterWatch = scope.$watch(attr.ngModel, (val) => {
                modelCtrl.$$setModelValue(deProxy(val));
              });

              scope.$on("$destroy", () => {
                modelCtrl.$$parentForm.$removeControl(modelCtrl);
                deregisterWatch();
              });
            },
            post: (scope, elementPost, _attr, ctrls) => {
              const modelCtrl = ctrls[0];

              modelCtrl.$$setUpdateOnEvents();

              function setTouched() {
                modelCtrl.$setTouched();
              }

              elementPost.addEventListener("blur", () => {
                if (modelCtrl.$touched) return;
                setTouched();
              });

              modelCtrl.$viewChangeListeners.push(() =>
                scope.$eval(elementPost.dataset.change),
              );
            },
          };
        },
    };
  }

  // Regex code was initially obtained from SO prior to modification: https://stackoverflow.com/questions/3143070/javascript-regex-iso-datetime#answer-3143231
  const ISO_DATE_REGEXP =
    /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
  // See valid URLs in RFC3987 (http://tools.ietf.org/html/rfc3987)
  // Note: We are being more lenient, because browsers are too.
  //   1. Scheme
  //   2. Slashes
  //   3. Username
  //   4. Password
  //   5. Hostname
  //   6. Port
  //   7. Path
  //   8. Query
  //   9. Fragment
  //                 1111111111111111 222   333333    44444        55555555555555555555555     666     77777777     8888888     999
  const URL_REGEXP =
    /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;

  const EMAIL_REGEXP =
    /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
  const NUMBER_REGEXP = /^\s*([-+])?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;

  const DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;

  const DATETIMELOCAL_REGEXP =
    /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;

  const WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;

  const MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;

  const TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;

  // The name of a form control's ValidityState property.
  // This is used so that it's possible for internal tests to create mock ValidityStates.
  const VALIDITY_STATE_PROPERTY = "validity";

  const PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown";

  /**
   * @type {Map<string, boolean>}
   */
  const PARTIAL_VALIDATION_TYPES = new Map();

  "date,datetime-local,month,time,week".split(",").forEach((type) => {
    PARTIAL_VALIDATION_TYPES.set(type, true);
  });

  const inputType = {
    text: textInputType,
    date: createDateInputType(
      "date",
      DATE_REGEXP,
      createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]),
    ),
    "datetime-local": createDateInputType(
      "datetimelocal",
      DATETIMELOCAL_REGEXP,
      createDateParser(DATETIMELOCAL_REGEXP, [
        "yyyy",
        "MM",
        "dd",
        "HH",
        "mm",
        "ss",
        "sss",
      ]),
    ),
    time: createDateInputType(
      "time",
      TIME_REGEXP,
      createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]),
    ),
    week: createDateInputType("week", WEEK_REGEXP, weekParser),
    month: createDateInputType(
      "month",
      MONTH_REGEXP,
      createDateParser(MONTH_REGEXP, ["yyyy", "MM"]),
    ),
    number: numberInputType,
    url: urlInputType,
    email: emailInputType,
    radio: radioInputType,
    range: rangeInputType,
    checkbox: checkboxInputType,
    hidden: () => {
      /* empty */
    },
    button: () => {
      /* empty */
    },
    submit: () => {
      /* empty */
    },
    reset: () => {
      /* empty */
    },
    file: () => {
      /* empty */
    },
  };

  function stringBasedInputType(ctrl) {
    ctrl.$formatters.push((value) =>
      ctrl.$isEmpty(value) ? value : value.toString(),
    );
  }

  function textInputType(scope, element, attr, ctrl) {
    baseInputType(scope, element, attr, ctrl);
    stringBasedInputType(ctrl);
  }

  function baseInputType(_, element, attr, ctrl) {
    const type = element.type.toLowerCase();

    let composing = false;

    // In composition mode, users are still inputting intermediate text buffer,
    // hold the listener until composition is done.
    // More about composition events: https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent
    element.addEventListener("compositionstart", () => {
      composing = true;
    });

    element.addEventListener("compositionend", () => {
      composing = false;
      listener();
    });

    let timeout;

    const listener = function (ev) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }

      if (composing) return;
      let { value } = element;

      const event = ev && ev.type;

      // By default we will trim the value
      // If the attribute ng-trim exists we will avoid trimming
      // If input type is 'password', the value is never trimmed
      if (type !== "password" && (!attr.ngTrim || attr.ngTrim !== "false")) {
        value = trim(value);
      }

      // If a control is suffering from bad input (due to native validators), browsers discard its
      // value, so it may be necessary to revalidate (by calling $setViewValue again) even if the
      // control's value is the same empty value twice in a row.
      if (
        ctrl.$viewValue !== value ||
        (value === "" && ctrl.$$hasNativeValidators)
      ) {
        ctrl.$target.$setViewValue(value, event);
      }
    };

    ["input", "change", "paste", "drop", "cut"].forEach((event) => {
      element.addEventListener(event, listener);
    });

    // Some native input types (date-family) have the ability to change validity without
    // firing any input/change events.
    // For these event types, when native validators are present and the browser supports the type,
    // check for validity changes on various DOM events.
    if (
      PARTIAL_VALIDATION_TYPES[type] &&
      ctrl.$$hasNativeValidators &&
      type === attr.type
    ) {
      element.addEventListener(PARTIAL_VALIDATION_EVENTS, (ev) => {
        if (!timeout) {
          // eslint-disable-next-line no-invalid-this
          const validity = this[VALIDITY_STATE_PROPERTY];

          const origBadInput = validity.badInput;

          const origTypeMismatch = validity.typeMismatch;

          timeout = setTimeout(() => {
            timeout = null;

            if (
              validity.badInput !== origBadInput ||
              validity.typeMismatch !== origTypeMismatch
            ) {
              listener(ev);
            }
          });
        }
      });
    }

    ctrl.$render = function () {
      // Workaround for Firefox validation #12102.
      const value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;

      if (element.value !== value) {
        element.value = value;
      }
    };
  }

  function weekParser(isoWeek, existingDate) {
    if (isDate(isoWeek)) {
      return isoWeek;
    }

    function getFirstThursdayOfYear(year) {
      // 0 = index of January
      const dayOfWeekOnFirst = new Date(year, 0, 1).getDay();

      // 4 = index of Thursday (+1 to account for 1st = 5)
      // 11 = index of *next* Thursday (+1 account for 1st = 12)
      return new Date(
        year,
        0,
        // eslint-disable-next-line no-magic-numbers
        (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst,
      );
    }

    if (isString(isoWeek)) {
      WEEK_REGEXP.lastIndex = 0;
      const parts = WEEK_REGEXP.exec(isoWeek);

      if (parts) {
        const year = +parts[1];

        const week = +parts[2];

        let hours = 0;

        let minutes = 0;

        let seconds = 0;

        let milliseconds = 0;

        const firstThurs = getFirstThursdayOfYear(year);

        const DAYS = 7;

        const addDays = (week - 1) * DAYS;

        if (existingDate) {
          hours = existingDate.getHours();
          minutes = existingDate.getMinutes();
          seconds = existingDate.getSeconds();
          milliseconds = existingDate.getMilliseconds();
        }

        return new Date(
          year,
          0,
          firstThurs.getDate() + addDays,
          hours,
          minutes,
          seconds,
          milliseconds,
        );
      }
    }

    return NaN;
  }

  function createDateParser(regexp, mapping) {
    return function (iso, previousDate) {
      let parts;

      let map;

      if (isDate(iso)) {
        return iso;
      }

      if (isString(iso)) {
        // When a date is JSON'ified to wraps itself inside of an extra
        // set of double quotes. This makes the date parsing code unable
        // to match the date string and parse it as a date.
        if (iso.charAt(0) === '"' && iso.charAt(iso.length - 1) === '"') {
          iso = iso.substring(1, iso.length - 1);
        }

        if (ISO_DATE_REGEXP.test(iso)) {
          return new Date(iso);
        }
        regexp.lastIndex = 0;
        parts = regexp.exec(iso);

        if (parts) {
          parts.shift();

          if (previousDate) {
            map = {
              yyyy: previousDate.getFullYear(),
              MM: previousDate.getMonth() + 1,
              dd: previousDate.getDate(),
              HH: previousDate.getHours(),
              mm: previousDate.getMinutes(),
              ss: previousDate.getSeconds(),
              sss: previousDate.getMilliseconds() / 1000,
            };
          } else {
            map = { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 };
          }

          Object.entries(parts).forEach(([index, part]) => {
            if (index < mapping.length) {
              map[mapping[index]] = +part;
            }
          });

          const date = new Date(
            map.yyyy,
            map.MM - 1,
            map.dd,
            map.HH,
            map.mm,
            map.ss || 0,
            map.sss * 1000 || 0,
          );

          if (map.yyyy < 100) {
            // In the constructor, 2-digit years map to 1900-1999.
            // Use `setFullYear()` to set the correct year.
            date.setFullYear(map.yyyy);
          }

          return date;
        }
      }

      return NaN;
    };
  }

  const MONTH_INPUT_FORMAT = /\b\d{4}-(0[1-9]|1[0-2])\b/;

  function createDateInputType(type, regexp, parseDate) {
    return function dynamicDateInputType(
      scope,
      element,
      attr,
      ctrl,
      $filter,
      $parse,
    ) {
      badInputChecker(scope, element, attr, ctrl, type);
      baseInputType(scope, element, attr, ctrl);
      let previousDate;

      ctrl.$parsers.push((value) => {
        if (ctrl.$isEmpty(value)) return null;

        if (regexp.test(value)) {
          // Do not convert for native HTML
          if (["month", "week", "datetimelocal", "time", "date"].includes(type)) {
            return value;
          }

          // Note: We cannot read ctrl.$modelValue, as there might be a different
          // parser/formatter in the processing chain so that the model
          // contains some different data format!
          return parseDateAndConvertTimeZoneToLocal(value, previousDate);
        }
        ctrl.$$parserName = type;

        return undefined;
      });

      ctrl.$formatters.push(function (value) {
        if (value && !isString(value)) {
          throw ngModelMinErr("datefmt", "Expected `{0}` to be a String", value);
        }

        if (type === "month") {
          if (isNullOrUndefined(value)) {
            return "";
          }

          if (!MONTH_INPUT_FORMAT.test(value)) {
            throw ngModelMinErr(
              "datefmt",
              "Expected month `{0}` to be a 'YYYY-DD'",
              value,
            );
          }
        }

        if (type === "week") {
          if (isNullOrUndefined(value)) {
            return "";
          }

          if (!WEEK_REGEXP.test(value)) {
            throw ngModelMinErr(
              "datefmt",
              "Expected week `{0}` to be a 'yyyy-Www'",
              value,
            );
          }
        }

        if (type === "datetimelocal") {
          if (isNullOrUndefined(value)) {
            return "";
          }

          if (!DATETIMELOCAL_REGEXP.test(value)) {
            throw ngModelMinErr(
              "datefmt",
              "Expected week `{0}` to be a in date time format. See: https://developer.mozilla.org/en-US/docs/Web/HTML/Date_and_time_formats#local_date_and_time_strings",
              value,
            );
          }
        }

        return value;

        // if (isValidDate(value)) {
        //   previousDate = value;
        //   const timezone = ctrl.$options.getOption("timezone");

        //   if (timezone) {
        //     previousTimezone = timezone;
        //     previousDate = convertTimezoneToLocal(previousDate, timezone, true);
        //   }

        //   return value;
        // }
        // previousDate = null;
        // previousTimezone = null;
        // return "";
      });

      if (isDefined(attr.min) || attr.ngMin) {
        let minVal = attr.min || $parse(attr.ngMin)(scope);

        let parsedMinVal = parseObservedDateValue(deProxy(minVal));

        ctrl.$validators.min = function (value) {
          if (type === "month") {
            return (
              isUndefined(parsedMinVal) ||
              parseDate(value) >= parseDate(parsedMinVal)
            );
          }

          return (
            !isValidDate(value) ||
            isUndefined(parsedMinVal) ||
            parseDate(value) >= parsedMinVal
          );
        };
        attr.$observe("min", (val) => {
          if (val !== minVal) {
            parsedMinVal = parseObservedDateValue(val);
            minVal = val;
            ctrl.$validate();
          }
        });
      }

      if (isDefined(attr.max) || attr.ngMax) {
        let maxVal = attr.max || $parse(attr.ngMax)(scope);

        let parsedMaxVal = parseObservedDateValue(deProxy(maxVal));

        ctrl.$validators.max = function (value) {
          if (type === "month") {
            return (
              isUndefined(parsedMaxVal) ||
              parseDate(value) <= parseDate(parsedMaxVal)
            );
          }

          return (
            !isValidDate(value) ||
            isUndefined(parsedMaxVal) ||
            parseDate(value) <= parsedMaxVal
          );
        };
        attr.$observe("max", (val) => {
          if (val !== maxVal) {
            parsedMaxVal = parseObservedDateValue(val);
            maxVal = val;
            ctrl.$validate();
          }
        });
      }

      function isValidDate(value) {
        // Invalid Date: getTime() returns NaN
        return value && !(value.getTime && Number.isNaN(value.getTime()));
      }

      function parseObservedDateValue(val) {
        return isDefined(val) && !isDate(val)
          ? parseDateAndConvertTimeZoneToLocal(val) || undefined
          : val;
      }

      function parseDateAndConvertTimeZoneToLocal(value, previousDateParam) {
        const timezone = ctrl.$options.getOption("timezone");

        let parsedDate = parseDate(value, previousDateParam);

        if (!Number.isNaN(parsedDate) && timezone) {
          parsedDate = convertTimezoneToLocal(parsedDate, timezone);
        }

        return parsedDate;
      }
    };
  }

  function badInputChecker(scope, element, attr, ctrl, parserName) {
    const nativeValidation = (ctrl.$$hasNativeValidators = isObject(
      element.validity,
    ));

    if (nativeValidation) {
      ctrl.$parsers.push((value) => {
        const validity = element[VALIDITY_STATE_PROPERTY] || {};

        if (validity.badInput || validity.typeMismatch) {
          ctrl.$$parserName = parserName;

          return undefined;
        }

        return value;
      });
    }
  }

  function numberFormatterParser(ctrl) {
    ctrl.$parsers.push((value) => {
      if (ctrl.$isEmpty(value)) return null;

      if (NUMBER_REGEXP.test(value)) return parseFloat(value);

      ctrl.$$parserName = "number";

      return undefined;
    });

    ctrl.$formatters.push((value) => {
      if (!ctrl.$isEmpty(value)) {
        if (!isNumber(value)) {
          throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
        }
        value = value.toString();
      }

      return value;
    });
  }

  function parseNumberAttrVal(val) {
    if (isDefined(val) && !isNumber(val)) {
      val = parseFloat(val);
    }

    return !isNumberNaN(val) ? val : undefined;
  }

  function isNumberInteger(num) {
    // See http://stackoverflow.com/questions/14636536/how-to-check-if-a-variable-is-an-integer-in-javascript#14794066
    // (minus the assumption that `num` is a number)

    return (num | 0) === num;
  }

  function countDecimals(num) {
    const numString = num.toString();

    const decimalSymbolIndex = numString.indexOf(".");

    if (decimalSymbolIndex === -1) {
      if (num > -1 && num < 1) {
        // It may be in the exponential notation format (`1e-X`)
        const match = /e-(\d+)$/.exec(numString);

        if (match) {
          return Number(match[1]);
        }
      }

      return 0;
    }

    return numString.length - decimalSymbolIndex - 1;
  }

  function isValidForStep(viewValue, stepBase, step) {
    // At this point `stepBase` and `step` are expected to be non-NaN values
    // and `viewValue` is expected to be a valid stringified number.
    let value = Number(viewValue);

    const isNonIntegerValue = !isNumberInteger(value);

    const isNonIntegerStepBase = !isNumberInteger(stepBase);

    const isNonIntegerStep = !isNumberInteger(step);

    // Due to limitations in Floating Point Arithmetic (e.g. `0.3 - 0.2 !== 0.1` or
    // `0.5 % 0.1 !== 0`), we need to convert all numbers to integers.
    if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
      const valueDecimals = isNonIntegerValue ? countDecimals(value) : 0;

      const stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0;

      const stepDecimals = isNonIntegerStep ? countDecimals(step) : 0;

      const decimalCount = Math.max(
        valueDecimals,
        stepBaseDecimals,
        stepDecimals,
      );

      const multiplier = 10 ** decimalCount;

      value *= multiplier;
      stepBase *= multiplier;
      step *= multiplier;

      if (isNonIntegerValue) value = Math.round(value);

      if (isNonIntegerStepBase) stepBase = Math.round(stepBase);

      if (isNonIntegerStep) step = Math.round(step);
    }

    return (value - stepBase) % step === 0;
  }

  function numberInputType(scope, element, attr, ctrl, $filter, $parse) {
    badInputChecker(scope, element, attr, ctrl, "number");
    numberFormatterParser(ctrl);
    baseInputType(scope, element, attr, ctrl);

    let parsedMinVal;

    if (isDefined(attr.min) || attr.ngMin) {
      let minVal = attr.min || $parse(attr.ngMin)(scope);

      parsedMinVal = parseNumberAttrVal(minVal);

      ctrl.$validators.min = function (modelValue, viewValue) {
        return (
          ctrl.$isEmpty(viewValue) ||
          isUndefined(parsedMinVal) ||
          viewValue >= parsedMinVal
        );
      };

      attr.$observe("min", (val) => {
        if (val !== minVal) {
          parsedMinVal = parseNumberAttrVal(val);
          minVal = val;
          // TODO(matsko): implement validateLater to reduce number of validations
          ctrl.$validate();
        }
      });
    }

    if (isDefined(attr.max) || attr.ngMax) {
      let maxVal = attr.max || $parse(attr.ngMax)(scope);

      let parsedMaxVal = parseNumberAttrVal(maxVal);

      ctrl.$validators.max = function (modelValue, viewValue) {
        return (
          ctrl.$isEmpty(viewValue) ||
          isUndefined(parsedMaxVal) ||
          viewValue <= parsedMaxVal
        );
      };

      attr.$observe("max", (val) => {
        if (val !== maxVal) {
          parsedMaxVal = parseNumberAttrVal(val);
          maxVal = val;
          // TODO(matsko): implement validateLater to reduce number of validations
          ctrl.$validate();
        }
      });
    }

    if (isDefined(attr.step) || attr.ngStep) {
      let stepVal = attr.step || $parse(attr.ngStep)(scope);

      let parsedStepVal = parseNumberAttrVal(stepVal);

      ctrl.$validators.step = function (modelValue, viewValue) {
        return (
          ctrl.$isEmpty(viewValue) ||
          isUndefined(parsedStepVal) ||
          isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal)
        );
      };

      attr.$observe("step", (val) => {
        // TODO(matsko): implement validateLater to reduce number of validations
        if (val !== stepVal) {
          parsedStepVal = parseNumberAttrVal(val);
          stepVal = val;
          ctrl.$validate();
        }
      });
    }
  }

  function rangeInputType(scope, element, attr, ctrl) {
    badInputChecker(scope, element, attr, ctrl, "range");
    numberFormatterParser(ctrl);
    baseInputType(scope, element, attr, ctrl);

    const supportsRange = ctrl.$$hasNativeValidators && element.type === "range";

    let minVal = supportsRange ? 0 : undefined;

    let maxVal = supportsRange ? 100 : undefined;

    let stepVal = supportsRange ? 1 : undefined;

    const { validity } = element;

    const hasMinAttr = isDefined(attr.min);

    const hasMaxAttr = isDefined(attr.max);

    const hasStepAttr = isDefined(attr.step);

    const originalRender = ctrl.$render;

    ctrl.$render =
      supportsRange &&
      isDefined(validity.rangeUnderflow) &&
      isDefined(validity.rangeOverflow)
        ? // Browsers that implement range will set these values automatically, but reading the adjusted values after
          // $render would cause the min / max validators to be applied with the wrong value
          function rangeRender() {
            originalRender();
            ctrl.$setViewValue(element.value);
          }
        : originalRender;

    if (hasMinAttr) {
      minVal = parseNumberAttrVal(attr.min);

      ctrl.$validators.min = supportsRange
        ? // Since all browsers set the input to a valid value, we don't need to check validity
          function noopMinValidator() {
            return true;
          }
        : // non-support browsers validate the min val
          function minValidator(modelValue, viewValue) {
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(minVal) ||
              viewValue >= minVal
            );
          };

      setInitialValueAndObserver("min", minChange);
    }

    if (hasMaxAttr) {
      maxVal = parseNumberAttrVal(attr.max);

      ctrl.$validators.max = supportsRange
        ? // Since all browsers set the input to a valid value, we don't need to check validity
          function noopMaxValidator() {
            return true;
          }
        : // non-support browsers validate the max val
          function maxValidator(modelValue, viewValue) {
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(maxVal) ||
              viewValue <= maxVal
            );
          };

      setInitialValueAndObserver("max", maxChange);
    }

    if (hasStepAttr) {
      stepVal = parseNumberAttrVal(attr.step);

      ctrl.$validators.step = supportsRange
        ? function nativeStepValidator() {
            // Currently, only FF implements the spec on step change correctly (i.e. adjusting the
            // input element value to a valid value). It's possible that other browsers set the stepMismatch
            // validity error instead, so we can at least report an error in that case.
            return !validity.stepMismatch;
          }
        : // ngStep doesn't set the setp attr, so the browser doesn't adjust the input value as setting step would
          function stepValidator(modelValue, viewValue) {
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(stepVal) ||
              isValidForStep(viewValue, minVal || 0, stepVal)
            );
          };

      setInitialValueAndObserver("step", stepChange);
    }

    function setInitialValueAndObserver(htmlAttrName, changeFn) {
      // interpolated attributes set the attribute value only after a digest, but we need the
      // attribute value when the input is first rendered, so that the browser can adjust the
      // input value based on the min/max value
      element.setAttribute(htmlAttrName, attr[htmlAttrName]);
      let oldVal = attr[htmlAttrName];

      attr.$observe(htmlAttrName, (val) => {
        if (val !== oldVal) {
          oldVal = val;
          changeFn(val);
        }
      });
    }

    function minChange(val) {
      minVal = parseNumberAttrVal(val);

      // ignore changes before model is initialized
      if (isNumberNaN(ctrl.$modelValue)) {
        return;
      }

      if (supportsRange) {
        let elVal = element.value;

        // IE11 doesn't set the el val correctly if the minVal is greater than the element value
        if (minVal > elVal) {
          elVal = minVal;
          element.value = elVal;
        }
        ctrl.$setViewValue(elVal);
      } else {
        // TODO(matsko): implement validateLater to reduce number of validations
        ctrl.$validate();
      }
    }

    function maxChange(val) {
      maxVal = parseNumberAttrVal(val);

      // ignore changes before model is initialized
      if (isNumberNaN(ctrl.$modelValue)) {
        return;
      }

      if (supportsRange) {
        let elVal = element.value;

        // IE11 doesn't set the el val correctly if the maxVal is less than the element value
        if (maxVal < elVal) {
          element.value = maxVal;
          // IE11 and Chrome don't set the value to the minVal when max < min
          elVal = maxVal < minVal ? minVal : maxVal;
        }
        ctrl.$setViewValue(elVal);
      } else {
        // TODO(matsko): implement validateLater to reduce number of validations
        ctrl.$validate();
      }
    }

    function stepChange(val) {
      stepVal = parseNumberAttrVal(val);

      // ignore changes before model is initialized
      if (isNumberNaN(ctrl.$modelValue)) {
        return;
      }

      // Some browsers don't adjust the input value correctly, but set the stepMismatch error
      if (!supportsRange) {
        // TODO(matsko): implement validateLater to reduce number of validations
        ctrl.$validate();
      } else if (ctrl.$viewValue !== element.value) {
        ctrl.$setViewValue(element.value);
      }
    }
  }

  function urlInputType(scope, element, attr, ctrl) {
    // Note: no badInputChecker here by purpose as `url` is only a validation
    // in browsers, i.e. we can always read out input.value even if it is not valid!
    baseInputType(scope, element, attr, ctrl);
    stringBasedInputType(ctrl);

    ctrl.$validators.url = function (modelValue, viewValue) {
      const value = modelValue || viewValue;

      return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
    };
  }

  function emailInputType(scope, element, attr, ctrl) {
    // Note: no badInputChecker here by purpose as `url` is only a validation
    // in browsers, i.e. we can always read out input.value even if it is not valid!
    baseInputType(scope, element, attr, ctrl);
    stringBasedInputType(ctrl);

    ctrl.$validators.email = function (modelValue, viewValue) {
      const value = modelValue || viewValue;

      return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
    };
  }

  function radioInputType(scope, element, attr, ctrl) {
    const doTrim = !attr.ngTrim || trim(attr.ngTrim) !== "false";

    // make the name unique, if not defined
    if (isUndefined(attr.name)) {
      element.setAttribute("name", nextUid());
    }

    const listener = function (ev) {
      if (element.checked) {
        let { value } = attr;

        if (doTrim) {
          value = trim(value);
        }
        ctrl.$setViewValue(value, ev && ev.type);
      }
    };

    element.addEventListener("change", listener);
    // NgModelController call
    ctrl.$render = function () {
      let { value } = attr;

      if (doTrim) {
        value = trim(value);
      }
      const deproxy = isProxy(ctrl.$viewValue)
        ? ctrl.$viewValue.$target
        : ctrl.$viewValue;

      // the proxy may reach down two levels
      element.checked = deProxy(value) === deProxy(deproxy);
    };

    attr.$observe("value", ctrl.$render);
  }

  function parseConstantExpr($parse, context, name, expression, fallback) {
    let parseFn;

    if (isDefined(expression)) {
      parseFn = $parse(expression);

      if (!parseFn.constant) {
        throw ngModelMinErr(
          "constexpr",
          "Expected constant expression for `{0}`, but saw " + "`{1}`.",
          name,
          expression,
        );
      }

      return parseFn(context);
    }

    return fallback;
  }

  function checkboxInputType(scope, element, attr, ctrl, $filter, $parse) {
    const trueValue = parseConstantExpr(
      $parse,
      scope,
      "ngTrueValue",
      attr.ngTrueValue,
      true,
    );

    const falseValue = parseConstantExpr(
      $parse,
      scope,
      "ngFalseValue",
      attr.ngFalseValue,
      false,
    );

    const listener = function (ev) {
      ctrl.$setViewValue(element.checked, ev && ev.type);
    };

    element.addEventListener("change", listener);

    ctrl.$render = function () {
      element.checked = ctrl.$viewValue;
    };

    // Override the standard `$isEmpty` because the $viewValue of an empty checkbox is always set to `false`
    // This is because of the parser below, which compares the `$modelValue` with `trueValue` to convert
    // it to a boolean.
    ctrl.$isEmpty = function (value) {
      return value === false;
    };

    ctrl.$formatters.push((value) => equals$1(value, trueValue));

    ctrl.$parsers.push((value) => (value ? trueValue : falseValue));
  }

  inputDirective.$inject = [$injectTokens._filter, $injectTokens._parse];

  /**
   * @param {ng.FilterFactory} $filter
   * @param {ng.ParseService} $parse
   * @returns {ng.Directive}
   */
  function inputDirective($filter, $parse) {
    return {
      restrict: "E",
      require: ["?ngModel"],
      link: {
        pre(scope, element, attr, ctrls) {
          if (ctrls[0]) {
            (inputType[attr.type?.toLowerCase()] || inputType.text)(
              scope,
              element,
              attr,
              ctrls[0],
              $filter,
              $parse,
            );
          }
        },
      },
    };
  }

  /**
   * @returns {ng.Directive}
   */
  function hiddenInputBrowserCacheDirective() {
    const valueProperty = {
      configurable: true,
      enumerable: false,
      get() {
        return this.getAttribute("value") || "";
      },
      set(val) {
        this.setAttribute("value", val);
      },
    };

    return {
      restrict: "E",
      priority: 200,
      compile(_, attr) {
        if (attr.type?.toLowerCase() !== "hidden") {
          return undefined;
        }

        const res = {
          pre(_scope, element) {
            const node = element;

            // Support: Edge
            // Moving the DOM around prevents autofillling
            if (node.parentNode) {
              node.parentNode.insertBefore(node, node.nextSibling);
            }

            // Support: FF, IE
            // Avoiding direct assignment to .value prevents autofillling
            if (Object.defineProperty) {
              Object.defineProperty(node, "value", valueProperty);
            }

            return undefined;
          },
        };

        return res;
      },
    };
  }

  const CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

  /**
   * @returns {ng.Directive}
   */
  function ngValueDirective() {
    /**
     *  inputs use the value attribute as their default value if the value property is not set.
     *  Once the value property has been set (by adding input), it will not react to changes to
     *  the value attribute anymore. Setting both attribute and property fixes this behavior, and
     *  makes it possible to use ngValue as a sort of one-way bind.
     */
    function updateElementValue(element, attr, value) {
      element.value = deProxy(value ?? "");
      attr.$set("value", value);
    }

    return {
      restrict: "A",
      priority: 100,
      compile(_, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function (scope, elm, attr) {
            const value = scope.$eval(attr.ngValue);

            updateElementValue(elm, attr, value);
          };
        }

        return function (scope, elm, attr) {
          scope.$watch(attr.ngValue, (value) => {
            updateElementValue(elm, attr, value);
          });
        };
      },
    };
  }

  scriptDirective.$inject = [$injectTokens._templateCache];

  /**
   * @param {ng.TemplateCacheService} $templateCache
   * @returns {ng.Directive}
   */
  function scriptDirective($templateCache) {
    return {
      restrict: "E",
      terminal: true,
      compile(element, attr) {
        if (attr.type === "text/ng-template") {
          $templateCache.set(attr.id, element.innerText);
        }
      },
    };
  }

  /**
   * The controller for the {@link ng.select select} directive.
   * The controller exposes a few utility methods that can be used to augment
   * the behavior of a regular or an {@link ng.ngOptions ngOptions} select element.
   */
  class SelectController {
    static $nonscope = [
      "ngModelCtrl",
      "selectValueMap",
      "emptyOption",
      "optionsMap",
      "$scope",
      "$element",
    ];

    /**
     * @type {Array<string>}
     */
    /* @ignore */ static $inject = [$injectTokens._element, $injectTokens._scope];

    /**
     * @param {HTMLSelectElement} $element
     * @param {ng.Scope} $scope
     */
    constructor($element, $scope) {
      /** @type {HTMLSelectElement} */
      this.$element = $element;

      /** @type {ng.Scope} */
      this.$scope = $scope;

      /** @type {Object<string, any>} */
      this.selectValueMap = {};

      /** @type {any} */
      this.ngModelCtrl = {};

      /** @type {boolean} */
      this.multiple = false;

      /** @type {HTMLOptionElement} */
      this.unknownOption = document.createElement("option");

      /** @type {boolean} */
      this.hasEmptyOption = false;

      /** @type {HTMLOptionElement|undefined} */
      this.emptyOption = undefined;

      /** @type {Map<any, number>} */
      this.optionsMap = new Map();

      /** @type {boolean} */
      this.renderScheduled = false;

      /** @type {boolean} */
      this.updateScheduled = false;

      $scope.$on("$destroy", () => {
        // disable unknown option so that we don't do work when the whole select is being destroyed
        this.renderUnknownOption = () => {
          /* empty */
        };
      });
    }

    /**
     * Render the unknown option when the viewValue doesn't match any options.
     * @param {*} val
     */
    renderUnknownOption(val) {
      const unknownVal = this.generateUnknownOptionValue(val);

      this.unknownOption.value = unknownVal;
      this.$element.prepend(this.unknownOption);
      this.unknownOption.selected = true;
      this.unknownOption.setAttribute("selected", "selected");
      this.$element.value = unknownVal;
    }

    /**
     * Update the unknown option if it's already rendered.
     * @param {*} val
     */
    updateUnknownOption(val) {
      const unknownVal = this.generateUnknownOptionValue(val);

      this.unknownOption.value = unknownVal;
      this.unknownOption.selected = true;
      this.unknownOption.setAttribute("selected", "selected");
      this.$element.value = unknownVal;
    }

    /**
     * Generate a special value used for unknown options.
     * @param {*} val
     * @returns {string}
     */
    generateUnknownOptionValue(val) {
      if (isUndefined(val)) {
        return `? undefined:undefined ?`;
      }

      return `? ${hashKey(val)} ?`;
    }

    /**
     * Remove the unknown option from the select element if it exists.
     */
    removeUnknownOption() {
      if (this.unknownOption.parentElement) this.unknownOption.remove();
    }

    /**
     * Select the empty option (value="") if it exists.
     */
    selectEmptyOption() {
      if (this.emptyOption) {
        this.$element.value = "";
        this.emptyOption.selected = true;
        this.emptyOption.setAttribute("selected", "selected");
      }
    }

    /**
     * Unselect the empty option if present.
     */
    unselectEmptyOption() {
      if (this.hasEmptyOption) {
        this.emptyOption.selected = false;
      }
    }

    /**
     * Read the current value from the select element.
     * @returns {*|null}
     */
    readValue() {
      const val = this.$element.value;

      const realVal = val in this.selectValueMap ? this.selectValueMap[val] : val;

      return this.hasOption(realVal) ? realVal : null;
    }

    /**
     * Write a value to the select control.
     * @param {*} value
     */
    writeValue(value) {
      const currentlySelectedOption =
        this.$element.options[this.$element.selectedIndex];

      if (currentlySelectedOption) currentlySelectedOption.selected = false;

      if (this.hasOption(value)) {
        this.removeUnknownOption();

        const hashedVal = hashKey(value);

        this.$element.value =
          hashedVal in this.selectValueMap ? hashedVal : value;
        const selectedOption = this.$element.options[this.$element.selectedIndex];

        if (!selectedOption) {
          this.selectUnknownOrEmptyOption(value);
        } else {
          selectedOption.selected = true;
        }
      } else {
        this.selectUnknownOrEmptyOption(value);
      }
    }

    /**
     * Register a new option with the controller.
     * @param {*} value
     * @param {HTMLOptionElement} element
     */
    addOption(value, element) {
      if (element.nodeType === NodeType._COMMENT_NODE) return;

      assertNotHasOwnProperty(value, '"option value"');

      if (value === "") {
        this.hasEmptyOption = true;
        this.emptyOption = element;
      }
      const count = this.optionsMap.get(value) || 0;

      this.optionsMap.set(value, count + 1);
      this.scheduleRender();
    }

    /**
     * Remove an option from the controller.
     * @param {*} value
     */
    removeOption(value) {
      const count = this.optionsMap.get(value);

      if (count) {
        if (count === 1) {
          this.optionsMap.delete(value);

          if (value === "") {
            this.hasEmptyOption = false;
            this.emptyOption = undefined;
          }
        } else {
          this.optionsMap.set(value, count - 1);
        }
      }
    }

    /**
     * Check if an option exists for the given value.
     * @param {*} value
     * @returns {boolean}
     */
    hasOption(value) {
      return !!this.optionsMap.get(value);
    }

    /**
     * @returns {boolean} Whether the select element currently has an empty option.
     */
    $hasEmptyOption() {
      return this.hasEmptyOption;
    }

    /**
     * @returns {boolean} Whether the unknown option is currently selected.
     */
    $isUnknownOptionSelected() {
      return this.$element.options[0] === this.unknownOption;
    }

    /**
     * @returns {boolean} Whether the empty option is selected.
     */
    $isEmptyOptionSelected() {
      return (
        this.hasEmptyOption &&
        this.$element.options[this.$element.selectedIndex] === this.emptyOption
      );
    }

    /**
     * Select unknown or empty option depending on the value.
     * @param {*} value
     */
    selectUnknownOrEmptyOption(value) {
      if (isNullOrUndefined(value) && this.emptyOption) {
        this.removeUnknownOption();
        this.selectEmptyOption();
      } else if (this.unknownOption.parentElement) {
        this.updateUnknownOption(value);
      } else {
        this.renderUnknownOption(value);
      }
    }

    /**
     * Schedule a render at the end of the digest cycle.
     */
    scheduleRender() {
      if (this.renderScheduled) return;
      this.renderScheduled = true;
      this.$scope.$postUpdate(() => {
        this.renderScheduled = false;
        this.ngModelCtrl.$render();
      });
    }

    /**
     * Schedule a view value update at the end of the digest cycle.
     * @param {boolean} [renderAfter=false]
     */
    scheduleViewValueUpdate(renderAfter = false) {
      if (this.updateScheduled) return;

      this.updateScheduled = true;

      this.$scope.$postUpdate(() => {
        if (this.$scope.$$destroyed) return;

        this.updateScheduled = false;
        this.ngModelCtrl.$setViewValue(this.readValue());

        if (renderAfter) this.ngModelCtrl.$render();
      });
    }

    /**
     * Register an option with interpolation or dynamic value/text.
     * @param {any} optionScope
     * @param {HTMLOptionElement} optionElement
     * @param {any} optionAttrs
     * @param {Function} [interpolateValueFn]
     * @param {Function} [interpolateTextFn]
     */
    registerOption(
      optionScope,
      optionElement,
      optionAttrs,
      interpolateValueFn,
      interpolateTextFn,
    ) {
      let oldVal;

      let hashedVal;

      if (optionAttrs.$attr.ngValue) {
        optionAttrs.$observe("value", (newVal) => {
          let removal;

          const previouslySelected = optionElement.selected;

          if (isDefined(hashedVal)) {
            this.removeOption(oldVal);
            delete this.selectValueMap[hashedVal];
            removal = true;
          }

          hashedVal = hashKey(newVal);
          oldVal = newVal;
          this.selectValueMap[hashedVal] = newVal;
          this.addOption(newVal, optionElement);
          optionElement.setAttribute("value", hashedVal);

          if (removal && previouslySelected) {
            this.scheduleViewValueUpdate();
          }
        });
      } else if (interpolateValueFn) {
        optionAttrs.$observe("value", (newVal) => {
          this.readValue();
          let removal;

          const previouslySelected = optionElement.selected;

          if (isDefined(oldVal)) {
            this.removeOption(oldVal);
            removal = true;
          }
          oldVal = newVal;
          this.addOption(newVal, optionElement);

          if (removal && previouslySelected) {
            this.scheduleViewValueUpdate();
          }
        });
      } else if (interpolateTextFn) {
        optionScope.value = interpolateTextFn(optionScope);

        if (!optionAttrs.value) {
          optionAttrs.$set("value", optionScope.value);
          this.addOption(optionScope.value, optionElement);
        }

        optionScope.$watch("value", () => {
          const newVal = interpolateTextFn(optionScope);

          if (!optionAttrs.value) {
            optionAttrs.$set("value", newVal);
          }
          const previouslySelected = optionElement.selected;

          if (oldVal !== newVal) {
            this.removeOption(oldVal);
            oldVal = newVal;
          }
          this.addOption(newVal, optionElement);

          if (oldVal && previouslySelected) {
            this.scheduleViewValueUpdate();
          }
        });
      } else {
        this.addOption(optionAttrs.value, optionElement);
      }

      optionAttrs.$observe("disabled", (newVal) => {
        if (newVal === "true" || (newVal && optionElement.selected)) {
          if (this.multiple) {
            this.scheduleViewValueUpdate(true);
          } else {
            this.ngModelCtrl.$setViewValue(null);
            this.ngModelCtrl.$render();
          }
        }
      });

      optionElement.addEventListener("$destroy", () => {
        const currentValue = this.readValue();

        const removeValue = optionAttrs.value;

        this.removeOption(removeValue);
        this.scheduleRender();

        if (
          (this.multiple &&
            currentValue &&
            currentValue.indexOf(removeValue) !== -1) ||
          currentValue === removeValue
        ) {
          this.scheduleViewValueUpdate(true);
        }
      });
    }
  }

  /**
   * @returns {import('../../interface.ts').Directive}
   */
  function selectDirective() {
    return {
      restrict: "E",
      require: ["select", "?ngModel"],
      controller: SelectController,
      priority: 1,
      link: {
        pre: selectPreLink,
        post: selectPostLink,
      },
    };

    function selectPreLink(_scope, element, attr, ctrls) {
      /** @type {SelectController} */
      const selectCtrl = ctrls[0];

      /** @type {import("../model/model.js").NgModelController} */
      const ngModelCtrl = ctrls[1];

      // if ngModel is not defined, we don't need to do anything but set the registerOption
      // function to noop, so options don't get added internally
      if (!ngModelCtrl) {
        selectCtrl.registerOption = () => {
          /* empty */
        };

        return;
      }
      selectCtrl.ngModelCtrl = ngModelCtrl;

      // When the selected item(s) changes we delegate getting the value of the select control
      // to the `readValue` method, which can be changed if the select can have multiple
      // selected values or if the options are being generated by `ngOptions`
      element.addEventListener("change", () => {
        selectCtrl.removeUnknownOption();
        const viewValue = selectCtrl.readValue();

        ngModelCtrl.$setViewValue(viewValue);
      });

      // If the select allows multiple values then we need to modify how we read and write
      // values from and to the control; also what it means for the value to be empty and
      // we have to add an extra watch since ngModel doesn't work well with arrays - it
      // doesn't trigger rendering if only an item in the array changes.
      if (attr.multiple) {
        selectCtrl.multiple = true;

        // Read value now needs to check each option to see if it is selected
        selectCtrl.readValue = function () {
          const array = [];

          /**
           * @type {HTMLCollection}
           */
          const options = element.getElementsByTagName("option");

          Array.from(options).forEach(
            /**
             * @param {HTMLOptionElement} option
             */
            (option) => {
              if (option.selected && !option.disabled) {
                const val = option.value;

                array.push(
                  val in selectCtrl.selectValueMap
                    ? selectCtrl.selectValueMap[val]
                    : val,
                );
              }
            },
          );

          return array;
        };

        // Write value now needs to set the selected property of each matching option
        selectCtrl.writeValue = function (value) {
          /**
           * @type {HTMLCollection}
           */
          const options = element.getElementsByTagName("option");

          Array.from(options).forEach(
            /**
             * @param {HTMLOptionElement} option
             */
            (option) => {
              const shouldBeSelected =
                !!value &&
                (includes(value, option.value) ||
                  includes(value, selectCtrl.selectValueMap[option.value]));

              const currentlySelected = option.selected;

              // Support: IE 9-11 only, Edge 12-15+
              // In IE and Edge adding options to the selection via shift+click/UP/DOWN
              // will de-select already selected options if "selected" on those options was set
              // more than once (i.e. when the options were already selected)
              // So we only modify the selected property if necessary.
              // Note: this behavior cannot be replicated via unit tests because it only shows in the
              // actual user interface.
              if (shouldBeSelected !== currentlySelected) {
                option.selected = shouldBeSelected;
              }
            },
          );
        };

        // we have to do it on each watch since ngModel watches reference, but
        // we need to work of an array, so we need to see if anything was inserted/removed
        let lastView;

        let lastViewRef = NaN;

        if (
          lastViewRef === ngModelCtrl.$viewValue &&
          !equals$1(lastView, ngModelCtrl.$viewValue)
        ) {
          lastView = shallowCopy(ngModelCtrl.$viewValue);
          ngModelCtrl.$render();
        }
        lastViewRef = ngModelCtrl.$viewValue;

        // If we are a multiple select then value is now a collection
        // so the meaning of $isEmpty changes
        ngModelCtrl.$isEmpty = function (value) {
          return !value || value.length === 0;
        };
      }
    }

    function selectPostLink(_scope, _element, _attrs, ctrls) {
      // if ngModel is not defined, we don't need to do anything
      const ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) return;

      const selectCtrl = ctrls[0];

      // We delegate rendering to the `writeValue` method, which can be changed
      // if the select can have multiple selected values or if the options are being
      // generated by `ngOptions`.
      // This must be done in the postLink fn to prevent $render to be called before
      // all nodes have been linked correctly.
      ngModelCtrl.$render = function () {
        selectCtrl.writeValue(ngModelCtrl.$viewValue);
      };
    }
  }

  // The option directive is purely designed to communicate the existence (or lack of)
  // of dynamically created (and destroyed) option elements to their containing select
  // directive via its controller.

  optionDirective.$inject = [$injectTokens._interpolate];
  /**
   * @param {ng.InterpolateService} $interpolate
   * @returns {ng.Directive}
   */
  function optionDirective($interpolate) {
    return {
      restrict: "E",
      priority: 100,
      compile(element, attr) {
        let interpolateValueFn;

        let interpolateTextFn;

        if (isDefined(attr.ngValue)) ; else if (isDefined(attr.value)) {
          // If the value attribute is defined, check if it contains an interpolation
          interpolateValueFn = $interpolate(attr.value, true);
        } else {
          // If the value attribute is not defined then we fall back to the
          // text content of the option element, which may be interpolated
          interpolateTextFn = $interpolate(element.textContent, true);

          if (!interpolateTextFn) {
            attr.$set("value", element.textContent);
          }
        }

        return function (scope, elemParam, attrParam) {
          // This is an optimization over using ^^ since we don't want to have to search
          // all the way to the root of the DOM for every single option element
          const selectCtrlName = "$selectController";

          const parent = elemParam.parentElement;

          const selectCtrl =
            getCacheData(parent, selectCtrlName) ||
            getCacheData(parent.parentElement, selectCtrlName); // in case we are in optgroup

          if (selectCtrl) {
            selectCtrl.registerOption(
              scope,
              elemParam,
              attrParam,
              interpolateValueFn,
              interpolateTextFn,
            );
          }
        };
      },
    };
  }

  /**
   * @returns {ng.Directive}
   */
  function ngBindDirective() {
    return {
      /**
       * @param {ng.Scope} scope
       * @param {Element} element
       * @param {ng.Attributes} attr
       */
      link(scope, element, attr) {
        scope.$watch(
          attr.ngBind,
          (value) => {
            element.textContent = stringify$1(deProxy(value));
          },
          isDefined(attr.lazy),
        );
      },
    };
  }

  /**
   * @returns {import('../../interface.ts').Directive}
   */
  function ngBindTemplateDirective() {
    return {
      /**
       * @param {ng.Scope} _scope
       * @param {Element} element
       * @param {import('../../core/compile/attributes.js').Attributes} attr
       */
      link(_scope, element, attr) {
        attr.$observe("ngBindTemplate", (value) => {
          element.textContent = isUndefined(value) ? "" : value;
        });
      },
    };
  }

  ngBindHtmlDirective.$inject = [$injectTokens._parse];
  /**
   * @param {import('../../core/parse/interface.ts').ParseService} $parse
   * @returns {import('../../interface.ts').Directive}
   */
  function ngBindHtmlDirective($parse) {
    return {
      restrict: "A",
      compile(_tElement, tAttrs) {
        $parse(tAttrs.ngBindHtml); // checks for interpolation errors

        return (
          /**
           * @param {ng.Scope} scope
           * @param {Element} element
           */
          (scope, element) => {
            scope.$watch(tAttrs.ngBindHtml, (val) => {
              if (isUndefined(val) || isNull(val)) {
                val = "";
              }
              element.innerHTML = val;
            });
          }
        );
      },
    };
  }

  /**
   * @param {string} name
   * @param {boolean|number} selector
   * @returns {ng.DirectiveFactory}
   */
  function classDirective(name, selector) {
    name = `ngClass${name}`;

    /**
     * @returns {ng.Directive}
     */
    return function () {
      return {
        /**
         * @param {ng.Scope} scope
         * @param {HTMLElement} element
         * @param {ng.Attributes} attr
         */
        link(scope, element, attr) {
          let classCounts = getCacheData(element, "$classCounts");

          let oldModulo = true;

          /** @type {string|undefined} */
          let oldClassString;

          if (!classCounts) {
            // Use Object.create(null) to prevent class assumptions involving property
            // names in Object.prototype
            classCounts = Object.create(null);
            setCacheData(element, "$classCounts", classCounts);
          }

          if (name !== "ngClass") {
            scope.$watch("$index", () => {
              ngClassIndexWatchAction(scope.$index & 1);
            });
          }
          scope.$watch(attr[name], (val) => {
            ngClassWatchAction(toClassString(val));
          });

          /**
           * @param {string} classString
           */
          function addClasses(classString) {
            classString = digestClassCounts(split(classString), 1);

            if (hasAnimate(element)) {
              attr.$addClass(classString);
            } else {
              scope.$postUpdate(() => {
                if (classString !== "") {
                  element.classList.add(...classString.trim().split(" "));
                }
              });
            }
          }

          /**
           * @param {string} classString
           */
          function removeClasses(classString) {
            classString = digestClassCounts(split(classString), -1);

            if (hasAnimate(element)) {
              attr.$removeClass(classString);
            } else {
              scope.$postUpdate(() => {
                if (classString !== "") {
                  element.classList.remove(...classString.trim().split(" "));
                }
              });
            }
          }

          /**
           * @param {string} oldClassStringParam
           * @param {string} newClassStringParam
           */
          function updateClasses(oldClassStringParam, newClassStringParam) {
            const oldClassArray = split(oldClassStringParam);

            const newClassArray = split(newClassStringParam);

            const toRemoveArray = arrayDifference(oldClassArray, newClassArray);

            const toAddArray = arrayDifference(newClassArray, oldClassArray);

            const toRemoveString = digestClassCounts(toRemoveArray, -1);

            const toAddString = digestClassCounts(toAddArray, 1);

            if (hasAnimate(element)) {
              attr.$addClass(toAddString);
              attr.$removeClass(toRemoveString);
            } else {
              if (toAddString !== "") {
                element.classList.add(...toAddString.trim().split(" "));
              }

              if (toRemoveString !== "") {
                element.classList.remove(...toRemoveString.trim().split(" "));
              }
            }
          }

          function digestClassCounts(classArray, count) {
            const classesToUpdate = [];

            if (classArray) {
              classArray.forEach((className) => {
                if (count > 0 || classCounts[className]) {
                  classCounts[className] = (classCounts[className] || 0) + count;

                  if (classCounts[className] === +(count > 0)) {
                    classesToUpdate.push(className);
                  }
                }
              });
            }

            return classesToUpdate.join(" ");
          }

          function ngClassIndexWatchAction(newModulo) {
            // This watch-action should run before the `ngClassWatchAction()`, thus it
            // adds/removes `oldClassString`. If the `ngClass` expression has changed as well, the
            // `ngClassWatchAction()` will update the classes.
            if (newModulo === selector) {
              addClasses(oldClassString);
            } else {
              removeClasses(oldClassString);
            }

            oldModulo = newModulo;
          }

          /**
           * @param {string} newClassString
           */
          function ngClassWatchAction(newClassString) {
            if (oldModulo === selector) {
              updateClasses(oldClassString, newClassString);
            }

            oldClassString = newClassString;
          }
        },
      };
    };
  }

  // Helpers
  function arrayDifference(tokens1, tokens2) {
    if (!tokens1 || !tokens1.length) return [];

    if (!tokens2 || !tokens2.length) return tokens1;

    const values = [];

    outer: for (let i = 0; i < tokens1.length; i++) {
      const token = tokens1[i];

      for (let j = 0; j < tokens2.length; j++) {
        if (token === tokens2[j]) continue outer;
      }
      values.push(token);
    }

    return values;
  }

  function split(classString) {
    return classString && classString.split(" ");
  }

  function toClassString(classValue) {
    if (!classValue) return classValue;

    let classString = classValue;

    if (isArray(classValue)) {
      classString = classValue.map(toClassString).join(" ");
    } else if (isObject(classValue)) {
      classString = keys(classValue)
        .filter((key) => classValue[key])
        .join(" ");
    } else if (!isString(classValue)) {
      classString = `${classValue}`;
    }

    return classString;
  }

  const ngClassDirective = classDirective("", true);
  const ngClassOddDirective = classDirective("Odd", 0);
  const ngClassEvenDirective = classDirective("Even", 1);

  /**
   * @returns {ng.Directive}
   */
  function ngCloakDirective() {
    return {
      compile(_, attr) {
        attr.$set("ngCloak", null);
      },
    };
  }

  /**
   * @returns {ng.Directive}
   */
  function ngControllerDirective() {
    return {
      restrict: "A",
      scope: true,
      controller: "@",
      priority: 500,
    };
  }

  const NG_HIDE_CLASS = "ng-hide";

  const NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate";

  ngShowDirective.$inject = [$injectTokens._animate];
  /**
   * @param {ng.AnimateService} $animate
   * @returns {ng.Directive}
   */
  function ngShowDirective($animate) {
    return {
      restrict: "A",
      /**
       * @param scope
       * @param {Element} element
       * @param $attr
       */
      link(scope, element, $attr) {
        scope.$watch($attr.ngShow, (value) => {
          // we're adding a temporary, animation-specific class for ng-hide since this way
          // we can control when the element is actually displayed on screen without having
          // to have a global/greedy CSS selector that breaks when other animations are run.
          // Read: https://github.com/angular/angular.js/issues/9103#issuecomment-58335845
          if (hasAnimate(element)) {
            $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
              tempClasses: NG_HIDE_IN_PROGRESS_CLASS,
            });
          } else {
            if (value) {
              element.classList.remove(NG_HIDE_CLASS);
            } else {
              element.classList.add(NG_HIDE_CLASS);
            }
          }
        });
      },
    };
  }

  ngHideDirective.$inject = [$injectTokens._animate];
  /**
   * @returns {import('../../interface.ts').Directive}
   */
  function ngHideDirective($animate) {
    return {
      restrict: "A",
      link(scope, element, attr) {
        scope.$watch(attr.ngHide, (value) => {
          // The comment inside of the ngShowDirective explains why we add and
          // remove a temporary class for the show/hide animation
          if (hasAnimate(element)) {
            $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
              tempClasses: NG_HIDE_IN_PROGRESS_CLASS,
            });
          } else {
            if (value) {
              element.classList.add(NG_HIDE_CLASS);
            } else {
              element.classList.remove(NG_HIDE_CLASS);
            }
          }
        });
      },
    };
  }

  ngIfDirective.$inject = [$injectTokens._animate];
  /**
   * @param {ng.AnimateService} $animate
   * @returns {ng.Directive}
   */
  function ngIfDirective($animate) {
    return {
      transclude: "element",
      priority: 600,
      terminal: true,
      restrict: "A",
      /**
       *
       * @param {ng.Scope} $scope
       * @param {Element} $element
       * @param {ng.Attributes} $attr
       * @param {*} _ctrl
       * @param {*} $transclude
       */
      link($scope, $element, $attr, _ctrl, $transclude) {
        /** @type {Element | null | undefined} */
        let block;

        /** @type {ng.Scope | null} */
        let childScope;

        /** @type {Element | null | undefined} */
        let previousElements;

        $scope.$watch($attr.ngIf, (value) => {
          if (value) {
            if (!childScope) {
              $transclude((clone, newScope) => {
                childScope = newScope;
                // Note: We only need the first/last node of the cloned nodes.
                // However, we need to keep the reference to the dom wrapper as it might be changed later
                // by a directive with templateUrl when its template arrives.
                block = clone;

                if (hasAnimate(clone)) {
                  $animate.enter(
                    clone,
                    /** @type {Element} */ ($element.parentElement),
                    $element,
                  );
                } else {
                  $element.after(clone);
                }
              });
            }
          } else {
            if (previousElements) {
              removeElement(previousElements);
              previousElements = null;
            }

            if (childScope) {
              childScope.$destroy();
              childScope = null;
            }

            if (block) {
              previousElements = block;

              if (hasAnimate(previousElements)) {
                $animate.leave(previousElements).done((response) => {
                  if (response !== false) previousElements = null;
                });
              } else {
                $element.nextElementSibling?.remove();
              }
              block = null;
            }
          }
        });
      },
    };
  }

  ngIncludeDirective.$inject = [
    $injectTokens._templateRequest,
    $injectTokens._anchorScroll,
    $injectTokens._animate,
    $injectTokens._exceptionHandler,
  ];

  /**
   *
   * @param {ng.TemplateRequestService} $templateRequest
   * @param {ng.AnchorScrollService} $anchorScroll
   * @param {ng.AnimateService} $animate
   * @param {ng.ExceptionHandlerService} $exceptionHandler
   * @returns {ng.Directive}
   */
  function ngIncludeDirective(
    $templateRequest,
    $anchorScroll,
    $animate,
    $exceptionHandler,
  ) {
    return {
      priority: 400,
      terminal: true,
      transclude: "element",
      controller: () => {
        /* empty */
      },
      compile(_element, attr) {
        const srcExp = attr.ngInclude || attr.src;

        const onloadExp = attr.onload || "";

        const autoScrollExp = attr.autoscroll;

        return (scope, $element, _$attr, ctrl, $transclude) => {
          function maybeScroll() {
            if (
              isDefined(autoScrollExp) &&
              (!autoScrollExp || scope.$eval(autoScrollExp))
            ) {
              /** @type {ng.AnchorScrollFunction} */ ($anchorScroll)();
            }
          }

          let changeCounter = 0;

          let currentScope;

          let previousElement;

          let currentElement;

          const cleanupLastIncludeContent = () => {
            if (previousElement) {
              previousElement.remove();
              previousElement = null;
            }

            if (currentScope) {
              currentScope.$destroy();
              currentScope = null;
            }

            if (currentElement) {
              if (hasAnimate(currentElement)) {
                $animate.leave(currentElement).done((response) => {
                  if (response !== false) previousElement = null;
                });
              } else {
                currentElement.remove();
              }

              previousElement = currentElement;
              currentElement = null;
            }
          };

          scope.$watch(srcExp, async (src) => {
            const afterAnimation = function (response) {
              response !== false && maybeScroll();
            };

            const thisChangeId = ++changeCounter;

            if (src) {
              // set the 2nd param to true to ignore the template request error so that the inner
              // contents and scope can be cleaned up.
              await $templateRequest(src, true).then(
                (response) => {
                  if (scope.$$destroyed) return;

                  if (thisChangeId !== changeCounter) return;
                  const newScope = scope.$new();

                  ctrl.template = response;

                  // Note: This will also link all children of ng-include that were contained in the original
                  // html. If that content contains controllers, ... they could pollute/change the scope.
                  // However, using ng-include on an element with additional content does not make sense...
                  // Note: We can't remove them in the cloneAttchFn of $transclude as that
                  // function is called before linking the content, which would apply child
                  // directives to non existing elements.
                  const clone = $transclude(newScope, (cloneParam) => {
                    cleanupLastIncludeContent();

                    if (hasAnimate(cloneParam)) {
                      $animate
                        .enter(cloneParam, null, $element)
                        .done(afterAnimation);
                    } else {
                      $element.after(cloneParam);
                      maybeScroll();
                    }
                  });

                  currentScope = newScope;
                  currentElement = clone;
                  currentScope.$emit("$includeContentLoaded", src);
                  scope.$eval(onloadExp);
                },
                (err) => {
                  if (scope.$$destroyed) return;

                  if (thisChangeId === changeCounter) {
                    cleanupLastIncludeContent();
                    scope.$emit("$includeContentError", src);
                  }
                  $exceptionHandler(new Error(err));
                },
              );
              scope.$emit("$includeContentRequested", src);
            } else {
              cleanupLastIncludeContent();
              ctrl.template = null;
            }
          });
        };
      },
    };
  }

  // This directive is called during the $transclude call of the first `ngInclude` directive.
  // It will replace and compile the content of the element with the loaded template.
  // We need this directive so that the element content is already filled when
  // the link function of another directive on the same element as ngInclude
  // is called.
  ngIncludeFillContentDirective.$inject = [$injectTokens._compile];

  /**
   * @param {ng.CompileService} $compile
   * @returns {ng.Directive}
   */
  function ngIncludeFillContentDirective($compile) {
    return {
      priority: -400,
      require: "ngInclude",
      link(scope, $element, _$attr, ctrl) {
        $element.innerHTML = ctrl.template;
        $compile($element.childNodes)(scope);
      },
    };
  }

  /**
   * @returns {import('../../interface.ts').Directive}
   */
  function ngInitDirective() {
    return {
      priority: 450,
      compile() {
        return {
          pre(scope, element, attrs) {
            const controller = getController(element);

            if (controller) {
              controller.$eval(attrs.ngInit);
            } else {
              scope.$eval(attrs.ngInit);
            }
          },
        };
      },
    };
  }

  /**
   * @returns {import('../../interface.ts').Directive}
   */
  function ngNonBindableDirective() {
    return {
      terminal: true,
      priority: 1000,
    };
  }

  /**
   * The `ngRef` attribute tells AngularTS to assign the controller of a component (or a directive)
   * to the given property in the current scope.
   *
   * If the element with `ngRef` is destroyed `null` is assigned to the property.
   *
   * Note that if you want to assign from a child into the parent scope, you must initialize the
   * target property on the parent scope, otherwise `ngRef` will assign on the child scope.
   * This commonly happens when assigning elements or components wrapped in {@link ngIf} or
   * {@link ngRepeat}. See the second example below.
   *
   *
   * @element ANY
   * @param {string} ngRef property name - A valid AngularTS expression identifier to which the
   *                       controller or dom-wrapped DOM element will be bound.
   * @param {string=} ngRefRead read value - The name of a directive (or component) on this element,
   *                            or the special string `$element`. If a name is provided, `ngRef` will
   *                            assign the matching controller. If `$element` is provided, the element
   *                            itself is assigned (even if a controller is available).
   */

  const ngRefMinErr = minErr("ngRef");

  ngRefDirective.$inject = [$injectTokens._parse];

  /**
   * @param {ng.ParseService} $parse
   * @return {ng.Directive}
   */
  function ngRefDirective($parse) {
    return {
      priority: -1, // Needed for compatibility with element transclusion on the same element
      restrict: "A",
      compile(tElement, tAttrs) {
        // Get the expected controller name, converts <data-some-thing> into "someThing"
        const controllerName = directiveNormalize(getNodeName(tElement));

        // Get the expression for value binding
        const getter = $parse(tAttrs.ngRef);

        const setter =
          getter.assign ||
          function () {
            throw ngRefMinErr(
              "nonassign",
              'Expression in ngRef="{0}" is non-assignable!',
              tAttrs.ngRef,
            );
          };

        return (scope, element, attrs) => {
          let refValue;

          if (hasOwn(attrs, "ngRefRead")) {
            if (attrs.ngRefRead === "$element") {
              refValue = element;
            } else {
              refValue = getCacheData(element, `$${attrs.ngRefRead}Controller`);

              if (!refValue) {
                throw ngRefMinErr(
                  "noctrl",
                  'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"',
                  attrs.ngRefRead,
                  tAttrs.ngRef,
                );
              }
            }
          } else {
            refValue = getCacheData(element, `$${controllerName}Controller`);
          }

          refValue = refValue || element;

          setter(scope, refValue);

          // when the element is removed, remove it (nullify it)
          element.addEventListener("$destroy", () => {
            // only remove it if value has not changed,
            // because animations (and other procedures) may duplicate elements
            if (getter(scope) === refValue) {
              setter(scope, null);
            }
          });
        };
      },
    };
  }

  const NG_REMOVED = "$$NG_REMOVED";

  const ngRepeatMinErr = minErr("ngRepeat");

  /**
   * Regular expression to match either:
   * 1. A single variable name (optionally preceded by whitespace), e.g. "foo", "   $bar"
   * 2. A pair of variable names inside parentheses separated by a comma (with optional whitespace), e.g. "(x, y)", "($foo, _bar123)"
   *
   * Capturing groups:
   * - Group 1: The single variable name (if present)
   * - Group 2: The first variable in the tuple (if present)
   * - Group 3: The second variable in the tuple (if present)
   *
   * Examples:
   *  - Matches: "foo", "   $var", "(x, y)", "($a, $b)"
   *  - Does NOT match: "x,y", "(x)", "(x y)", ""
   *
   * @constant {RegExp}
   */
  const VAR_OR_TUPLE_REGEX =
    /^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/;

  ngRepeatDirective.$inject = [$injectTokens._animate];

  /**
   * TODO // Add type for animate service
   * @param {*}  $animate
   * @returns {ng.Directive}
   */
  function ngRepeatDirective($animate) {
    function updateScope(
      scope,
      index,
      valueIdentifier,
      value,
      keyIdentifier,
      key,
      arrayLength,
    ) {
      // TODO(perf): generate setters to shave off ~40ms or 1-1.5%
      if (scope[valueIdentifier] !== value) {
        scope[valueIdentifier] = value;
      }

      if (keyIdentifier) scope[keyIdentifier] = key;

      if (value) {
        scope.$target.$$hashKey = value.$$hashKey;
      }
      scope.$index = index;
      scope.$first = index === 0;
      scope.$last = index === arrayLength - 1;
      scope.$middle = !(scope.$first || scope.$last);
      scope.$odd = !(scope.$even = (index & 1) === 0);
    }

    function getBlockStart(block) {
      return block.clone;
    }

    function getBlockEnd(block) {
      return block.clone;
    }

    function trackByIdArrayFn(_$scope, _key, value) {
      return hashKey(value);
    }

    function trackByIdObjFn(_$scope, key) {
      return key;
    }

    return {
      restrict: "A",
      transclude: "element",
      priority: 1000,
      terminal: true,
      compile: (_$element, $attr) => {
        const expression = $attr.ngRepeat;

        const hasAnimate = !!$attr.animate;

        let match = expression.match(
          /^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/,
        );

        if (!match) {
          throw ngRepeatMinErr(
            "iexp",
            "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.",
            expression,
          );
        }

        const lhs = match[1];

        const rhs = match[2];

        const aliasAs = match[3];

        match = lhs.match(VAR_OR_TUPLE_REGEX);

        if (!match) {
          throw ngRepeatMinErr(
            "iidexp",
            "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.",
            lhs,
          );
        }
        const valueIdentifier = match[3] || match[1];

        const keyIdentifier = match[2];

        if (
          aliasAs &&
          (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) ||
            /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(
              aliasAs,
            ))
        ) {
          throw ngRepeatMinErr(
            "badident",
            "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.",
            aliasAs,
          );
        }

        const swap = callBackOnce(() => {
          if (isDefined($attr.lazy) && isDefined($attr.swap)) {
            document
              .querySelectorAll($attr.swap)
              .forEach((x) => removeElement(x));
          }
        });

        return function ngRepeatLink($scope, $element, attr, ctrl, $transclude) {
          // Store a list of elements from previous run. This is a hash where key is the item from the
          // iterator, and the value is objects with following properties.
          //   - scope: bound scope
          //   - clone: previous element.
          //   - index: position
          //
          // We are using no-proto object so that we don't need to guard against inherited props via
          // hasOwnProperty.
          let lastBlockMap = Object.create(null);

          // watch props
          $scope.$watch(
            rhs,
            (collection) => {
              swap();
              let index,
                previousNode = $element, // node that cloned nodes should be inserted after
                // initialized to the comment node anchor
                nextNode;

              const // Same as lastBlockMap but it has the current state. It will become the
                // lastBlockMap on the next iteration.
                nextBlockMap = Object.create(null);

              let key,
                value, // key/value of iteration
                trackById,
                trackByIdFn,
                collectionKeys,
                block, // last object information {scope, element, id}
                elementsToRemove;

              if (aliasAs) {
                $scope[aliasAs] = collection;
              }

              if (isArrayLike(collection)) {
                collectionKeys = collection;
                trackByIdFn = trackByIdArrayFn;
              } else {
                trackByIdFn = trackByIdObjFn;
                // if object, extract keys, in enumeration order, unsorted
                collectionKeys = [];

                for (const itemKey in collection) {
                  if (hasOwn(collection, itemKey) && itemKey.charAt(0) !== "$") {
                    collectionKeys.push(itemKey);
                  }
                }
              }

              const collectionLength = collectionKeys.length;

              const nextBlockOrder = new Array(collectionLength);

              // locate existing items
              for (index = 0; index < collectionLength; index++) {
                key =
                  collection === collectionKeys ? index : collectionKeys[index];
                value = collection[key];
                trackById = trackByIdFn($scope, key, value);

                if (lastBlockMap[trackById]) {
                  // found previously seen block
                  block = lastBlockMap[trackById];
                  delete lastBlockMap[trackById];
                  nextBlockMap[trackById] = block;
                  nextBlockOrder[index] = block;
                } else if (nextBlockMap[trackById]) {
                  // if collision detected. restore lastBlockMap and throw an error
                  Object.values(nextBlockOrder).forEach((x) => {
                    if (x && x.scope) lastBlockMap[x.id] = block;
                  });
                  throw ngRepeatMinErr(
                    "dupes",
                    "Duplicates keys in a repeater are not allowed. Repeater: {0}, Duplicate key: {1} for value: {2}",
                    expression,
                    trackById,
                    value,
                  );
                } else {
                  // new never before seen block
                  nextBlockOrder[index] = {
                    id: trackById,
                    scope: undefined,
                    clone: undefined,
                  };
                  nextBlockMap[trackById] = true;
                }
              }

              // remove leftover items
              for (const blockKey in lastBlockMap) {
                block = lastBlockMap[blockKey];
                elementsToRemove = block.clone;

                if (hasAnimate) {
                  $animate.leave(elementsToRemove);
                } else {
                  elementsToRemove.remove();
                }

                if (elementsToRemove.parentNode) {
                  // if the element was not removed yet because of pending animation, mark it as deleted
                  // so that we can ignore it later
                  for (let i = 0, j = elementsToRemove.length; i < j; i++) {
                    elementsToRemove[i][NG_REMOVED] = true;
                  }
                }
                block.scope.$destroy();
              }

              for (index = 0; index < collectionLength; index++) {
                key =
                  collection === collectionKeys ? index : collectionKeys[index];
                value = collection[key];
                block = nextBlockOrder[index];

                if (block.scope) {
                  // if we have already seen this object, then we need to reuse the
                  // associated scope/element

                  nextNode = previousNode;

                  // skip nodes that are already pending removal via leave animation
                  do {
                    nextNode = nextNode.nextSibling;
                  } while (nextNode && nextNode[NG_REMOVED]);

                  if (getBlockStart(block) !== nextNode) {
                    // existing item which got moved
                    $animate.move(getBlockNodes(block.clone), null, previousNode);
                  }
                  previousNode = getBlockEnd(block);
                  updateScope(
                    block.scope,
                    index,
                    valueIdentifier,
                    value,
                    keyIdentifier,
                    key,
                    collectionLength,
                  );
                } else {
                  // new item which we don't know about
                  $transclude(
                    /**
                     * Clone attach function
                     * @param {Array<NodeList>} clone
                     * @param {ng.Scope} scope
                     */

                    (clone, scope) => {
                      block.scope = scope;
                      const endNode = clone;

                      if (hasAnimate) {
                        $animate.enter(clone, null, previousNode);
                      } else {
                        // @ts-ignore
                        previousNode.after(clone);
                      }

                      // @ts-ignore
                      previousNode = endNode;
                      // Note: We only need the first/last node of the cloned nodes.
                      // However, we need to keep the reference to the dom wrapper as it might be changed later
                      // by a directive with templateUrl when its template arrives.
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(
                        block.scope,
                        index,
                        valueIdentifier,
                        value,
                        keyIdentifier,
                        key,
                        collectionLength,
                      );
                    },
                  );
                }
              }
              lastBlockMap = nextBlockMap;
            },
            isDefined(attr.lazy),
          );
        };
      },
    };
  }

  /**
   * @returns {ng.Directive}
   */
  function ngStyleDirective() {
    return {
      restrict: "A",
      link(scope, element, attr) {
        let oldStyles = null;

        scope.$watch(attr.ngStyle, (newStyles) => {
          const target = newStyles?.$target || newStyles;

          if (oldStyles) {
            for (const key in oldStyles) {
              element.style.removeProperty(key);
            }
          }

          if (target) {
            oldStyles = {};

            for (const key in target) {
              const value = target[key];

              element.style.setProperty(key, value);
              oldStyles[key] = value;
            }
          } else {
            oldStyles = null;
          }
        });
      },
    };
  }

  ngSwitchDirective.$inject = [$injectTokens._animate];

  /**
   * @param {ng.AnimateService} $animate
   * @returns {ng.Directive}
   */
  function ngSwitchDirective($animate) {
    return {
      require: "ngSwitch",

      // asks for $scope to fool the BC controller module
      controller: [
        "$scope",
        class {
          constructor() {
            this.cases = {};
          }
        },
      ],
      link(scope, _element, attr, ngSwitchController) {
        const watchExpr = attr.ngSwitch || attr.on;

        let selectedTranscludes = [];

        const selectedElements = [];

        const previousLeaveAnimations = [];

        const selectedScopes = [];

        const spliceFactory = function (array, index) {
          return function (response) {
            if (response !== false) array.splice(index, 1);
          };
        };

        scope.$watch(watchExpr, (value) => {
          let i;

          let ii;

          // Start with the last, in case the array is modified during the loop
          while (previousLeaveAnimations.length) {
            $animate.cancel(previousLeaveAnimations.pop());
          }

          for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
            const selected = getBlockNodes(selectedElements[i].clone);

            selectedScopes[i].$destroy();

            if (hasAnimate(selected)) {
              const runner = (previousLeaveAnimations[i] =
                $animate.leave(selected));

              runner.done(spliceFactory(previousLeaveAnimations, i));
            } else {
              selected.remove();
            }
          }

          selectedElements.length = 0;
          selectedScopes.length = 0;

          if (
            (selectedTranscludes =
              ngSwitchController.cases[`!${value}`] ||
              ngSwitchController.cases["?"])
          ) {
            Object.values(selectedTranscludes).forEach((selectedTransclude) => {
              selectedTransclude.transclude((caseElement, selectedScope) => {
                selectedScopes.push(selectedScope);
                const anchor = selectedTransclude.element;

                // TODO removing this breaks repeater test
                const block = {
                  clone: caseElement,
                  comment: document.createComment(""),
                };

                selectedElements.push(block);

                if (hasAnimate(caseElement)) {
                  $animate.enter(caseElement, anchor.parentElement, anchor);
                } else {
                  domInsert(caseElement, anchor.parentElement, anchor);
                }
              });
            });
          }
        });
      },
    };
  }

  /**
   * @returns {import('../../interface.ts').Directive}
   */
  function ngSwitchWhenDirective() {
    return {
      transclude: "element",
      terminal: true,
      priority: 1200,

      require: "^ngSwitch",
      link(scope, element, attrs, ctrl, $transclude) {
        const cases = attrs.ngSwitchWhen
          .split(attrs.ngSwitchWhenSeparator)
          .sort()
          .filter(
            // Filter duplicate cases
            (elementParam, index, array) => array[index - 1] !== elementParam,
          );

        cases.forEach((whenCase) => {
          ctrl.cases[`!${whenCase}`] = ctrl.cases[`!${whenCase}`] || [];
          ctrl.cases[`!${whenCase}`].push({
            transclude: $transclude,
            element,
          });
        });
      },
    };
  }

  /**
   * @returns {import('../../interface.ts').Directive}
   */
  function ngSwitchDefaultDirective() {
    return {
      transclude: "element",
      terminal: true,
      priority: 1200,
      require: "^ngSwitch",
      link(_scope, element, _attr, ctrl, $transclude) {
        ctrl.cases["?"] = ctrl.cases["?"] || [];
        ctrl.cases["?"].push({ transclude: $transclude, element });
      },
    };
  }

  const ngOptionsMinErr = minErr("ngOptions");

  /** @type {HTMLOptionElement} */
  const optionTemplate = document.createElement("option");

  /** @type {HTMLOptGroupElement} */
  const optGroupTemplate = document.createElement("optgroup");

  const NG_OPTIONS_REGEXP =
    /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;

  // 1: value expression (valueFn)
  // 2: label expression (displayFn)
  // 3: group by expression (groupByFn)
  // 4: disable when expression (disableWhenFn)
  // 5: array item variable name
  // 6: object item key variable name
  // 7: object item value variable name
  // 8: collection expression
  // 9: track by expression

  ngOptionsDirective.$inject = [$injectTokens._compile, $injectTokens._parse];
  /**
   *
   * @param {ng.CompileService} $compile
   * @param {ng.ParseService} $parse
   * @returns {ng.Directive}
   */
  function ngOptionsDirective($compile, $parse) {
    /**
     * @param {import('../../interface.ts').Expression} optionsExp
     * @param {HTMLSelectElement} selectElement
     * @param {ng.Scope} scope
     * @returns
     */
    function parseOptionsExpression(optionsExp, selectElement, scope) {
      const match = optionsExp.match(NG_OPTIONS_REGEXP);

      if (!match) {
        throw ngOptionsMinErr(
          "iexp",
          "Expected expression in form of " +
            "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
            " but got '{0}'. Element: {1}",
          optionsExp,
          startingTag(selectElement),
        );
      }
      // Extract the parts from the ngOptions expression

      // The variable name for the value of the item in the collection
      const valueName = match[5] || match[7];

      // The variable name for the key of the item in the collection
      const keyName = match[6];

      // An expression that generates the viewValue for an option if there is a label expression
      const selectAs = / as /.test(match[0]) && match[1];

      // An expression that is used to track the id of each object in the options collection
      const trackBy = match[9];

      // An expression that generates the viewValue for an option if there is no label expression
      const valueFn = $parse(match[2] ? match[1] : valueName);

      const selectAsFn = selectAs && $parse(selectAs);

      const viewValueFn = selectAsFn || valueFn;

      const trackByFn = trackBy && $parse(trackBy);

      // Get the value by which we are going to track the option
      // if we have a trackFn then use that (passing scope and locals)
      // otherwise just hash the given viewValue
      const getTrackByValueFn = trackBy
        ? function (value, locals) {
            return trackByFn(scope, locals);
          }
        : function getHashOfValue(value) {
            return hashKey(value);
          };

      const getTrackByValue = function (value, key) {
        return getTrackByValueFn(value, getLocals(value, key));
      };

      const displayFn = $parse(match[2] || match[1]);

      const groupByFn = $parse(match[3] || "");

      const disableWhenFn = $parse(match[4] || "");

      const valuesFn = $parse(match[8]);

      const locals = {};

      const getLocals = keyName
        ? function (value, key) {
            locals[keyName] = key;
            locals[valueName] = value;

            return locals;
          }
        : function (value) {
            locals[valueName] = value;

            return locals;
          };

      class Option {
        constructor(selectValue, viewValue, label, group, disabled) {
          this.selectValue = selectValue;
          this.viewValue = viewValue;
          this.label = label;
          this.group = group;
          this.disabled = disabled;
        }
      }

      function getOptionValuesKeys(optionValues) {
        let optionValuesKeys;

        if (!keyName && isArrayLike(optionValues)) {
          optionValuesKeys = optionValues;
        } else {
          // if object, extract keys, in enumeration order, unsorted
          optionValuesKeys = [];

          for (const itemKey in optionValues) {
            if (hasOwn(optionValues, itemKey) && itemKey.charAt(0) !== "$") {
              optionValuesKeys.push(itemKey);
            }
          }
        }

        return optionValuesKeys;
      }

      return {
        trackBy,
        getTrackByValue,
        getWatchables: $parse(valuesFn, (optionValues) => {
          // Create a collection of things that we would like to watch (watchedArray)
          // so that they can all be watched using a single $watchCollection
          // that only runs the handler once if anything changes
          const watchedArray = [];

          optionValues = optionValues || [];

          const optionValuesKeys = getOptionValuesKeys(optionValues);

          const optionValuesLength = optionValuesKeys.length;

          for (let index = 0; index < optionValuesLength; index++) {
            const key =
              optionValues === optionValuesKeys ? index : optionValuesKeys[index];

            const value = optionValues[key];

            const updatedLocals = getLocals(value, key);

            const selectValue = getTrackByValueFn(value, updatedLocals);

            watchedArray.push(selectValue);

            // Only need to watch the displayFn if there is a specific label expression
            if (match[2] || match[1]) {
              const label = displayFn(scope, updatedLocals);

              watchedArray.push(label);
            }

            // Only need to watch the disableWhenFn if there is a specific disable expression
            if (match[4]) {
              const disableWhen = disableWhenFn(scope, updatedLocals);

              watchedArray.push(disableWhen);
            }
          }

          return watchedArray;
        }),

        getOptions() {
          /** @type {Option[]} */
          const optionItems = [];

          /** @type {Object.<string, Option>} */
          const selectValueMap = {};

          // The option values were already computed in the `getWatchables` fn,
          // which must have been called to trigger `getOptions`
          const optionValues = valuesFn(scope) || [];

          const optionValuesKeys = getOptionValuesKeys(optionValues);

          const optionValuesLength = optionValuesKeys.length;

          for (let index = 0; index < optionValuesLength; index++) {
            const key =
              optionValues === optionValuesKeys ? index : optionValuesKeys[index];

            const value = optionValues[key];

            const updatedLocals = getLocals(value, key);

            const viewValue = viewValueFn(scope, updatedLocals);

            const selectValue = getTrackByValueFn(viewValue, updatedLocals);

            const label = displayFn(scope, updatedLocals);

            const group = groupByFn(scope, updatedLocals);

            const disabled = disableWhenFn(scope, updatedLocals);

            const optionItem = new Option(
              selectValue,
              viewValue,
              label,
              group,
              disabled,
            );

            optionItems.push(optionItem);
            selectValueMap[selectValue] = optionItem;
          }

          return {
            items: optionItems,
            selectValueMap,
            getOptionFromViewValue(value) {
              return selectValueMap[getTrackByValue(value)];
            },
            getViewValueFromOption(option) {
              // If the viewValue could be an object that may be mutated by the application,
              // we need to make a copy and not return the reference to the value on the option.
              return trackBy
                ? structuredClone(option.viewValue)
                : option.viewValue;
            },
          };
        },
      };
    }

    /**
     *
     * @param {ng.Scope} scope
     * @param {HTMLSelectElement} selectElement
     * @param {ng.Attributes} attr
     * @param {*} ctrls
     */
    function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
      const selectCtrl = ctrls[0];

      const ngModelCtrl = ctrls[1];

      const { multiple } = attr;

      // The emptyOption allows the application developer to provide their own custom "empty"
      // option when the viewValue does not match any of the option values.
      for (
        let i = 0, children = selectElement.childNodes, ii = children.length;
        i < ii;
        i++
      ) {
        if (/** @type {HTMLOptionElement} */ (children[i]).value === "") {
          selectCtrl.hasEmptyOption = true;
          selectCtrl.emptyOption = children[i];
          break;
        }
      }

      // The empty option will be compiled and rendered before we first generate the options
      emptyElement(selectElement);

      const providedEmptyOption = !!selectCtrl.emptyOption;

      const unknownOption = optionTemplate.cloneNode(false);

      // TODO double check
      unknownOption.nodeValue = "?";

      let options;

      const ngOptions = parseOptionsExpression(
        attr.ngOptions,
        selectElement,
        scope,
      );

      // This stores the newly created options before they are appended to the select.
      // Since the contents are removed from the fragment when it is appended,
      // we only need to create it once.
      const listFragment = document.createDocumentFragment();

      // Overwrite the implementation. ngOptions doesn't use hashes
      selectCtrl.generateUnknownOptionValue = () => "?";

      // Update the controller methods for multiple selectable options
      if (!multiple) {
        selectCtrl.writeValue = function writeNgOptionsValue(value) {
          // The options might not be defined yet when ngModel tries to render
          if (!options) return;

          const selectedOption =
            selectElement.options[selectElement.selectedIndex];

          const option = options.getOptionFromViewValue(value);

          // Make sure to remove the selected attribute from the previously selected option
          // Otherwise, screen readers might get confused
          if (selectedOption) selectedOption.removeAttribute("selected");

          if (option) {
            // Don't update the option when it is already selected.
            // For example, the browser will select the first option by default. In that case,
            // most properties are set automatically - except the `selected` attribute, which we
            // set always

            if (selectElement.value !== option.selectValue) {
              selectCtrl.removeUnknownOption();

              selectElement.value = option.selectValue;
              option.element.selected = true;
            }

            option.element.setAttribute("selected", "selected");
          } else {
            selectCtrl.selectUnknownOrEmptyOption(value);
          }
        };

        selectCtrl.readValue = function readNgOptionsValue() {
          const selectedOption = options.selectValueMap[selectElement.value];

          if (selectedOption && !selectedOption.disabled) {
            selectCtrl.unselectEmptyOption();
            selectCtrl.removeUnknownOption();

            return options.getViewValueFromOption(selectedOption);
          }

          return null;
        };

        // If we are using `track by` then we must watch the tracked value on the model
        // since ngModel only watches for object identity change
        // FIXME: When a user selects an option, this watch will fire needlessly
        if (ngOptions.trackBy) {
          scope.$watch(ngOptions.getTrackByValue(ngModelCtrl.$viewValue), () => {
            ngModelCtrl.$render();
          });
        }
      } else {
        selectCtrl.writeValue = function writeNgOptionsMultiple(values) {
          // The options might not be defined yet when ngModel tries to render
          if (!options) return;

          // Only set `<option>.selected` if necessary, in order to prevent some browsers from
          // scrolling to `<option>` elements that are outside the `<select>` element's viewport.
          const selectedOptions =
            (values && values.map(getAndUpdateSelectedOption)) || [];

          options.items.forEach((option) => {
            if (option.element.selected && !includes(selectedOptions, option)) {
              option.element.selected = false;
            }
          });
        };

        selectCtrl.readValue = function readNgOptionsMultiple() {
          const selectedValues = selectElement.value || [];

          const selections = [];

          // @ts-ignore
          selectedValues.forEach((value) => {
            const option = options.selectValueMap[value];

            if (option && !option.disabled)
              selections.push(options.getViewValueFromOption(option));
          });

          return selections;
        };

        // If we are using `track by` then we must watch these tracked values on the model
        // since ngModel only watches for object identity change
        // if (ngOptions.trackBy) {
        //   scope.$watchCollection(
        //     () => {
        //       if (isArray(ngModelCtrl.$viewValue)) {
        //         return ngModelCtrl.$viewValue.map((value) =>
        //           ngOptions.getTrackByValue(value),
        //         );
        //       }
        //     },
        //     () => {
        //       ngModelCtrl.$render();
        //     },
        //   );
        // }
      }

      if (providedEmptyOption) {
        // compile the element since there might be bindings in it
        const linkFn = $compile(selectCtrl.emptyOption);

        selectElement.prepend(selectCtrl.emptyOption);
        linkFn(scope);

        if (selectCtrl.emptyOption.nodeType === NodeType._COMMENT_NODE) {
          // This means the empty option has currently no actual DOM node, probably because
          // it has been modified by a transclusion directive.
          selectCtrl.hasEmptyOption = false;

          // Redefine the registerOption function, which will catch
          // options that are added by ngIf etc. (rendering of the node is async because of
          // lazy transclusion)
          selectCtrl.registerOption = function (optionScope, optionEl) {
            if (optionEl.value === "") {
              selectCtrl.hasEmptyOption = true;
              selectCtrl.emptyOption = optionEl;
              // This ensures the new empty option is selected if previously no option was selected
              ngModelCtrl.$render();

              optionEl.addEventListener("$destroy", () => {
                const needsRerender = selectCtrl.$isEmptyOptionSelected();

                selectCtrl.hasEmptyOption = false;
                selectCtrl.emptyOption = undefined;

                if (needsRerender) ngModelCtrl.$render();
              });
            }
          };
        }
      }

      // We will re-render the option elements if the option values or labels change

      // let watchables = ngOptions.getWatchables();
      // watchables.forEach((i) => {
      //   scope.$watch(i, updateOptions);
      // });
      scope.$watch(
        ngOptions.getWatchables.decoratedNode.body[0].expression.name,
        updateOptions,
      );

      // ------------------------------------------------------------------ //

      function addOptionElement(option, parent) {
        /**
         * @type {HTMLOptionElement}
         */
        const optionElement = /** @type {HTMLOptionElement} */ (
          optionTemplate.cloneNode(false)
        );

        parent.appendChild(optionElement);
        updateOptionElement(option, optionElement);
      }

      function getAndUpdateSelectedOption(viewValue) {
        const option = options.getOptionFromViewValue(viewValue);

        const element = option && option.element;

        if (element && !element.selected) element.selected = true;

        return option;
      }

      function updateOptionElement(option, element) {
        option.element = element;
        element.disabled = option.disabled;

        // Support: IE 11 only, Edge 12-13 only
        // NOTE: The label must be set before the value, otherwise IE 11 & Edge create unresponsive
        // selects in certain circumstances when multiple selects are next to each other and display
        // the option list in listbox style, i.e. the select is [multiple], or specifies a [size].
        // See https://github.com/angular/angular.js/issues/11314 for more info.
        // This is unfortunately untestable with unit / e2e tests
        if (option.label !== element.label) {
          element.label = option.label;
          element.textContent = option.label;
        }
        element.value = option.selectValue;
      }

      function updateOptions() {
        const previousValue = options && selectCtrl.readValue();

        // We must remove all current options, but cannot simply set innerHTML = null
        // since the providedEmptyOption might have an ngIf on it that inserts comments which we
        // must preserve.
        // Instead, iterate over the current option elements and remove them or their optgroup
        // parents
        if (options) {
          for (let i = options.items.length - 1; i >= 0; i--) {
            const option = options.items[i];

            if (isDefined(option.group)) {
              removeElement(option.element.parentNode);
            } else {
              removeElement(option.element);
            }
          }
        }

        options = ngOptions.getOptions();

        const groupElementMap = {};

        options.items.forEach((option) => {
          let groupElement;

          if (isDefined(option.group)) {
            // This option is to live in a group
            // See if we have already created this group
            groupElement = groupElementMap[option.group];

            if (!groupElement) {
              groupElement = optGroupTemplate.cloneNode(false);
              listFragment.appendChild(groupElement);

              // Update the label on the group element
              // "null" is special cased because of Safari
              /** @type {HTMLOptGroupElement} */
              (groupElement).label =
                option.group === null ? "null" : option.group;

              // Store it for use later
              groupElementMap[option.group] = groupElement;
            }

            addOptionElement(option, groupElement);
          } else {
            // This option is not in a group
            addOptionElement(option, listFragment);
          }
        });

        selectElement.appendChild(listFragment);

        ngModelCtrl.$render();

        // Check to see if the value has changed due to the update to the options
        if (!ngModelCtrl.$isEmpty(previousValue)) {
          const nextValue = selectCtrl.readValue();

          const isNotPrimitive = ngOptions.trackBy || multiple;

          if (
            isNotPrimitive
              ? !equals$1(previousValue, nextValue)
              : previousValue !== nextValue
          ) {
            ngModelCtrl.$setViewValue(nextValue);
            ngModelCtrl.$render();
          }
        }
      }
    }

    return {
      restrict: "A",
      terminal: true,
      require: ["select", "ngModel"],
      link: {
        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
          // Deactivate the SelectController.register method to prevent
          // option directives from accidentally registering themselves
          // (and unwanted $destroy handlers etc.)
          ctrls[0].registerOption = () => {
            /* empty */
          };
        },
        post: ngOptionsPostLink,
      },
    };
  }

  /**
   * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.
   *
   * You can specify that you want to insert a named transclusion slot, instead of the default slot, by providing the slot name
   * as the value of the `ng-transclude` or `ng-transclude-slot` attribute.
   *
   * If the transcluded content is not empty (i.e. contains one or more DOM nodes, including whitespace text nodes), any existing
   * content of this element will be removed before the transcluded content is inserted.
   * If the transcluded content is empty (or only whitespace), the existing content is left intact. This lets you provide fallback
   * content in the case that no transcluded content is provided.
   *
   * @element ANY
   *
   * @param {string} ngTransclude|ngTranscludeSlot the name of the slot to insert at this point. If this is not provided, is empty
   *                                               or its value is the same as the name of the attribute then the default slot is used.
   */
  const ngTranscludeMinErr = minErr("ngTransclude");

  ngTranscludeDirective.$inject = [$injectTokens._compile];
  /**
   * @param {ng.CompileService} $compile
   * @returns {ng.Directive}
   */
  function ngTranscludeDirective($compile) {
    return {
      compile: function ngTranscludeCompile(tElement) {
        // Remove and cache any original content to act as a fallback
        const fallbackLinkFn = $compile(tElement.childNodes);

        emptyElement(tElement);

        /**
         *
         * @param {ng.Scope} $scope
         * @param {Element} $element
         * @param {ng.Attributes} $attrs
         * @param {*} _controller
         * @param {*} $transclude
         */
        function ngTranscludePostLink(
          $scope,
          $element,
          $attrs,
          _controller,
          $transclude,
        ) {
          if (!$transclude) {
            throw ngTranscludeMinErr(
              "orphan",
              "Illegal use of ngTransclude directive in the template! " +
                "No parent directive that requires a transclusion found. " +
                "Element: {0}",
              startingTag($element),
            );
          }

          // If the attribute is of the form: `ng-transclude="ng-transclude"` then treat it like the default
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = "";
          }
          const slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;

          // If the slot is required and no transclusion content is provided then this call will throw an error
          $transclude(ngTranscludeCloneAttachFn, null, slotName);

          // If the slot is optional and no transclusion content is provided then use the fallback content
          if (slotName && !$transclude.isSlotFilled(slotName)) {
            useFallbackContent();
          }

          /**
           * @param {NodeList | Node} clone
           * @param {ng.Scope} transcludedScope
           */
          function ngTranscludeCloneAttachFn(clone, transcludedScope) {
            if (notWhitespace(clone)) {
              if (clone instanceof NodeList) {
                Array.from(clone).forEach((el) => {
                  $element.append(el);
                });
              } else {
                $element.append(/** @type {Node} */ (clone));
              }
            } else {
              useFallbackContent();
              // There is nothing linked against the transcluded scope since no content was available,
              // so it should be safe to clean up the generated scope.
              transcludedScope.$destroy();
            }
          }

          function useFallbackContent() {
            // Since this is the fallback content rather than the transcluded content,
            // we link against the scope of this directive rather than the transcluded scope
            fallbackLinkFn(
              $scope,

              (clone) => {
                // @ts-ignore
                $element.append(clone);
              },
            );
          }

          function notWhitespace(node) {
            if (node instanceof Array) {
              return false;
            } else if (
              node.nodeType !== NodeType._TEXT_NODE ||
              node.nodeValue.trim()
            ) {
              return true;
            }

            return false;
          }
        }

        return ngTranscludePostLink;
      },
    };
  }

  const REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;

  /**
   * @type {Record<string, ng.DirectiveFactory>}
   */
  const ngAttributeAliasDirectives = {};

  // boolean attrs are evaluated
  BOOLEAN_ATTR.forEach((i) => {
    // binding to multiple is not supported
    if (i === "multiple") return;

    function defaultLinkFn(scope, _element, attr) {
      scope.$watch(attr[normalized], (value) => {
        attr.$set(i, !!value);
      });
    }

    const normalized = directiveNormalize(`ng-${i}`);

    let linkFn = defaultLinkFn;

    if (i === "checked") {
      linkFn = function (scope, element, attr) {
        // ensuring ngChecked doesn't interfere with ngModel when both are set on the same input
        if (attr.ngModel !== attr[normalized]) {
          defaultLinkFn(scope, element, attr);
        }
      };
    }

    ngAttributeAliasDirectives[normalized] = function () {
      return {
        restrict: "A",
        priority: 100,
        link: linkFn,
      };
    };
  });

  // aliased input attrs are evaluated
  entries(ALIASED_ATTR).forEach(([ngAttr]) => {
    ngAttributeAliasDirectives[ngAttr] = function () {
      return {
        priority: 100,
        link(scope, element, attr) {
          // special case ngPattern when a literal regular expression value
          // is used as the expression (this way we don't have to watch anything).
          if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) === "/") {
            const match = attr.ngPattern.match(REGEX_STRING_REGEXP);

            if (match) {
              attr.$set("ngPattern", new RegExp(match[1], match[2]).toString());

              return;
            }
          }

          scope.$watch(attr[ngAttr], (value) => {
            attr.$set(ngAttr, value);
          });
        },
      };
    };
  });

  // ng-src, ng-srcset, ng-href are interpolated
  ["src", "srcset", "href"].forEach((attrName) => {
    const normalized = directiveNormalize(`ng-${attrName}`);

    ngAttributeAliasDirectives[normalized] = [
      $injectTokens._sce,
      function ($sce) {
        return {
          priority: 99, // it needs to run after the attributes are interpolated
          link(_scope, element, attr) {
            let name = attrName;

            if (
              attrName === "href" &&
              toString.call(/** @type {HTMLLinkElement} */ (element).href) ===
                "[object SVGAnimatedString]"
            ) {
              name = "xlinkHref";
              attr.$attr[name] = "href";
            }

            // We need to sanitize the url at least once, in case it is a constant
            // non-interpolated attribute.
            attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized]));

            attr.$observe(normalized, (value) => {
              if (!value) {
                if (attrName === "href") {
                  attr.$set(name, null);
                }

                return;
              }

              attr.$set(name, value);
            });
          },
        };
      },
    ];
  });

  /**
   *
   * @param {string} ngRequired AngularTS expression. If it evaluates to `true`, it sets the
   *                                `required` attribute to the element and adds the `required`
   *                                {@link ngModel.NgModelController#$validators `validator`}.
   *
   *
   * ngRequired adds the required {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
   * It is most often used for {@link input `input`} and {@link select `select`} controls, but can also be
   * applied to custom controls.
   *
   * The directive sets the `required` attribute on the element if the AngularTS expression inside
   * `ngRequired` evaluates to true. A special directive for setting `required` is necessary because we
   * cannot use interpolation inside `required`. See the {@link guide/interpolation interpolation guide}
   * for more info.
   *
   * The validator will set the `required` error key to true if the `required` attribute is set and
   * calling {@link ngModel.NgModelController#$isEmpty `NgModelController.$isEmpty`} with the
   * {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`} returns `true`. For example, the
   * `$isEmpty()` implementation for `input[text]` checks the length of the `$viewValue`. When developing
   * custom controls, `$isEmpty()` can be overwritten to account for a $viewValue that is not string-based.
   *
   */
  const requiredDirective = [
    $injectTokens._parse,
    /**
     * @param {import("../../core/parse/interface.ts").ParseService} $parse
     * @returns {ng.Directive}
     */
    ($parse) => ({
      restrict: "A",
      require: "?ngModel",
      link:
        /**
         * @param {ng.Scope} scope
         * @param {Element} _elm
         * @param {ng.Attributes} attr
         * @param {ng.NgModelController} ctrl
         * @returns
         */
        (scope, _elm, attr, ctrl) => {
          if (!ctrl) return;
          // For boolean attributes like required, presence means true
          let value = hasOwn(attr, "required") || $parse(attr.ngRequired)(scope);

          if (!attr.ngRequired) {
            // force truthy in case we are on non input element
            // (input elements do this automatically for boolean attributes like required)
            attr.required = "true";
          }

          ctrl.$validators.required = (_modelValue, viewValue) => {
            return !value || !ctrl.$isEmpty(viewValue);
          };

          attr.$observe("required", (newVal) => {
            if (value !== newVal) {
              value = newVal;
              ctrl.$validate();
            }
          });
        },
    }),
  ];

  /**
   * @param {String|RegExp} ngPattern AngularTS expression that must evaluate to a `RegExp` or a `String`
   *                                      parsable into a `RegExp`, or a `RegExp` literal. See above for
   *                                      more details.
   *
   * @description
   *
   * ngPattern adds the pattern {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
   * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.
   *
   * The validator sets the `pattern` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
   * does not match a RegExp which is obtained from the `ngPattern` attribute value:
   * - the value is an AngularTS expression:
   *   - If the expression evaluates to a RegExp object, then this is used directly.
   *   - If the expression evaluates to a string, then it will be converted to a RegExp after wrapping it
   *     in `^` and `$` characters. For instance, `"abc"` will be converted to `new RegExp('^abc$')`.
   * - If the value is a RegExp literal, e.g. `ngPattern="/^\d+$/"`, it is used directly.
   *
   * <div class="alert alert-info">
   * **Note:** Avoid using the `g` flag on the RegExp, as it will cause each successive search to
   * start at the index of the last search's match, thus not taking the whole input value into
   * account.
   * </div>
   *
   * <div class="alert alert-info">
   * **Note:** This directive is also added when the plain `pattern` attribute is used, with two
   * differences:
   * <ol>
   *   <li>
   *     `ngPattern` does not set the `pattern` attribute and therefore HTML5 constraint validation is
   *     not available.
   *   </li>
   *   <li>
   *     The `ngPattern` attribute must be an expression, while the `pattern` value must be
   *     interpolated.
   *   </li>
   * </ol>
   * </div>
   */
  const patternDirective = [
    $injectTokens._parse,
    /**
     * @param {import("../../core/parse/interface.ts").ParseService} $parse
     * @returns {ng.Directive}
     */
    ($parse) => ({
      restrict: "A",
      require: "?ngModel",
      compile: (_Elm, tAttr) => {
        let patternExp;

        let parseFn;

        if (tAttr.ngPattern) {
          patternExp = tAttr.ngPattern;

          // ngPattern might be a scope expression, or an inlined regex, which is not parsable.
          // We get value of the attribute here, so we can compare the old and the new value
          // in the observer to avoid unnecessary validations
          if (
            tAttr.ngPattern.charAt(0) === "/" &&
            REGEX_STRING_REGEXP.test(tAttr.ngPattern)
          ) {
            parseFn = function () {
              return tAttr.ngPattern;
            };
          } else {
            parseFn = $parse(tAttr.ngPattern);
          }
        }

        return function (scope, elm, attr, ctrl) {
          if (!ctrl) return;
          let attrVal = attr.pattern;

          if (attr.ngPattern) {
            attrVal = parseFn(scope);
          } else {
            patternExp = attr.pattern;
          }

          let regexp = parsePatternAttr(attrVal, patternExp, elm);

          attr.$observe("pattern", (newVal) => {
            const oldRegexp = regexp;

            regexp = parsePatternAttr(newVal, patternExp, elm);

            if (
              (oldRegexp && oldRegexp.toString()) !==
              (regexp && regexp.toString())
            ) {
              ctrl.$validate();
            }
          });

          ctrl.$validators.pattern = (_modelValue, viewValue) => {
            // HTML5 pattern constraint validates the input value, so we validate the viewValue
            return (
              ctrl.$isEmpty(viewValue) ||
              isUndefined(regexp) ||
              regexp.test(viewValue)
            );
          };
        };
      },
    }),
  ];

  /**
   * @param {string} ngMaxlength AngularTS expression that must evaluate to a `Number` or `String`
   *                                 parsable into a `Number`. Used as value for the `maxlength`
   *                                 {@link ngModel.NgModelController#$validators validator}.
   *
   * @description
   *
   * ngMaxlength adds the maxlength {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
   * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.
   *
   * The validator sets the `maxlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
   * is longer than the integer obtained by evaluating the AngularTS expression given in the
   * `ngMaxlength` attribute value.
   *
   * <div class="alert alert-info">
   * **Note:** This directive is also added when the plain `maxlength` attribute is used, with two
   * differences:
   * <ol>
   *   <li>
   *     `ngMaxlength` does not set the `maxlength` attribute and therefore HTML5 constraint
   *     validation is not available.
   *   </li>
   *   <li>
   *     The `ngMaxlength` attribute must be an expression, while the `maxlength` value must be
   *     interpolated.
   *   </li>
   * </ol>
   * </div>
   *
   */
  const maxlengthDirective = [
    $injectTokens._parse,
    /**
     * @param {ng.ParseService} $parse
     * @returns {ng.Directive}
     */
    ($parse) => ({
      restrict: "A",
      require: "?ngModel",
      link:
        /**
         * @param {ng.Scope} scope
         * @param {Element} _elm
         * @param {ng.Attributes} attr
         * @param {ng.NgModelController} ctrl
         * @returns
         */
        (scope, _elm, attr, ctrl) => {
          if (!ctrl) return;

          let maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope);

          let maxlengthParsed = parseLength(maxlength);

          attr.$observe("maxlength", (value) => {
            if (maxlength !== value) {
              maxlengthParsed = parseLength(value);
              maxlength = value;
              ctrl.$validate();
            }
          });
          ctrl.$validators.maxlength = function (_modelValue, viewValue) {
            return (
              maxlengthParsed < 0 ||
              ctrl.$isEmpty(viewValue) ||
              viewValue.length <= maxlengthParsed
            );
          };
        },
    }),
  ];

  /**
   *
   * @param {string} ngMinlength AngularTS expression that must evaluate to a `Number` or `String`
   *                                 parsable into a `Number`. Used as value for the `minlength`
   *                                 {@link ngModel.NgModelController#$validators validator}.
   *
   * @description
   *
   * ngMinlength adds the minlength {@link ngModel.NgModelController#$validators `validator`} to {@link ngModel `ngModel`}.
   * It is most often used for text-based {@link input `input`} controls, but can also be applied to custom text-based controls.
   *
   * The validator sets the `minlength` error key if the {@link ngModel.NgModelController#$viewValue `ngModel.$viewValue`}
   * is shorter than the integer obtained by evaluating the AngularTS expression given in the
   * `ngMinlength` attribute value.
   *
   * <div class="alert alert-info">
   * **Note:** This directive is also added when the plain `minlength` attribute is used, with two
   * differences:
   * <ol>
   *   <li>
   *     `ngMinlength` does not set the `minlength` attribute and therefore HTML5 constraint
   *     validation is not available.
   *   </li>
   *   <li>
   *     The `ngMinlength` value must be an expression, while the `minlength` value must be
   *     interpolated.
   *   </li>
   * </ol>
   * </div>
   *
   */
  const minlengthDirective = [
    $injectTokens._parse,
    ($parse) => ({
      restrict: "A",
      require: "?ngModel",
      link(scope, elm, attr, ctrl) {
        if (!ctrl) return;

        let minlength = attr.minlength || $parse(attr.ngMinlength)(scope);

        let minlengthParsed = parseLength(minlength) || -1;

        attr.$observe("minlength", (value) => {
          if (minlength !== value) {
            minlengthParsed = parseLength(value) || -1;
            minlength = value;
            ctrl.$validate();
          }
        });
        ctrl.$validators.minlength = function (modelValue, viewValue) {
          return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;
        };
      },
    }),
  ];

  function parsePatternAttr(regex, patternExp, elm) {
    if (!regex) return undefined;

    if (isProxy(regex)) {
      regex = /** @type {ng.Scope} */ (regex).$target;
    }

    if (isString(regex)) {
      const match = regex.match(/^\/(.*)\/([gimsuy]*)$/);

      if (match) {
        regex = new RegExp(match[1], match[2]);
      } else {
        regex = new RegExp(`^${regex}$`);
      }
    }

    if (!regex.test) {
      throw minErr("ngPattern")(
        "noregexp",
        "Expected {0} to be a RegExp but was {1}. Element: {2}",
        patternExp,
        regex,
        startingTag(elm),
      );
    }

    return regex;
  }

  function parseLength(val) {
    const intVal = parseInt(val, 10);

    return isNumberNaN(intVal) ? -1 : intVal;
  }

  class AnchorScrollProvider {
    constructor() {
      this.autoScrollingEnabled = true;
    }

    $get = [
      $injectTokens._location,
      $injectTokens._rootScope,
      /**
       *
       * @param {ng.LocationService} $location
       * @param {ng.Scope} $rootScope
       * @returns
       */
      ($location, $rootScope) => {
        // Helper function to get first anchor from a NodeList
        // (using `Array#some()` instead of `angular#forEach()` since it's more performant
        //  and working in all supported browsers.)
        function getFirstAnchor(list) {
          let result = null;

          Array.prototype.some.call(list, (element) => {
            if (getNodeName(element) === "a") {
              result = element;

              return true;
            }

            return false;
          });

          return result;
        }

        function getYOffset() {
          // Figure out a better way to configure this other than bolting on a property onto a function
          let offset = /** @type {ng.AnchorScrollObject} */ (scroll).yOffset;

          if (isFunction(offset)) {
            offset = /** @type {Function} */ (offset)();
          } else if (offset instanceof Element) {
            const elem = offset[0];

            const style = window.getComputedStyle(elem);

            if (style.position !== "fixed") {
              offset = 0;
            } else {
              offset = elem.getBoundingClientRect().bottom;
            }
          } else if (!isNumber(offset)) {
            offset = 0;
          }

          return offset;
        }

        function scrollTo(elem) {
          if (elem) {
            elem.scrollIntoView();

            const offset = getYOffset();

            if (offset) {
              // `offset` is the number of pixels we should scroll UP in order to align `elem` properly.
              // This is true ONLY if the call to `elem.scrollIntoView()` initially aligns `elem` at the
              // top of the viewport.
              //
              // IF the number of pixels from the top of `elem` to the end of the page's content is less
              // than the height of the viewport, then `elem.scrollIntoView()` will align the `elem` some
              // way down the page.
              //
              // This is often the case for elements near the bottom of the page.
              //
              // In such cases we do not need to scroll the whole `offset` up, just the difference between
              // the top of the element and the offset, which is enough to align the top of `elem` at the
              // desired position.
              const elemTop = elem.getBoundingClientRect().top;

              window.scrollBy(0, elemTop - /** @type {number} */ (offset));
            }
          } else {
            window.scrollTo(0, 0);
          }
        }

        /** @type {ng.AnchorScrollService} */
        const scroll = function (/** @type {string | number} */ hash) {
          // Allow numeric hashes
          hash = isString(hash)
            ? hash
            : isNumber(hash)
              ? hash.toString()
              : $location.getHash();
          let elm;

          // empty hash, scroll to the top of the page
          if (!hash) {
            scrollTo(null);
          }
          // element with given id
          else if ((elm = document.getElementById(hash))) scrollTo(elm);
          // first anchor with given name :-D
          else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
            scrollTo(elm);
          // no element and hash === 'top', scroll to the top of the page
          else if (hash === "top") scrollTo(null);
        };

        // does not scroll when user clicks on anchor link that is currently on
        // (no url change, no $location.getHash() change), browser native does scroll
        if (this.autoScrollingEnabled) {
          $rootScope.$location = $location;
          $rootScope.$watch("$location.$$hash", (newVal, oldVal) => {
            // skip the initial scroll if $location.hash is empty
            if (newVal === oldVal && newVal === "") return;

            const action = () => scroll(newVal);

            if (document.readyState === "complete") {
              // Force the action to be run async for consistent behavior
              // from the action's point of view
              // i.e. it will definitely not be in a $apply
              queueMicrotask(() => action());
            } else {
              window.addEventListener("load", () => action());
            }
          });
        }

        return scroll;
      },
    ];
  }

  const $animateMinErr = minErr("$animate");

  // if any other type of options value besides an Object value is
  // passed into the $animate.method() animation then this helper code
  // will be run which will ignore it. While this patch is not the
  // greatest solution to this, a lot of existing plugins depend on
  // $animate to either call the callback (< 1.2) or return a promise
  // that can be changed. This helper function ensures that the options
  // are wiped clean incase a callback function is provided.
  function prepareAnimateOptions(options) {
    return isObject(options) ? options : {};
  }

  AnimateProvider.$inject = [$injectTokens._provide];

  /** @param {ng.ProvideService} $provide */
  function AnimateProvider($provide) {
    const provider = this;

    let classNameFilter = null;

    let customFilter = null;

    this.$$registeredAnimations = Object.create(null);

    /**
     * Registers a new injectable animation factory function. The factory function produces the
     * animation object which contains callback functions for each event that is expected to be
     * animated.
     *
     *   * `eventFn`: `function(element, ... , doneFunction, options)`
     *   The element to animate, the `doneFunction` and the options fed into the animation. Depending
     *   on the type of animation additional arguments will be injected into the animation function. The
     *   list below explains the function signatures for the different animation methods:
     *
     *   - setClass: function(element, addedClasses, removedClasses, doneFunction, options)
     *   - addClass: function(element, addedClasses, doneFunction, options)
     *   - removeClass: function(element, removedClasses, doneFunction, options)
     *   - enter, leave, move: function(element, doneFunction, options)
     *   - animate: function(element, fromStyles, toStyles, doneFunction, options)
     *
     *   Make sure to trigger the `doneFunction` once the animation is fully complete.
     *
     * ```js
     *   return {
     *     //enter, leave, move signature
     *     eventFn : function(element, done, options) {
     *       //code to run the animation
     *       //once complete, then run done()
     *       return function endFunction(wasCancelled) {
     *         //code to cancel the animation
     *       }
     *     }
     *   }
     * ```
     *
     * @param {string} name The name of the animation (this is what the class-based CSS value will be compared to).
     * @param {import("../interface.ts").Injectable<any>} factory The factory function that will be executed to return the animation
     *                           object.
     */
    this.register = function (name, factory) {
      if (name && name.charAt(0) !== ".") {
        throw $animateMinErr(
          "notcsel",
          "Expecting class selector starting with '.' got '{0}'.",
          name,
        );
      }

      const key = `${name}-animation`;

      provider.$$registeredAnimations[name.substring(1)] = key;
      $provide.factory(key, factory);
    };

    /**
     * Sets and/or returns the custom filter function that is used to "filter" animations, i.e.
     * determine if an animation is allowed or not. When no filter is specified (the default), no
     * animation will be blocked. Setting the `customFilter` value will only allow animations for
     * which the filter function's return value is truthy.
     *
     * This allows to easily create arbitrarily complex rules for filtering animations, such as
     * allowing specific events only, or enabling animations on specific subtrees of the DOM, etc.
     * Filtering animations can also boost performance for low-powered devices, as well as
     * applications containing a lot of structural operations.
     *
     * <div class="alert alert-success">
     *   **Best Practice:**
     *   Keep the filtering function as lean as possible, because it will be called for each DOM
     *   action (e.g. insertion, removal, class change) performed by "animation-aware" directives.
     *   See {@link guide/animations#which-directives-support-animations- here} for a list of built-in
     *   directives that support animations.
     *   Performing computationally expensive or time-consuming operations on each call of the
     *   filtering function can make your animations sluggish.
     * </div>
     *
     * **Note:** If present, `customFilter` will be checked before
     * {@link $animateProvider#classNameFilter classNameFilter}.
     *
     * @param {Function=} filterFn - The filter function which will be used to filter all animations.
     *   If a falsy value is returned, no animation will be performed. The function will be called
     *   with the following arguments:
     *   - **node** `{Element}` - The DOM element to be animated.
     *   - **event** `{String}` - The name of the animation event (e.g. `enter`, `leave`, `addClass`
     *     etc).
     *   - **options** `{Object}` - A collection of options/styles used for the animation.
     * @return {Function} The current filter function or `null` if there is none set.
     */
    this.customFilter = function (filterFn) {
      if (arguments.length === 1) {
        customFilter = isFunction(filterFn) ? filterFn : null;
      }

      return customFilter;
    };

    /**
     * Sets and/or returns the CSS class regular expression that is checked when performing
     * an animation. Upon bootstrap the classNameFilter value is not set at all and will
     * therefore enable $animate to attempt to perform an animation on any element that is triggered.
     * When setting the `classNameFilter` value, animations will only be performed on elements
     * that successfully match the filter expression. This in turn can boost performance
     * for low-powered devices as well as applications containing a lot of structural operations.
     *
     * **Note:** If present, `classNameFilter` will be checked after
     * {@link $animateProvider#customFilter customFilter}. If `customFilter` is present and returns
     * false, `classNameFilter` will not be checked.
     *
     * @param {RegExp=} expression The className expression which will be checked against all animations
     * @return {RegExp} The current CSS className expression value. If null then there is no expression value
     */
    this.classNameFilter = function (expression) {
      if (arguments.length === 1) {
        classNameFilter = expression instanceof RegExp ? expression : null;

        if (classNameFilter) {
          const reservedRegex = new RegExp(
            `[(\\s|\\/)]${NG_ANIMATE_CLASSNAME}[(\\s|\\/)]`,
          );

          if (reservedRegex.test(classNameFilter.toString())) {
            classNameFilter = null;
            throw $animateMinErr(
              "nongcls",
              '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.',
              NG_ANIMATE_CLASSNAME,
            );
          }
        }
      }

      return classNameFilter;
    };

    this.$get = [
      $injectTokens._animateQueue,
      /**
       * @param {import("./queue/interface.ts").AnimateQueueService} $$animateQueue
       * @returns {ng.AnimateService}
       */
      function ($$animateQueue) {
        /**
         * The $animate service exposes a series of DOM utility methods that provide support
         * for animation hooks. The default behavior is the application of DOM operations, however,
         * when an animation is detected (and animations are enabled), $animate will do the heavy lifting
         * to ensure that animation runs with the triggered DOM operation.
         *
         * By default $animate doesn't trigger any animations. This is because the `ngAnimate` module isn't
         * included and only when it is active then the animation hooks that `$animate` triggers will be
         * functional. Once active then all structural `ng-` directives will trigger animations as they perform
         * their DOM-related operations (enter, leave and move). Other directives such as `ngClass`,
         * `ngShow`, `ngHide` and `ngMessages` also provide support for animations.
         *
         * It is recommended that the`$animate` service is always used when executing DOM-related procedures within directives.
         */
        return {
          /**
           *
           * Sets up an event listener to fire whenever the animation event (enter, leave, move, etc...)
           *    has fired on the given element or among any of its children. Once the listener is fired, the provided callback
           *    is fired with the following params:
           *
           * ```js
           * $animate.on('enter', container,
           *    function callback(element, phase) {
           *      // cool we detected an enter animation within the container
           *    }
           * );
           * ```
           *
           * <div class="alert alert-warning">
           * **Note**: Generally, the events that are fired correspond 1:1 to `$animate` method names,
           * e.g. {@link ng.$animate#addClass addClass()} will fire `addClass`, and {@link ng.ngClass}
           * will fire `addClass` if classes are added, and `removeClass` if classes are removed.
           * However, there are two exceptions:
           *
           * <ul>
           *   <li>if both an {@link ng.$animate#addClass addClass()} and a
           *   {@link ng.$animate#removeClass removeClass()} action are performed during the same
           *   animation, the event fired will be `setClass`. This is true even for `ngClass`.</li>
           *   <li>an {@link ng.$animate#animate animate()} call that adds and removes classes will fire
           *   the `setClass` event, but if it either removes or adds classes,
           *   it will fire `animate` instead.</li>
           * </ul>
           *
           * </div>
           *
           * @param {string} event the animation event that will be captured (e.g. enter, leave, move, addClass, removeClass, etc...)
           * @param {Element} container the container element that will capture each of the animation events that are fired on itself
           *     as well as among its children
           * @param {Function} callback the callback function that will be fired when the listener is triggered.
           *
           * The arguments present in the callback function are:
           * * `element` - The captured DOM element that the animation was fired on.
           * * `phase` - The phase of the animation. The two possible phases are **start** (when the animation starts) and **close** (when it ends).
           * * `data` - an object with these properties:
           *     * addClass - `{string|null}` - space-separated CSS classes to add to the element
           *     * removeClass - `{string|null}` - space-separated CSS classes to remove from the element
           *     * from - `{Object|null}` - CSS properties & values at the beginning of the animation
           *     * to - `{Object|null}` - CSS properties & values at the end of the animation
           *
           * Note that the callback does not trigger a scope digest. Wrap your call into a
           * {@link $rootScope.Scope#$apply scope.$apply} to propagate changes to the scope.
           */
          on: $$animateQueue.on,

          /**
           * Deregisters an event listener based on the event which has been associated with the provided element. This method
           * can be used in three different ways depending on the arguments:
           *
           * ```js
           * // remove all the animation event listeners listening for `enter`
           * $animate.off('enter');
           *
           * // remove listeners for all animation events from the container element
           * $animate.off(container);
           *
           * // remove all the animation event listeners listening for `enter` on the given element and its children
           * $animate.off('enter', container);
           *
           * // remove the event listener function provided by `callback` that is set
           * // to listen for `enter` on the given `container` as well as its children
           * $animate.off('enter', container, callback);
           * ```
           *
           * @param {string|Element} event|container the animation event (e.g. enter, leave, move,
           * addClass, removeClass, etc...), or the container element. If it is the element, all other
           * arguments are ignored.
           * @param {Element=} container the container element the event listener was placed on
           * @param {Function=} callback the callback function that was registered as the listener
           */
          off: $$animateQueue.off,

          /**
           *  Associates the provided element with a host parent element to allow the element to be animated even if it exists
           *  outside of the DOM structure of the AngularTS application. By doing so, any animation triggered via `$animate` can be issued on the
           *  element despite being outside the realm of the application or within another application. Say for example if the application
           *  was bootstrapped on an element that is somewhere inside of the `<body>` tag, but we wanted to allow for an element to be situated
           *  as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind
           *  that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.
           *
           *  Note that this feature is only active when the `ngAnimate` module is used.
           *
           * @param {Element} element the external element that will be pinned
           * @param {Element} parentElement the host parent element that will be associated with the external element
           */
          pin: $$animateQueue.pin,

          /**
           * Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This
           * function can be called in four ways:
           *
           * ```js
           * // returns true or false
           * $animate.enabled();
           *
           * // changes the enabled state for all animations
           * $animate.enabled(false);
           * $animate.enabled(true);
           *
           * // returns true or false if animations are enabled for an element
           * $animate.enabled(element);
           *
           * // changes the enabled state for an element and its children
           * $animate.enabled(element, true);
           * $animate.enabled(element, false);
           * ```
           *
           * @param {Element=} element the element that will be considered for checking/setting the enabled state
           * @param {boolean=} enabled whether or not the animations will be enabled for the element
           *
           * @return {boolean} whether or not animations are enabled
           */
          enabled: (element, enabled) => {
            if (enabled !== undefined) {
              return hasAnimate(element);
            } else {
              element.setAttribute("animate", `${enabled}`);
            }

            return true;
          },

          /**
           * Cancels the provided animation and applies the end state of the animation.
           * Note that this does not cancel the underlying operation, e.g. the setting of classes or
           * adding the element to the DOM.
           *
           * @param {import('./runner/animate-runner.js').AnimateRunner} runner An animation runner returned by an $animate function.
           */
          cancel(runner) {
            if (runner.cancel) {
              runner.cancel();
            }
          },

          /**
           * Inserts the element into the DOM either after the `after` element (if provided) or
           * as the first child within the `parent` element and then triggers an animation.
           * A promise is returned that will be resolved during the next digest once the animation
           * has completed.
           *
           * @param {Element} element - the element which will be inserted into the DOM
           * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)
           * @param {Element} [after] - after the sibling element after which the element will be appended
           * @param {import("./interface.ts").AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.
           * @returns {import('./runner/animate-runner.js').AnimateRunner} the animation runner
           */
          enter(element, parent, after, options) {
            parent = parent || after.parentElement;
            animatedomInsert(element, parent, after);

            return $$animateQueue.push(
              element,
              "enter",
              prepareAnimateOptions(options),
            );
          },

          /**
           * Inserts (moves) the element into its new position in the DOM either after
           * the `after` element (if provided) or as the first child within the `parent` element
           * and then triggers an animation. A promise is returned that will be resolved
           * during the next digest once the animation has completed.
           *
           * @param {Element} element - the element which will be inserted into the DOM
           * @param {Element} parent - the parent element which will append the element as a child (so long as the after element is not present)
           * @param {Element} after - after the sibling element after which the element will be appended
           * @param {import("./interface.ts").AnimationOptions} [options] - an optional collection of options/styles that will be applied to the element.
           * @returns {import('./runner/animate-runner.js').AnimateRunner} the animation runner
           */
          move(element, parent, after, options) {
            parent = parent || after.parentElement;
            animatedomInsert(element, parent, after);

            return $$animateQueue.push(
              element,
              "move",
              prepareAnimateOptions(options),
            );
          },

          /**
           * Triggers an animation and then removes the element from the DOM.
           * When the function is called a promise is returned that will be resolved during the next
           * digest once the animation has completed.
           *
           * @param {Element} element the element which will be removed from the DOM
           * @param {import("./interface.ts").AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.
           * @returns {import('./runner/animate-runner.js').AnimateRunner} the animation runner
           */
          leave(element, options) {
            return $$animateQueue.push(
              element,
              "leave",
              prepareAnimateOptions(options),
              () => {
                removeElement(element);
              },
            );
          },

          /**
           * Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon
           * execution, the addClass operation will only be handled after the next digest and it will not trigger an
           * animation if element already contains the CSS class or if the class is removed at a later step.
           * Note that class-based animations are treated differently compared to structural animations
           * (like enter, move and leave) since the CSS classes may be added/removed at different points
           * depending if CSS or JavaScript animations are used.
           *
           * @param {Element} element the element which the CSS classes will be applied to
           * @param {string} className the CSS class(es) that will be added (multiple classes are separated via spaces)
           * @param {import("./interface").AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.
           * @return {import('./runner/animate-runner.js').AnimateRunner}} animationRunner the animation runner
           */
          addClass(element, className, options) {
            options = prepareAnimateOptions(options);
            options.addClass = mergeClasses(options.addClass, className);

            return $$animateQueue.push(element, "addClass", options);
          },

          /**
           * Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon
           * execution, the removeClass operation will only be handled after the next digest and it will not trigger an
           * animation if element does not contain the CSS class or if the class is added at a later step.
           * Note that class-based animations are treated differently compared to structural animations
           * (like enter, move and leave) since the CSS classes may be added/removed at different points
           * depending if CSS or JavaScript animations are used.
           *
           * @param {Element} element the element which the CSS classes will be applied to
           * @param {string} className the CSS class(es) that will be removed (multiple classes are separated via spaces)
           * @param {import("./interface").AnimationOptions} [options] an optional collection of options/styles that will be applied to the element.         *
           * @return {import('./runner/animate-runner.js').AnimateRunner} animationRunner the animation runner
           */
          removeClass(element, className, options) {
            options = prepareAnimateOptions(options);
            options.removeClass = mergeClasses(options.removeClass, className);

            return $$animateQueue.push(element, "removeClass", options);
          },

          /**
           * Performs both the addition and removal of a CSS classes on an element and (during the process)
           * triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and
           * `$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has
           * passed. Note that class-based animations are treated differently compared to structural animations
           * (like enter, move and leave) since the CSS classes may be added/removed at different points
           * depending if CSS or JavaScript animations are used.
           *
           * @param {Element} element the element which the CSS classes will be applied to
           * @param {string} add the CSS class(es) that will be added (multiple classes are separated via spaces)
           * @param {string} remove the CSS class(es) that will be removed (multiple classes are separated via spaces)
           * @param {object=} options an optional collection of options/styles that will be applied to the element.
           *
           * @return {import('./runner/animate-runner.js').AnimateRunner} the animation runner
           */
          setClass(element, add, remove, options) {
            options = prepareAnimateOptions(options);
            options.addClass = mergeClasses(options.addClass, add);
            options.removeClass = mergeClasses(options.removeClass, remove);

            return $$animateQueue.push(element, "setClass", options);
          },

          /**
           * Performs an inline animation on the element which applies the provided to and from CSS styles to the element.
           * If any detected CSS transition, keyframe or JavaScript matches the provided className value, then the animation will take
           * on the provided styles. For example, if a transition animation is set for the given className, then the provided `from` and
           * `to` styles will be applied alongside the given transition. If the CSS style provided in `from` does not have a corresponding
           * style in `to`, the style in `from` is applied immediately, and no animation is run.
           * If a JavaScript animation is detected then the provided styles will be given in as function parameters into the `animate`
           * method (or as part of the `options` parameter):
           *
           * ```js
           * ngModule.animation('.my-inline-animation', function() {
           *   return {
           *     animate : function(element, from, to, done, options) {
           *       //animation
           *       done();
           *     }
           *   }
           * });
           * ```
           *  @return {import('./runner/animate-runner.js').AnimateRunner} the animation runner
           */
          animate(element, from, to, className, options) {
            options = prepareAnimateOptions(options);
            options.from = options.from ? extend(options.from, from) : from;
            options.to = options.to ? extend(options.to, to) : to;

            className = className || "ng-inline-animate";
            options.tempClasses = mergeClasses(options.tempClasses, className);

            return $$animateQueue.push(element, "animate", options);
          },
        };
      },
    ];
  }

  /**
   * Provides an instance of a cache that can be used to store and retrieve template content.
   */
  class TemplateCacheProvider {
    constructor() {
      /** @type {ng.TemplateCacheService} */
      this.cache = new Map();
    }

    /**
     * @returns {ng.TemplateCacheService}
     */
    $get() {
      return this.cache;
    }
  }

  /**
   * Unified exception handler used throughout AngularTS.
   *
   * This service receives uncaught exceptions from both synchronous and asynchronous operations.
   * Its purpose is to provide a central point through which the framework
   * processes errors.
   *
   * By default, `$exceptionHandler` simply rethrows the exception. This ensures fail-fast
   * behavior, making errors visible immediately in development and in unit tests.
   * Applications may override this service to introduce custom error handling.
   *
   * ### Example: Custom `$exceptionHandler`
   *
   * ```js
   * angular
   *   .module('app')
   *   .factory('$exceptionHandler', function(myLogger) {
   *     return function handleError(error) {
   *       myLogger.capture(error);
   *       // Rethrow to preserve fail-fast behavior:
   *       throw error;
   *     };
   *   });
   * ```
   *
   * IMPORTANT: custom implementation should always rethrow the error as the framework assumes that `$exceptionHandler` always does the throwing.
   *
   * ### Manual Invocation
   *
   * You can invoke the exception handler directly when catching errors in your own code:
   *
   * ```js
   * try {
   *   riskyOperation();
   * } catch (err) {
   *   $exceptionHandler(err);
   * }
   * ```
   *
   * @see {@link ng.ExceptionHandlerService} ExceptionHandlerService
   */

  /**
   * Provider for the `$exceptionHandler` service.
   *
   * The default implementation rethrows exceptions, enabling strict fail-fast behavior.
   * Applications may replace the handler via by setting `errorHandler`property or by providing their own
   * `$exceptionHandler` factory.
   */
  class ExceptionHandlerProvider {
    constructor() {
      /** @type {ng.ExceptionHandlerService} */
      this.handler = (exception) => {
        throw exception;
      };
    }

    /**
     * @returns {ng.ExceptionHandlerService}
     */
    $get() {
      return (exception) => this.handler(exception);
    }
  }

  /**
   * @returns {ng.FilterFn}
   */
  function filterFilter() {
    /**
     * @param {Array<any>} array The source array.
     * @param {string|Object|function(any, number, []):[]} expression The predicate to be used for selecting items from `array`.
     * @param {function(any, any):boolean|boolean} [comparator] Comparator which is used in determining if values retrieved using `expression`
     * (when it is not a function) should be considered a match based on the expected value (from the filter expression) and actual value (from the object in the array).
     * @param {string} [anyPropertyKey] The special property name that matches against any property.
     * @return {Array<any>} Filtered array
     */
    return function (array, expression, comparator, anyPropertyKey) {
      if (!isArrayLike(array)) {
        if (isNullOrUndefined(array)) {
          return array;
        }
        throw minErr("filter")(
          "notarray",
          "Expected array but received: {0}",
          array,
        );
      }

      anyPropertyKey = anyPropertyKey || "$";
      let predicateFn;

      let matchAgainstAnyProp = false;

      switch (getTypeForFilter(expression)) {
        case "function":
          predicateFn = expression;
          break;
        case "boolean":
        case "null":
        case "number":
        case "string":
          matchAgainstAnyProp = true;
        // falls through
        case "object":
          predicateFn = createPredicateFn(
            expression,
            comparator,
            anyPropertyKey,
            matchAgainstAnyProp,
          );
          break;
        default:
          return array;
      }

      return Array.prototype.filter.call(array, predicateFn);
    };
  }

  // Helper functions for `filterFilter`
  function createPredicateFn(
    expression,
    comparator,
    anyPropertyKey,
    matchAgainstAnyProp,
  ) {
    const shouldMatchPrimitives =
      isObject(expression) && anyPropertyKey in expression;

    if (comparator === true) {
      comparator = equals$1;
    } else if (!isFunction(comparator)) {
      comparator = function (actual, expected) {
        if (isUndefined(actual)) {
          // No substring matching against `undefined`
          return false;
        }

        if (actual === null || expected === null) {
          // No substring matching against `null`; only match against `null`
          return actual === expected;
        }

        if (
          isObject(expected) ||
          (isObject(actual) && !hasCustomToString(actual))
        ) {
          // Should not compare primitives against objects, unless they have custom `toString` method
          return false;
        }

        actual = `${actual}`.toLowerCase();
        expected = `${expected}`.toLowerCase();

        return actual.indexOf(expected) !== -1;
      };
    }

    const predicateFn = function (item) {
      if (shouldMatchPrimitives && !isObject(item)) {
        return deepCompare(
          item,
          expression[anyPropertyKey],
          comparator,
          anyPropertyKey,
          false,
        );
      }

      return deepCompare(
        item,
        expression,
        comparator,
        anyPropertyKey,
        matchAgainstAnyProp,
      );
    };

    return predicateFn;
  }

  function deepCompare(
    actual,
    expected,
    comparator,
    anyPropertyKey,
    matchAgainstAnyProp,
    dontMatchWholeObject,
  ) {
    const actualType = getTypeForFilter(actual);

    const expectedType = getTypeForFilter(expected);

    if (expectedType === "string" && expected.charAt(0) === "!") {
      return !deepCompare(
        actual,
        expected.substring(1),
        comparator,
        anyPropertyKey,
        matchAgainstAnyProp,
      );
    }

    if (isArray(actual)) {
      // In case `actual` is an array, consider it a match
      // if ANY of it's items matches `expected`
      return actual.some((item) =>
        deepCompare(
          item,
          expected,
          comparator,
          anyPropertyKey,
          matchAgainstAnyProp,
        ),
      );
    }

    switch (actualType) {
      case "object":
        if (matchAgainstAnyProp) {
          for (const key in actual) {
            // Under certain, rare, circumstances, key may not be a string and `charAt` will be undefined
            // See: https://github.com/angular/angular.js/issues/15644
            if (
              key.charAt &&
              key.charAt(0) !== "$" &&
              deepCompare(actual[key], expected, comparator, anyPropertyKey, true)
            ) {
              return true;
            }
          }

          return dontMatchWholeObject
            ? false
            : deepCompare(actual, expected, comparator, anyPropertyKey, false);
        }

        if (expectedType === "object") {
          for (const key in expected) {
            const expectedVal = expected[key];

            if (isFunction(expectedVal) || isUndefined(expectedVal)) {
              continue;
            }

            const matchAnyProperty = key === anyPropertyKey;

            const actualVal = matchAnyProperty ? actual : actual[key];

            if (
              !deepCompare(
                actualVal,
                expectedVal,
                comparator,
                anyPropertyKey,
                matchAnyProperty,
                matchAnyProperty,
              )
            ) {
              return false;
            }
          }

          return true;
        }

        return comparator(actual, expected);

      case "function":
        return false;
      default:
        return comparator(actual, expected);
    }
  }

  // Used for easily differentiating between `null` and actual `object`
  function getTypeForFilter(val) {
    return val === null ? "null" : typeof val;
  }

  /**
   * @returns {ng.FilterFn}
   */
  function jsonFilter() {
    return function (object, spacing) {
      if (isUndefined(spacing)) {
        spacing = 2;
      }

      return toJson(object, spacing);
    };
  }

  /**
   * @returns {ng.FilterFn}
   */
  function limitToFilter() {
    /**
     * @param {Array|ArrayLike|string|number|Function} input Array/array-like, string, or number to be limited.
     * @param {string|number} limit The length of the returned array or string.
     * @param {string|number} [begin] Index at which to begin limitation. As a negative index, `begin` indicates an offset from the end of `input`. Defaults to `0`.
     */
    return function (input, limit, begin) {
      if (isFunction(input)) {
        input = /** @type {Function} */ (input)();
      }

      if (Math.abs(Number(limit)) === Infinity) {
        limit = Number(limit);
      } else {
        limit = parseInt(/** @type {string} */ (limit), 10);
      }

      if (isNumberNaN(limit)) return input;

      if (isNumber(input)) input = input.toString();

      if (!isArrayLike(input)) return input;

      begin =
        !begin || isNaN(/** @type {any} */ (begin))
          ? 0
          : parseInt(/** @type {string} */ (begin), 10);
      begin =
        begin < 0 ? Math.max(0, /** @type {[]} */ (input).length + begin) : begin;

      if (limit >= 0) {
        return sliceFn(input, begin, begin + limit);
      } else {
        if (begin === 0) {
          return sliceFn(input, limit, /** @type {[]} */ (input).length);
        } else {
          return sliceFn(input, Math.max(0, begin + limit), begin);
        }
      }
    };
  }

  function sliceFn(input, begin, end) {
    if (isString(input)) return input.slice(begin, end);

    return [].slice.call(input, begin, end);
  }

  orderByFilter.$inject = [$injectTokens._parse];

  /**
   * @returns {ng.FilterFn}
   */
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder, compareFn) {
      if (isNullOrUndefined(array)) return array;

      if (isFunction(array)) return array();

      if (!isArrayLike(array)) {
        throw minErr("orderBy")(
          "notarray",
          "Expected array but received: {0}",
          array,
        );
      }

      if (!isArray(sortPredicate)) {
        sortPredicate = [sortPredicate];
      }

      if (sortPredicate.length === 0) {
        sortPredicate = ["+"];
      }

      const predicates = processPredicates(sortPredicate);

      const descending = reverseOrder ? -1 : 1;

      // Define the `compare()` function. Use a default comparator if none is specified.
      const compare = isFunction(compareFn) ? compareFn : defaultCompare;

      // The next three lines are a version of a Swartzian Transform idiom from Perl
      // (sometimes called the Decorate-Sort-Undecorate idiom)
      // See https://en.wikipedia.org/wiki/Schwartzian_transform
      const compareValues = Array.prototype.map.call(array, getComparisonObject);

      compareValues.sort(doComparison);
      array = compareValues.map((item) => item.value);

      return array;

      function getComparisonObject(value, index) {
        // NOTE: We are adding an extra `tieBreaker` value based on the element's index.
        // This will be used to keep the sort stable when none of the input predicates can
        // distinguish between two elements.
        return {
          value,
          tieBreaker: { value: index, type: "number", index },
          predicateValues: predicates.map((predicate) =>
            getPredicateValue(predicate.get(value), index),
          ),
        };
      }

      function doComparison(v1, v2) {
        for (let i = 0, ii = predicates.length; i < ii; i++) {
          const result = compare(v1.predicateValues[i], v2.predicateValues[i]);

          if (result) {
            return result * predicates[i].descending * descending;
          }
        }

        return (
          (compare(v1.tieBreaker, v2.tieBreaker) ||
            defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending
        );
      }
    };

    function processPredicates(sortPredicates) {
      return sortPredicates.map((predicate) => {
        let descending = 1;

        let get = (x) => x;

        if (isFunction(predicate)) {
          get = predicate;
        } else if (isString(predicate)) {
          if (predicate.charAt(0) === "+" || predicate.charAt(0) === "-") {
            descending = predicate.charAt(0) === "-" ? -1 : 1;
            predicate = predicate.substring(1);
          }

          if (predicate !== "") {
            const parsed = $parse(predicate);

            if (parsed.constant) {
              const key = parsed();

              get = (value) => value[key];
            } else {
              get = parsed;
            }
          }
        }

        return { get, descending };
      });
    }

    function isPrimitive(value) {
      switch (typeof value) {
        case "number": /* falls through */
        case "boolean": /* falls through */
        case "string":
          return true;
        default:
          return false;
      }
    }

    function objectValue(value) {
      // If `valueOf` is a valid function use that
      if (isFunction(value.valueOf)) {
        value = value.valueOf();

        if (isPrimitive(value)) return value;
      }

      // If `toString` is a valid function and not the one from `Object.prototype` use that
      if (hasCustomToString(value)) {
        value = value.toString();

        if (isPrimitive(value)) return value;
      }

      return value;
    }

    function getPredicateValue(value, index) {
      /** @type {String} */ let type = typeof value;

      if (value === null) {
        type = "null";
      } else if (type === "object") {
        value = objectValue(value);
      }

      return { value, type, index };
    }

    function defaultCompare(v1, v2) {
      let result = 0;

      const type1 = v1.type;

      const type2 = v2.type;

      if (type1 === type2) {
        let value1 = v1.value;

        let value2 = v2.value;

        if (type1 === "string") {
          // Compare strings case-insensitively
          value1 = value1.toLowerCase();
          value2 = value2.toLowerCase();
        } else if (type1 === "object") {
          // For basic objects, use the position of the object
          // in the collection instead of the value
          if (isObject(value1)) value1 = v1.index;

          if (isObject(value2)) value2 = v2.index;
        }

        if (value1 !== value2) {
          result = value1 < value2 ? -1 : 1;
        }
      } else {
        result =
          type1 === "undefined"
            ? 1
            : type2 === "undefined"
              ? -1
              : type1 === "null"
                ? 1
                : type2 === "null"
                  ? -1
                  : type1 < type2
                    ? -1
                    : 1;
      }

      return result;
    }
  }

  $IsStateFilter.$inject = [$injectTokens._state];

  /**
   * `isState` Filter: truthy if the current state is the parameter
   *
   * Translates to [[StateService.is]] `$state.is("stateName")`.
   *
   * #### Example:
   * ```html
   * <div ng-if="'stateName' | isState">show if state is 'stateName'</div>
   * ```
   *
   * @param {import('./state/state-service.js').StateProvider} $state
   * @returns {ng.FilterFn}
   */
  function $IsStateFilter($state) {
    const isFilter = (state, params, options) =>
      $state.is(state, params, options);

    isFilter.$stateful = true;

    return isFilter;
  }

  $IncludedByStateFilter.$inject = [$injectTokens._state];

  /**
   * `includedByState` Filter: truthy if the current state includes the parameter
   *
   * Translates to [[StateService.includes]]` $state.is("fullOrPartialStateName")`.
   *
   * #### Example:
   * ```html
   * <div ng-if="'fullOrPartialStateName' | includedByState">show if state includes 'fullOrPartialStateName'</div>
   * ```
   *
   * @param {import('./state/state-service.js').StateProvider} $state
   * @returns {ng.FilterFn}
   */
  function $IncludedByStateFilter($state) {
    const includesFilter = function (state, params, options) {
      return $state.includes(state, params, options);
    };

    includesFilter.$stateful = true;

    return includesFilter;
  }

  /* @ignore */
  const SUFFIX = "Filter";

  /**
   * $filterProvider - $filter - provider in module ng
   *
   * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To achieve this a filter definition consists of a factory function which is annotated with dependencies and is responsible for creating a filter function.
   * @extends {ng.ServiceProvider}
   */
  class FilterProvider {
    /* @ignore */ static $inject = [$injectTokens._provide];

    /**
     * @param {ng.ProvideService} $provide
     */
    constructor($provide) {
      assert(isDefined($provide));
      this._$provide = $provide;
      entries({
        filter: filterFilter,
        json: jsonFilter,
        limitTo: limitToFilter,
        orderBy: orderByFilter,
        isState: $IsStateFilter,
        includedByState: $IncludedByStateFilter,
      }).forEach(([k, v]) =>
        this.register(k, /** @type {ng.FilterFactory} */ (v)),
      );
    }

    /**
     * Register a filter a config phase;
     * @param {string} name
     * @param {ng.FilterFactory} factory
     * @return {ng.FilterProvider}
     */
    register(name, factory) {
      validateIsString(name, "name");
      validate(isFunction, factory, "factory");
      this._$provide.factory(name + SUFFIX, factory);

      return this;
    }

    $get = [
      $injectTokens._injector,
      /**
       * @param {ng.InjectorService} $injector
       * @returns {ng.FilterService}
       */
      ($injector) => (name) => {
        validateIsString(name, "name");

        return $injector.get(name + SUFFIX);
      },
    ];
  }

  /**
   * @readonly
   * @enum {number}
   */
  const ASTType = {
    _Program: 1,
    _ExpressionStatement: 2,
    _AssignmentExpression: 3,
    _ConditionalExpression: 4,
    _LogicalExpression: 5,
    _BinaryExpression: 6,
    _UnaryExpression: 7,
    _CallExpression: 8,
    _MemberExpression: 9,
    _Identifier: 10,
    _Literal: 11,
    _ArrayExpression: 12,
    _Property: 13,
    _ObjectExpression: 14,
    _ThisExpression: 15,
    _LocalsExpression: 16,
    NGValueParameter: 17,
  };

  const PURITY_ABSOLUTE = 1;
  const PURITY_RELATIVE = 2;

  class ASTInterpreter {
    /**
     * @param {function(any):any} $filter
     */
    constructor($filter) {
      this._$filter = $filter;
    }

    /**
     * Compiles the AST into a function.
     * @param {import("./ast/ast.js").ASTNode} ast - The AST to compile.
     * @returns {import("./interface.ts").CompiledExpression}
     */
    compile(ast) {
      const decoratedNode = findConstantAndWatchExpressions(ast, this._$filter);

      /** @type {import("./ast/ast.js").ASTNode} */
      const assignable = assignableAST(decoratedNode);

      /** @type {import("./interface.ts").CompiledExpression} */
      let assign;

      if (assignable) {
        assign = /** @type {import("./interface.ts").CompiledExpression} */ (
          this.#recurse(assignable)
        );
      }
      const toWatch = getInputs(decoratedNode.body);

      let inputs;

      if (toWatch) {
        inputs = [];

        for (const [key, watch] of entries(toWatch)) {
          const input =
            /** @type {import("./interface.ts").CompiledExpression} */ (
              this.#recurse(watch)
            );

          input.isPure = watch.isPure;
          watch.input = input;
          inputs.push(input);
          watch.watchId = key;
        }
      }
      const expressions = [];

      decoratedNode.body.forEach((expression) => {
        expressions.push(this.#recurse(expression.expression));
      });

      /** @type {import("./interface.ts").CompiledExpression} */
      const fn =
        decoratedNode.body.length === 0
          ? () => {
              /* empty */
            }
          : decoratedNode.body.length === 1
            ? expressions[0]
            : function (scope, locals) {
                let lastValue;

                expressions.forEach((exp) => {
                  lastValue = exp(scope, locals);
                });

                return lastValue;
              };

      if (assign) {
        fn.assign = (scope, value, locals) => assign(scope, locals, value);
      }

      if (inputs) {
        fn.inputs = inputs;
      }
      fn.decoratedNode = decoratedNode;

      return fn;
    }

    /**
     * Recurses the AST nodes.
     * @param {import("./ast/ast").ASTNode} ast - The AST node.
     * @param {Object} [context] - The context.
     * @param {boolean|1} [create] - The create flag.
     * @returns {import("./interface.ts").CompiledExpressionFunction} The recursive function.
     */
    #recurse(ast, context, create) {
      let left;

      let right;

      const self = this;

      let args;

      switch (ast.type) {
        case ASTType._Literal:
          return this.value(ast.value, context);
        case ASTType._UnaryExpression:
          right = this.#recurse(ast.argument);

          return this[`unary${ast.operator}`](right, context);
        case ASTType._BinaryExpression:
          left = this.#recurse(ast.left);
          right = this.#recurse(ast.right);

          return this[`binary${ast.operator}`](left, right, context);
        case ASTType._LogicalExpression:
          left = this.#recurse(ast.left);
          right = this.#recurse(ast.right);

          return this[`binary${ast.operator}`](left, right, context);
        case ASTType._ConditionalExpression:
          return /** @type {import("./interface.ts").CompiledExpressionFunction} */ (
            this["ternary?:"](
              this.#recurse(ast.test),
              this.#recurse(ast.alternate),
              this.#recurse(ast.consequent),
              context,
            )
          );
        case ASTType._Identifier:
          return self.identifier(ast.name, context, create);
        case ASTType._MemberExpression:
          left = this.#recurse(ast.object, false, !!create);

          if (!ast.computed) {
            right = ast.property.name;
          }

          if (ast.computed) right = this.#recurse(ast.property);

          return /** @type {import("./interface.ts").CompiledExpressionFunction} */ (
            ast.computed
              ? this.#computedMember(
                  left,
                  /** @type {function } */ (right),
                  context,
                  create,
                )
              : this.nonComputedMember(
                  left,
                  /** @type {string } */ (right),
                  context,
                  create,
                )
          );
        case ASTType._CallExpression:
          args = [];
          ast.arguments.forEach((expr) => {
            args.push(self.#recurse(expr));
          });

          if (ast.filter) right = this._$filter(ast.callee.name);

          if (!ast.filter) right = this.#recurse(ast.callee, true);

          return ast.filter
            ? (scope, locals, assign) => {
                const values = [];

                for (let i = 0; i < args.length; ++i) {
                  const res = args[i](scope && deProxy(scope), locals, assign);

                  values.push(res);
                }
                const value = () => {
                  return right.apply(undefined, values);
                };

                return context
                  ? { context: undefined, name: undefined, value }
                  : value;
              }
            : (scope, locals, assign) => {
                const rhs = right(
                  /** @type {ng.Scope} */ (scope).$target
                    ? /** @type {ng.Scope} */ (scope).$target
                    : scope,
                  locals,
                  assign,
                );

                let value;

                if (!isNullOrUndefined(rhs.value) && isFunction(rhs.value)) {
                  const values = [];

                  for (let i = 0; i < args.length; ++i) {
                    const res = args[i](scope, locals, assign);

                    values.push(isFunction(res) ? res() : res);
                  }
                  value = rhs.value.apply(rhs.context, values);
                }

                return context ? { value } : value;
              };
        case ASTType._AssignmentExpression:
          left = this.#recurse(ast.left, true, 1);
          right = this.#recurse(ast.right);

          return (scope, locals, assign) => {
            const lhs = left(scope, locals, assign);

            const rhs = right(scope, locals, assign);

            // lhs.context[lhs.name] = rhs;
            const ctx = isProxy(lhs.context)
              ? lhs.context
              : (lhs.context.$proxy ?? lhs.context);

            ctx[lhs.name] = rhs;

            return context ? { value: rhs } : rhs;
          };
        case ASTType._ArrayExpression:
          args = [];
          ast.elements.forEach((expr) => {
            args.push(self.#recurse(expr));
          });

          return (scope, locals, assign) => {
            const value = [];

            for (let i = 0; i < args.length; ++i) {
              value.push(args[i](scope, locals, assign));
            }

            return context ? { value } : value;
          };
        case ASTType._ObjectExpression:
          args = [];
          ast.properties.forEach((property) => {
            if (property.computed) {
              args.push({
                key: self.#recurse(property.key),
                computed: true,
                value: self.#recurse(property.value),
              });
            } else {
              args.push({
                key:
                  property.key.type === ASTType._Identifier
                    ? property.key.name
                    : `${property.key.value}`,
                computed: false,
                value: self.#recurse(property.value),
              });
            }
          });

          return (scope, locals, assign) => {
            const value = {};

            for (let i = 0; i < args.length; ++i) {
              if (args[i].computed) {
                value[args[i].key(scope, locals, assign)] = args[i].value(
                  scope,
                  locals,
                  assign,
                );
              } else {
                value[args[i].key] = args[i].value(scope, locals, assign);
              }
            }

            return context ? { value } : value;
          };
        case ASTType._ThisExpression:
          return (scope) =>
            context ? { value: scope } : /** @type {ng.Scope} */ (scope).$proxy;
        case ASTType._LocalsExpression:
          return (scope, locals) => (context ? { value: locals } : locals);
        case ASTType.NGValueParameter:
          return (scope, locals, assign) =>
            context ? { value: assign } : assign;
      }

      return undefined;
    }

    /**
     * Unary plus operation.
     * @param {function} argument - The argument function.
     * @param {Object} [context] - The context.
     * @returns {function} The unary plus function.
     */
    "unary+"(argument, context) {
      return (scope, locals, assign) => {
        let arg = argument(scope, locals, assign);

        if (isDefined(arg)) {
          arg = +arg;
        } else {
          arg = 0;
        }

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Unary minus operation.
     * @param {function} argument - The argument function.
     * @param {Object} [context] - The context.
     * @returns {function} The unary minus function.
     */
    "unary-"(argument, context) {
      return (scope, locals, assign) => {
        let arg = argument(scope, locals, assign);

        if (isDefined(arg)) {
          arg = -arg;
        } else {
          arg = -0;
        }

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Unary negation operation.
     * @param {function} argument - The argument function.
     * @param {Object} [context] - The context.
     * @returns {function} The unary negation function.
     */
    "unary!"(argument, context) {
      return (scope, locals, assign) => {
        const arg = !argument(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary plus operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary plus function.
     */
    "binary+"(left, right, context) {
      return (scope, locals, assign) => {
        const lhs = left(scope, locals, assign);

        const rhs = right(scope, locals, assign);

        const arg = plusFn(lhs, rhs);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary minus operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary minus function.
     */
    "binary-"(left, right, context) {
      return (scope, locals, assign) => {
        const lhs = left(scope, locals, assign);

        const rhs = right(scope, locals, assign);

        const arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary multiplication operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary multiplication function.
     */
    "binary*"(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) * right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    "binary/"(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) / right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary division operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary division function.
     */
    "binary%"(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) % right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary strict equality operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary strict equality function.
     */
    "binary==="(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) === right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary strict inequality operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary strict inequality function.
     */
    "binary!=="(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) !== right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary equality operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary equality function.
     */
    "binary=="(left, right, context) {
      return (scope, locals, assign) => {
        // eslint-disable-next-line eqeqeq
        const arg = left(scope, locals, assign) == right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary inequality operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary inequality function.
     */
    "binary!="(left, right, context) {
      return (scope, locals, assign) => {
        // eslint-disable-next-line eqeqeq
        const arg = left(scope, locals, assign) != right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary less-than operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary less-than function.
     */
    "binary<"(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) < right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary greater-than operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary greater-than function.
     */
    "binary>"(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) > right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary less-than-or-equal-to operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary less-than-or-equal-to function.
     */
    "binary<="(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) <= right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary greater-than-or-equal-to operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary greater-than-or-equal-to function.
     */
    "binary>="(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) >= right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary logical AND operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary logical AND function.
     */
    "binary&&"(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) && right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Binary logical OR operation.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @returns {function} The binary logical OR function.
     */
    "binary||"(left, right, context) {
      return (scope, locals, assign) => {
        const arg = left(scope, locals, assign) || right(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Ternary conditional operation.
     * @param {function} test - The test function.
     * @param {function} alternate - The alternate function.
     * @param {function} consequent - The consequent function.
     * @param {Object} [context] - The context.
     * @returns {function} The ternary conditional function.
     */
    "ternary?:"(test, alternate, consequent, context) {
      return (scope, locals, assign) => {
        const arg = test(scope, locals, assign)
          ? alternate(scope, locals, assign)
          : consequent(scope, locals, assign);

        return context ? { value: arg } : arg;
      };
    }

    /**
     * Returns the value of a literal.
     * @param {*} value - The literal value.
     * @param {Object} [context] - The context.
     * @returns {import("./interface.ts").CompiledExpressionFunction} The function returning the literal value.
     */
    value(value, context) {
      return () =>
        context ? { context: undefined, name: undefined, value } : value;
    }

    /**
     * Returns the value of an identifier.
     * @param {string} name - The identifier name.
     * @param {Object} [context] - The context.
     * @param {boolean|1} [create] - Whether to create the identifier if it does not exist.
     * @returns {import("./interface.ts").CompiledExpressionFunction} The function returning the identifier value.
     */
    identifier(name, context, create) {
      return (scope, locals) => {
        /** @type {ng.Scope | unknown} */
        const base =
          locals && name in locals
            ? locals
            : ((scope && /** @type {ng.Scope} */ (scope).$proxy) ?? scope);

        if (create && create !== 1 && base && isNullOrUndefined(base[name])) {
          base[name] = {};
        }
        let value = undefined;

        if (base) {
          value = deProxy(base)[name];
        }

        if (context) {
          return { context: base, name, value };
        }

        return value;
      };
    }

    /**
     * Returns the value of a computed member expression.
     * @param {function} left - The left operand function.
     * @param {function} right - The right operand function.
     * @param {Object} [context] - The context.
     * @param {boolean|1} [create] - Whether to create the member if it does not exist.
     * @returns {function} The function returning the computed member value.
     */
    #computedMember(left, right, context, create) {
      return (scope, locals, assign) => {
        const lhs = left(scope, locals, assign);

        let rhs;

        let value;

        if (!isNullOrUndefined(lhs)) {
          rhs = right(scope, locals, assign);
          rhs = getStringValue(rhs);

          if (create && create !== 1) {
            if (lhs && !lhs[rhs]) {
              lhs[rhs] = {};
            }
          }
          value = lhs[rhs];
        }

        if (context) {
          return { context: lhs, name: rhs, value };
        }

        return value;
      };
    }

    /**
     * Returns the value of a non-computed member expression.
     * @param {function} left - The left operand function.
     * @param {string} right - The right operand function.
     * @param {Object} [context] - The context.
     * @param {boolean|1} [create] - Whether to create the member if it does not exist.
     * @returns {function} The function returning the non-computed member value.
     */
    nonComputedMember(left, right, context, create) {
      return (scope, locals, assign) => {
        const lhs = left(scope, locals, assign);

        if (create && create !== 1) {
          if (lhs && isNullOrUndefined(lhs[right])) {
            lhs[right] = {};
          }
        }
        const value = !isNullOrUndefined(lhs) ? lhs[right] : undefined;

        if (context) {
          return { context: lhs, name: right, value };
        }

        return value;
      };
    }
  }

  /**
   * @typedef {import("./ast/ast").ASTNode & {
   *  isPure: boolean|number,
   *  constant: boolean,
   *  toWatch: Array,
   * }} DecoratedASTNode
   */

  /**
   * Decorates AST with constant, toWatch, and isPure properties
   * @param {import("./ast/ast").ASTNode} ast
   * @param {function(any):any} $filter
   * @param {boolean|1|2} [parentIsPure]
   * @returns {DecoratedASTNode}
   */
  function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
    let allConstants;

    let argsToWatch;

    let isStatelessFilter;

    const decoratedNode = /** @type  {DecoratedASTNode} */ (ast);

    let decoratedLeft,
      decoratedRight,
      decoratedTest,
      decoratedAlternate,
      decoratedConsequent,
      decoratedObject,
      decoratedProperty,
      decoratedKey;

    // @ts-ignore
    const astIsPure = (decoratedNode.isPure = isPure(ast, parentIsPure));

    switch (ast.type) {
      case ASTType._Program:
        allConstants = true;
        decoratedNode.body.forEach((expr) => {
          const decorated = findConstantAndWatchExpressions(
            expr.expression,
            $filter,
            astIsPure,
          );

          allConstants = allConstants && decorated.constant;
        });
        decoratedNode.constant = allConstants;

        return decoratedNode;
      case ASTType._Literal:
        decoratedNode.constant = true;
        decoratedNode.toWatch = [];

        return decoratedNode;
      case ASTType._UnaryExpression:
        // eslint-disable-next-line no-var
        var decorated = findConstantAndWatchExpressions(
          decoratedNode.argument,
          $filter,
          astIsPure,
        );

        decoratedNode.constant = decorated.constant;
        decoratedNode.toWatch = decorated.toWatch;

        return decoratedNode;
      case ASTType._BinaryExpression:
        decoratedLeft = findConstantAndWatchExpressions(
          decoratedNode.left,
          $filter,
          astIsPure,
        );
        decoratedRight = findConstantAndWatchExpressions(
          decoratedNode.right,
          $filter,
          astIsPure,
        );
        decoratedNode.constant =
          decoratedLeft.constant && decoratedRight.constant;
        decoratedNode.toWatch = decoratedLeft.toWatch.concat(
          decoratedRight.toWatch,
        );

        return decoratedNode;
      case ASTType._LogicalExpression:
        decoratedLeft = findConstantAndWatchExpressions(
          decoratedNode.left,
          $filter,
          astIsPure,
        );
        decoratedRight = findConstantAndWatchExpressions(
          decoratedNode.right,
          $filter,
          astIsPure,
        );
        decoratedNode.constant =
          decoratedLeft.constant && decoratedRight.constant;
        decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];

        return decoratedNode;
      case ASTType._ConditionalExpression:
        decoratedTest = findConstantAndWatchExpressions(
          ast.test,
          $filter,
          astIsPure,
        );
        decoratedAlternate = findConstantAndWatchExpressions(
          ast.alternate,
          $filter,
          astIsPure,
        );
        decoratedConsequent = findConstantAndWatchExpressions(
          ast.consequent,
          $filter,
          astIsPure,
        );
        decoratedNode.constant =
          decoratedTest.constant &&
          decoratedAlternate.constant &&
          decoratedConsequent.constant;
        decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];

        return decoratedNode;
      case ASTType._Identifier:
        decoratedNode.constant = false;
        decoratedNode.toWatch = [ast];

        return decoratedNode;
      case ASTType._MemberExpression:
        decoratedObject = findConstantAndWatchExpressions(
          ast.object,
          $filter,
          astIsPure,
        );

        if (ast.computed) {
          decoratedProperty = findConstantAndWatchExpressions(
            ast.property,
            $filter,
            astIsPure,
          );
        }
        decoratedNode.constant =
          decoratedObject.constant &&
          (!decoratedNode.computed || decoratedProperty.constant);
        decoratedNode.toWatch = decoratedNode.constant ? [] : [ast];

        return decoratedNode;
      case ASTType._CallExpression:
        isStatelessFilter = ast.filter
          ? isStateless($filter, ast.callee.name)
          : false;
        allConstants = isStatelessFilter;
        argsToWatch = [];
        ast.arguments.forEach((expr) => {
          decorated = findConstantAndWatchExpressions(expr, $filter, astIsPure);
          allConstants = allConstants && decorated.constant;
          argsToWatch.push.apply(argsToWatch, decorated.toWatch);
        });
        decoratedNode.constant = allConstants;
        decoratedNode.toWatch = isStatelessFilter ? argsToWatch : [decoratedNode];

        return decoratedNode;
      case ASTType._AssignmentExpression:
        decoratedLeft = findConstantAndWatchExpressions(
          ast.left,
          $filter,
          astIsPure,
        );
        decoratedRight = findConstantAndWatchExpressions(
          ast.right,
          $filter,
          astIsPure,
        );
        decoratedNode.constant =
          decoratedLeft.constant && decoratedRight.constant;
        decoratedNode.toWatch = [decoratedNode];

        return decoratedNode;
      case ASTType._ArrayExpression:
        allConstants = true;
        argsToWatch = [];
        ast.elements.forEach((expr) => {
          decorated = findConstantAndWatchExpressions(expr, $filter, astIsPure);
          allConstants = allConstants && decorated.constant;
          argsToWatch.push.apply(argsToWatch, decorated.toWatch);
        });
        decoratedNode.constant = allConstants;
        decoratedNode.toWatch = argsToWatch;

        return decoratedNode;
      case ASTType._ObjectExpression:
        allConstants = true;
        argsToWatch = [];
        ast.properties.forEach((property) => {
          decorated = findConstantAndWatchExpressions(
            property.value,
            $filter,
            astIsPure,
          );
          allConstants = allConstants && decorated.constant;
          argsToWatch.push.apply(argsToWatch, decorated.toWatch);

          if (property.computed) {
            // `{[key]: value}` implicitly does `key.toString()` which may be non-pure
            decoratedKey = findConstantAndWatchExpressions(
              property.key,
              $filter,
              false,
            );
            allConstants = allConstants && decoratedKey.constant;
            argsToWatch.push.apply(argsToWatch, decoratedKey.toWatch);
          }
        });
        decoratedNode.constant = allConstants;
        decoratedNode.toWatch = argsToWatch;

        return decoratedNode;
      case ASTType._ThisExpression:
        decoratedNode.constant = false;
        decoratedNode.toWatch = [];

        return decoratedNode;
      case ASTType._LocalsExpression:
        decoratedNode.constant = false;
        decoratedNode.toWatch = [];

        return decoratedNode;
    }

    return undefined;
  }

  /**
   * Converts a single expression AST node into an assignment expression if the expression is assignable.
   *
   * @param {import("./ast/ast").ASTNode} ast
   * @returns {import("./ast/ast").ASTNode}
   */
  function assignableAST(ast) {
    if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
      return {
        type: ASTType._AssignmentExpression,
        left: ast.body[0].expression,
        right: { type: ASTType.NGValueParameter },
        operator: "=",
      };
    }

    return undefined;
  }

  function plusFn(left, right) {
    if (typeof left === "undefined" || isObject(left)) return right;

    if (typeof right === "undefined" || isObject(right)) return left;

    return left + right;
  }

  /**
   *
   * @param {import("./ast/ast").ASTNode[]} body
   * @returns {any}
   */
  function getInputs(body) {
    if (body.length !== 1) return undefined;
    const lastExpression = /** @type {DecoratedASTNode} */ (body[0].expression);

    const candidate = lastExpression.toWatch;

    if (candidate.length !== 1) return candidate;

    return candidate[0] !== lastExpression ? candidate : undefined;
  }

  /**
   * Detect nodes which could depend on non-shallow state of objects
   * @param {import("./ast/ast").ASTNode} node
   * @param {boolean|PURITY_ABSOLUTE|PURITY_RELATIVE} parentIsPure
   * @returns {boolean|PURITY_ABSOLUTE|PURITY_RELATIVE}
   */
  function isPure(node, parentIsPure) {
    switch (node.type) {
      // Computed members might invoke a stateful toString()
      case ASTType._MemberExpression:
        if (node.computed) {
          return false;
        }
        break;

      // Unary always convert to primitive
      case ASTType._UnaryExpression:
        return PURITY_ABSOLUTE;

      // The binary + operator can invoke a stateful toString().
      case ASTType._BinaryExpression:
        return node.operator !== "+" ? PURITY_ABSOLUTE : false;

      // Functions / filters probably read state from within objects
      case ASTType._CallExpression:
        return false;
    }

    return undefined === parentIsPure ? PURITY_RELATIVE : parentIsPure;
  }

  function isStateless($filter, filterName) {
    const fn = $filter(filterName);

    return !fn.$stateful;
  }

  /**
   * Converts parameter to  strings property name for use  as keys in an object.
   * Any non-string object, including a number, is typecasted into a string via the toString method.
   * {@link https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names}
   *
   * @param {!any} name
   * @returns {string}
   */
  function getStringValue(name) {
    return `${name}`;
  }

  /**
   * @param {import("./ast/ast").ASTNode} ast
   * @returns {boolean}
   */
  function isAssignable(ast) {
    return (
      ast.type === ASTType._Identifier || ast.type === ASTType._MemberExpression
    );
  }

  /* eslint-disable id-length */
  /* eslint-disable no-magic-numbers */

  /**
   * @typedef {import("./token.ts").Token} Token
   */

  const $parseMinErr$1 = minErr("$parse");

  const ESCAPE = {
    n: "\n",
    f: "\f",
    r: "\r",
    t: "\t",
    v: "\v",
    "'": "'",
    '"': '"',
  };

  const OPERATORS = new Set(
    "+ - * / % === !== == != < > <= >= && || ! = |".split(" "),
  );

  /**
   * @typedef {Object} LexerOptions
   * @property {(ch: string, codePoint: number) => boolean} [isIdentifierStart] - Custom function to determine if a character is a valid identifier start.
   * @property {(ch: string, codePoint: number) => boolean} [isIdentifierContinue] - Custom function to determine if a character is a valid identifier continuation.
   */

  /**
   * Represents a lexer that tokenizes input text. The Lexer takes the original expression string and returns an array of tokens parsed from that string.
   * For example, the string "a + b" would result in tokens for a, +, and b.
   */
  class Lexer {
    /**
     * Creates an instance of Lexer.
     * @param {LexerOptions} options - Lexer options.
     */
    constructor(options) {
      /** @type {LexerOptions} */
      this._options = options;
    }

    /**
     * Tokenizes the input text.
     * @param {string} text Input text to lex.
     * @returns {Array<Token>} Array of tokens.
     */
    _lex(text) {
      this._text = text;
      this._index = 0;
      /** @type {Array<Token>} */
      this._tokens = [];

      while (this._index < this._text.length) {
        const ch = this._text.charAt(this._index);

        if (ch === '"' || ch === "'") {
          this._readString(ch);
        } else if (
          this._isNumber(ch) ||
          (ch === "." && this._isNumber(/** @type {string} */ (this._peek())))
        ) {
          this._readNumber();
        } else if (
          this._isIdentifierStart &&
          this._isIdentifierStart(this._peekMultichar())
        ) {
          this._readIdent();
        } else if (this._is(ch, "(){}[].,;:?")) {
          this._tokens.push({ index: this._index, text: ch });
          this._index++;
        } else if (this._isWhitespace(ch)) {
          this._index++;
        } else {
          const ch2 = ch + this._peek();

          const ch3 = ch2 + this._peek(2);

          const op1 = OPERATORS.has(ch);

          const op2 = OPERATORS.has(ch2);

          const op3 = OPERATORS.has(ch3);

          if (op1 || op2 || op3) {
            const token = op3 ? ch3 : op2 ? ch2 : ch;

            this._tokens.push({
              index: this._index,
              text: token,
              operator: true,
            });
            this._index += token.length;
          } else {
            this._throwError(
              "Unexpected next character ",
              this._index,
              this._index + 1,
            );
          }
        }
      }

      return this._tokens;
    }

    /**
     * Checks if a character is contained in a set of characters.
     * @param {string} ch Character to check.
     * @param {string} chars Set of characters.
     * @returns {boolean} True if character is in the set, false otherwise.
     */
    _is(ch, chars) {
      return chars.indexOf(ch) !== -1;
    }

    /**
     * Peeks at the next character in the text.
     * @param {number} [i=1] Number of characters to peek.
     * @returns {string|false} Next character or false if end of text.
     */
    _peek(i) {
      const num = i || 1;

      return this._index + num < this._text.length
        ? this._text.charAt(this._index + num)
        : false;
    }

    /**
     * Checks if a character is a number.
     * @param {string} ch Character to check.
     * @returns {boolean} True if character is a number, false otherwise.
     */
    _isNumber(ch) {
      return ch >= "0" && ch <= "9" && typeof ch === "string";
    }

    /**
     * Checks if a character is whitespace.
     * @param {string} ch Character to check.
     * @returns {boolean} True if character is whitespace, false otherwise.
     */
    _isWhitespace(ch) {
      return (
        ch === " " || ch === "\r" || ch === "\t" || ch === "\n" || ch === "\v"
      );
    }

    /**
     * Checks if a character is a valid identifier start.
     * @param {string} ch Character to check.
     * @returns {boolean} True if character is a valid identifier start, false otherwise.
     */
    _isIdentifierStart(ch) {
      return this._options.isIdentifierStart
        ? this._options.isIdentifierStart(ch, this._codePointAt(ch))
        : (ch >= "a" && ch <= "z") ||
            (ch >= "A" && ch <= "Z") ||
            ch === "_" ||
            ch === "$";
    }

    /**
     * Checks if a character is a valid identifier continuation.
     * @param {string} ch Character to check.
     * @returns {boolean} True if character is a valid identifier continuation, false otherwise.
     */
    _isIdentifierContinue(ch) {
      return this._options.isIdentifierContinue
        ? this._options.isIdentifierContinue(ch, this._codePointAt(ch))
        : (ch >= "a" && ch <= "z") ||
            (ch >= "A" && ch <= "Z") ||
            ch === "_" ||
            ch === "$" ||
            (ch >= "0" && ch <= "9");
    }

    /**
     * Converts a character to its Unicode code point.
     * @param {string} ch Character to convert.
     * @returns {number} Unicode code point.
     */
    _codePointAt(ch) {
      if (ch.length === 1) return ch.charCodeAt(0);

      return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35fdc00;
    }

    /**
     * Peeks at the next multicharacter sequence in the text.
     * @returns {string} Next multicharacter sequence.
     */
    _peekMultichar() {
      const ch = this._text.charAt(this._index);

      const peek = this._peek();

      if (!peek) {
        return ch;
      }
      const cp1 = ch.charCodeAt(0);

      const cp2 = peek.charCodeAt(0);

      if (cp1 >= 0xd800 && cp1 <= 0xdbff && cp2 >= 0xdc00 && cp2 <= 0xdfff) {
        return ch + peek;
      }

      return ch;
    }

    /**
     * Checks if a character is an exponent operator.
     * @param {string} ch Character to check.
     * @returns {boolean} True if character is an exponent operator, false otherwise.
     */
    _isExpOperator(ch) {
      return ch === "-" || ch === "+" || this._isNumber(ch);
    }

    /**
     * Throws a lexer error.
     * @param {string} error Error message.
     * @param {number} [start] Start index.
     * @param {number} [end] End index.
     * @throws {Error} Lexer error.
     */
    _throwError(error, start, end) {
      end = end || this._index;
      const colStr = isDefined(start)
        ? `s ${start}-${this._index} [${this._text.substring(start, end)}]`
        : ` ${end}`;

      throw $parseMinErr$1(
        "lexerr",
        `Lexer Error: ${error} at column${colStr} in expression [${this._text}].`,
      );
    }

    /**
     * Reads and tokenizes a number from the text.
     * @return {void}
     */
    _readNumber() {
      let number = "";

      const start = this._index;

      while (this._index < this._text.length) {
        const ch = this._text.charAt(this._index).toLowerCase();

        if (ch === "." || this._isNumber(ch)) {
          number += ch;
        } else {
          const peekCh = this._peek();

          if (ch === "e" && this._isExpOperator(/** @type {string} */ (peekCh))) {
            number += ch;
          } else if (
            this._isExpOperator(ch) &&
            peekCh &&
            this._isNumber(peekCh) &&
            number.charAt(number.length - 1) === "e"
          ) {
            number += ch;
          } else if (
            this._isExpOperator(ch) &&
            (!peekCh || !this._isNumber(peekCh)) &&
            number.charAt(number.length - 1) === "e"
          ) {
            this._throwError("Invalid exponent");
          } else {
            break;
          }
        }
        this._index++;
      }
      this._tokens.push({
        index: start,
        text: number,
        constant: true,
        value: Number(number),
      });
    }

    /**
     * Reads and tokenizes an identifier from the text.
     */
    _readIdent() {
      const start = this._index;

      this._index += this._peekMultichar().length;

      while (this._index < this._text.length) {
        const ch = this._peekMultichar();

        if (this._isIdentifierContinue && !this._isIdentifierContinue(ch)) {
          break;
        }
        this._index += ch.length;
      }
      this._tokens.push({
        index: start,
        text: this._text.slice(start, this._index),
        identifier: true,
      });
    }

    /**
     * Reads and tokenizes a string from the text.
     * @param {string} quote Quote character used for the string.
     */
    _readString(quote) {
      const start = this._index;

      let string = "";

      let escape = false;

      this._index++; // Skip opening quote

      while (this._index < this._text.length) {
        const ch = this._text[this._index];

        if (escape) {
          if (ch === "u") {
            // Handle unicode escapes
            // Simplified for brevity
            string += this._handleUnicodeEscape();
          } else {
            string += ESCAPE[ch] || ch;
          }
          escape = false;
        } else if (ch === "\\") {
          escape = true;
        } else if (ch === quote) {
          this._tokens.push({
            index: start,
            text: this._text.slice(start, this._index + 1),
            constant: true,
            value: string,
          });
          this._index++; // Skip closing quote

          return;
        } else {
          string += ch;
        }

        this._index++;
      }

      this._throwError("Unterminated quote", start);
    }

    /**
     * @returns {string}
     */
    _handleUnicodeEscape() {
      const hex = this._text.substring(this._index + 1, this._index + 5);

      if (!hex.match(/[\da-f]{4}/i)) {
        this._throwError(`Invalid unicode escape [\\u${hex}]`);
      }
      this._index += 4; // Move index past the four hexadecimal digits

      return String.fromCharCode(parseInt(hex, 16));
    }
  }

  /**
   * @typedef {import("./ast-node.ts").ASTNode} ASTNode
   * @typedef {import("../lexer/token.js").Token} Token
   */

  const $parseMinErr = minErr("$parse");

  const literals = {
    true: true,
    false: false,
    null: null,
    undefined,
  };

  /**
   * @class
   */
  class AST {
    /**
     * @param {import('../lexer/lexer.js').Lexer} lexer - The lexer instance for tokenizing input
     */
    constructor(lexer) {
      /** @type {import('../lexer/lexer.js').Lexer} */
      this._lexer = lexer;
      this._selfReferential = {
        this: { type: ASTType._ThisExpression },
        $locals: { type: ASTType._LocalsExpression },
      };
      this._index = 0;
    }

    /**
     * Parses the input text and generates an AST.
     * @param {string} text - The input text to parse.
     * @returns {ASTNode} The root node of the AST.
     */
    _ast(text) {
      this._text = text;
      this._tokens = this._lexer._lex(text);

      const value = this._program();

      if (this._tokens.length > this._index) {
        this._throwError("is an unexpected token", this._tokens[this._index]);
      }

      return value;
    }

    /**
     * Parses a program.
     * @returns {ASTNode} The program node.
     */
    _program() {
      const body = [];

      let hasMore = true;

      while (hasMore) {
        if (this._tokens.length > this._index && !this._peek("}", ")", ";", "]"))
          body.push(this._expressionStatement());

        if (!this._expect(";")) {
          hasMore = false;
        }
      }

      return { type: ASTType._Program, body };
    }

    /**
     * Parses an expression statement.
     * @returns {ASTNode} The expression statement node.
     */
    _expressionStatement() {
      return {
        type: ASTType._ExpressionStatement,
        expression: this._filterChain(),
      };
    }

    /**
     * Parses a filter chain.
     * @returns {ASTNode} The filter chain node.
     */
    _filterChain() {
      let left = this._assignment();

      while (this._expect("|")) {
        left = this._filter(left);
      }

      return left;
    }

    /**
     * Parses an assignment expression.
     * @returns {ASTNode} The assignment expression node.
     */
    _assignment() {
      let result = this._ternary();

      if (this._expect("=")) {
        if (!isAssignable(result)) {
          throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
        }

        result = {
          type: ASTType._AssignmentExpression,
          left: result,
          right: this._assignment(),
          operator: "=",
        };
      }

      return result;
    }

    /**
     * Parses a ternary expression.
     * @returns {ASTNode} The ternary expression node.
     */
    _ternary() {
      const test = this._logicalOR();

      if (this._expect("?")) {
        const alternate = this._assignment();

        if (this._consume(":")) {
          const consequent = this._assignment();

          return {
            type: ASTType._ConditionalExpression,
            test,
            alternate,
            consequent,
          };
        }
      }

      return test;
    }

    /**
     * Parses a logical OR expression.
     * @returns {ASTNode} The logical OR expression node.
     */
    _logicalOR() {
      let left = this._logicalAND();

      while (this._expect("||")) {
        left = {
          type: ASTType._LogicalExpression,
          operator: "||",
          left,
          right: this._logicalAND(),
        };
      }

      return left;
    }

    /**
     * Parses a logical AND expression.
     * @returns {ASTNode} The logical AND expression node.
     */
    _logicalAND() {
      let left = this._equality();

      while (this._expect("&&")) {
        left = {
          type: ASTType._LogicalExpression,
          operator: "&&",
          left,
          right: this._equality(),
        };
      }

      return left;
    }

    /**
     * Parses an equality expression.
     * @returns {ASTNode} The equality expression node.
     */
    _equality() {
      let left = this._relational();

      let token;

      while ((token = this._expect("==", "!=", "===", "!=="))) {
        left = {
          type: ASTType._BinaryExpression,
          operator: /** @type {Token} */ (token).text,
          left,
          right: this._relational(),
        };
      }

      return left;
    }

    /**
     * Parses a relational expression.
     * @returns {ASTNode} The relational expression node.
     */
    _relational() {
      let left = this._additive();

      let token;

      while ((token = this._expect("<", ">", "<=", ">="))) {
        left = {
          type: ASTType._BinaryExpression,
          operator: /** @type {Token} */ (token).text,
          left,
          right: this._additive(),
        };
      }

      return left;
    }

    /**
     * Parses an additive expression.
     * @returns {ASTNode} The additive expression node.
     */
    _additive() {
      let left = this._multiplicative();

      let token;

      while ((token = this._expect("+", "-"))) {
        left = {
          type: ASTType._BinaryExpression,
          operator: /** @type {Token} */ (token).text,
          left,
          right: this._multiplicative(),
        };
      }

      return left;
    }

    /**
     * Parses a multiplicative expression.
     * @returns {ASTNode} The multiplicative expression node.
     */
    _multiplicative() {
      let left = this._unary();

      let token;

      while ((token = this._expect("*", "/", "%"))) {
        left = {
          type: ASTType._BinaryExpression,
          operator: /** @type {import("../lexer/lexer.js").Token} */ (token).text,
          left,
          right: this._unary(),
        };
      }

      return left;
    }

    /**
     * Parses a unary expression.
     * @returns {ASTNode} The unary expression node.
     */
    _unary() {
      let token;

      if ((token = this._expect("+", "-", "!"))) {
        return {
          type: ASTType._UnaryExpression,
          operator: /** @type {import("../lexer/lexer.js").Token} */ (token).text,
          prefix: true,
          argument: this._unary(),
        };
      }

      return this._primary();
    }

    /**
     * Parses a primary expression.
     * @returns {ASTNode} The primary expression node.
     */
    _primary() {
      let primary;

      if (this._expect("(")) {
        primary = this._filterChain();
        this._consume(")");
      } else if (this._expect("[")) {
        primary = this._arrayDeclaration();
      } else if (this._expect("{")) {
        primary = this._object();
      } else if (
        hasOwn(
          this._selfReferential,
          /** @type {import("../lexer/lexer.js").Token} */ (this._peek()).text,
        )
      ) {
        primary = structuredClone(this._selfReferential[this._consume().text]);
      } else if (
        hasOwn(
          literals,
          /** @type {import("../lexer/lexer.js").Token} */ (this._peek()).text,
        )
      ) {
        primary = {
          type: ASTType._Literal,
          value: literals[this._consume().text],
        };
      } else if (
        /** @type {import("../lexer/lexer.js").Token} */ (this._peek()).identifier
      ) {
        primary = this._identifier();
      } else if (
        /** @type {import("../lexer/lexer.js").Token} */ (this._peek()).constant
      ) {
        primary = this._constant();
      } else {
        this._throwError(
          "not a primary expression",
          /** @type {import("../lexer/lexer.js").Token} */ (this._peek()),
        );
      }

      let next;

      while ((next = this._expect("(", "[", "."))) {
        if (
          /** @type {import("../lexer/lexer.js").Token} */ (next).text === "("
        ) {
          primary = {
            type: ASTType._CallExpression,
            callee: primary,
            arguments: this._parseArguments(),
          };
          this._consume(")");
        } else if (
          /** @type {import("../lexer/lexer.js").Token} */ (next).text === "["
        ) {
          primary = {
            type: ASTType._MemberExpression,
            object: primary,
            property: this._assignment(),
            computed: true,
          };
          this._consume("]");
        } else if (
          /** @type {import("../lexer/lexer.js").Token} */ (next).text === "."
        ) {
          primary = {
            type: ASTType._MemberExpression,
            object: primary,
            property: this._identifier(),
            computed: false,
          };
        } else {
          this._throwError("IMPOSSIBLE");
        }
      }

      return primary;
    }

    /**
     * Parses a filter.
     * @param {ASTNode} baseExpression - The base expression to apply the filter to.
     * @returns {ASTNode} The filter node.
     */
    _filter(baseExpression) {
      /** @type {ASTNode[]} */
      const args = [baseExpression];

      const result = {
        type: ASTType._CallExpression,
        callee: this._identifier(),
        arguments: args,
        filter: true,
      };

      while (this._expect(":")) {
        args.push(this._assignment());
      }

      return result;
    }

    /**
     * Parses function arguments.
     * @returns {ASTNode[]} The arguments array.
     */
    _parseArguments() {
      /** @type {ASTNode[]} */
      const args = [];

      if (this._peekToken().text !== ")") {
        do {
          args.push(this._filterChain());
        } while (this._expect(","));
      }

      return args;
    }

    /**
     * Parses an identifier.
     * @returns {ASTNode} The identifier node.
     */
    _identifier() {
      const token = this._consume();

      if (!token.identifier) {
        this._throwError("is not a valid identifier", token);
      }

      return { type: ASTType._Identifier, name: token.text };
    }

    /**
     * Parses a constant.
     * @returns {ASTNode} The constant node.
     */
    _constant() {
      // TODO check that it is a constant
      return { type: ASTType._Literal, value: this._consume().value };
    }

    /**
     * Parses an array declaration.
     * @returns {ASTNode} The array declaration node.
     */
    _arrayDeclaration() {
      /** @type {ASTNode[]} */
      const elements = [];

      if (this._peekToken().text !== "]") {
        do {
          if (this._peek("]")) {
            // Support trailing commas per ES5.1.
            break;
          }
          elements.push(this._assignment());
        } while (this._expect(","));
      }
      this._consume("]");

      return { type: ASTType._ArrayExpression, elements };
    }

    /**
     * Parses an object.
     * @returns {ASTNode} The object node.
     */
    _object() {
      /** @type {ASTNode[]} */
      const properties = [];

      /** @type {ASTNode} */
      let property;

      if (this._peekToken().text !== "}") {
        do {
          if (this._peek("}")) {
            // Support trailing commas per ES5.1.
            break;
          }
          property = { type: ASTType._Property, kind: "init" };

          if (
            /** @type {import("../lexer/lexer.js").Token} */ (this._peek())
              .constant
          ) {
            property.key = this._constant();
            property.computed = false;
            this._consume(":");
            property.value = this._assignment();
          } else if (
            /** @type {import("../lexer/lexer.js").Token} */ (this._peek())
              .identifier
          ) {
            property.key = this._identifier();
            property.computed = false;

            if (this._peek(":")) {
              this._consume(":");
              property.value = this._assignment();
            } else {
              property.value = property.key;
            }
          } else if (this._peek("[")) {
            this._consume("[");
            property.key = this._assignment();
            this._consume("]");
            property.computed = true;
            this._consume(":");
            property.value = this._assignment();
          } else {
            this._throwError(
              "invalid key",
              /** @type {import("../lexer/lexer.js").Token} */ (this._peek()),
            );
          }
          properties.push(property);
        } while (this._expect(","));
      }
      this._consume("}");

      return { type: ASTType._ObjectExpression, properties };
    }

    /**
     * Throws a syntax error.
     * @param {string} msg - The error message.
     * @param {import("../lexer/lexer.js").Token} [token] - The token that caused the error.
     */
    _throwError(msg, token) {
      throw $parseMinErr(
        "syntax",
        "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].",
        token.text,
        msg,
        token.index + 1,
        this._text,
        this._text.substring(token.index),
      );
    }

    /**
     * Consumes a token if it matches the expected type.
     * @param {string} [e1] - The expected token type.
     * @returns {import("../lexer/lexer.js").Token} The consumed token.
     */
    _consume(e1) {
      if (this._tokens.length === this._index) {
        throw $parseMinErr(
          "ueoe",
          "Unexpected end of expression: {0}",
          this._text,
        );
      }

      const token = this._expect(e1);

      if (!token) {
        this._throwError(
          `is unexpected, expecting [${e1}]`,
          /** @type {import("../lexer/lexer.js").Token} */ (this._peek()),
        );
      } else {
        return /** @type  {import("../lexer/lexer.js").Token} */ (token);
      }

      return undefined;
    }

    /**
     * Returns the next token without consuming it.
     * @returns {import("../lexer/lexer.js").Token} The next token.
     */
    _peekToken() {
      if (this._tokens.length === this._index) {
        throw $parseMinErr(
          "ueoe",
          "Unexpected end of expression: {0}",
          this._text,
        );
      }

      return this._tokens[this._index];
    }

    /**
     * Checks if the next token matches any of the expected types.
     * @param {...string} [expected] - The expected token types.
     * @returns {import('../lexer/lexer.js').Token|boolean} The next token if it matches, otherwise false.
     */
    _peek(...expected) {
      const token = this._tokens[this._index];

      const j = expected.length;

      if (!token || !j) return token;

      const txt = token.text;

      for (let i = 0; i < j; i++) {
        if (expected[i] === txt || !expected[i]) return token;
      }

      return false;
    }

    /**
     * Consumes the next token if it matches any of the expected types.
     * @param {...string} [expected] - The expected token types.
     * @returns {import("../lexer/lexer.js").Token|boolean} The consumed token if it matches, otherwise false.
     */
    _expect(...expected) {
      const token = this._peek(...expected);

      if (token) {
        this._index++;

        return token;
      }

      return false;
    }
  }

  /**
   * @typedef {Object} ParsedAST
   * @property {import("../ast/ast-node.d.ts").ASTNode} ast - AST representation of expression
   */

  /**
   * @constructor
   */
  class Parser {
    /**
     *
     * @param {import('../lexer/lexer.js').Lexer} lexer
     * @param {function(any):any} $filter
     */
    constructor(lexer, $filter) {
      /** @type {AST} */
      this._ast = new AST(lexer);

      /** @type {ASTInterpreter} */
      this._astCompiler = new ASTInterpreter($filter);
    }

    /**
     * @param {string} exp - Expression to be parsed
     * @returns {import("../interface.ts").CompiledExpression}
     */
    _parse(exp) {
      const { ast } = this.#getAst(exp);

      const fn = this._astCompiler.compile(ast);

      fn.literal = isLiteral(ast);
      fn.constant = isConstant(ast);

      return fn;
    }

    /**
     * @param {string} exp - Expression to be parsed
     * @returns {ParsedAST}
     */
    #getAst(exp) {
      exp = exp.trim();

      return {
        ast: this._ast._ast(exp),
      };
    }
  }

  function isLiteral(ast) {
    return (
      ast.body.length === 0 ||
      (ast.body.length === 1 &&
        (ast.body[0].expression.type === ASTType._Literal ||
          ast.body[0].expression.type === ASTType._ArrayExpression ||
          ast.body[0].expression.type === ASTType._ObjectExpression))
    );
  }

  function isConstant(ast) {
    return ast.constant;
  }

  class ParseProvider {
    constructor() {
      const cache = Object.create(null);

      /** @type {function(any):boolean?} */
      let identStart;

      /** @type {function(any):boolean?} */
      let identContinue;

      /**
       * Allows defining the set of characters that are allowed in AngularTS expressions. The function
       * `identifierStart` will get called to know if a given character is a valid character to be the
       * first character for an identifier. The function `identifierContinue` will get called to know if
       * a given character is a valid character to be a follow-up identifier character. The functions
       * `identifierStart` and `identifierContinue` will receive as arguments the single character to be
       * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in
       * mind that the `string` parameter can be two characters long depending on the character
       * representation. It is expected for the function to return `true` or `false`, whether that
       * character is allowed or not.
       *
       * Since this function will be called extensively, keep the implementation of these functions fast,
       * as the performance of these functions have a direct impact on the expressions parsing speed.
       *
       * @param {function(any):boolean} [identifierStart] The function that will decide whether the given character is
       *   a valid identifier start character.
       * @param {function(any):boolean} [identifierContinue] The function that will decide whether the given character is
       *   a valid identifier continue character.
       * @returns {ParseProvider}
       */
      this.setIdentifierFns = function (identifierStart, identifierContinue) {
        identStart = identifierStart;
        identContinue = identifierContinue;

        return this;
      };

      this.$get = [
        $injectTokens._filter,
        /**
         *
         * @param {(any) => any} $filter
         * @returns {import('./interface').ParseService}
         */
        function ($filter) {
          /** @type {import("./lexer/lexer.js").LexerOptions} */
          const $lexerOptions = {
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue,
          };

          return $parse;

          /**
           * @param {string} exp
           * @param interceptorFn
           * @returns any
           */
          function $parse(exp, interceptorFn) {
            let parsedExpression, cacheKey;

            switch (typeof exp) {
              case "string":
                exp = exp.trim();
                cacheKey = exp;

                parsedExpression = cache[cacheKey];

                if (!parsedExpression) {
                  const lexer = new Lexer($lexerOptions);

                  const parser = new Parser(lexer, $filter);

                  parsedExpression = parser._parse(exp);

                  cache[cacheKey] = addWatchDelegate(parsedExpression);
                }

                return addInterceptor(parsedExpression, interceptorFn);

              case "function":
                return addInterceptor(exp, interceptorFn);

              default:
                return addInterceptor(() => {
                  /* empty */
                }, interceptorFn);
            }
          }

          /**
           * @param {Function} parsedExpression
           * @param interceptorFn
           * @returns {import('./interface').CompiledExpression|*}
           */
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn) {
              return parsedExpression;
            }

            // Extract any existing interceptors out of the parsedExpression
            // to ensure the original parsedExpression is always the $$intercepted
            // @ts-ignore
            if (parsedExpression.$$interceptor) {
              interceptorFn = chainInterceptors(
                // @ts-ignore
                parsedExpression.$$interceptor,
                interceptorFn,
              );
              // @ts-ignore
              parsedExpression = parsedExpression.$$intercepted;
            }

            let useInputs = false;

            const fn = function interceptedExpression(
              scope,
              locals,
              assign,
              inputs,
            ) {
              const value =
                useInputs && inputs
                  ? inputs[0]
                  : parsedExpression(scope, locals, assign, inputs);

              // Do not invoke for getters
              if (scope?.getter) {
                return undefined;
              }
              const res = isFunction(value) ? value() : value;

              return interceptorFn(deProxy(res));
            };

            // Maintain references to the interceptor/intercepted
            fn.$$intercepted = parsedExpression;
            fn.$$interceptor = interceptorFn;

            // Propagate the literal/oneTime/constant attributes
            // @ts-ignore
            fn.literal = parsedExpression.literal;
            // @ts-ignore
            fn.oneTime = parsedExpression.oneTime;
            // @ts-ignore
            fn.constant = parsedExpression.constant;
            // @ts-ignore
            fn.decoratedNode = parsedExpression.decoratedNode;

            // Treat the interceptor like filters.
            // If it is not $stateful then only watch its inputs.
            // If the expression itself has no inputs then use the full expression as an input.
            if (!interceptorFn.$stateful) {
              // @ts-ignore
              useInputs = !parsedExpression.inputs;
              // @ts-ignore
              fn.inputs = parsedExpression.inputs
                ? // @ts-ignore
                  parsedExpression.inputs
                : [parsedExpression];

              if (!interceptorFn.$$pure) {
                fn.inputs = fn.inputs.map(function (input) {
                  // Remove the isPure flag of inputs when it is not absolute because they are now wrapped in a
                  // non-pure interceptor function.
                  if (input.isPure === PURITY_RELATIVE) {
                    return function depurifier(x) {
                      return input(x);
                    };
                  }

                  return input;
                });
              }
            }

            return addWatchDelegate(fn);
          }
        },
      ];
    }
  }

  function constantWatchDelegate(
    scope,
    listener,
    objectEquality,
    parsedExpression,
  ) {
    const unwatch = scope.$watch(
      () => {
        unwatch();

        return parsedExpression(scope);
      },
      listener,
      objectEquality,
    );

    return unwatch;
  }

  /**
   *
   * @param {import('./interface.ts').CompiledExpression} parsedExpression
   * @returns {import('./interface.ts').CompiledExpression}
   */
  function addWatchDelegate(parsedExpression) {
    if (parsedExpression.constant) {
      parsedExpression.$$watchDelegate = constantWatchDelegate;
    } else if (parsedExpression.inputs) {
      parsedExpression.$$watchDelegate = inputsWatchDelegate;
    }

    return parsedExpression;
  }

  /**
   *
   * @param {ng.Scope} scope
   * @param {Function} listener
   * @param {*} objectEquality
   * @param {import('./interface').CompiledExpression} parsedExpression
   * @returns {any}
   */
  function inputsWatchDelegate(
    scope,
    listener,
    objectEquality,
    parsedExpression,
  ) {
    const inputExpressions = /** @type {Function} */ (parsedExpression.inputs);

    let lastResult;

    if (inputExpressions.length === 1) {
      let oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails

      const inputExpression = inputExpressions[0];

      return scope.$watch(
        // @ts-ignore
        ($scope) => {
          const newInputValue = inputExpression($scope);

          if (
            !expressionInputDirtyCheck(
              newInputValue,
              oldInputValueOf,
              inputExpression.isPure,
            )
          ) {
            lastResult = parsedExpression($scope, undefined, [newInputValue]);
            oldInputValueOf = newInputValue && getValueOf(newInputValue);
          }

          return lastResult;
        },
        listener,
        objectEquality,
      );
    } else {

      for (let i = 0, ii = inputExpressions.length; i < ii; i++) {
      }

      // return scope.$watch(
      //   // @ts-ignore
      //   (scope) => {
      //     debugger
      //     let changed = false;

      //     for (let i = 0, ii = inputExpressions.length; i < ii; i++) {
      //       const newInputValue = inputExpressions[i](scope);

      //       if (
      //         changed ||
      //         (changed = !expressionInputDirtyCheck(
      //           newInputValue,
      //           oldInputValueOfValues[i],
      //           inputExpressions[i].isPure,
      //         ))
      //       ) {
      //         oldInputValues[i] = newInputValue;
      //         oldInputValueOfValues[i] =
      //           newInputValue && getValueOf(newInputValue);
      //       }
      //     }

      //     if (changed) {
      //       lastResult = parsedExpression(scope, undefined, oldInputValues);
      //     }

      //     return lastResult;
      //   },
      //   listener,
      //   objectEquality,
      // );
      return undefined;
    }
  }

  function chainInterceptors(first, second) {
    function chainedInterceptor(value) {
      return second(first(value));
    }
    chainedInterceptor.$stateful = first.$stateful || second.$stateful;
    chainedInterceptor.$$pure = first.$$pure && second.$$pure;

    return chainedInterceptor;
  }

  function expressionInputDirtyCheck(
    newValue,
    oldValueOfValue,
    compareObjectIdentity,
  ) {
    if (isNullOrUndefined(newValue) || isNullOrUndefined(oldValueOfValue)) {
      // null/undefined
      return newValue === oldValueOfValue;
    }

    if (typeof newValue === "object") {
      // attempt to convert the value to a primitive type
      // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can
      //             be cheaply dirty-checked
      newValue = getValueOf(newValue);

      if (typeof newValue === "object" && !compareObjectIdentity) {
        // objects/arrays are not supported - deep-watching them would be too expensive
        return false;
      }

      // fall-through to the primitive equality check
    }

    // Primitive or NaN

    return (
      newValue === oldValueOfValue ||
      (Number.isNaN(newValue) && Number.isNaN(oldValueOfValue))
    );
  }

  function getValueOf(value) {
    return isFunction(value.valueOf)
      ? value.valueOf()
      : {}.constructor.prototype.valueOf.call(value);
  }

  const $interpolateMinErr = minErr("$interpolate");

  function throwNoconcat(text) {
    throw $interpolateMinErr(
      "noconcat",
      "Error while interpolating: {0}\nStrict Contextual Escaping disallows " +
        "interpolations that concatenate multiple expressions when a trusted value is " +
        "required.  See http://docs.angularjs.org/api/ng.$sce",
      text,
    );
  }

  function interr(text, err) {
    throw $interpolateMinErr(
      "interr",
      "Can't interpolate: {0}\n{1}",
      text,
      err.toString(),
    );
  }

  /**
   *
   * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.
   *
   * <div class="alert alert-danger">
   * This feature is sometimes used to mix different markup languages, e.g. to wrap an AngularTS
   * template within a Python Jinja template (or any other template language). Mixing templating
   * languages is **very dangerous**. The embedding template language will not safely escape AngularTS
   * expressions, so any user-controlled values in the template will cause Cross Site Scripting (XSS)
   * security bugs!
   * </div>
   */
  class InterpolateProvider {
    constructor() {
      /**
       * @type {string} Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
       */
      this.startSymbol = "{{";

      /**
       * @type {string} Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
       */
      this.endSymbol = "}}";
    }

    $get = [
      $injectTokens._parse,
      $injectTokens._sce,
      /**
       *
       * @param {ng.ParseService} $parse
       * @param {*} $sce
       * @returns {ng.InterpolateService}
       */
      ($parse, $sce) => {
        /** @type {InterpolateProvider} */
        const provider = this;

        const startSymbolLength = provider.startSymbol.length;

        const endSymbolLength = provider.endSymbol.length;

        const escapedStartRegexp = new RegExp(
          provider.startSymbol.replace(/./g, escape),
          "g",
        );

        const escapedEndRegexp = new RegExp(
          provider.endSymbol.replace(/./g, escape),
          "g",
        );

        function escape(ch) {
          return `\\\\\\${ch}`;
        }

        function unescapeText(text) {
          return text
            .replace(escapedStartRegexp, provider.startSymbol)
            .replace(escapedEndRegexp, provider.endSymbol);
        }

        /**
         *
         * Compiles a string with markup into an interpolation function. This service is used by the
         * HTML {@link ng.$compile $compile} service for data binding. See
         * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
         * interpolation markup.
         *
         *
         * ```js
         *   let $interpolate = ...; // injected
         *   let exp = $interpolate('Hello {{name | uppercase}}!');
         *   expect(exp({name:'AngularTS'})).toEqual('Hello ANGULARJS!');
         * ```
         *
         * `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is
         * `true`, the interpolation function will return `undefined` unless all embedded expressions
         * evaluate to a value other than `undefined`.
         *
         * ```js
         *   let $interpolate = ...; // injected
         *   let context = {greeting: 'Hello', name: undefined };
         *
         *   // default "forgiving" mode
         *   let exp = $interpolate('{{greeting}} {{name}}!');
         *   expect(exp(context)).toEqual('Hello !');
         *
         *   // "allOrNothing" mode
         *   exp = $interpolate('{{greeting}} {{name}}!', false, null, true);
         *   expect(exp(context)).toBeUndefined();
         *   context.name = 'AngularTS';
         *   expect(exp(context)).toEqual('Hello AngularTS!');
         * ```
         *
         * `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.
         *
         * #### Escaped Interpolation
         * $interpolate provides a mechanism for escaping interpolation markers. Start and end markers
         * can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).
         * It will be rendered as a regular start/end marker, and will not be interpreted as an expression
         * or binding.
         *
         * This enables web-servers to prevent script injection attacks and defacing attacks, to some
         * degree, while also enabling code examples to work without relying on the
         * {@link ng.directive:ngNonBindable ngNonBindable} directive.
         *
         * **For security purposes, it is strongly encouraged that web servers escape user-supplied data,
         * replacing angle brackets (&lt;, &gt;) with &amp;lt; and &amp;gt; respectively, and replacing all
         * interpolation start/end markers with their escaped counterparts.**
         *
         * Escaped interpolation markers are only replaced with the actual interpolation markers in rendered
         * output when the $interpolate service processes the text. So, for HTML elements interpolated
         * by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter
         * set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,
         * this is typically useful only when user-data is used in rendering a template from the server, or
         * when otherwise untrusted data is used by a directive.
         *
         * <example name="interpolation">
         *  <file name="index.html">
         *    <div ng-init="username='A user'">
         *      <p ng-init="apptitle='Escaping demo'">{{apptitle}}: \{\{ username = "defaced value"; \}\}
         *        </p>
         *      <p><strong>{{username}}</strong> attempts to inject code which will deface the
         *        application, but fails to accomplish their task, because the server has correctly
         *        escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)
         *        characters.</p>
         *      <p>Instead, the result of the attempted script injection is visible, and can be removed
         *        from the database by an administrator.</p>
         *    </div>
         *  </file>
         * </example>
         *
         * @knownIssue
         * It is currently not possible for an interpolated expression to contain the interpolation end
         * symbol. For example, `{{ '}}' }}` will be incorrectly interpreted as `{{ ' }}` + `' }}`, i.e.
         * an interpolated expression consisting of a single-quote (`'`) and the `' }}` string.
         *
         * @knownIssue
         * All directives and components must use the standard `{{` `}}` interpolation symbols
         * in their templates. If you change the application interpolation symbols the {@link $compile}
         * service will attempt to denormalize the standard symbols to the custom symbols.
         * The denormalization process is not clever enough to know not to replace instances of the standard
         * symbols where they would not normally be treated as interpolation symbols. For example in the following
         * code snippet the closing braces of the literal object will get incorrectly denormalized:
         *
         * ```
         * <div data-context='{"context":{"id":3,"type":"page"}}">
         * ```
         *
         * The workaround is to ensure that such instances are separated by whitespace:
         * ```
         * <div data-context='{"context":{"id":3,"type":"page"} }">
         * ```
         *
         * See https://github.com/angular/angular.js/pull/14610#issuecomment-219401099 for more information.
         *
         * @param {string} text The text with markup to interpolate.
         * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
         *    embedded expression in order to return an interpolation function. Strings with no
         *    embedded expression will return null for the interpolation function.
         * @param {string=} trustedContext when provided, the returned function passes the interpolated
         *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,
         *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that
         *    provides Strict Contextual Escaping for details.
         * @param {boolean=} allOrNothing if `true`, then the returned function returns undefined
         *    unless all embedded expressions evaluate to a value other than `undefined`.
         * @returns {Function} an interpolation function which is used to compute the
         *    interpolated string. The function has these parameters:
         *
         * - `context`: evaluation context for all expressions embedded in the interpolated text
         */
        function $interpolate(
          text,
          mustHaveExpression,
          trustedContext,
          allOrNothing,
        ) {
          const contextAllowsConcatenation =
            trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;

          // Provide a quick exit and simplified result function for text with no interpolation
          if (!text.length || text.indexOf(provider.startSymbol) === -1) {
            if (mustHaveExpression) return undefined;

            let unescapedText = unescapeText(text);

            if (contextAllowsConcatenation) {
              unescapedText = $sce.getTrusted(trustedContext, unescapedText);
            }

            /**
             * @type {any}
             */
            const constantInterp = () => unescapedText;

            constantInterp.exp = text;
            constantInterp.expressions = [];
            constantInterp.$$watchDelegate = constantWatchDelegate;

            return constantInterp;
          }

          allOrNothing = !!allOrNothing;
          let startIndex;

          let endIndex;

          let index = 0;

          const expressions = [];

          const textLength = text.length;

          let exp;

          const concat = [];

          const expressionPositions = [];

          while (index < textLength) {
            if (
              (startIndex = text.indexOf(provider.startSymbol, index)) !== -1 &&
              (endIndex = text.indexOf(
                provider.endSymbol,
                startIndex + startSymbolLength,
              )) !== -1
            ) {
              if (index !== startIndex) {
                concat.push(unescapeText(text.substring(index, startIndex)));
              }
              exp = text.substring(startIndex + startSymbolLength, endIndex);
              expressions.push(exp);
              index = endIndex + endSymbolLength;
              expressionPositions.push(concat.length);
              concat.push(""); // Placeholder that will get replaced with the evaluated expression.
            } else {
              // we did not find an interpolation, so we have to add the remainder to the separators array
              if (index !== textLength) {
                concat.push(unescapeText(text.substring(index)));
              }
              break;
            }
          }

          const singleExpression =
            concat.length === 1 && expressionPositions.length === 1;

          // Intercept expression if we need to stringify concatenated inputs, which may be SCE trusted
          // objects rather than simple strings
          // (we don't modify the expression if the input consists of only a single trusted input)
          const interceptor =
            contextAllowsConcatenation && singleExpression
              ? undefined
              : parseStringifyInterceptor;

          const parseFns = expressions.map((x) => $parse(x, interceptor));

          // Concatenating expressions makes it hard to reason about whether some combination of
          // concatenated values are unsafe to use and could easily lead to XSS.  By requiring that a
          // single expression be used for some $sce-managed secure contexts (RESOURCE_URLs mostly),
          // we ensure that the value that's used is assigned or constructed by some JS code somewhere
          // that is more testable or make it obvious that you bound the value to some user controlled
          // value.  This helps reduce the load when auditing for XSS issues.

          // Note that URL and MEDIA_URL $sce contexts do not need this, since `$sce` can sanitize the values
          // passed to it. In that case, `$sce.getTrusted` will be called on either the single expression
          // or on the overall concatenated string (losing trusted types used in the mix, by design).
          // Both these methods will sanitize plain strings. Also, HTML could be included, but since it's
          // only used in srcdoc attributes, this would not be very useful.

          if (!mustHaveExpression || expressions.length) {
            const compute = function (values) {
              for (let i = 0, ii = expressions.length; i < ii; i++) {
                if (allOrNothing && isUndefined(values[i])) return undefined;
                concat[expressionPositions[i]] = values[i];
              }

              if (contextAllowsConcatenation) {
                // If `singleExpression` then `concat[0]` might be a "trusted" value or `null`, rather than a string
                return $sce.getTrusted(
                  trustedContext,
                  singleExpression ? concat[0] : concat.join(""),
                );
              }

              if (trustedContext && concat.length > 1) {
                // This context does not allow more than one part, e.g. expr + string or exp + exp.
                throwNoconcat(text);
              }

              // In an unprivileged context or only one part: just concatenate and return.
              return concat.join("");
            };

            return /**@type {import("./interface.ts").InterpolationFunction}  */ extend(
              (context, cb) => {
                let i = 0;

                const ii = expressions.length;

                const values = new Array(ii);

                try {
                  for (; i < ii; i++) {
                    if (cb) {
                      const watchProp = expressions[i].trim();

                      context.$watch(watchProp, () => {
                        const vals = new Array(ii);

                        let j = 0;

                        for (; j < ii; j++) {
                          const fn = parseFns[j];

                          vals[j] = fn(context);
                        }
                        cb(compute(vals));
                      });
                    }

                    values[i] = parseFns[i](context);
                  }

                  return compute(values);
                } catch (err) {
                  return interr(text, err);
                }
              },
              {
                // Most likely we would need to register watches during interpolation
                // all of these properties are undocumented for now
                exp: text, // just for compatibility with regular watchers created via $watch
                expressions,
                $$watchDelegate(scope, listener) {
                  let lastValue;

                  return scope.$watch(
                    parseFns,
                    function interpolateFnWatcher(values, oldValues) {
                      const currValue = compute(values);

                      listener.call(
                        provider,
                        currValue,
                        values !== oldValues ? lastValue : currValue,
                        scope,
                      );
                      lastValue = currValue;
                    },
                  );
                },
              },
            );
          }

          function parseStringifyInterceptor(value) {
            try {
              // In concatenable contexts, getTrusted comes at the end, to avoid sanitizing individual
              // parts of a full URL. We don't care about losing the trustedness here.
              // In non-concatenable contexts, where there is only one expression, this interceptor is
              // not applied to the expression.
              value =
                trustedContext && !contextAllowsConcatenation
                  ? $sce.getTrusted(trustedContext, value)
                  : $sce.valueOf(value);

              return allOrNothing && !isDefined(value) ? value : stringify$1(value);
            } catch (err) {
              return interr(text, err);
            }
          }

          return undefined;
        }

        /**
         * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.
         *
         * Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change
         * the symbol.
         *
         * @returns {string} start symbol.
         */
        $interpolate.startSymbol = function () {
          return provider.startSymbol;
        };

        /**
         * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
         *
         * Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change
         * the symbol.
         *
         * @returns {string} end symbol.
         */
        $interpolate.endSymbol = function () {
          return provider.endSymbol;
        };

        // @ts-ignore
        return $interpolate;
      },
    ];
  }

  const PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/;

  const $locationMinErr = minErr("$location");

  let urlUpdatedByLocation = false;

  /**
   * @ignore
   * The pathname, beginning with "/"
   * @type {string}
   */
  let $$path;

  /**
   * @type {Object.<string,boolean|Array>}
   */
  let $$search;

  /**
   * @ignore
   * The hash string, minus the hash symbol
   * @type {string}
   */
  let $$hash;

  class Location {
    /**
     * @param {string} appBase application base URL
     * @param {string} appBaseNoFile application base URL stripped of any filename
     * @param {boolean} [html5] Defaults to true
     * @param {string} [prefix] URL path prefix for html5 mode or hash prefix for hashbang mode
     */
    constructor(appBase, appBaseNoFile, html5 = true, prefix) {
      /** @type {string} */
      this.appBase = appBase;

      /** @type {string} */
      this.appBaseNoFile = appBaseNoFile;

      /** @type {boolean} */
      this.html5 = html5;

      /** @type {string | undefined} */
      this.basePrefix = html5 ? prefix || "" : undefined;

      /** @type {string | undefined} */
      this.hashPrefix = html5 ? undefined : prefix;

      /**
       * An absolute URL is the full URL, including protocol (http/https ), the optional subdomain (e.g. www ), domain (example.com), and path (which includes the directory and slug)
       * with all segments encoded according to rules specified in [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).
       * @type {string}
       */
      this.absUrl = "";

      /**
       * @ignore
       * Current url
       * @type {string}
       */
      this.$$url = undefined;

      /**
       * @ignore
       * Callback to update browser url
       * @type {Function}
       */
      this.$$updateBrowser = undefined;
    }

    /**
     * Change path, search and hash, when called with parameter and return `$location`.
     *
     * @param {string} url New URL without base prefix (e.g. `/path?a=b#hash`)
     * @return {Location} url
     */
    setUrl(url) {
      const match = PATH_MATCH.exec(url);

      if (match[1] !== undefined || url === "") {
        this.setPath(match[1] || "");
      }

      if (match[2] !== undefined || match[1] !== undefined || url === "") {
        this.setSearch(match[3] || "");
      }

      this.setHash(match[5] || "");

      return this;
    }

    /**
     * Return URL (e.g. `/path?a=b#hash`) when called without any parameter.
     *
     * @return {string} url
     */
    getUrl() {
      return this.$$url;
    }

    /**
     * Change path parameter and return `$location`.
     *
     * @param {(string|number)} path New path
     * @return {Location}
     */
    setPath(path) {
      const newPath = path !== null ? path.toString() : "";

      $$path = newPath.charAt(0) === "/" ? newPath : `/${newPath}`;
      this.$$compose();

      return this;
    }

    /**
     *
     * Return path of current URL
     *
     * @return {string}
     */
    getPath() {
      return $$path;
    }

    /**
     * Changes the hash fragment when called with a parameter and returns `$location`.
     * @param {(string|number)} hash New hash fragment
     * @return {Location} hash
     */
    setHash(hash) {
      $$hash = hash !== null ? hash.toString() : "";
      this.$$compose();

      return this;
    }

    /**
     * Returns the hash fragment when called without any parameters.
     * @return {string} hash
     */
    getHash() {
      return $$hash;
    }

    /**
     * Sets the search part (as object) of current URL
     *
     * @param {string|Object} search New search params - string or hash object.
     * @param {(string|number|Array<string>|boolean)=} paramValue If search is a string or number, then paramValue will override only a single search property.
     * @returns {Object} Search object or Location object
     */
    setSearch(search, paramValue) {
      switch (arguments.length) {
        case 1:
          if (isString(search) || isNumber(search)) {
            search = search.toString();
            $$search = parseKeyValue(search);
          } else if (isObject(search)) {
            search = structuredClone(search, {});
            // remove object undefined or null properties
            entries(search).forEach(([key, value]) => {
              if (isNull(value)) delete search[key];
            });

            $$search = search;
          } else {
            throw $locationMinErr(
              "isrcharg",
              "The first argument of the `$location#search()` call must be a string or an object.",
            );
          }
          break;
        default:
          if (isUndefined(paramValue) || paramValue === null) {
            delete $$search[search];
          } else {
            // @ts-ignore
            $$search[search] = paramValue;
          }
      }

      this.$$compose();

      return this;
    }

    /**
     * Returns the search part (as object) of current URL
     *
     * @returns {Object} Search object or Location object
     */
    getSearch() {
      return $$search;
    }

    /**
     * @private
     * Compose url and update `url` and `absUrl` property
     */
    $$compose() {
      this.$$url = normalizePath($$path, $$search, $$hash);
      this.absUrl = this.html5
        ? this.appBaseNoFile + this.$$url.substring(1)
        : this.appBase + (this.$$url ? this.hashPrefix + this.$$url : "");
      urlUpdatedByLocation = true;
      setTimeout(() => this.$$updateBrowser && this.$$updateBrowser());
    }

    /**
     * Change the history state object when called with one parameter and return `$location`.
     * The state object is later passed to `pushState` or `replaceState`.
     * See {@link https://developer.mozilla.org/en-US/docs/Web/API/History/pushState#state|History.state}
     *
     * NOTE: This method is supported only in HTML5 mode and only in browsers supporting
     * the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support
     * older browsers (like IE9 or Android < 4.0), don't use this method.
     * @param {any} state
     * @returns {Location}
     */
    setState(state) {
      if (!this.html5) {
        throw $locationMinErr(
          "nostate",
          "History API state support is available only in HTML5 mode",
        );
      }
      // The user might modify `stateObject` after invoking `$location.setState(stateObject)`
      // but we're changing the $$state reference to $browser.state() during the $digest
      // so the modification window is narrow.
      this.$$state = isUndefined(state) ? null : state;
      urlUpdatedByLocation = true;

      return this;
    }

    /**
     * Return the history state object
     * @returns {any}
     */
    getState() {
      return this.$$state;
    }

    /**
     * @param {string} url
     * @param {string} relHref
     * @returns {boolean}
     */
    parseLinkUrl(url, relHref) {
      if (this.html5) {
        if (relHref && relHref[0] === "#") {
          // special case for links to hash fragments:
          // keep the old url and only replace the hash fragment
          this.setHash(relHref.slice(1));

          return true;
        }
        let appUrl;

        let prevAppUrl;

        let rewrittenUrl;

        if (isDefined((appUrl = stripBaseUrl(this.appBase, url)))) {
          prevAppUrl = appUrl;

          if (
            this.basePrefix &&
            isDefined((appUrl = stripBaseUrl(this.basePrefix, appUrl)))
          ) {
            rewrittenUrl =
              this.appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl);
          } else {
            rewrittenUrl = this.appBase + prevAppUrl;
          }
        } else if (isDefined((appUrl = stripBaseUrl(this.appBaseNoFile, url)))) {
          rewrittenUrl = this.appBaseNoFile + appUrl;
        } else if (this.appBaseNoFile === `${url}/`) {
          rewrittenUrl = this.appBaseNoFile;
        }

        if (rewrittenUrl) {
          this.parse(rewrittenUrl);
        }

        return !!rewrittenUrl;
      } else {
        if (stripHash(this.appBase) === stripHash(url)) {
          this.parse(url);

          return true;
        }

        return false;
      }
    }

    /**
     * Parse given HTML5 (regular) URL string into properties
     * @param {string} url HTML5 URL
     */
    parse(url) {
      if (this.html5) {
        const pathUrl = stripBaseUrl(this.appBaseNoFile, url);

        if (!isString(pathUrl)) {
          throw $locationMinErr(
            "ipthprfx",
            'Invalid url "{0}", missing path prefix "{1}".',
            url,
            this.appBaseNoFile,
          );
        }

        parseAppUrl(pathUrl, true);

        if (!$$path) {
          $$path = "/";
        }

        this.$$compose();
      } else {
        const withoutBaseUrl =
          stripBaseUrl(this.appBase, url) ||
          stripBaseUrl(this.appBaseNoFile, url);

        let withoutHashUrl;

        if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === "#") {
          // The rest of the URL starts with a hash so we have
          // got either a hashbang path or a plain hash fragment
          withoutHashUrl = stripBaseUrl(this.hashPrefix, withoutBaseUrl);

          if (isUndefined(withoutHashUrl)) {
            // There was no hashbang prefix so we just have a hash fragment
            withoutHashUrl = withoutBaseUrl;
          }
        } else {
          // There was no hashbang path nor hash fragment:
          // If we are in HTML5 mode we use what is left as the path;
          // Otherwise we ignore what is left
          if (this.html5) {
            withoutHashUrl = withoutBaseUrl;
          } else {
            withoutHashUrl = "";

            if (isUndefined(withoutBaseUrl)) {
              this.appBase = url;
            }
          }
        }

        parseAppUrl(withoutHashUrl, false);

        $$path = removeWindowsDriveName($$path, withoutHashUrl, this.appBase);

        this.$$compose();

        /*
         * In Windows, on an anchor node on documents loaded from
         * the filesystem, the browser will return a pathname
         * prefixed with the drive name ('/C:/path') when a
         * pathname without a drive is set:
         *  * a.setAttribute('href', '/foo')
         *   * a.pathname === '/C:/foo' //true
         *
         * Inside of AngularTS, we're always using pathnames that
         * do not include drive names for routing.
         */
        function removeWindowsDriveName(path, urlParam, base) {
          /*
          Matches paths for file protocol on windows,
          such as /C:/foo/bar, and captures only /foo/bar.
          */
          const windowsFilePathExp = /^\/[A-Z]:(\/.*)/;

          // Get the relative path from the input URL.
          if (startsWith(urlParam, base)) {
            urlParam = urlParam.replace(base, "");
          }

          // The input URL intentionally contains a first path segment that ends with a colon.
          if (windowsFilePathExp.exec(urlParam)) {
            return path;
          }

          const firstPathSegmentMatch = windowsFilePathExp.exec(path);

          return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
        }
      }
    }
  }

  class LocationProvider {
    constructor() {
      /** @type {string} */
      this.hashPrefixConf = "!";

      /** @type {import("./interface.ts").Html5Mode} */
      this.html5ModeConf = {
        enabled: true,
        requireBase: false,
        rewriteLinks: true,
      };

      /** @type {Array<import("./interface.ts").UrlChangeListener>} */
      this.urlChangeListeners = [];
      this.urlChangeInit = false;

      /** @type {History['state']} */
      this.cachedState = null;
      /** @type {History['state']} */
      this.lastHistoryState = null;
      /** @type {string} */
      this.lastBrowserUrl = window.location.href;
      this.cacheState();
    }

    /// ///////////////////////////////////////////////////////////
    // URL API
    /// ///////////////////////////////////////////////////////////

    /**
     * Updates the browser's current URL and history state.
     *
     * @param {string|undefined} url - The target URL to navigate to.
     * @param {*} [state=null] - Optional history state object to associate with the new URL.
     * @returns {LocationProvider}
     */
    setUrl(url, state) {
      if (state === undefined) {
        state = null;
      }

      if (url) {
        url = new URL(url).href;

        if (this.lastBrowserUrl === url && this.lastHistoryState === state) {
          return this;
        }

        this.lastBrowserUrl = url;
        this.lastHistoryState = state;
        history.pushState(state, "", url);
        this.cacheState();
      }

      return this;
    }

    /**
     * Returns the current URL with any empty hash (`#`) removed.
     * @return {string}
     */
    getBrowserUrl() {
      return trimEmptyHash(window.location.href);
    }

    /**
     * Returns the cached state.
     * @returns {History['state']} The cached state.
     */
    state() {
      return this.cachedState;
    }

    /**
     * Caches the current state.
     *
     * @private
     */
    cacheState() {
      const currentState = history.state ?? null;

      if (!equals$1(currentState, this.lastCachedState)) {
        this.cachedState = currentState;
        this.lastCachedState = currentState;
        this.lastHistoryState = currentState;
      }
    }

    /**
     * Fires the state or URL change event.
     */
    #fireStateOrUrlChange() {
      const prevLastHistoryState = this.lastHistoryState;

      this.cacheState();

      if (
        this.lastBrowserUrl === this.getBrowserUrl() &&
        prevLastHistoryState === this.cachedState
      ) {
        return;
      }
      this.lastBrowserUrl = this.getBrowserUrl();
      this.lastHistoryState = this.cachedState;
      this.urlChangeListeners.forEach((listener) => {
        listener(trimEmptyHash(window.location.href), this.cachedState);
      });
    }

    /**
     * Registers a callback to be called when the URL changes.
     *
     * @param {import("./interface.ts").UrlChangeListener} callback - The callback function to register.
     * @returns void
     */
    #onUrlChange(callback) {
      if (!this.urlChangeInit) {
        window.addEventListener(
          "popstate",
          this.#fireStateOrUrlChange.bind(this),
        );
        window.addEventListener(
          "hashchange",
          this.#fireStateOrUrlChange.bind(this),
        );
        this.urlChangeInit = true;
      }
      this.urlChangeListeners.push(callback);
    }

    $get = [
      $injectTokens._rootScope,
      $injectTokens._rootElement,
      $injectTokens._exceptionHandler,
      /**
       *
       * @param {ng.Scope} $rootScope
       * @param {Element} $rootElement
       * @param {ng.ExceptionHandlerService} $exceptionHandler
       * @returns {Location}
       */
      ($rootScope, $rootElement, $exceptionHandler) => {
        const baseHref = getBaseHref(); // if base[href] is undefined, it defaults to ''

        const initialUrl = trimEmptyHash(window.location.href);

        let appBase;

        if (this.html5ModeConf.enabled) {
          if (!baseHref && this.html5ModeConf.requireBase) {
            throw $locationMinErr(
              "nobase",
              "$location in HTML5 mode requires a <base> tag to be present!",
            );
          }
          appBase = serverBase(initialUrl) + (baseHref || "/");
        } else {
          appBase = stripHash(initialUrl);
        }
        const appBaseNoFile = stripFile(appBase);

        const $location = new Location(
          appBase,
          appBaseNoFile,
          this.html5ModeConf.enabled,
          `#${this.hashPrefixConf}`,
        );

        $location.parseLinkUrl(initialUrl, initialUrl);

        $location.$$state = this.state();

        const IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;

        const setBrowserUrlWithFallback = (url, state) => {
          const oldUrl = $location.getUrl();

          const oldState = $location.$$state;

          try {
            this.setUrl(url, state);

            // Make sure $location.getState() returns referentially identical (not just deeply equal)
            // state object; this makes possible quick checking if the state changed in the digest
            // loop. Checking deep equality would be too expensive.
            $location.$$state = this.state();
          } catch (err) {
            // Restore old values if pushState fails
            $location.setUrl(/** @type {string} */ (oldUrl));
            $location.$$state = oldState;
            $exceptionHandler(err);
          }
        };

        $rootElement.addEventListener(
          "click",
          /** @param {MouseEvent} event */
          (event) => {
            const { rewriteLinks } = this.html5ModeConf;
            // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
            // currently we open nice url link and redirect then

            if (
              !rewriteLinks ||
              event.ctrlKey ||
              event.metaKey ||
              event.shiftKey ||
              event.button === 2
            ) {
              return;
            }
            let elm = /** @type {HTMLAnchorElement} */ (event.target);

            // traverse the DOM up to find first A tag
            while (elm.nodeName.toLowerCase() !== "a") {
              // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
              // @ts-ignore
              if (elm === $rootElement || !(elm = elm.parentElement)) return;
            }

            if (
              isString(rewriteLinks) &&
              isUndefined(elm.getAttribute(/** @type {string} */ (rewriteLinks)))
            ) {
              return;
            }

            let absHref = elm.href;

            // get the actual href attribute - see
            // http://msdn.microsoft.com/en-us/library/ie/dd347148(v=vs.85).aspx
            const relHref =
              elm.getAttribute("href") || elm.getAttribute("xlink:href");

            if (
              isObject(absHref) &&
              absHref.toString() === "[object SVGAnimatedString]"
            ) {
              // SVGAnimatedString.animVal should be identical to SVGAnimatedString.baseVal, unless during
              // an animation.

              const scvAnimatedString = /** @type {unknown} */ (absHref);

              absHref = new URL(
                /** @type {SVGAnimatedString } */ (scvAnimatedString).animVal,
              ).href;
            }

            // Ignore when url is started with javascript: or mailto:
            if (IGNORE_URI_REGEXP.test(absHref)) return;

            if (
              absHref &&
              !elm.getAttribute("target") &&
              !event.defaultPrevented
            ) {
              if ($location.parseLinkUrl(absHref, relHref)) {
                // We do a preventDefault for all urls that are part of the AngularTS application,
                // in html5mode and also without, so that we are able to abort navigation without
                // getting double entries in the location history.
                event.preventDefault();
              }
            }
          },
        );

        // rewrite hashbang url <> html5 url
        if ($location.absUrl !== initialUrl) {
          this.setUrl($location.absUrl, true);
        }

        let initializing = true;

        // update $location when $browser url changes
        this.#onUrlChange((newUrl, newState) => {
          if (!startsWith(newUrl, appBaseNoFile)) {
            // If we are navigating outside of the app then force a reload
            window.location.href = newUrl;

            return;
          }

          queueMicrotask(() => {
            const oldUrl = $location.absUrl;

            const oldState = $location.$$state;

            $location.parse(newUrl);
            $location.$$state = newState;

            const { defaultPrevented } = $rootScope.$broadcast(
              "$locationChangeStart",
              newUrl,
              oldUrl,
              newState,
              oldState,
            );

            // if the location was changed by a `$locationChangeStart` handler then stop
            // processing this location change
            if ($location.absUrl !== newUrl) return;

            if (defaultPrevented) {
              $location.parse(oldUrl);
              $location.$$state = oldState;
              setBrowserUrlWithFallback(oldUrl, oldState);
            } else {
              initializing = false;
              afterLocationChange(oldUrl, oldState);
            }
          });
        });

        // update browser
        const updateBrowser = () => {
          if (initializing || urlUpdatedByLocation) {
            urlUpdatedByLocation = false;

            const oldUrl = /** @type {string} */ (this.getBrowserUrl());

            let newUrl = $location.absUrl;

            const oldState = this.state();

            const urlOrStateChanged =
              !urlsEqual(oldUrl, newUrl) ||
              ($location.html5 && oldState !== $location.$$state);

            if (initializing || urlOrStateChanged) {
              initializing = false;

              setTimeout(() => {
                newUrl = $location.absUrl;

                const { defaultPrevented } = $rootScope.$broadcast(
                  "$locationChangeStart",
                  $location.absUrl,
                  oldUrl,
                  $location.$$state,
                  oldState,
                );

                // if the location was changed by a `$locationChangeStart` handler then stop
                // processing this location change
                if ($location.absUrl !== newUrl) return;

                if (defaultPrevented) {
                  $location.parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(
                      newUrl,
                      oldState === $location.$$state ? null : $location.$$state,
                    );
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
          }
        };

        $location.$$updateBrowser = updateBrowser;
        updateBrowser();
        $rootScope.$on("$updateBrowser", updateBrowser);

        return $location;

        function afterLocationChange(oldUrl, oldState) {
          $rootScope.$broadcast(
            "$locationChangeSuccess",
            $location.absUrl,
            oldUrl,
            $location.$$state,
            oldState,
          );
        }
      },
    ];
  }

  /**
   * ///////////////////////////
   *     PRIVATE HELPERS
   * ///////////////////////////
   */

  /**
   * @ignore
   * Encodes a URL path by encoding each path segment individually using `encodeUriSegment`,
   * while preserving forward slashes (`/`) as segment separators.
   *
   * This function first decodes any existing percent-encodings (such as `%20` or `%2F`)
   * in each segment to prevent double encoding, except for encoded forward slashes (`%2F`),
   * which are replaced with literal slashes before decoding to keep path boundaries intact.
   *
   * After decoding, each segment is re-encoded with `encodeUriSegment` according to RFC 3986,
   * encoding only characters that must be encoded in a path segment.
   *
   * The encoded segments are then rejoined with `/` to form the encoded path.
   *
   * @param {string} path - The URL path string to encode. May contain multiple segments separated by `/`.
   * @returns {string} The encoded path, where each segment is encoded, but forward slashes are preserved.
   *
   * @example
   * encodePath("user profile/images/pic 1.jpg")
   * // returns "user%20profile/images/pic%201.jpg"
   *
   * @example
   * encodePath("folder1%2Fsub/folder2")
   * // returns "folder1%2Fsub/folder2"
   */
  function encodePath(path) {
    const segments = path.split("/");

    let i = segments.length;

    while (i--) {
      // Decode any existing encodings (e.g. %20, %2F) to prevent double-encoding
      // But keep slashes intact (they were split on)
      const decodedSegment = decodeURIComponent(
        segments[i].replace(/%2F/gi, "/"),
      );

      segments[i] = encodeUriSegment(decodedSegment);
    }

    return segments.join("/");
  }

  /**
   * @ignore
   * Decodes each segment of a URL path.
   *
   * Splits the input path by "/", decodes each segment using decodeURIComponent,
   * and if html5Mode is enabled, re-encodes any forward slashes inside segments
   * as "%2F" to avoid confusion with path separators.
   *
   * @param {string} path - The URL path to decode.
   * @param {boolean} html5Mode - If true, encodes forward slashes in segments as "%2F".
   * @returns {string} The decoded path with segments optionally encoding slashes.
   */
  function decodePath(path, html5Mode) {
    const segments = path.split("/");

    let i = segments.length;

    while (i--) {
      segments[i] = decodeURIComponent(segments[i]);

      if (html5Mode) {
        // encode forward slashes to prevent them from being mistaken for path separators
        segments[i] = segments[i].replace(/\//g, "%2F");
      }
    }

    return segments.join("/");
  }

  /**
   * @ignore
   * Normalizes a URL path by encoding the path segments, query parameters, and hash fragment.
   *
   * - Path segments are encoded using `encodePath`, which encodes each segment individually.
   * - Query parameters (`searchValue`) are converted to a query string using `toKeyValue`.
   * - Hash fragment (`hashValue`) is encoded using `encodeUriSegment` and prefixed with `#`.
   *
   * This function returns a fully constructed URL path with optional query and hash components.
   *
   * @param {string} pathValue - The base URL path (e.g., "folder/item name").
   * @param {Object.<string, any> | string | null} searchValue - An object or string representing query parameters.
   *   - If an object, it can contain strings, numbers, booleans, or arrays of values.
   *   - If a string, it is assumed to be a raw query string.
   *   - If null or undefined, no query string is added.
   * @param {string | null} hashValue - The URL fragment (everything after `#`). If null or undefined, no hash is added.
   *
   * @returns {string} The normalized URL path including encoded path, optional query string, and optional hash.
   *
   * @example
   * normalizePath("products/list", { category: "books", page: 2 }, "section1")
   * // returns "products/list?category=books&page=2#section1"
   *
   * @example
   * normalizePath("user profile/images", null, null)
   * // returns "user%20profile/images"
   */
  function normalizePath(pathValue, searchValue, hashValue) {
    const search = toKeyValue(searchValue);

    const hash = hashValue ? `#${encodeUriSegment(hashValue)}` : "";

    const path = encodePath(pathValue);

    return path + (search ? `?${search}` : "") + hash;
  }

  /**
   * @ignore
   * Parses the application URL and updates the location object with path, search, and hash.
   *
   * @param {string} url - The URL string to parse.
   * @param {boolean} html5Mode - Whether HTML5 mode is enabled (affects decoding).
   * @throws Will throw an error if the URL starts with invalid slashes.
   */
  function parseAppUrl(url, html5Mode) {
    if (/^\s*[\\/]{2,}/.test(url)) {
      throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
    }

    const prefixed = url.charAt(0) !== "/";

    if (prefixed) {
      url = `/${url}`;
    }
    const match = urlResolve(url);

    const path =
      prefixed && match.pathname.charAt(0) === "/"
        ? match.pathname.substring(1)
        : match.pathname;

    $$path = decodePath(path, html5Mode);
    $$search = parseKeyValue(match.search);
    $$hash = decodeURIComponent(match.hash);

    // make sure path starts with '/';
    if ($$path && $$path.charAt(0) !== "/") {
      $$path = `/${$$path}`;
    }
  }

  /**
   * @ignore
   * Returns the substring of `url` after the `base` string if `url` starts with `base`.
   * Returns `undefined` if `url` does not start with `base`.
   * @param {string} base
   * @param {string} url
   * @returns {string|undefined} returns text from `url` after `base` or `undefined` if it does not begin with
   *                   the expected string.
   */
  function stripBaseUrl(base, url) {
    if (startsWith(url, base)) {
      return url.substring(base.length);
    }

    return undefined;
  }

  /**
   * @ignore
   * Removes the hash fragment (including the '#') from the given URL string.
   *
   * @param {string} url - The URL string to process.
   * @returns {string} The URL without the hash fragment.
   */
  function stripHash(url) {
    const index = url.indexOf("#");

    return index === -1 ? url : url.substring(0, index);
  }

  /**
   * @ignore
   * Removes the file name (and any hash) from a URL, returning the base directory path.
   *
   * For example:
   * - Input: "https://example.com/path/to/file.js"
   *   Output: "https://example.com/path/to/"
   *
   * - Input: "https://example.com/path/to/file.js#section"
   *   Output: "https://example.com/path/to/"
   *
   * @param {string} url - The URL from which to strip the file name and hash.
   * @returns {string} The base path of the URL, ending with a slash.
   */
  function stripFile(url) {
    return url.substring(0, stripHash(url).lastIndexOf("/") + 1);
  }

  /**
   * @ignore
   * Extracts the base server URL (scheme, host, and optional port) from a full URL.
   *
   * If no path is present, returns the full URL.
   *
   * For example:
   * - Input: "https://example.com/path/to/file"
   *   Output: "https://example.com"
   *
   * - Input: "http://localhost:3000/api/data"
   *   Output: "http://localhost:3000"
   *
   * @param {string} url - The full URL to extract the server base from.
   * @returns {string} The server base, including scheme and host (and port if present).
   */
  function serverBase(url) {
    const start = url.indexOf("//") + 2;

    const slashIndex = url.indexOf("/", start);

    return slashIndex === -1 ? url : url.substring(0, slashIndex);
  }

  /**
   * @ignore
   * Determine if two URLs are equal despite potential differences in encoding,
   * trailing slashes, or empty hash fragments, such as between $location.absUrl() and $browser.url().
   *
   * @param {string} x - First URL to compare.
   * @param {string} y - Second URL to compare.
   * @returns {boolean} True if URLs are equivalent after normalization.
   */
  function urlsEqual(x, y) {
    return normalizeUrl(x) === normalizeUrl(y);
  }

  /**
   * @ignore
   * Normalize a URL by resolving it via a DOM anchor element,
   * removing trailing slashes (except root), and trimming empty hashes.
   *
   * @param {string} url - URL to normalize.
   * @returns {string} Normalized URL string.
   */
  function normalizeUrl(url) {
    const anchor = document.createElement("a");

    anchor.href = url;

    let normalized = anchor.href;

    // Remove trailing slash unless it's root (e.g., https://example.com/)
    if (normalized.endsWith("/") && !/^https?:\/\/[^/]+\/$/.test(normalized)) {
      normalized = normalized.slice(0, -1);
    }

    // Remove empty hash (e.g., https://example.com/foo# -> https://example.com/foo)
    if (normalized.endsWith("#")) {
      normalized = normalized.slice(0, -1);
    }

    return normalized;
  }

  /**
   * Configuration provider for `$log` service
   */
  class LogProvider {
    /** @private */
    constructor() {
      /** @type {boolean} */
      this.debug = false;
      /** @private @type {import("./interface.ts").LogServiceFactory | null} */
      this._override = null;
    }

    /**
     * Override the default {@link LogService} implemenation
     * @param {import("./interface.ts").LogServiceFactory} fn
     */
    setLogger(fn) {
      this._override = fn;
    }

    /**
     * @private
     * @param {unknown} arg
     *
     */
    _formatError(arg) {
      if (isError(arg)) {
        if (arg.stack) {
          arg =
            arg.message && arg.stack.indexOf(arg.message) === -1
              ? `Error: ${arg.message}\n${arg.stack}`
              : arg.stack;
        }
      }

      return arg;
    }

    /**
     * @private
     * @param {string} type
     */
    _consoleLog(type) {
      const console = window.console || {};

      const logFn =
        console[type] ||
        console.log ||
        (() => {
          /* empty */
        });

      return (...args) => {
        const formattedArgs = args.map((arg) => this._formatError(arg));

        return logFn.apply(console, formattedArgs);
      };
    }

    /**
     * @returns {ng.LogService}
     */
    $get() {
      if (this._override) {
        return this._override();
      }

      return {
        log: this._consoleLog("log"),
        info: this._consoleLog("info"),
        warn: this._consoleLog("warn"),
        error: this._consoleLog("error"),
        debug: (() => {
          const fn = this._consoleLog("debug");

          return (...args) => {
            if (this.debug) {
              fn.apply(this, args);
            }
          };
        })(),
      };
    }
  }

  /**
   * @type {number}
   */
  let uid = 0;

  function nextId() {
    uid += 1;

    return uid;
  }

  /**
   * @type {ng.ParseService}
   */
  let $parse;

  /**@type {ng.ExceptionHandlerService} */
  let $exceptionHandler;

  /** @ignore @type {Function[]}*/
  const $postUpdateQueue = [];

  class RootScopeProvider {
    constructor() {
      this.rootScope = createScope();
    }

    $get = [
      $injectTokens._exceptionHandler,
      $injectTokens._parse,
      /**
       * @param {ng.ExceptionHandlerService} exceptionHandler
       * @param {ng.ParseService} parse
       */
      (exceptionHandler, parse) => {
        $exceptionHandler = exceptionHandler;
        $parse = parse;

        return this.rootScope;
      },
    ];
  }

  /**
   * @private
   * Creates a deep proxy for the target object, intercepting property changes
   * and recursively applying proxies to nested objects.
   *
   * @param {Object} target - The object to be wrapped in a proxy.
   * @param {Scope} [context] - The context for the handler, used to track listeners.
   * @returns {Scope} - A proxy that intercepts operations on the target object,
   *                                     or the original value if the target is not an object.
   */
  function createScope(target = {}, context) {
    if (!isObject(target) || isNonScope(target)) return target;

    const proxy = new Proxy(target, context || new Scope());

    const keyList = keys(target);

    const ctorNonScope = isArray(target.constructor?.$nonscope)
      ? target.constructor.$nonscope
      : null;

    const instNonScope = isArray(target.$nonscope) ? target.$nonscope : null;

    for (let i = 0, l = keyList.length; i < l; i++) {
      const key = keyList[i];

      if (ctorNonScope?.includes(key) || instNonScope?.includes(key)) continue;
      target[key] = createScope(target[key], proxy.$handler);
    }

    return proxy;
  }

  const global = globalThis;

  const proto = Object.prototype;

  const { toString: toString$1 } = proto;

  const wStr = "[object Window]";

  /**
   * @ignore
   * Checks if a target should be excluded from scope observability
   * @param {any} target
   * @returns {boolean}
   */
  function isNonScope(target) {
    if (
      target.$nonscope === true ||
      (target.constructor && target.constructor.$nonscope) === true ||
      target === global.window ||
      target === global.document ||
      target === global.self ||
      target === global.frames ||
      target instanceof Window ||
      target instanceof Document ||
      target instanceof Element ||
      target instanceof Node ||
      target instanceof EventTarget ||
      target instanceof Promise ||
      target instanceof HTMLCollection ||
      target instanceof NodeList ||
      target instanceof Event
    ) {
      return true;
    }

    try {
      return toString$1.call(target) === wStr;
    } catch {
      return false;
    }
  }

  /**
   * Scope class for the Proxy. It intercepts operations like property access (get)
   * and property setting (set), and adds support for deep change tracking and
   * observer-like behavior.
   * @extends {Record<string, any>}
   */
  class Scope {
    /**
     * Initializes the handler with the target object and a context.
     *
     * @param {Scope} [context] - The context containing listeners.
     * @param {Scope} [parent] - Custom parent.
     */
    constructor(context, parent) {
      this.context = context
        ? context.context
          ? context.context
          : context
        : undefined;

      /** @type {Map<string, Array<import('./interface.ts').Listener>>} Watch listeners */
      this.watchers = context ? context.watchers : new Map();

      /** @type {Map<String, Function[]>} Event listeners */
      this.$$listeners = new Map();

      /** @type {Map<string, Array<import('./interface.ts').Listener>>} Watch listeners from other proxies */
      this.foreignListeners = context ? context.foreignListeners : new Map();

      /** @type {Set<Proxy<ng.Scope>>} */
      this.foreignProxies = context ? context.foreignProxies : new Set();

      /** @type {WeakMap<Object, Array<string>>} */
      this.objectListeners = context ? context.objectListeners : new WeakMap();

      /** @type {Map<Function, {oldValue: any, fn: Function}>} */
      this.functionListeners = context ? context.functionListeners : new Map();

      /** @type {Proxy<Scope>} Current proxy being operated on */
      this.$proxy = null;

      /** @type {Scope} The actual proxy */
      this.$handler = /** @type {Scope} */ (this);

      /** @type {*} Current target being called on */
      this.$target = null;

      /** @type {*} Value wrapped by the proxy */
      this.$value = null;

      /**
       * @type {Scope[]}
       */
      this.$children = [];

      /**
       * @type {number} Unique model ID (monotonically increasing) useful for debugging.
       */
      this.$id = nextId();

      /**
       * @type {Scope}
       */
      this.$root = context ? context.$root : /** @type {Scope} */ (this);

      this.$parent = parent
        ? parent
        : /** @type {Scope} */ (this).$root === /** @type {Scope} */ (this)
          ? null
          : context;

      this.filters = [];

      /** @type {boolean} */
      this.$$destroyed = false;

      this.scheduled = [];

      this.$scopename = undefined;

      /** @private */
      this.propertyMap = {
        $watch: this.$watch.bind(this),
        $new: this.$new.bind(this),
        $newIsolate: this.$newIsolate.bind(this),
        $destroy: this.$destroy.bind(this),
        $flushQueue: this.$flushQueue.bind(this),
        $eval: this.$eval.bind(this),
        $apply: this.$apply.bind(this),
        $postUpdate: this.$postUpdate.bind(this),
        $isRoot: this.#isRoot.bind(this),
        $on: this.$on.bind(this),
        $emit: this.$emit.bind(this),
        $broadcast: this.$broadcast.bind(this),
        $transcluded: this.$transcluded.bind(this),
        $handler: /** @type {Scope} */ (this),
        $merge: this.$merge.bind(this),
        $getById: this.$getById.bind(this),
        $searchByName: this.$searchByName.bind(this),
        $proxy: this.$proxy,
        $parent: this.$parent,
        $root: this.$root,
        $children: this.$children,
        $id: this.$id,
        $scopename: this.$scopename,
      };
    }

    /**
     * Intercepts and handles property assignments on the target object. If a new value is
     * an object, it will be recursively proxied.
     *
     * @param {Object} target - The target object.
     * @param {string} property - The name of the property being set.
     * @param {*} value - The new value being assigned to the property.
     * @param {Proxy<Scope>} proxy - The proxy intercepting property access
     * @returns {boolean} - Returns true to indicate success of the operation.
     */
    set(target, property, value, proxy) {
      if (property === "undefined") {
        return false;
      }

      if (property === "$scopename") {
        this.$scopename = value;

        return true;
      }

      if (
        (target.constructor?.$nonscope &&
          isArray(target.constructor.$nonscope) &&
          target.constructor.$nonscope.includes(property)) ||
        (target.$nonscope &&
          isArray(target.$nonscope) &&
          target.$nonscope.includes(property))
      ) {
        target[property] = value;

        return true;
      }

      this.$proxy = proxy;
      this.$target = target;
      const oldValue = target[property];

      // Handle NaNs
      if (
        oldValue !== undefined &&
        Number.isNaN(oldValue) &&
        Number.isNaN(value)
      ) {
        return true;
      }

      if (oldValue && oldValue[isProxySymbol]) {
        if (isArray(value)) {
          if (oldValue !== value) {
            const listeners = this.watchers.get(property);

            if (listeners) {
              this.#scheduleListener(listeners);
            }

            const foreignListeners = this.foreignListeners.get(property);

            if (foreignListeners) {
              this.#scheduleListener(foreignListeners);
            }
          }

          if (this.objectListeners.get(target[property])) {
            this.objectListeners.delete(target[property]);
          }
          target[property] = createScope(value, this);
          this.objectListeners.set(target[property], [property]);

          return true;
        }

        if (isObject(value)) {
          if (hasOwn(target, property)) {
            const keyList = keys(oldValue);

            for (const k of keyList) {
              if (!value[k]) delete oldValue[k];
            }
          }

          if (oldValue !== value) {
            const listeners = this.watchers.get(property);

            if (listeners) {
              this.#scheduleListener(listeners);
            }

            const foreignListeners = this.foreignListeners.get(property);

            if (foreignListeners) {
              this.#scheduleListener(foreignListeners);
            }

            this.#checkeListenersForAllKeys(value);
          }
          target[property] = createScope(value, this);

          //setDeepValue(target[property], value);
          return true;
        }

        if (isUndefined(value)) {
          let called = false;

          const keyList = keys(oldValue.$target);

          const tgt = oldValue.$target;

          let i = 0;

          for (i; i < keyList.length; i++) {
            const k = keyList[i];

            const v = tgt[k];

            if (v && v[isProxySymbol]) {
              called = true;
            }
            delete oldValue[k];
          }

          target[property] = undefined;

          if (!called) {
            const listeners = this.watchers.get(property);

            if (listeners) {
              this.#scheduleListener(listeners);
            }
          }

          return true;
        }

        if (isDefined(value)) {
          target[property] = value;
          const listeners = this.watchers.get(property);

          if (listeners) {
            this.#scheduleListener(listeners);
          }

          if (isArray(target)) {
            if (this.objectListeners.has(proxy) && property !== "length") {
              const keyList = this.objectListeners.get(proxy);

              for (let i = 0, l = keyList.length; i < l; i++) {
                const currentListeners = this.watchers.get(keyList[i]);

                if (currentListeners) this.#scheduleListener(currentListeners);
              }
            }
          }

          return true;
        }

        return true;
      } else {
        if (isUndefined(target[property]) && isProxy(value)) {
          this.foreignProxies.add(/** @type {Proxy<ng.Scope>} */ (value));
          target[property] = value;

          if (!this.watchers.has(property)) {
            return true;
          }
        }

        if (isUndefined(value)) {
          target[property] = value;
        } else {
          target[property] = createScope(value, this);
        }

        if (oldValue !== value) {
          let expectedTarget = this.$target;

          const listeners = [];

          // Handle the case where we need to start observing object after a watcher has been set
          if (isUndefined(oldValue) && isObject(target[property])) {
            if (!this.objectListeners.has(target[property])) {
              this.objectListeners.set(target[property], [property]);
            }
            const keyList = keys(value);

            for (let i = 0, l = keyList.length; i < l; i++) {
              const key = keyList[i];

              const keyListeners = this.watchers.get(key);

              if (keyListeners) {
                for (let j = 0, jl = keyListeners.length; j < jl; j++) {
                  listeners.push(keyListeners[j]);
                }
              }
            }
            expectedTarget = value;
          }

          if (isArray(target)) {
            const lengthListeners = this.watchers.get("length");

            if (lengthListeners) {
              for (let i = 0, l = lengthListeners.length; i < l; i++) {
                listeners.push(lengthListeners[i]);
              }
            }
          }

          const propListeners = this.watchers.get(property);

          if (propListeners) {
            for (let i = 0, l = propListeners.length; i < l; i++) {
              listeners.push(propListeners[i]);
            }
          }

          if (listeners.length > 0) {
            this.#scheduleListener(listeners, (list) => {
              const scheduled = [];

              for (let i = 0, l = list.length; i < l; i++) {
                const x = list[i];

                if (!x.watchProp) {
                  scheduled.push(x);
                  continue;
                }

                const wrapperExpr = x.watchProp.split(".").slice(0, -1).join(".");

                const expectedHandler = $parse(wrapperExpr)(
                  x.originalTarget,
                )?.$handler;

                if (expectedTarget === expectedHandler?.$target) {
                  scheduled.push(x);
                }
              }

              return scheduled;
            });
          }

          let foreignListeners = this.foreignListeners.get(property);

          if (!foreignListeners && this.$parent?.foreignListeners) {
            foreignListeners = this.$parent.foreignListeners.get(property);
          }

          if (foreignListeners) {
            let scheduled = foreignListeners;

            // filter for repeaters
            const hashKey = this.$target.$$hashKey;

            if (hashKey) {
              scheduled = [];

              for (let i = 0, l = foreignListeners.length; i < l; i++) {
                const listener = foreignListeners[i];

                if (listener.originalTarget.$$hashKey === hashKey) {
                  scheduled.push(listener);
                }
              }
            }

            if (scheduled.length > 0) {
              this.#scheduleListener(scheduled);
            }
          }
        }

        if (this.objectListeners.has(proxy) && property !== "length") {
          const keyList = this.objectListeners.get(proxy);

          for (let i = 0, l = keyList.length; i < l; i++) {
            const key = keyList[i];

            const listeners = this.watchers.get(key);

            if (listeners && this.scheduled !== listeners) {
              this.#scheduleListener(listeners);
            }
          }
        }

        return true;
      }
    }

    /**
     * Intercepts property access on the target object. It checks for specific
     * properties (`watch` and `sync`) and binds their methods. For other properties,
     * it returns the value directly.
     *
     * @param {Object} target - The target object.
     * @param {string|number|symbol} property - The name of the property being accessed.
     * @param {Proxy<Scope>} proxy - The proxy object being invoked
     * @returns {*} - The value of the property or a method if accessing `watch` or `sync`.
     */
    get(target, property, proxy) {
      if (property === "$scopename" && this.$scopename) return this.$scopename;

      if (property === "$$watchersCount") return calculateWatcherCount(this);

      if (property === isProxySymbol) return true;

      if (target[property] && isProxy(target[property])) {
        this.$proxy = /** @type {Proxy<Scope>} */ (target[property]);
      } else {
        this.$proxy = proxy;
      }

      this.propertyMap.$target = target;
      this.propertyMap.$proxy = proxy;

      if (
        isArray(target) &&
        ["pop", "shift", "unshift"].includes(/** @type { string } */ (property))
      ) {
        if (this.objectListeners.has(proxy)) {
          const keyList = this.objectListeners.get(proxy);

          for (let i = 0, l = keyList.length; i < l; i++) {
            const key = keyList[i];

            const listeners = this.watchers.get(key);

            if (listeners) {
              this.scheduled = listeners;
            }
          }
        }

        if (property === "unshift") {
          this.#scheduleListener(this.scheduled);
        }
      }

      if (hasOwn(this.propertyMap, property)) {
        this.$target = target;

        return this.propertyMap[property];
      } else {
        // we are a simple getter
        return target[property];
      }
    }

    deleteProperty(target, property) {
      // Currently deletes $model
      if (target[property] && target[property][isProxySymbol]) {
        target[property] = undefined;

        const listeners = this.watchers.get(property);

        if (listeners) {
          this.#scheduleListener(listeners);
        }

        if (this.objectListeners.has(this.$proxy)) {
          const keyList = this.objectListeners.get(this.$proxy);

          for (let i = 0, l = keyList.length; i < l; i++) {
            const key = keyList[i];

            const currentListeners = this.watchers.get(key);

            if (currentListeners) this.#scheduleListener(currentListeners);
          }
        }

        if (this.scheduled) {
          this.#scheduleListener(this.scheduled);
          this.scheduled = [];
        }

        return true;
      }

      delete target[property];

      if (this.objectListeners.has(this.$proxy)) {
        const keyList = this.objectListeners.get(this.$proxy);

        for (let i = 0, l = keyList.length; i < l; i++) {
          const key = keyList[i];

          const listeners = this.watchers.get(key);

          if (listeners) this.#scheduleListener(listeners);
        }
      } else {
        const listeners = this.watchers.get(property);

        if (listeners) {
          this.#scheduleListener(listeners, target[property]);
        }
      }

      return true;
    }

    /** @internal **/
    #checkeListenersForAllKeys(value) {
      if (isUndefined(value)) {
        return;
      }
      keys(value).forEach((k) => {
        const listeners = this.watchers.get(k);

        if (listeners) {
          this.#scheduleListener(listeners);
        }

        if (isObject(value[k])) {
          this.#checkeListenersForAllKeys(value[k]);
        }
      });
    }

    /**
     * @param {import('./interface.ts').Listener[]} listeners
     * @param {Function} filter
     */
    #scheduleListener(listeners, filter = (val) => val) {
      queueMicrotask(() => {
        let index = 0;

        const filteredListeners = filter(listeners);

        while (index < filteredListeners.length) {
          const listener = filteredListeners[index];

          if (listener.foreignListener) {
            listener.foreignListener.#notifyListener(listener, this.$target);
          } else {
            this.#notifyListener(listener, this.$target);
          }
          index++;
        }
      });
    }

    /**
     * Registers a watcher for a property along with a listener function. The listener
     * function is invoked when changes to that property are detected.
     *
     * @param {string} watchProp - An expression to be watched in the context of this model.
     * @param {ng.ListenerFn} [listenerFn] - A function to execute when changes are detected on watched context.
     * @param {boolean} [lazy] - A flag to indicate if the listener should be invoked immediately. Defaults to false.
     */
    $watch(watchProp, listenerFn, lazy = false) {
      assert(isString(watchProp), "Watched property required");
      watchProp = watchProp.trim();
      const get = $parse(watchProp);

      // Constant are immediately passed to listener function
      if (get.constant) {
        if (listenerFn) {
          queueMicrotask(() => {
            let res = get();

            while (isFunction(res)) {
              res = res();
            }
            listenerFn(res, this.$target);
          });
        }

        return () => {
          /* empty */
        };
      }

      /** @type {ng.Listener} */
      const listener = {
        originalTarget: this.$target,
        listenerFn,
        watchFn: get,
        scopeId: this.$id,
        id: nextUid(),
        property: [],
      };

      // simplest case
      let key = get.decoratedNode.body[0].expression.name;

      const keySet = [];

      const { type } = get.decoratedNode.body[0].expression;

      switch (type) {
        // 3
        case ASTType._AssignmentExpression:
          // assignment calls without listener functions
          if (!listenerFn) {
            let res = get(this.$target);

            while (isFunction(res)) {
              res = res(this.$target);
            }

            return undefined;
          }
          key = get.decoratedNode.body[0].expression.left.name;
          break;
        // 4
        case ASTType._ConditionalExpression: {
          key = get.decoratedNode.body[0].expression.toWatch[0]?.test?.name;
          listener.property.push(key);
          break;
        }
        // 5
        case ASTType._LogicalExpression: {
          const keyList = [
            get.decoratedNode.body[0].expression.left.toWatch[0]?.name,
            get.decoratedNode.body[0].expression.right.toWatch[0]?.name,
          ];

          for (let i = 0, l = keyList.length; i < l; i++) {
            const registerKey = keyList[i];

            if (registerKey) this.#registerKey(registerKey, listener);
          }

          return () => {
            for (let i = 0, l = keyList.length; i < l; i++) {
              const deregisterKey = keyList[i];

              this.#deregisterKey(deregisterKey, listener.id);
            }
          };
        }
        // 6
        case ASTType._BinaryExpression: {
          if (get.decoratedNode.body[0].expression.isPure) {
            const expr = get.decoratedNode.body[0].expression.toWatch[0];

            key = expr.property ? expr.property.name : expr.name;

            if (!key) {
              throw new Error("Unable to determine key");
            }
            listener.property.push(key);
            break;
          } else {
            const { toWatch } = get.decoratedNode.body[0].expression;

            for (let i = 0, l = toWatch.length; i < l; i++) {
              const x = toWatch[i];

              const registerKey = x.property ? x.property.name : x.name;

              if (!registerKey) throw new Error("Unable to determine key");

              this.#registerKey(registerKey, listener);
              this.#scheduleListener([listener]);
            }

            // Return deregistration function
            return () => {
              for (let i = 0, l = toWatch.length; i < l; i++) {
                const x = toWatch[i];

                const deregisterKey = x.property ? x.property.name : x.name;

                this.#deregisterKey(deregisterKey, listener.id);
              }
            };
          }
        }
        // 7
        case ASTType._UnaryExpression: {
          const expr = get.decoratedNode.body[0].expression.toWatch[0];

          key = expr.property ? expr.property.name : expr.name;

          if (!key) {
            throw new Error("Unable to determine key");
          }
          listener.property.push(key);
          break;
        }
        // 8 function
        case ASTType._CallExpression: {
          const { toWatch } = get.decoratedNode.body[0].expression;

          for (let i = 0, l = toWatch.length; i < l; i++) {
            const x = toWatch[i];

            if (!isDefined(x)) continue;
            this.#registerKey(x.name, listener);
            this.#scheduleListener([listener]);
          }

          return () => {
            for (let i = 0, l = toWatch.length; i < l; i++) {
              const x = toWatch[i];

              if (!isDefined(x)) continue;
              this.#deregisterKey(x.name, listener.id);
            }
          };
        }

        // 9
        case ASTType._MemberExpression: {
          key = get.decoratedNode.body[0].expression.property.name;

          // array watcher
          if (!key) {
            key = get.decoratedNode.body[0].expression.object.name;
          }

          listener.property.push(key);

          if (watchProp !== key) {
            // Handle nested expression call
            listener.watchProp = watchProp;

            const potentialProxy = $parse(
              watchProp.split(".").slice(0, -1).join("."),
            )(/** @type {Scope} */ (listener.originalTarget));

            if (potentialProxy && this.foreignProxies.has(potentialProxy)) {
              potentialProxy.$handler.#registerForeignKey(key, listener);
              potentialProxy.$handler.#scheduleListener([listener]);

              return () => {
                return potentialProxy.$handler.#deregisterKey(key, listener.id);
              };
            }
          }
          break;
        }

        // 10
        case ASTType._Identifier: {
          listener.property.push(get.decoratedNode.body[0].expression.name);
          break;
        }

        // 12
        case ASTType._ArrayExpression: {
          const { elements } = get.decoratedNode.body[0].expression;

          for (let i = 0, l = elements.length; i < l; i++) {
            const x = elements[i];

            const registerKey =
              x.type === ASTType._Literal ? x.value : x.toWatch[0]?.name;

            if (!registerKey) continue;

            this.#registerKey(registerKey, listener);
            this.#scheduleListener([listener]);
          }

          return () => {
            for (let i = 0, l = elements.length; i < l; i++) {
              const x = elements[i];

              const deregisterKey =
                x.type === ASTType._Literal ? x.value : x.toWatch[0]?.name;

              if (!deregisterKey) continue;

              this.#deregisterKey(deregisterKey, listener.id);
            }
          };
        }

        // 14
        case ASTType._ObjectExpression: {
          const { properties } = get.decoratedNode.body[0].expression;

          for (let i = 0, l = properties.length; i < l; i++) {
            const prop = properties[i];

            let currentKey;

            if (prop.key.isPure === false) {
              currentKey = prop.key.name;
            } else if (prop.value?.name) {
              currentKey = prop.value.name;
            } else {
              const target = get.decoratedNode.body[0].expression.toWatch[0];

              currentKey = target.property ? target.property.name : target.name;
            }

            if (currentKey) {
              keySet.push(currentKey);
              listener.property.push(currentKey);
            }
          }
          break;
        }
        default: {
          throw new Error(`Unsupported type ${type}`);
        }
      }

      // if the target is an object, then start observing it
      const listenerObject = listener.watchFn(this.$target);

      if (isObject(listenerObject)) {
        this.objectListeners.set(listenerObject, [key]);
      }

      if (keySet.length > 0) {
        for (let i = 0, l = keySet.length; i < l; i++) {
          this.#registerKey(keySet[i], listener);
        }
      } else {
        this.#registerKey(key, listener);
      }

      if (!lazy) {
        this.#scheduleListener([listener]);
      }

      return () => {
        if (keySet.length > 0) {
          let res = true;

          for (let i = 0, l = keySet.length; i < l; i++) {
            const success = this.#deregisterKey(keySet[i], listener.id);

            if (!success) {
              res = false;
            }
          }

          return res;
        } else {
          return this.#deregisterKey(key, listener.id);
        }
      };
    }

    $new(childInstance) {
      let child;

      if (childInstance) {
        if (Object.getPrototypeOf(childInstance) === Object.prototype) {
          Object.setPrototypeOf(childInstance, this.$target);
        } else {
          if (Object.getPrototypeOf(childInstance) === this.$target) {
            Object.setPrototypeOf(childInstance, this.$target);
          } else {
            Object.setPrototypeOf(
              Object.getPrototypeOf(childInstance) || childInstance,
              this.$target,
            );
          }
        }

        child = childInstance;
      } else {
        child = Object.create(this.$target);
      }

      const proxy = new Proxy(child, new Scope(this));

      this.$children.push(proxy);

      return proxy;
    }

    $newIsolate(instance) {
      const child = instance ? Object.create(instance) : Object.create(null);

      const proxy = new Proxy(child, new Scope(this, this.$root));

      this.$children.push(proxy);

      return proxy;
    }

    $transcluded(parentInstance) {
      const child = Object.create(this.$target);

      const proxy = new Proxy(child, new Scope(this, parentInstance));

      this.$children.push(proxy);

      return proxy;
    }

    /** @internal **/
    #registerKey(key, listener) {
      if (this.watchers.has(key)) {
        this.watchers.get(key).push(listener);
      } else {
        this.watchers.set(key, [listener]);
      }
    }

    /** @internal **/
    #registerForeignKey(key, listener) {
      if (this.foreignListeners.has(key)) {
        this.foreignListeners.get(key).push(listener);
      } else {
        this.foreignListeners.set(key, [listener]);
      }
    }

    #deregisterKey(key, id) {
      const listenerList = this.watchers.get(key);

      if (!listenerList) return false;

      const index = listenerList.findIndex((x) => x.id === id);

      if (index === -1) return false;

      listenerList.splice(index, 1);

      if (listenerList.length) {
        this.watchers.set(key, listenerList);
      } else {
        this.watchers.delete(key);
      }

      return true;
    }

    // #deregisterForeignKey(key, id) {
    //   const listenerList = this.foreignListeners.get(key);
    //   if (!listenerList) return false;

    //   const index = listenerList.findIndex((x) => x.id === id);
    //   if (index === -1) return false;

    //   listenerList.splice(index, 1);
    //   if (listenerList.length) {
    //     this.foreignListeners.set(key, listenerList);
    //   } else {
    //     this.foreignListeners.delete(key);
    //   }
    //   return true;
    // }

    $eval(expr, locals) {
      const fn = $parse(expr);

      const res = fn(this, locals);

      if (isUndefined(res) || res === null) {
        return res;
      }

      if (res.name === Object.hasOwnProperty.name) {
        return res;
      }

      if (isFunction(res)) {
        return res();
      }

      if (Number.isNaN(res)) {
        return 0;
      }

      return res;
    }

    /**
     * @param {Object} newTarget
     */
    $merge(newTarget) {
      const list = entries(newTarget);

      for (let i = 0, l = list.length; i < l; i++) {
        const [key, value] = list[i];

        this.set(this.$target, key, value, this.$proxy);
      }
    }

    /**
     * @param {ng.Expression} expr
     * @returns {any}
     */
    $apply(expr) {
      try {
        return $parse(expr)(this.$proxy);
      } catch (err) {
        return $exceptionHandler(err);
      }
    }

    /**
     * @param {string} name
     * @param {Function} listener
     * @returns {(function(): void)|*}
     */
    $on(name, listener) {
      let namedListeners = this.$$listeners.get(name);

      if (!namedListeners) {
        namedListeners = [];
        this.$$listeners.set(name, namedListeners);
      }
      namedListeners.push(listener);

      return () => {
        const indexOfListener = namedListeners.indexOf(listener);

        if (indexOfListener !== -1) {
          namedListeners.splice(indexOfListener, 1);

          if (namedListeners.length === 0) {
            this.$$listeners.delete(name);
          }
        }
      };
    }

    /**
     * @param {string} name
     * @param  {...any} args
     * @returns {void}
     */
    $emit(name, ...args) {
      return this.#eventHelper(
        { name, event: undefined, broadcast: false },
        ...args,
      );
    }

    /**
     * @param {string} name
     * @param  {...any} args
     * @returns {any}
     */
    $broadcast(name, ...args) {
      return this.#eventHelper(
        { name, event: undefined, broadcast: true },
        ...args,
      );
    }

    /**
     * @internal
     * @returns {any}
     */
    #eventHelper({ name, event, broadcast }, ...args) {
      if (!broadcast) {
        if (!this.$$listeners.has(name)) {
          if (this.$parent) {
            return this.$parent.$handler.#eventHelper(
              { name, event, broadcast },
              ...args,
            );
          }

          return undefined;
        }
      }

      if (event) {
        event.currentScope = this.$target;
      } else {
        event = event || {
          name,
          targetScope: this.$target,
          currentScope: this.$target,
          stopped: false,
          stopPropagation() {
            event.stopped = true;
          },
          preventDefault() {
            event.defaultPrevented = true;
          },
          defaultPrevented: false,
        };
      }

      const listenerArgs = concat([event], [event].concat(args), 1);

      const listeners = this.$$listeners.get(name);

      if (listeners) {
        let { length } = listeners;

        for (let i = 0; i < length; i++) {
          try {
            const cb = listeners[i];

            cb.apply(null, listenerArgs);

            const currentLength = listeners.length;

            if (currentLength !== length) {
              if (currentLength < length) {
                i--;
              }
              length = currentLength;
            }
          } catch (err) {
            $exceptionHandler(err);
          }
        }
      }

      event.currentScope = null;

      if (event.stopped) {
        return event;
      }

      if (broadcast) {
        if (this.$children.length > 0) {
          this.$children.forEach((child) => {
            event = child.$handler.#eventHelper(
              { name, event, broadcast },
              ...args,
            );
          });
        }

        return event;
      } else {
        if (this.$parent) {
          return this.$parent.#eventHelper({ name, event, broadcast }, ...args);
        } else {
          return event;
        }
      }
    }

    /**
     * @internal
     * @returns {boolean}
     */
    #isRoot() {
      return this.$root === /** @type {Scope} */ (this);
    }

    /**
     * @param {Function} fn
     */
    $postUpdate(fn) {
      $postUpdateQueue.push(fn);
    }

    $destroy() {
      if (this.$$destroyed) return;

      this.$broadcast("$destroy");

      for (const [key, val] of this.watchers) {
        for (let i = val.length - 1; i >= 0; i--) {
          if (val[i].scopeId === this.$id) {
            val.splice(i, 1);
          }
        }

        if (val.length === 0) {
          this.watchers.delete(key);
        } else {
          this.watchers.set(key, val);
        }
      }

      if (this.#isRoot()) {
        this.watchers.clear();
      } else {
        const children = this.$parent.$children;

        for (let i = 0, l = children.length; i < l; i++) {
          if (children[i].$id === this.$id) {
            children.splice(i, 1);
            break;
          }
        }
      }

      this.$$listeners.clear();
      this.$$destroyed = true;
    }

    /**
     * @internal
     * @param {import('./interface.ts').Listener} listener - The property path that was changed.
     */
    #notifyListener(listener, target) {
      const { originalTarget, listenerFn, watchFn } = listener;

      try {
        let newVal = watchFn(originalTarget);

        if (isUndefined(newVal)) {
          newVal = watchFn(target);
        }

        if (isFunction(newVal)) {
          newVal = newVal(originalTarget);
        }

        if (isArray(newVal)) {
          for (let i = 0, l = newVal.length; i < l; i++) {
            if (isFunction(newVal[i])) {
              newVal[i] = newVal[i](originalTarget);
            }
          }
        }

        listenerFn(newVal, originalTarget);

        while ($postUpdateQueue.length) {
          const fn = $postUpdateQueue.shift();

          fn();
        }
      } catch (err) {
        $exceptionHandler(err);
      }
    }

    /* @ignore */
    $flushQueue() {
      while ($postUpdateQueue.length) {
        $postUpdateQueue.shift()();
      }
    }

    /**
     * Searches the scope instance
     *
     * @param {string|number}id
     * @returns {Scope|undefined}
     */
    $getById(id) {
      if (isString(id)) {
        id = parseInt(/** @type {string} */ (id), 10);
      }

      if (this.$id === id) {
        return this;
      } else {
        let res = undefined;

        for (const child of this.$children) {
          const found = child.$getById(id);

          if (found) {
            res = found;
            break;
          }
        }

        return res;
      }
    }

    /**
     * @param {string} name
     * @returns {ng.Scope|undefined}
     */
    $searchByName(name) {
      /**
       * @param {ng.Scope} scope
       * @param {string} nameParam
       * @returns {ng.Scope|undefined}
       */
      function getByName(scope, nameParam) {
        if (scope.$scopename === nameParam) {
          return scope;
        } else {
          let res = undefined;

          for (const child of scope.$children) {
            const found = getByName(child, nameParam);

            if (found) {
              res = found;
              break;
            }
          }

          return res;
        }
      }

      return getByName(this.$root, name);
    }
  }

  /*------------- Private helpers -------------*/

  /**
   * @param {Scope} model
   * @returns {number}
   */
  function calculateWatcherCount(model) {
    const childIds = collectChildIds(model);

    let count = 0;

    for (const watchers of model.watchers.values()) {
      for (let i = 0, l = watchers.length; i < l; i++) {
        if (childIds.has(watchers[i].scopeId)) {
          count++;
        }
      }
    }

    return count;
  }

  /**
   * @param {Scope} child
   * @returns {Set<number>}
   */
  function collectChildIds(child) {
    const ids = new Set();

    const stack = [child];

    while (stack.length) {
      const node = stack.pop();

      if (!ids.has(node.$id)) {
        ids.add(node.$id);

        if (node.$children) {
          for (let i = 0, l = node.$children.length; i < l; i++) {
            stack.push(node.$children[i]);
          }
        }
      }
    }

    return ids;
  }

  const $templateRequestMinErr = minErr("$templateRequest");

  /**
   * Used to configure the options passed to the {@link $http} service when making a template request.
   *
   * For example, it can be used for specifying the "Accept" header that is sent to the server, when
   * requesting a template.
   */
  function TemplateRequestProvider() {
    let httpOptions;

    /**
     * The options to be passed to the {@link $http} service when making the request.
     * You can use this to override options such as the "Accept" header for template requests.
     * The {@link $templateRequest} will set the `cache` and the `transformResponse` properties of the
     * options if not overridden here.
     *
     * @param {string=} val new value for the {@link $http} options.
     * @returns {string|TemplateRequestProvider} Returns the {@link $http} options when used as getter and self if used as setter.
     */
    this.httpOptions = function (val) {
      if (val) {
        httpOptions = val;

        return this;
      }

      return httpOptions;
    };

    /**
     * The `$templateRequest` service runs security checks then downloads the provided template using
     * `$http` and, upon success, stores the contents inside of `$templateCache`. If the HTTP request
     * fails or the response data of the HTTP request is empty, a `$compile` error will be thrown (the
     * exception can be thwarted by setting the 2nd parameter of the function to true). Note that the
     * contents of `$templateCache` are trusted, so the call to `$sce.getTrustedUrl(tpl)` is omitted
     * when `tpl` is of type string and `$templateCache` has the matching entry.
     *
     * If you want to pass custom options to the `$http` service, such as setting the Accept header you
     * can configure this via {@link $templateRequestProvider#httpOptions}.
     *
     * `$templateRequest` is used internally by {@link $compile}, {@link ngRoute.$route}, and directives such
     * as {@link ngInclude} to download and cache templates.
     *
     * 3rd party modules should use `$templateRequest` if their services or directives are loading
     * templates.
     *
     * @param {string} tpl The HTTP request template URL
     * @param {boolean=} ignoreRequestError Whether or not to ignore the exception when the request fails or the template is empty
     *
     * @return {Promise} a promise for the HTTP response data of the given URL.
     *
     * @property {number} totalPendingRequests total amount of pending template requests being downloaded.
     */
    this.$get = [
      $injectTokens._exceptionHandler,
      $injectTokens._templateCache,
      $injectTokens._http,
      $injectTokens._sce,
      /**
       *
       * @param {ng.ExceptionHandlerService} $exceptionHandler
       * @param {ng.TemplateCacheService} $templateCache
       * @param {ng.HttpService} $http
       * @param {*} $sce
       * @returns {ng.TemplateRequestService}
       */
      function ($exceptionHandler, $templateCache, $http, $sce) {
        function handleRequestFn(tpl, ignoreRequestError) {
          handleRequestFn.totalPendingRequests++;

          // We consider the template cache holds only trusted templates, so
          // there's no need to go through adding the template again to the trusted
          // resources for keys that already are included in there. This also makes
          // AngularTS accept any script directive, no matter its name. However, we
          // still need to unwrap trusted types.

          if (!isString(tpl) || !$templateCache.has(tpl)) {
            try {
              tpl = $sce.getTrustedResourceUrl(tpl);

              if (!tpl) {
                return Promise.reject("Template not found");
              }
            } catch (err) {
              return Promise.reject(err.message);
            }
          }

          let transformResponse =
            $http.defaults && $http.defaults.transformResponse;

          if (isArray(transformResponse)) {
            transformResponse = transformResponse.filter(function (transformer) {
              return transformer !== defaultHttpResponseTransform;
            });
          } else if (transformResponse === defaultHttpResponseTransform) {
            transformResponse = null;
          }

          return $http
            .get(
              tpl,
              extend(
                {
                  cache: $templateCache,
                  transformResponse,
                },
                httpOptions,
              ),
            )
            .finally(function () {
              handleRequestFn.totalPendingRequests--;
            })
            .then(function (response) {
              $templateCache.set(tpl, response.data);

              return response.data;
            }, handleError);

          function handleError(resp) {
            if (!ignoreRequestError) {
              resp = $templateRequestMinErr(
                "tpload",
                "Failed to load template: {0} (HTTP status: {1} {2})",
                tpl,
                resp.status,
                resp.statusText,
              );

              $exceptionHandler(resp);
            }

            return Promise.reject(resp);
          }
        }

        handleRequestFn.totalPendingRequests = 0;

        return handleRequestFn;
      },
    ];
  }

  /** @typedef {import('../../interface.ts').ServiceProvider} ServiceProvider */

  /**
   * Private service to sanitize uris for links and images. Used by $compile.
   * @implements {ServiceProvider}
   */
  class SanitizeUriProvider {
    constructor() {
      /**
       * @private
       * @type {RegExp}
       */
      this._aHrefSanitizationTrustedUrlList =
        /^\s*(https?|s?ftp|mailto|tel|file):/;

      /**
       * @private
       * @type {RegExp}
       */
      this._imgSrcSanitizationTrustedUrlList =
        /^\s*((https?|ftp|file|blob):|data:image\/)/;
    }

    /**
     * Retrieves or overrides the regexp used to trust URLs for a[href] sanitization.
     *
     * @param {RegExp=} regexp New regexp to trust URLs with.
     * @returns {RegExp|SanitizeUriProvider} Current regexp if no param, or self for chaining.
     */
    aHrefSanitizationTrustedUrlList(regexp) {
      if (isDefined(regexp)) {
        this._aHrefSanitizationTrustedUrlList = regexp;

        return this;
      }

      return this._aHrefSanitizationTrustedUrlList;
    }

    /**
     * Retrieves or overrides the regexp used to trust URLs for img[src] sanitization.
     *
     * @param {RegExp=} regexp New regexp to trust URLs with.
     * @returns {RegExp|SanitizeUriProvider} Current regexp if no param, or self for chaining.
     */
    imgSrcSanitizationTrustedUrlList(regexp) {
      if (isDefined(regexp)) {
        this._imgSrcSanitizationTrustedUrlList = regexp;

        return this;
      }

      return this._imgSrcSanitizationTrustedUrlList;
    }

    /**
     * @returns {import("./interface.ts").SanitizerFn}
     */
    $get = [
      $injectTokens._window,
      /** @param {ng.WindowService} $window */
      ($window) => {
        return /** @type {import("./interface.ts").SanitizerFn} */ (
          (uri, isMediaUrl) => {
            if (!uri) return uri;

            /** @type {RegExp} */
            const regex = isMediaUrl
              ? this._imgSrcSanitizationTrustedUrlList
              : this._aHrefSanitizationTrustedUrlList;

            const normalizedVal = new URL(uri.trim(), $window.location.href).href;

            if (normalizedVal !== "" && !normalizedVal.match(regex)) {
              return `unsafe:${normalizedVal}`;
            }

            return uri;
          }
        );
      },
    ];
  }

  const ACTIVE_CLASS = "ng-active";

  const INACTIVE_CLASS = "ng-inactive";

  class NgMessageCtrl {
    /**
     * @param {Element} $element
     * @param {ng.Scope} $scope
     * @param {ng.Attributes} $attrs
     * @param {ng.AnimateService} $animate
     */
    constructor($element, $scope, $attrs, $animate) {
      this.$element = $element;
      this.$scope = $scope;
      this.$attrs = $attrs;
      this.$animate = $animate;

      this.latestKey = 0;
      this.nextAttachId = 0;
      this.messages = {};
      this.renderLater = false;
      this.cachedCollection = null;

      this.head = undefined;
      this.default = undefined;

      this.$scope.$watch(
        this.$attrs.ngMessages || this.$attrs.for,
        this.render.bind(this),
      );
    }

    getAttachId() {
      return this.nextAttachId++;
    }

    render(collection = {}) {
      this.renderLater = false;
      this.cachedCollection = collection;

      const multiple =
        isAttrTruthy(this.$scope, this.$attrs.ngMessagesMultiple) ||
        isAttrTruthy(this.$scope, this.$attrs.multiple);

      const unmatchedMessages = [];

      const matchedKeys = {};

      let truthyKeys = 0;

      let messageItem = this.head;

      let messageFound = false;

      let totalMessages = 0;

      while (messageItem) {
        totalMessages++;
        const messageCtrl = messageItem.message;

        let messageUsed = false;

        if (!messageFound) {
          entries(collection).forEach(([key, value]) => {
            if (truthy(value) && !messageUsed) {
              truthyKeys++;

              if (messageCtrl.test(key)) {
                if (matchedKeys[key]) return;
                matchedKeys[key] = true;

                messageUsed = true;
                messageCtrl.attach();
              }
            }
          });
        }

        if (messageUsed) {
          messageFound = !multiple;
        } else {
          unmatchedMessages.push(messageCtrl);
        }

        messageItem = messageItem.next;
      }

      unmatchedMessages.forEach((messageCtrl) => {
        messageCtrl.detach();
      });

      const messageMatched = unmatchedMessages.length !== totalMessages;

      const attachDefault = this.default && !messageMatched && truthyKeys > 0;

      if (attachDefault) {
        this.default.attach();
      } else if (this.default) {
        this.default.detach();
      }

      if (messageMatched || attachDefault) {
        this.$animate.setClass(this.$element, ACTIVE_CLASS, INACTIVE_CLASS);
      } else {
        this.$animate.setClass(this.$element, INACTIVE_CLASS, ACTIVE_CLASS);
      }
    }

    reRender() {
      if (!this.renderLater) {
        this.renderLater = true;
        Promise.resolve().then(() => {
          if (this.renderLater && this.cachedCollection) {
            this.render(this.cachedCollection);
          }
        });
      }
    }

    register(comment, messageCtrl, isDefault) {
      if (isDefault) {
        this.default = messageCtrl;
      } else {
        const nextKey = this.latestKey.toString();

        this.messages[nextKey] = {
          message: messageCtrl,
        };
        this.insertMessageNode(this.$element, comment, nextKey);
        comment.$$ngMessageNode = nextKey;
        this.latestKey++;
      }

      this.reRender();
    }

    deregister(comment, isDefault) {
      if (isDefault) {
        delete this.default;
      } else {
        const key = comment.$$ngMessageNode;

        delete comment.$$ngMessageNode;
        this.removeMessageNode(this.$element, comment, key);
        delete this.messages[key];
      }
      this.reRender();
    }

    findPreviousMessage(parent, comment) {
      let prevNode = comment;

      const parentLookup = [];

      while (prevNode && prevNode !== parent) {
        const prevKey = prevNode.$$ngMessageNode;

        if (prevKey && prevKey.length) {
          return this.messages[prevKey];
        }

        if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {
          parentLookup.push(prevNode);
          prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
        } else if (prevNode.previousSibling) {
          prevNode = prevNode.previousSibling;
        } else {
          prevNode = prevNode.parentNode;
          parentLookup.push(prevNode);
        }
      }

      return undefined;
    }

    insertMessageNode(parent, comment, key) {
      const messageNode = this.messages[key];

      if (!this.head) {
        this.head = messageNode;
      } else {
        const match = this.findPreviousMessage(parent, comment);

        if (match) {
          messageNode.next = match.next;
          match.next = messageNode;
        } else {
          messageNode.next = this.head;
          this.head = messageNode;
        }
      }
    }

    removeMessageNode(parent, comment, key) {
      const messageNode = this.messages[key];

      if (!messageNode) return;

      const match = this.findPreviousMessage(parent, comment);

      if (match) {
        match.next = messageNode.next;
      } else {
        this.head = messageNode.next;
      }
    }
  }

  ngMessagesDirective.$inject = [$injectTokens._animate];
  /**
   * @param {ng.AnimateService} $animate
   * @returns {ng.Directive<NgMessageCtrl>}
   */
  function ngMessagesDirective($animate) {
    return {
      require: "ngMessages",
      restrict: "AE",
      controller: ($element, $scope, $attrs) =>
        new NgMessageCtrl($element, $scope, $attrs, $animate),
    };
  }

  function isAttrTruthy(scope, attr) {
    return (
      (isString(attr) && attr.length === 0) || // empty attribute
      truthy(scope.$eval(attr))
    );
  }

  function truthy(val) {
    return isString(val) ? val.length : !!val;
  }

  ngMessagesIncludeDirective.$inject = [
    $injectTokens._templateRequest,
    $injectTokens._compile,
  ];

  /**
   * @param {ng.TemplateRequestService} $templateRequest
   * @param {ng.CompileService} $compile
   * @returns {ng.Directive}
   */
  function ngMessagesIncludeDirective($templateRequest, $compile) {
    return {
      restrict: "AE",
      require: "^^ngMessages", // we only require this for validation sake
      link($scope, element, attrs) {
        const src = attrs.ngMessagesInclude || attrs.src;

        $templateRequest(src).then((html) => {
          if ($scope.$$destroyed) return;

          if (isString(html) && !html.trim()) ; else {
            // Non-empty template - compile and link
            $compile(html)($scope, (contents) => {
              isIntanceOf(contents, Node) && element.after(contents);
            });
          }
        });
      },
    };
  }

  const ngMessageDirective = ngMessageDirectiveFactory(false);
  const ngMessageExpDirective = ngMessageDirectiveFactory(false);
  const ngMessageDefaultDirective = ngMessageDirectiveFactory(true);

  /**
   * @param {boolean} isDefault
   * @returns {(any) => ng.Directive}
   */
  function ngMessageDirectiveFactory(isDefault) {
    ngMessageDirectiveFn.$inject = [$injectTokens._animate];
    /**
     * @param {ng.AnimateService} $animate
     * @returns {ng.Directive}
     */
    function ngMessageDirectiveFn($animate) {
      return {
        restrict: "AE",
        transclude: "element",
        priority: 1, // must run before ngBind, otherwise the text is set on the comment
        terminal: true,
        require: "^^ngMessages",
        link(scope, element, attrs, ngMessagesCtrl, $transclude) {
          let commentNode;

          let records;

          let staticExp;

          let dynamicExp;

          if (!isDefault) {
            commentNode = element;
            staticExp = attrs.ngMessage || attrs.when;
            dynamicExp = attrs.ngMessageExp || attrs.whenExp;

            const assignRecords = function (items) {
              records = items
                ? isArray(items)
                  ? items
                  : items.split(/[\s,]+/)
                : null;
              ngMessagesCtrl.reRender();
            };

            if (dynamicExp) {
              assignRecords(scope.$eval(dynamicExp));
              scope.$watch(dynamicExp, assignRecords);
            } else {
              assignRecords(staticExp);
            }
          }

          let currentElement;

          let messageCtrl;

          ngMessagesCtrl.register(
            commentNode,
            (messageCtrl = {
              test(name) {
                return contains(records, name);
              },
              attach() {
                if (!currentElement) {
                  $transclude((elm, newScope) => {
                    $animate.enter(elm, null, element);
                    currentElement = elm;

                    // Each time we attach this node to a message we get a new id that we can match
                    // when we are destroying the node later.
                    const $$attachId = (currentElement.$$attachId =
                      ngMessagesCtrl.getAttachId());

                    // in the event that the element or a parent element is destroyed
                    // by another structural directive then it's time
                    // to deregister the message from the controller
                    currentElement.addEventListener("$destroy", () => {
                      // If the message element was removed via a call to `detach` then `currentElement` will be null
                      // So this handler only handles cases where something else removed the message element.
                      if (
                        currentElement &&
                        currentElement.$$attachId === $$attachId
                      ) {
                        ngMessagesCtrl.deregister(commentNode, isDefault);
                        messageCtrl.detach();
                      }
                      newScope.$destroy();
                    });
                  });
                }
              },
              detach() {
                if (currentElement) {
                  const elm = currentElement;

                  currentElement = null;
                  $animate.leave(elm);
                }
              },
            }),
            isDefault,
          );

          // We need to ensure that this directive deregisters itself when it no longer exists
          // Normally this is done when the attached element is destroyed; but if this directive
          // gets removed before we attach the message to the DOM there is nothing to watch
          // in which case we must deregister when the containing scope is destroyed.
          scope.$on("$destroy", () => {
            ngMessagesCtrl.deregister(commentNode, isDefault);
          });
        },
      };
    }

    return ngMessageDirectiveFn;
  }

  function contains(collection, key) {
    if (collection) {
      return isArray(collection)
        ? collection.indexOf(key) >= 0
        : hasOwn(collection, key);
    }

    return undefined;
  }

  const ARIA_DISABLE_ATTR = "ngAriaDisable";

  /**
   * Internal Utilities
   */
  const nativeAriaNodeNames = [
    "BUTTON",
    "A",
    "INPUT",
    "TEXTAREA",
    "SELECT",
    "DETAILS",
    "SUMMARY",
  ];

  const isNodeOneOf = function (elem, nodeTypeArray) {
    if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
      return true;
    }

    return false;
  };

  /**
   * Used for configuring the ARIA attributes injected and managed by ngAria.
   *
   * ```js
   * angular.module('myApp', ['ngAria'], function config($ariaProvider) {
   *   $ariaProvider.config({
   *     ariaValue: true,
   *     tabindex: false
   *   });
   * });
   *```
   *
   * ## Dependencies
   * Requires the {@link ngAria} module to be installed.
   *
   */
  function AriaProvider() {
    let config = {
      ariaHidden: true,
      ariaChecked: true,
      ariaReadonly: true,
      ariaDisabled: true,
      ariaRequired: true,
      ariaInvalid: true,
      ariaValue: true,
      tabindex: true,
      bindKeydown: true,
      bindRoleForClick: true,
    };

    this.config = function (newConfig) {
      config = extend(config, newConfig);
    };

    function watchExpr(attrName, ariaAttr, nativeAriaNodeNamesParam, negate) {
      return function (scope, elem, attr) {
        if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;

        const ariaCamelName = attr.$normalize(ariaAttr);

        if (
          config[ariaCamelName] &&
          !isNodeOneOf(elem, nativeAriaNodeNamesParam) &&
          !attr[ariaCamelName]
        ) {
          scope.$watch(attr[attrName], (boolVal) => {
            // ensure boolean value
            boolVal = negate ? !boolVal : !!boolVal;
            elem.setAttribute(ariaAttr, boolVal);
          });
        }
      };
    }

    this.$get = function () {
      return {
        config(key) {
          return config[key];
        },
        $$watchExpr: watchExpr,
      };
    };
  }

  ngDisabledAriaDirective.$inject = [$injectTokens._aria];
  function ngDisabledAriaDirective($aria) {
    return $aria.$$watchExpr(
      "ngDisabled",
      "aria-disabled",
      nativeAriaNodeNames,
      false,
    );
  }

  ngShowAriaDirective.$inject = [$injectTokens._aria];
  function ngShowAriaDirective($aria) {
    return $aria.$$watchExpr("ngShow", "aria-hidden", [], true);
  }

  /**
   * @return {ng.Directive}
   */
  function ngMessagesAriaDirective() {
    return {
      restrict: "A",
      require: "?ngMessages",
      link(_scope, elem, attr) {
        if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;

        if (!elem.hasAttribute("aria-live")) {
          elem.setAttribute("aria-live", "assertive");
        }
      },
    };
  }

  ngClickAriaDirective.$inject = [$injectTokens._aria, $injectTokens._parse];

  /**
   * @param $aria
   * @param {ng.ParseService} $parse
   * @return {ng.Directive}
   */
  function ngClickAriaDirective($aria, $parse) {
    return {
      restrict: "A",
      compile(_elem, attr) {
        if (hasOwn(attr, ARIA_DISABLE_ATTR)) return undefined;

        const fn = $parse(attr.ngClick);

        return (scope, elem, attrParam) => {
          if (!isNodeOneOf(elem, nativeAriaNodeNames)) {
            if ($aria.config("bindRoleForClick") && !elem.hasAttribute("role")) {
              elem.setAttribute("role", "button");
            }

            if ($aria.config("tabindex") && !elem.hasAttribute("tabindex")) {
              elem.setAttribute("tabindex", "0");
            }

            if (
              $aria.config("bindKeydown") &&
              !attrParam.ngKeydown &&
              !attrParam.ngKeypress &&
              !attrParam.ngKeyup
            ) {
              elem.addEventListener(
                "keydown",
                /** @param {KeyboardEvent} event */
                (event) => {
                  const keyCode = parseInt(event.key, 10);

                  // eslint-disable-next-line no-magic-numbers
                  if (keyCode === 13 || keyCode === 32) {
                    // If the event is triggered on a non-interactive element ...
                    if (
                      nativeAriaNodeNames.indexOf(
                        /** @type {Node} */ (event.target).nodeName,
                      ) === -1 &&
                      !(
                        /** @type {HTMLElement} */ (event.target)
                          .isContentEditable
                      )
                    ) {
                      // ... prevent the default browser behavior (e.g. scrolling when pressing spacebar)
                      // See https://github.com/angular/angular.js/issues/16664
                      event.preventDefault();
                    }
                    fn(scope, { $event: event });
                  }
                },
              );
            }
          }
        };
      },
    };
  }

  ngRequiredAriaDirective.$inject = [$injectTokens._aria];
  function ngRequiredAriaDirective($aria) {
    return $aria.$$watchExpr(
      "ngRequired",
      "aria-required",
      nativeAriaNodeNames,
      false,
    );
  }

  ngCheckedAriaDirective.$inject = [$injectTokens._aria];
  function ngCheckedAriaDirective($aria) {
    return $aria.$$watchExpr(
      "ngChecked",
      "aria-checked",
      nativeAriaNodeNames,
      false,
    );
  }

  ngValueAriaDirective.$inject = [$injectTokens._aria];
  function ngValueAriaDirective($aria) {
    return $aria.$$watchExpr(
      "ngValue",
      "aria-checked",
      nativeAriaNodeNames,
      false,
    );
  }

  ngHideAriaDirective.$inject = [$injectTokens._aria];
  function ngHideAriaDirective($aria) {
    return $aria.$$watchExpr("ngHide", "aria-hidden", [], false);
  }

  ngReadonlyAriaDirective.$inject = [$injectTokens._aria];
  function ngReadonlyAriaDirective($aria) {
    return $aria.$$watchExpr(
      "ngReadonly",
      "aria-readonly",
      nativeAriaNodeNames,
      false,
    );
  }

  ngModelAriaDirective.$inject = [$injectTokens._aria];
  function ngModelAriaDirective($aria) {
    function shouldAttachAttr(attr, normalizedAttr, elem, allowNonAriaNodes) {
      return (
        $aria.config(normalizedAttr) &&
        !elem.getAttribute(attr) &&
        (allowNonAriaNodes || !isNodeOneOf(elem, nativeAriaNodeNames)) &&
        (elem.getAttribute("type") !== "hidden" || elem.nodeName !== "INPUT")
      );
    }

    function shouldAttachRole(role, elem) {
      // if element does not have role attribute
      // AND element type is equal to role (if custom element has a type equaling shape) <-- remove?
      // AND element is not in nativeAriaNodeNames
      return (
        !elem.getAttribute("role") &&
        elem.getAttribute("type") === role &&
        !isNodeOneOf(elem, nativeAriaNodeNames)
      );
    }

    function getShape(attr) {
      const { type } = attr;

      const { role } = attr;

      return (type || role) === "checkbox" || role === "menuitemcheckbox"
        ? "checkbox"
        : (type || role) === "radio" || role === "menuitemradio"
          ? "radio"
          : type === "range" || role === "progressbar" || role === "slider"
            ? "range"
            : "";
    }

    return {
      restrict: "A",
      require: "ngModel",
      priority: 200, // Make sure watches are fired after any other directives that affect the ngModel value
      compile(_, attr) {
        if (hasOwn(attr, ARIA_DISABLE_ATTR)) return undefined;

        const shape = getShape(attr);

        return {
          // eslint-disable-next-line no-shadow
          post(_, elem, attrPost, ngModel) {
            const needsTabIndex = shouldAttachAttr(
              "tabindex",
              "tabindex",
              elem,
              false,
            );

            function getRadioReaction() {
              // Strict comparison would cause a BC
              elem.setAttribute(
                "aria-checked",
                // eslint-disable-next-line eqeqeq
                (attrPost.value == ngModel.$viewValue).toString(),
              );
            }

            function getCheckboxReaction() {
              elem.setAttribute(
                "aria-checked",
                (!ngModel.$isEmpty(ngModel.$viewValue)).toString(),
              );
            }

            switch (shape) {
              case "radio":
              case "checkbox":
                if (shouldAttachRole(shape, elem)) {
                  elem.setAttribute("role", shape);
                }

                if (
                  shouldAttachAttr("aria-checked", "ariaChecked", elem, false)
                ) {
                  ngModel.$watch(
                    "$modelValue",
                    shape === "radio" ? getRadioReaction : getCheckboxReaction,
                  );
                }

                if (needsTabIndex) {
                  elem.setAttribute("tabindex", 0);
                }
                break;
              case "range":
                if (shouldAttachRole(shape, elem)) {
                  elem.setAttribute("role", "slider");
                }

                if ($aria.config("ariaValue")) {
                  const needsAriaValuemin =
                    !elem.hasAttribute("aria-valuemin") &&
                    (hasOwn(attrPost, "min") || hasOwn(attrPost, "ngMin"));

                  const needsAriaValuemax =
                    !elem.hasAttribute("aria-valuemax") &&
                    (hasOwn(attrPost, "max") || hasOwn(attrPost, "ngMax"));

                  const needsAriaValuenow = !elem.hasAttribute("aria-valuenow");

                  if (needsAriaValuemin) {
                    attrPost.$observe("min", (newVal) => {
                      elem.setAttribute("aria-valuemin", newVal);
                    });
                  }

                  if (needsAriaValuemax) {
                    attrPost.$observe("max", (newVal) => {
                      elem.setAttribute("aria-valuemax", newVal);
                    });
                  }

                  if (needsAriaValuenow) {
                    ngModel.$watch("$modelValue", (newVal) => {
                      elem.setAttribute("aria-valuenow", newVal);
                    });
                  }
                }

                if (needsTabIndex) {
                  elem.setAttribute("tabindex", 0);
                }
                break;
            }

            if (
              !hasOwn(attrPost, "ngRequired") &&
              ngModel.$validators.required &&
              shouldAttachAttr("aria-required", "ariaRequired", elem, false)
            ) {
              // ngModel.$error.required is undefined on custom controls
              attrPost.$observe("required", () => {
                elem.setAttribute(
                  "aria-required",
                  (!!attrPost.required).toString(),
                );
              });
            }

            if (shouldAttachAttr("aria-invalid", "ariaInvalid", elem, true)) {
              ngModel.$watch("$invalid", (newVal) => {
                elem.setAttribute("aria-invalid", (!!newVal).toString());
              });
            }
          },
        };
      },
    };
  }

  ngDblclickAriaDirective.$inject = [$injectTokens._aria];
  function ngDblclickAriaDirective($aria) {
    return function (scope, elem, attr) {
      if (hasOwn(attr, ARIA_DISABLE_ATTR)) return;

      if (
        $aria.config("tabindex") &&
        !elem.hasAttribute("tabindex") &&
        !isNodeOneOf(elem, nativeAriaNodeNames)
      ) {
        elem.setAttribute("tabindex", 0);
      }
    };
  }

  /**
   * Hybrid AnimateRunner
   * Supports both CSS animations (batched) and JS animations (per-Tick).
   *
   * The runner:
   *   - tracks completion state
   *   - supports done callbacks
   *   - exposes a host API (end, cancel, pause, resume)
   *   - can be awaited as a Promise
   *
   * It intentionally mirrors AngularJS 1.x $$AnimateRunner behavior.
   */

  /**
   * @typedef {import("../interface.ts").AnimationHost} AnimationHost
   */

  /**
   * Internal runner states.
   * @internal
   * @enum {number}
   */
  const RunnerState = {
    /** Initial state before any completion logic started */
    _INITIAL: 0,

    /** Completion has been scheduled but not finished */
    _PENDING: 1,

    /** The runner is fully completed and callbacks fired */
    _DONE: 2,
  };

  /**
   * Global queue used to batch CSS animation callbacks.
   * @type {Array<VoidFunction>}
   */
  let queue = [];

  /** @type {boolean} */
  let scheduled = false;

  /**
   * Flushes all queued callbacks in FIFO order.
   * @private
   */
  function flush() {
    const tasks = queue;

    queue = [];
    scheduled = false;

    for (let i = 0; i < tasks.length; i++) {
      tasks[i]();
    }
  }

  /**
   * Schedules a callback for next animation frame,
   * falling back to setTimeout(0) when RAF is unavailable.
   *
   * @param {VoidFunction} fn
   */
  function schedule(fn) {
    queue.push(fn);

    if (!scheduled) {
      scheduled = true;

      requestAnimationFrame(flush);
    }
  }

  class AnimateRunner {
    /**
     * @param {AnimationHost} [host] - Optional animation host callbacks.
     * @param {boolean} [jsAnimation=false]
     *        If true: use RAF/timer ticks.
     *        If false: use batched CSS animation ticks.
     */
    constructor(host = {}, jsAnimation = false) {
      /** @type {AnimationHost} */
      this._host = host;

      /** @type {Array<(ok: boolean) => void>} */
      this._doneCallbacks = [];

      /** @type {RunnerState} */
      this._state = RunnerState._INITIAL;

      /**
       * Deferred promise used by .then/.catch/.finally.
       * @type {Promise<void>|null}
       * @private
       */
      this._promise = null;

      /**
       * Internal tick scheduling function.
       * - JS animations: immediate RAF or fallback timer
       * - CSS animations: batched global queue
       * @type {(fn: VoidFunction) => void}
       * @private
       */
      if (jsAnimation) {
        const rafTick = (fn) => requestAnimationFrame(fn);

        const timeoutTick = (fn) => setTimeout(fn, 0);

        this._tick = (fn) => {
          // When tab is hidden, requestAnimationFrame throttles heavily.
          if (document.hidden) timeoutTick(fn);
          else rafTick(fn);
        };
      } else {
        this._tick = schedule;
      }
    }

    /**
     * Sets or replaces the current host.
     * @param {AnimationHost} host
     */
    setHost(host) {
      this._host = host || {};
    }

    /**
     * Register a completion callback.
     * Fires immediately if animation is already done.
     *
     * @param {(ok: boolean) => void} fn
     */
    done(fn) {
      if (this._state === RunnerState._DONE) {
        fn(true);
      } else {
        this._doneCallbacks.push(fn);
      }
    }

    /**
     * Reports progress to host.
     * @param {...any} args
     */
    progress(...args) {
      this._host.progress?.(...args);
    }

    /** Pause underlying animation (if supported). */
    pause() {
      this._host.pause?.();
    }

    /** Resume underlying animation (if supported). */
    resume() {
      this._host.resume?.();
    }

    /**
     * Ends the animation successfully.
     * Equivalent to user choosing to finish it immediately.
     */
    end() {
      this._host.end?.();
      this._finish(true);
    }

    /**
     * Cancels the animation.
     */
    cancel() {
      this._host.cancel?.();
      this._finish(false);
    }

    /**
     * Schedule animation completion.
     *
     * @param {boolean} [status=true]
     */
    complete(status = true) {
      if (this._state === RunnerState._INITIAL) {
        this._state = RunnerState._PENDING;
        this._tick(() => this._finish(status));
      }
    }

    /**
     * Completes the animation and invokes all done callbacks.
     * @param {boolean} status
     * @private
     */
    _finish(status) {
      if (this._state === RunnerState._DONE) return;

      this._state = RunnerState._DONE;

      const callbacks = this._doneCallbacks;

      this._doneCallbacks = [];

      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i] && callbacks[i](status);
      }
    }

    /**
     * Returns an internal promise that resolves on success,
     * and rejects on cancel.
     *
     * @returns {Promise<void>}
     */
    getPromise() {
      if (!this._promise) {
        this._promise = new Promise((resolve, reject) => {
          this.done((ok) => (ok === false ? reject() : resolve()));
        });
      }

      return this._promise;
    }

    /**
     * Standard "thenable" interface
     * @template T
     * @param {(value: void) => T|Promise<T>} onFulfilled
     * @param {(reason: any) => any} [onRejected]
     * @returns {Promise<T>}
     */
    then(onFulfilled, onRejected) {
      return this.getPromise().then(onFulfilled, onRejected);
    }

    /**
     * Standard promise catcher.
     * @param {(reason: any) => any} onRejected
     * @returns {Promise<void>}
     */
    catch(onRejected) {
      return this.getPromise().catch(onRejected);
    }

    /**
     * Standard promise finally.
     * @param {() => any} onFinally
     * @returns {Promise<void>}
     */
    finally(onFinally) {
      return this.getPromise().finally(onFinally);
    }

    // ---------------------------------------------------------------------------
    //  STATIC HELPERS
    // ---------------------------------------------------------------------------

    /**
     * Executes a list of runners sequentially.
     * Each must complete before the next starts.
     *
     * @param {AnimateRunner[]} runners
     * @param {(ok: boolean) => void} callback
     */
    static _chain(runners, callback) {
      let i = 0;

      const next = (ok = true) => {
        if (!ok || i >= runners.length) {
          callback(ok);

          return;
        }
        runners[i++].done(next);
      };

      next();
    }

    /**
     * Waits until all runners complete.
     *
     * @param {AnimateRunner[]} runners
     * @param {(ok: boolean) => void} callback
     */
    static _all(runners, callback) {
      let remaining = runners.length;

      let status = true;

      for (const i of runners) {
        i.done((result) => {
          if (result === false) status = false;

          if (--remaining === 0) callback(status);
        });
      }
    }
  }

  const ANIMATE_TIMER_KEY = $injectTokens._animateCss;

  const ONE_SECOND = 1000;

  const SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

  const ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;

  const CLOSING_TIME_BUFFER = 1.5;

  const DETECT_CSS_PROPERTIES = {
    transitionDuration: "transitionDuration",
    transitionDelay: "transitionDelay",
    transitionProperty: "transitionProperty",
    animationDuration: "animationDuration",
    animationDelay: "animationDelay",
    animationIterationCount: "animationIterationCount",
  };

  const DETECT_STAGGER_CSS_PROPERTIES = {
    transitionDuration: "transitionDuration",
    transitionDelay: "transitionDelay",
    animationDuration: "animationDuration",
    animationDelay: "animationDelay",
  };

  function getCssKeyframeDurationStyle(duration) {
    return ["animationDuration", `${duration}s`];
  }

  function getCssDelayStyle(delay, isKeyframeAnimation) {
    const prop = isKeyframeAnimation ? "animationDelay" : "transitionDelay";

    return [prop, `${delay}s`];
  }

  function computeCssStyles(element, properties) {
    const styles = Object.create(null);

    const detectedStyles = window.getComputedStyle(element) || {};

    entries(properties).forEach(([actualStyleName, formalStyleName]) => {
      let val = detectedStyles[formalStyleName];

      if (val) {
        const char = val.charAt(0);

        // only numerical-based values have a negative sign or digit as the first value
        if (char === "-" || char === "+" || char >= 0) {
          val = parseMaxTime(val);
        }

        // by setting this to null in the event that the delay is not set or is set directly as 0
        // then we can still allow for negative values to be used later on and not mistake this
        // value for being greater than any other negative value.
        if (val === 0) {
          val = null;
        }
        styles[actualStyleName] = val;
      }
    });

    return styles;
  }

  function parseMaxTime(str) {
    let maxValue = 0;

    str.split(/\s*,\s*/).forEach((value) => {
      // it's always safe to consider only second values and omit `ms` values since
      // getComputedStyle will always handle the conversion for us
      if (value.charAt(value.length - 1) === "s") {
        value = value.substring(0, value.length - 1);
      }
      value = parseFloat(value) || 0;
      maxValue = maxValue ? Math.max(value, maxValue) : value;
    });

    return maxValue;
  }

  function truthyTimingValue(val) {
    return val === 0 || !isNullOrUndefined(val);
  }

  function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
    let style = "transition";

    let value = `${duration}s`;

    if (applyOnlyDuration) {
      style += "Duration";
    } else {
      value += " linear all";
    }

    return [style, value];
  }

  // we do not reassign an already present style value since
  // if we detect the style property value again we may be
  // detecting styles that were added via the `from` styles.
  // We make use of `isDefined` here since an empty string
  // or null value (which is what getPropertyValue will return
  // for a non-existing style) will still be marked as a valid
  // value for the style (a falsy value implies that the style
  // is to be removed at the end of the animation). If we had a simple
  // "OR" statement then it would not be enough to catch that.
  function registerRestorableStyles(backup, node, properties) {
    properties.forEach((prop) => {
      backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
    });
  }

  function AnimateCssProvider() {
    let activeClasses;

    this.$get = [
      $injectTokens._animateCache,
      $injectTokens._rAFScheduler,

      /**
       *
       * @param {*} $$animateCache
       * @param {import("./raf-scheduler").RafScheduler} $$rAFScheduler
       * @returns
       */
      function ($$animateCache, $$rAFScheduler) {
        const applyAnimationClasses = applyAnimationClassesFactory();

        // TODO add types
        function computeCachedCssStyles(
          node,
          cacheKey,
          allowNoDuration,
          properties,
        ) {
          let timings = $$animateCache.get(cacheKey);

          if (!timings) {
            timings = computeCssStyles(node, properties);

            if (timings.animationIterationCount === "infinite") {
              timings.animationIterationCount = 1;
            }
          }

          // if a css animation has no duration we
          // should mark that so that repeated addClass/removeClass calls are skipped
          const hasDuration =
            allowNoDuration ||
            timings.transitionDuration > 0 ||
            timings.animationDuration > 0;

          // we keep putting this in multiple times even though the value and the cacheKey are the same
          // because we're keeping an internal tally of how many duplicate animations are detected.
          $$animateCache.put(cacheKey, timings, hasDuration);

          return timings;
        }

        function computeCachedCssStaggerStyles(
          node,
          className,
          cacheKey,
          properties,
        ) {
          let stagger;

          const staggerCacheKey = `stagger-${cacheKey}`;

          // if we have one or more existing matches of matching elements
          // containing the same parent + CSS styles (which is how cacheKey works)
          // then staggering is possible
          if ($$animateCache.count(cacheKey) > 0) {
            stagger = $$animateCache.get(staggerCacheKey);

            if (!stagger) {
              const staggerClassName = pendClasses(className, "-stagger");

              node.className += ` ${staggerClassName}`;
              stagger = computeCssStyles(node, properties);

              // force the conversion of a null value to zero incase not set
              stagger.animationDuration = Math.max(stagger.animationDuration, 0);
              stagger.transitionDuration = Math.max(
                stagger.transitionDuration,
                0,
              );

              node.classList.remove(staggerClassName);

              $$animateCache.put(staggerCacheKey, stagger, true);
            }
          }

          return stagger || {};
        }

        const rafWaitQueue = [];

        function waitUntilQuiet(callback) {
          rafWaitQueue.push(callback);
          $$rAFScheduler._waitUntilQuiet(() => {
            $$animateCache.flush();

            // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
            // the line below will force the browser to perform a repaint so
            // that all the animated elements within the animation frame will
            // be properly updated and drawn on screen. This is required to
            // ensure that the preparation animation is properly flushed so that
            // the active state picks up from there. DO NOT REMOVE THIS LINE.
            // DO NOT OPTIMIZE THIS LINE. THE MINIFIER WILL REMOVE IT OTHERWISE WHICH
            // WILL RESULT IN AN UNPREDICTABLE BUG THAT IS VERY HARD TO TRACK DOWN AND
            // WILL TAKE YEARS AWAY FROM YOUR LIFE.

            const pageWidth = document.body.offsetWidth + 1;

            // we use a for loop to ensure that if the queue is changed
            // during this looping then it will consider new requests
            for (let i = 0; i < rafWaitQueue.length; i++) {
              rafWaitQueue[i](pageWidth);
            }
            rafWaitQueue.length = 0;
          });
        }

        function computeTimings(node, cacheKey, allowNoDuration) {
          const timings = computeCachedCssStyles(
            node,
            cacheKey,
            allowNoDuration,
            DETECT_CSS_PROPERTIES,
          );

          const aD = timings.animationDelay;

          const tD = timings.transitionDelay;

          timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
          timings.maxDuration = Math.max(
            timings.animationDuration * timings.animationIterationCount,
            timings.transitionDuration,
          );

          return timings;
        }

        return function init(element, initialOptions) {
          // all of the animation functions should create
          // a copy of the options data, however, if a
          // parent service has already created a copy then
          let delayStyle;

          // we should stick to using that
          let options = initialOptions || {
            $$skipPreparationClasses: false,
          };

          if (!options.$$prepared) {
            options = prepareAnimationOptions(structuredClone(options));
          }

          const restoreStyles = {};

          const node = /** @type {HTMLElement} */ (element);

          // Note: this had an additional  !$$animateQueue.enabled() check
          if (!node || !node.parentNode) {
            return closeAndReturnNoopAnimator();
          }

          const temporaryStyles = [];

          const styles = packageStyles(options);

          let animationClosed;

          let animationPaused;

          let animationCompleted;

          let runner;

          let runnerHost;

          let maxDelay;

          let maxDelayTime;

          let maxDuration;

          let maxDurationTime;

          let startTime;

          const events = [];

          if (options.duration === 0) {
            return closeAndReturnNoopAnimator();
          }

          const method =
            options.event && isArray(options.event)
              ? options.event.join(" ")
              : options.event;

          const isStructural = method && options.structural;

          let structuralClassName = "";

          let addRemoveClassName = "";

          if (isStructural) {
            structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
          } else if (method) {
            structuralClassName = method;
          }

          if (options.addClass) {
            addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
          }

          if (options.removeClass) {
            if (addRemoveClassName.length) {
              addRemoveClassName += " ";
            }
            addRemoveClassName += pendClasses(
              options.removeClass,
              REMOVE_CLASS_SUFFIX,
            );
          }

          // there may be a situation where a structural animation is combined together
          // with CSS classes that need to resolve before the animation is computed.
          // However this means that there is no explicit CSS code to block the animation
          // from happening (by setting 0s none in the class name). If this is the case
          // we need to apply the classes before the first rAF so we know to continue if
          // there actually is a detected transition or keyframe animation
          if (options.applyClassesEarly && addRemoveClassName.length) {
            applyAnimationClasses(element, options);
          }

          let preparationClasses = [structuralClassName, addRemoveClassName]
            .join(" ")
            .trim();

          const hasToStyles = styles.to && Object.keys(styles.to).length > 0;

          const containsKeyframeAnimation =
            (options.keyframeStyle || "").length > 0;

          // there is no way we can trigger an animation if no styles and
          // no classes are being applied which would then trigger a transition,
          // unless there a is raw keyframe value that is applied to the element.
          if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
            return closeAndReturnNoopAnimator();
          }

          let stagger;

          let cacheKey = $$animateCache.cacheKey(
            node,
            method,
            options.addClass,
            options.removeClass,
          );

          if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) {
            preparationClasses = null;

            return closeAndReturnNoopAnimator();
          }

          if (options.stagger > 0) {
            const staggerVal = parseFloat(options.stagger);

            stagger = {
              transitionDelay: staggerVal,
              animationDelay: staggerVal,
              transitionDuration: 0,
              animationDuration: 0,
            };
          } else {
            stagger = computeCachedCssStaggerStyles(
              node,
              preparationClasses,
              cacheKey,
              DETECT_STAGGER_CSS_PROPERTIES,
            );
          }

          if (!options.$$skipPreparationClasses) {
            element.classList.add(
              ...preparationClasses.split(" ").filter((x) => x !== ""),
            );
          }

          let applyOnlyDuration;

          if (options.transitionStyle) {
            const transitionStyle = ["transition", options.transitionStyle];

            applyInlineStyle(node, transitionStyle);
            temporaryStyles.push(transitionStyle);
          }

          if (options.duration >= 0) {
            applyOnlyDuration = node.style.transition.length > 0;
            const durationStyle = getCssTransitionDurationStyle(
              options.duration,
              applyOnlyDuration,
            );

            // we set the duration so that it will be picked up by getComputedStyle later
            applyInlineStyle(node, durationStyle);

            temporaryStyles.push(durationStyle);
          }

          if (options.keyframeStyle) {
            const keyframeStyle = ["animation", options.keyframeStyle];

            applyInlineStyle(node, keyframeStyle);
            temporaryStyles.push(keyframeStyle);
          }

          const itemIndex = stagger
            ? options.staggerIndex >= 0
              ? options.staggerIndex
              : $$animateCache.count(cacheKey)
            : 0;

          const isFirst = itemIndex === 0;

          // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
          // without causing any combination of transitions to kick in. By adding a negative delay value
          // it forces the setup class' transition to end immediately. We later then remove the negative
          // transition delay to allow for the transition to naturally do it's thing. The beauty here is
          // that if there is no transition defined then nothing will happen and this will also allow
          // other transitions to be stacked on top of each other without any chopping them out.
          if (isFirst && !options.skipBlocking) {
            blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
          }

          let timings = computeTimings(node, cacheKey, !isStructural);

          let relativeDelay = timings.maxDelay;

          maxDelay = Math.max(relativeDelay, 0);
          // eslint-disable-next-line prefer-destructuring
          maxDuration = timings.maxDuration;

          const flags = {};

          flags.hasTransitions = timings.transitionDuration > 0;
          flags.hasAnimations = timings.animationDuration > 0;
          flags.hasTransitionAll =
            flags.hasTransitions && timings.transitionProperty === "all";
          flags.applyTransitionDuration =
            hasToStyles &&
            ((flags.hasTransitions && !flags.hasTransitionAll) ||
              (flags.hasAnimations && !flags.hasTransitions));
          flags.applyAnimationDuration = options.duration && flags.hasAnimations;
          flags.applyTransitionDelay =
            truthyTimingValue(options.delay) &&
            (flags.applyTransitionDuration || flags.hasTransitions);
          flags.applyAnimationDelay =
            truthyTimingValue(options.delay) && flags.hasAnimations;
          flags.recalculateTimingStyles = addRemoveClassName.length > 0;

          if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
            maxDuration = options.duration
              ? parseFloat(options.duration)
              : maxDuration;

            if (flags.applyTransitionDuration) {
              flags.hasTransitions = true;
              timings.transitionDuration = maxDuration;
              applyOnlyDuration = node.style.transitionProperty.length > 0;
              temporaryStyles.push(
                getCssTransitionDurationStyle(maxDuration, applyOnlyDuration),
              );
            }

            if (flags.applyAnimationDuration) {
              flags.hasAnimations = true;
              timings.animationDuration = maxDuration;
              temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
            }
          }

          if (maxDuration === 0 && !flags.recalculateTimingStyles) {
            return closeAndReturnNoopAnimator();
          }

          activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);

          if (!isNullOrUndefined(options.delay)) {
            if (typeof options.delay !== "boolean") {
              delayStyle = parseFloat(options.delay);
              // number in options.delay means we have to recalculate the delay for the closing timeout
              maxDelay = Math.max(delayStyle, 0);
            }

            if (flags.applyTransitionDelay) {
              temporaryStyles.push(getCssDelayStyle(delayStyle));
            }

            if (flags.applyAnimationDelay) {
              temporaryStyles.push(getCssDelayStyle(delayStyle, true));
            }
          }

          // we need to recalculate the delay value since we used a pre-emptive negative
          // delay value and the delay value is required for the final event checking. This
          // property will ensure that this will happen after the RAF phase has passed.
          if (
            isNullOrUndefined(options.duration) &&
            timings.transitionDuration > 0
          ) {
            flags.recalculateTimingStyles =
              flags.recalculateTimingStyles || isFirst;
          }

          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;

          if (!options.skipBlocking) {
            flags.blockTransition = timings.transitionDuration > 0;
            flags.blockKeyframeAnimation =
              timings.animationDuration > 0 &&
              stagger.animationDelay > 0 &&
              stagger.animationDuration === 0;
          }

          if (options.from) {
            if (options.cleanupStyles) {
              registerRestorableStyles(
                restoreStyles,
                node,
                Object.keys(options.from),
              );
            }
            applyAnimationFromStyles(element, options);
          }

          if (flags.blockTransition || flags.blockKeyframeAnimation) {
            applyBlocking(maxDuration);
          } else if (!options.skipBlocking) {
            blockTransitions(node, false);
          }

          // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
          return {
            $$willAnimate: true,
            end: endFn,
            start() {
              if (animationClosed) return undefined;

              runnerHost = {
                end: endFn,
                cancel: cancelFn,
                resume: null, // this will be set during the start() phase
                pause: null,
              };

              runner = new AnimateRunner(runnerHost);

              waitUntilQuiet(start);

              // we don't have access to pause/resume the animation
              // since it hasn't run yet. AnimateRunner will therefore
              // set noop functions for resume and pause and they will
              // later be overridden once the animation is triggered
              return runner;
            },
          };

          function endFn() {
            close();
          }

          function cancelFn() {
            close(true);
          }

          function close(rejected) {
            // if the promise has been called already then we shouldn't close
            // the animation again
            if (animationClosed || (animationCompleted && animationPaused))
              return;
            animationClosed = true;
            animationPaused = false;

            if (preparationClasses && !options.$$skipPreparationClasses) {
              element.classList.remove(...preparationClasses.split(" "));
            }
            activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);

            if (activeClasses) {
              element.classList.remove(...activeClasses.split(" "));
            }

            blockKeyframeAnimations(node, false);
            blockTransitions(node, false);

            temporaryStyles.forEach((entry) => {
              // There is only one way to remove inline style properties entirely from elements.
              // By using `removeProperty` this works, but we need to convert camel-cased CSS
              // styles down to hyphenated values.
              node.style[entry[0]] = "";
            });

            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);

            if (keys(restoreStyles).length) {
              entries(restoreStyles).forEach(([prop, value]) => {
                if (value) {
                  node.style.setProperty(prop, value);
                } else {
                  node.style.removeProperty(prop);
                }
              });
            }

            // the reason why we have this option is to allow a synchronous closing callback
            // that is fired as SOON as the animation ends (when the CSS is removed) or if
            // the animation never takes off at all. A good example is a leave animation since
            // the element must be removed just after the animation is over or else the element
            // will appear on screen for one animation frame causing an overbearing flicker.
            if (options.onDone) {
              options.onDone();
            }

            if (events && events.length) {
              // Remove the transitionend / animationend listener(s)
              events.forEach((i) =>
                element.removeEventListener(i, onAnimationProgress),
              );
            }

            // Cancel the fallback closing timeout and remove the timer data
            const animationTimerData = getCacheData(element, ANIMATE_TIMER_KEY);

            if (animationTimerData) {
              clearTimeout(animationTimerData[0].timer);
              removeElementData(element, ANIMATE_TIMER_KEY);
            }

            // if the preparation function fails then the promise is not setup
            if (runner) {
              runner.complete(!rejected);
            }
          }

          function applyBlocking(duration) {
            if (flags.blockTransition) {
              blockTransitions(node, duration);
            }

            if (flags.blockKeyframeAnimation) {
              blockKeyframeAnimations(node, !!duration);
            }
          }

          function closeAndReturnNoopAnimator() {
            runner = new AnimateRunner({
              end: endFn,
              cancel: cancelFn,
            });

            // should flush the cache animation
            waitUntilQuiet(() => {
              /* empty */
            });
            close();

            return {
              $$willAnimate: false,
              start() {
                return runner;
              },
              end: endFn,
            };
          }

          function onAnimationProgress(event) {
            event.stopPropagation();
            const ev = event.originalEvent || event;

            if (ev.target !== node) {
              // Since TransitionEvent / AnimationEvent bubble up,
              // we have to ignore events by finished child animations
              return;
            }

            // we now always use `Date.now()` due to the recent changes with
            // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
            const timeStamp = ev.$manualTimeStamp || Date.now();

            /* Firefox (or possibly just Gecko) likes to not round values up
             * when a ms measurement is used for the animation */
            const elapsedTime = parseFloat(
              ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES),
            );

            /* $manualTimeStamp is a mocked timeStamp value which is set
             * within browserTrigger(). This is only here so that tests can
             * mock animations properly. Real events fallback to event.timeStamp,
             * or, if they don't, then a timeStamp is automatically created for them.
             * We're checking to see if the timeStamp surpasses the expected delay,
             * but we're using elapsedTime instead of the timeStamp on the 2nd
             * pre-condition since animationPauseds sometimes close off early */
            if (
              Math.max(timeStamp - startTime, 0) >= maxDelayTime &&
              elapsedTime >= maxDuration
            ) {
              // we set this flag to ensure that if the transition is paused then, when resumed,
              // the animation will automatically close itself since transitions cannot be paused.
              animationCompleted = true;
              close();
            }
          }

          function start() {
            if (animationClosed) return;

            if (!node.parentNode) {
              close();

              return;
            }

            // even though we only pause keyframe animations here the pause flag
            // will still happen when transitions are used. Only the transition will
            // not be paused since that is not possible. If the animation ends when
            // paused then it will not complete until unpaused or cancelled.
            const playPause = function (playAnimation) {
              if (!animationCompleted) {
                animationPaused = !playAnimation;

                if (timings.animationDuration) {
                  const value = blockKeyframeAnimations(node, animationPaused);

                  if (animationPaused) {
                    temporaryStyles.push(value);
                  } else {
                    removeFromArray(temporaryStyles, value);
                  }
                }
              } else if (animationPaused && playAnimation) {
                animationPaused = false;
                close();
              }
            };

            // checking the stagger duration prevents an accidentally cascade of the CSS delay style
            // being inherited from the parent. If the transition duration is zero then we can safely
            // rely that the delay value is an intentional stagger delay style.
            const maxStagger =
              itemIndex > 0 &&
              ((timings.transitionDuration && stagger.transitionDuration === 0) ||
                (timings.animationDuration && stagger.animationDuration === 0)) &&
              Math.max(stagger.animationDelay, stagger.transitionDelay);

            if (maxStagger) {
              setTimeout(
                triggerAnimationStart,
                Math.floor(maxStagger * itemIndex * ONE_SECOND),
                false,
              );
            } else {
              triggerAnimationStart();
            }

            // this will decorate the existing promise runner with pause/resume methods
            runnerHost.resume = function () {
              playPause(true);
            };

            runnerHost.pause = function () {
              playPause(false);
            };

            function triggerAnimationStart() {
              // just incase a stagger animation kicks in when the animation
              // itself was cancelled entirely
              if (animationClosed) return;

              applyBlocking(false);

              temporaryStyles.forEach((entry) => {
                const key = entry[0];

                node.style[key] = entry[1];
              });

              applyAnimationClasses(element, options);
              element.classList.add(
                ...activeClasses.split(" ").filter((x) => x !== ""),
              );

              if (flags.recalculateTimingStyles) {
                cacheKey = $$animateCache.cacheKey(
                  node,
                  method,
                  options.addClass,
                  options.removeClass,
                );

                timings = computeTimings(node, cacheKey, false);
                relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0);
                // eslint-disable-next-line prefer-destructuring
                maxDuration = timings.maxDuration;

                if (maxDuration === 0) {
                  close();

                  return;
                }

                flags.hasTransitions = timings.transitionDuration > 0;
                flags.hasAnimations = timings.animationDuration > 0;
              }

              if (flags.applyAnimationDelay) {
                relativeDelay =
                  typeof options.delay !== "boolean" &&
                  truthyTimingValue(options.delay)
                    ? parseFloat(options.delay)
                    : relativeDelay;

                maxDelay = Math.max(relativeDelay, 0);
                timings.animationDelay = relativeDelay;
                delayStyle = getCssDelayStyle(relativeDelay, true);
                temporaryStyles.push(delayStyle);
                node.style[delayStyle[0]] = delayStyle[1];
              }

              maxDelayTime = maxDelay * ONE_SECOND;
              maxDurationTime = maxDuration * ONE_SECOND;

              if (options.easing) {
                let easeProp;

                const easeVal = options.easing;

                if (flags.hasTransitions) {
                  easeProp = "transitionTimingFunction";
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }

                if (flags.hasAnimations) {
                  easeProp = "animationTimingFunction";
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }
              }

              if (timings.transitionDuration) {
                events.push("transitionend");
              }

              if (timings.animationDuration) {
                events.push("animationend");
              }

              startTime = Date.now();
              const timerTime =
                maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;

              const endTime = startTime + timerTime;

              const animationsData =
                getCacheData(element, ANIMATE_TIMER_KEY) || [];

              let setupFallbackTimer = true;

              if (animationsData.length) {
                const currentTimerData = animationsData[0];

                setupFallbackTimer = endTime > currentTimerData.expectedEndTime;

                if (setupFallbackTimer) {
                  clearTimeout(currentTimerData.timer);
                } else {
                  animationsData.push(close);
                }
              }

              if (setupFallbackTimer) {
                const timer = setTimeout(onAnimationExpired, timerTime, false);

                animationsData[0] = {
                  timer,
                  expectedEndTime: endTime,
                };
                animationsData.push(close);
                setCacheData(element, ANIMATE_TIMER_KEY, animationsData);
              }

              if (events.length) {
                events.forEach((x) => {
                  element.addEventListener(x, onAnimationProgress);
                });
              }

              if (options.to) {
                if (options.cleanupStyles) {
                  registerRestorableStyles(
                    restoreStyles,
                    node,
                    Object.keys(options.to),
                  );
                }
                applyAnimationToStyles(element, options);
              }
            }

            function onAnimationExpired() {
              const animationsData = getCacheData(element, ANIMATE_TIMER_KEY);

              // this will be false in the event that the element was
              // removed from the DOM (via a leave animation or something
              // similar)
              if (animationsData) {
                for (let i = 1; i < animationsData.length; i++) {
                  animationsData[i]();
                }
                removeElementData(element, ANIMATE_TIMER_KEY);
              }
            }
          }
        };
      },
    ];
  }

  function blockTransitions(node, duration) {
    // we use a negative delay value since it performs blocking
    // yet it doesn't kill any existing transitions running on the
    // same element which makes this safe for class-based animations
    const value = duration ? `-${duration}s` : "";

    applyInlineStyle(node, ["transitionDelay", value]);

    return ["transitionDelay", value];
  }

  const NG_ANIMATE_ATTR_NAME = "data-ng-animate";

  const NG_ANIMATE_PIN_DATA = "$ngAnimatePin";

  AnimateQueueProvider.$inject = provider([$injectTokens._animate]);
  function AnimateQueueProvider($animateProvider) {
    const PRE_DIGEST_STATE = 1;

    const RUNNING_STATE = 2;

    const ONE_SPACE = " ";

    const rules = (this.rules = {
      skip: [],
      cancel: [],
      join: [],
    });

    function getEventData(options) {
      return {
        addClass: options.addClass,
        removeClass: options.removeClass,
        from: options.from,
        to: options.to,
      };
    }

    function makeTruthyCssClassMap(classString) {
      if (!classString) {
        return null;
      }

      const keys = classString.split(ONE_SPACE);

      const map = Object.create(null);

      keys.forEach((key) => {
        map[key] = true;
      });

      return map;
    }

    function hasMatchingClasses(newClassString, currentClassString) {
      if (newClassString && currentClassString) {
        const currentClassMap = makeTruthyCssClassMap(currentClassString);

        return newClassString
          .split(ONE_SPACE)
          .some((className) => currentClassMap[className]);
      }

      return undefined;
    }

    function isAllowed(ruleType, currentAnimation, previousAnimation) {
      return rules[ruleType].some((fn) =>
        fn(currentAnimation, previousAnimation),
      );
    }

    function hasAnimationClasses(animation, and) {
      const a = (animation.addClass || "").length > 0;

      const b = (animation.removeClass || "").length > 0;

      return and ? a && b : a || b;
    }

    rules.join.push(
      (newAnimation) =>
        // if the new animation is class-based then we can just tack that on
        !newAnimation.structural && hasAnimationClasses(newAnimation),
    );

    rules.skip.push(
      (newAnimation) =>
        // there is no need to animate anything if no classes are being added and
        // there is no structural animation that will be triggered
        !newAnimation.structural && !hasAnimationClasses(newAnimation),
    );

    rules.skip.push(
      (newAnimation, currentAnimation) =>
        // why should we trigger a new structural animation if the element will
        // be removed from the DOM anyway?
        currentAnimation.event === "leave" && newAnimation.structural,
    );

    rules.skip.push(
      (newAnimation, currentAnimation) =>
        // if there is an ongoing current animation then don't even bother running the class-based animation
        currentAnimation.structural &&
        currentAnimation.state === RUNNING_STATE &&
        !newAnimation.structural,
    );

    rules.cancel.push(
      (newAnimation, currentAnimation) =>
        // there can never be two structural animations running at the same time
        currentAnimation.structural && newAnimation.structural,
    );

    rules.cancel.push(
      (newAnimation, currentAnimation) =>
        // if the previous animation is already running, but the new animation will
        // be triggered, but the new animation is structural
        currentAnimation.state === RUNNING_STATE && newAnimation.structural,
    );

    rules.cancel.push((newAnimation, currentAnimation) => {
      // cancel the animation if classes added / removed in both animation cancel each other out,
      // but only if the current animation isn't structural

      if (currentAnimation.structural) return false;

      const nA = newAnimation.addClass;

      const nR = newAnimation.removeClass;

      const cA = currentAnimation.addClass;

      const cR = currentAnimation.removeClass;

      // early detection to save the global CPU shortage :)
      if (
        (isUndefined(nA) && isUndefined(nR)) ||
        (isUndefined(cA) && isUndefined(cR))
      ) {
        return false;
      }

      return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
    });

    this.$get = [
      $injectTokens._rootScope,
      $injectTokens._injector,
      $injectTokens._animation,
      /**
       *
       * @param {ng.RootScopeService} $rootScope
       * @param {ng.InjectorService} $injector
       * @param {*} $$animation
       * @returns {import("../queue/interface.ts").AnimateQueueService}
       */
      function ($rootScope, $injector, $$animation) {
        const activeAnimationsLookup = new Map();

        const disabledElementsLookup = new Map();

        function postDigestTaskFactory() {
          let postDigestCalled = false;

          return function (fn) {
            // we only issue a call to postDigest before
            // it has first passed. This prevents any callbacks
            // from not firing once the animation has completed
            // since it will be out of the digest cycle.
            if (postDigestCalled) {
              fn();
            } else {
              $rootScope.$postUpdate(() => {
                postDigestCalled = true;
                fn();
              });
            }
          };
        }

        const callbackRegistry = Object.create(null);

        // remember that the `customFilter`/`classNameFilter` are set during the
        // provider/config stage therefore we can optimize here and setup helper functions
        const customFilter = $animateProvider.customFilter();

        const classNameFilter = $animateProvider.classNameFilter();

        const returnTrue = function () {
          return true;
        };

        const isAnimatableByFilter = customFilter || returnTrue;

        const isAnimatableClassName = !classNameFilter
          ? returnTrue
          : function (node, options) {
              const className = [
                node.getAttribute("class"),
                options.addClass,
                options.removeClass,
              ].join(" ");

              return classNameFilter.test(className);
            };

        const applyAnimationClasses = applyAnimationClassesFactory();

        function normalizeAnimationDetails(element, animation) {
          return mergeAnimationDetails(element, animation, {});
        }

        function findCallbacks(targetParentNode, targetNode, event) {
          const matches = [];

          const entries = callbackRegistry[event];

          if (entries) {
            entries.forEach((entry) => {
              if (entry.node.contains(targetNode)) {
                matches.push(entry.callback);
              } else if (
                event === "leave" &&
                entry.node.contains(targetParentNode)
              ) {
                matches.push(entry.callback);
              }
            });
          }

          return matches;
        }

        function filterFromRegistry(list, matchContainer, matchCallback) {
          const containerNode = extractElementNode(matchContainer);

          return list.filter((entry) => {
            const isMatch =
              entry.node === containerNode &&
              (!matchCallback || entry.callback === matchCallback);

            return !isMatch;
          });
        }

        function cleanupEventListeners(phase, node) {
          if (phase === "close" && !node.parentNode) {
            // If the element is not attached to a parentNode, it has been removed by
            // the domOperation, and we can safely remove the event callbacks
            $animate.off(node);
          }
        }

        const $animate = {
          on(event, container, callback) {
            const node = extractElementNode(container);

            callbackRegistry[event] = callbackRegistry[event] || [];
            callbackRegistry[event].push({
              node,
              callback,
            });

            // Remove the callback when the element is removed from the DOM
            container.addEventListener("$destroy", () => {
              const animationDetails = activeAnimationsLookup.get(node);

              if (!animationDetails) {
                // If there's an animation ongoing, the callback calling code will remove
                // the event listeners. If we'd remove here, the callbacks would be removed
                // before the animation ends
                $animate.off(event, container, callback);
              }
            });
          },

          off(event, container, callback) {
            if (arguments.length === 1 && !isString(arguments[0])) {
              container = arguments[0];

              for (const eventType in callbackRegistry) {
                callbackRegistry[eventType] = filterFromRegistry(
                  callbackRegistry[eventType],
                  container,
                );
              }

              return;
            }

            const entries = callbackRegistry[event];

            if (!entries) return;

            callbackRegistry[event] =
              arguments.length === 1
                ? null
                : filterFromRegistry(entries, container, callback);
          },

          pin(element, parentElement) {
            setCacheData(element, NG_ANIMATE_PIN_DATA, parentElement);
          },

          push(element, event, options, domOperation) {
            options = options || {};
            options.domOperation = domOperation;

            return queueAnimation(element, event, options);
          },
        };

        return $animate;

        /**
         * @param {Element} originalElement
         * @param {string} event
         * @param {*} initialOptions
         * @returns void
         */
        function queueAnimation(originalElement, event, initialOptions) {
          // we always make a copy of the options since
          // there should never be any side effects on
          // the input data when running `$animateCss`.
          let options = initialOptions;

          // strip comments

          let element = isArray(originalElement)
            ? // @ts-ignore
              originalElement.filter((x) => x.nodeName !== "#comment")[0]
            : originalElement;

          const node = element;

          const parentNode = node && node.parentNode;

          options = prepareAnimationOptions(options);

          // we create a fake runner with a working promise.
          // These methods will become available after the digest has passed
          const runner = new AnimateRunner();

          // this is used to trigger callbacks in postDigest mode
          const runInNextPostDigestOrNow = postDigestTaskFactory();

          if (isArray(options.addClass)) {
            options.addClass = options.addClass.join(" ");
          }

          if (options.addClass && !isString(options.addClass)) {
            options.addClass = null;
          }

          if (isArray(options.removeClass)) {
            options.removeClass = options.removeClass.join(" ");
          }

          if (options.removeClass && !isString(options.removeClass)) {
            options.removeClass = null;
          }

          if (options.from && !isObject(options.from)) {
            options.from = null;
          }

          if (options.to && !isObject(options.to)) {
            options.to = null;
          }

          // If animations are hard-disabled for the whole application there is no need to continue.
          // There are also situations where a directive issues an animation for a JQLite wrapper that
          // contains only comment nodes. In this case, there is no way we can perform an animation.
          if (
            // !animationsEnabled ||
            !node ||
            !isAnimatableByFilter(node, event, initialOptions) ||
            !isAnimatableClassName(node, options)
          ) {
            close();

            return runner;
          }
          const isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;

          // This is a hard disable of all animations the element itself, therefore  there is no need to
          // continue further past this point if not enabled
          // Animations are also disabled if the document is currently hidden (page is not visible
          // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
          let skipAnimations =
            document.hidden || disabledElementsLookup.get(node);

          const existingAnimation =
            (!skipAnimations && activeAnimationsLookup.get(node)) || {};

          const hasExistingAnimation = !!existingAnimation.state;

          // there is no point in traversing the same collection of parent ancestors if a followup
          // animation will be run on the same element that already did all that checking work
          if (
            !skipAnimations &&
            (!hasExistingAnimation ||
              existingAnimation.state !== PRE_DIGEST_STATE)
          ) {
            skipAnimations = !areAnimationsAllowed(node, parentNode);
          }

          if (skipAnimations) {
            // Callbacks should fire even if the document is hidden (regression fix for issue #14120)
            if (document.hidden)
              notifyProgress(runner, event, "start", getEventData(options));
            close();

            if (document.hidden)
              notifyProgress(runner, event, "close", getEventData(options));

            return runner;
          }

          if (isStructural) {
            closeChildAnimations(node);
          }

          const newAnimation = {
            structural: isStructural,
            element,
            event,
            addClass: options.addClass,
            removeClass: options.removeClass,
            close,
            options,
            runner,
          };

          if (hasExistingAnimation) {
            const skipAnimationFlag = isAllowed(
              "skip",
              newAnimation,
              existingAnimation,
            );

            if (skipAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                close();

                return runner;
              }
              mergeAnimationDetails(element, existingAnimation, newAnimation);

              return existingAnimation.runner;
            }
            const cancelAnimationFlag = isAllowed(
              "cancel",
              newAnimation,
              existingAnimation,
            );

            if (cancelAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                // this will end the animation right away and it is safe
                // to do so since the animation is already running and the
                // runner callback code will run in async
                existingAnimation.runner.end();
              } else if (existingAnimation.structural) {
                // this means that the animation is queued into a digest, but
                // hasn't started yet. Therefore it is safe to run the close
                // method which will call the runner methods in async.
                existingAnimation.close();
              } else {
                // this will merge the new animation options into existing animation options
                mergeAnimationDetails(element, existingAnimation, newAnimation);

                return existingAnimation.runner;
              }
            } else {
              // a joined animation means that this animation will take over the existing one
              // so an example would involve a leave animation taking over an enter. Then when
              // the postDigest kicks in the enter will be ignored.
              const joinAnimationFlag = isAllowed(
                "join",
                newAnimation,
                existingAnimation,
              );

              if (joinAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  normalizeAnimationDetails(element, newAnimation);
                } else {
                  applyGeneratedPreparationClasses(
                    element,
                    isStructural ? event : null,
                    options,
                  );

                  event = newAnimation.event = existingAnimation.event;
                  options = mergeAnimationDetails(
                    element,
                    existingAnimation,
                    newAnimation,
                  );

                  // we return the same runner since only the option values of this animation will
                  // be fed into the `existingAnimation`.
                  return existingAnimation.runner;
                }
              }
            }
          } else {
            // normalization in this case means that it removes redundant CSS classes that
            // already exist (addClass) or do not exist (removeClass) on the element
            normalizeAnimationDetails(element, newAnimation);
          }

          // when the options are merged and cleaned up we may end up not having to do
          // an animation at all, therefore we should check this before issuing a post
          // digest callback. Structural animations will always run no matter what.
          let isValidAnimation = newAnimation.structural;

          if (!isValidAnimation) {
            // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
            isValidAnimation =
              (newAnimation.event === "animate" &&
                Object.keys(newAnimation.options.to || {}).length > 0) ||
              hasAnimationClasses(newAnimation);
          }

          if (!isValidAnimation) {
            close();
            clearElementAnimationState(node);

            return runner;
          }

          // the counter keeps track of cancelled animations
          const counter = (existingAnimation.counter || 0) + 1;

          newAnimation.counter = counter;

          markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);
          $rootScope.$postUpdate(() => {
            // It is possible that the DOM nodes inside `originalElement` have been replaced. This can
            // happen if the animated element is a transcluded clone and also has a `templateUrl`
            // directive on it. Therefore, we must recreate `element` in order to interact with the
            // actual DOM nodes.
            // Note: We still need to use the old `node` for certain things, such as looking up in
            //       HashMaps where it was used as the key.

            element = stripCommentsFromElement(originalElement);

            let animationDetails = activeAnimationsLookup.get(node);

            const animationCancelled = !animationDetails;

            animationDetails = animationDetails || {};

            // if addClass/removeClass is called before something like enter then the
            // registered parent element may not be present. The code below will ensure
            // that a final value for parent element is obtained
            const parentElement = element.parentElement || [];

            // animate/structural/class-based animations all have requirements. Otherwise there
            // is no point in performing an animation. The parent node must also be set.
            const isCurrentAnimationValid =
              parentElement &&
              (animationDetails.event === "animate" ||
                animationDetails.structural ||
                hasAnimationClasses(animationDetails));

            // this means that the previous animation was cancelled
            // even if the follow-up animation is the same event
            if (
              animationCancelled ||
              animationDetails.counter !== counter ||
              !isCurrentAnimationValid
            ) {
              // if another animation did not take over then we need
              // to make sure that the domOperation and options are
              // handled accordingly
              if (animationCancelled) {
                applyAnimationClasses(element, options);
                applyAnimationStyles(element, options);
              }

              // if the event changed from something like enter to leave then we do
              // it, otherwise if it's the same then the end result will be the same too
              if (
                animationCancelled ||
                (isStructural && animationDetails.event !== event)
              ) {
                options.domOperation();
                runner.end();
              }

              // in the event that the element animation was not cancelled or a follow-up animation
              // isn't allowed to animate from here then we need to clear the state of the element
              // so that any future animations won't read the expired animation data.
              if (!isCurrentAnimationValid) {
                clearElementAnimationState(node);
              }

              return;
            }

            // this combined multiple class to addClass / removeClass into a setClass event
            // so long as a structural event did not take over the animation
            event =
              !animationDetails.structural &&
              hasAnimationClasses(animationDetails, true)
                ? "setClass"
                : animationDetails.event;

            markElementAnimationState(node, RUNNING_STATE);
            const realRunner = $$animation(
              element,
              event,
              animationDetails.options,
            );

            // this will update the runner's flow-control events based on
            // the `realRunner` object.
            runner.setHost(realRunner);
            notifyProgress(runner, event, "start", getEventData(options));

            realRunner.done((status) => {
              close(!status);

              if (activeAnimationsLookup.get(node)?.counter === counter) {
                clearElementAnimationState(node);
              }
              notifyProgress(runner, event, "close", getEventData(options));
            });
          });

          // Since we don't have digest any more - trigger queue here
          setTimeout($rootScope.$flushQueue, 0);

          return runner;

          function notifyProgress(runnerParam, eventParam, phase, data) {
            runInNextPostDigestOrNow(() => {
              const callbacks = findCallbacks(parentNode, node, eventParam);

              if (callbacks.length) {
                callbacks.forEach((callback) => {
                  callback(element, phase, data);
                });
                cleanupEventListeners(phase, node);
              } else {
                cleanupEventListeners(phase, node);
              }
            });
            runnerParam.progress(eventParam, phase, data);
          }

          function close(reject) {
            clearGeneratedClasses(element, options);
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            options.domOperation();
            runner.complete(!reject);
          }
        }

        /**
         * Closes and cleans up any child animations found under the given node.
         *
         * Looks for elements that have the NG_ANIMATE_ATTR_NAME attribute, checks their
         * animation state, ends running animations, and removes them from the
         * activeAnimationsLookup if appropriate.
         *
         * @param {Element | ParentNode} node
         *   The DOM node whose descendant animations should be closed.
         *
         * @returns {void}
         */
        function closeChildAnimations(node) {
          const children = node.querySelectorAll(`[${NG_ANIMATE_ATTR_NAME}]`);

          children.forEach((child) => {
            const state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);

            const animationDetails = activeAnimationsLookup.get(child);

            if (animationDetails) {
              switch (state) {
                case RUNNING_STATE:
                  animationDetails.runner.end();
                /* falls through */
                case PRE_DIGEST_STATE:
                  activeAnimationsLookup.delete(child);
                  break;
              }
            }
          });
        }

        function clearElementAnimationState(node) {
          node.removeAttribute(NG_ANIMATE_ATTR_NAME);
          activeAnimationsLookup.delete(node);
        }

        /**
         * This fn returns false if any of the following is true:
         * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed
         * b) a parent element has an ongoing structural animation, and animateChildren is false
         * c) the element is not a child of the body
         * d) the element is not a child of the $rootElement
         */
        function areAnimationsAllowed(node, parentNode) {
          const bodyNode = document.body;

          const rootNode = $injector.get("$rootElement");

          let bodyNodeDetected = node === bodyNode || node.nodeName === "HTML";

          let rootNodeDetected = node === rootNode;

          let parentAnimationDetected = false;

          let elementDisabled = disabledElementsLookup.get(node);

          let animateChildren;

          let parentHost = getOrSetCacheData(node, NG_ANIMATE_PIN_DATA);

          if (parentHost) {
            parentNode = parentHost;
          }

          while (parentNode) {
            if (!rootNodeDetected) {
              // AngularTS doesn't want to attempt to animate elements outside of the application
              // therefore we need to ensure that the rootElement is an ancestor of the current element
              rootNodeDetected = parentNode === rootNode;
            }

            if (parentNode.nodeType !== NodeType._ELEMENT_NODE) {
              // no point in inspecting the #document element
              break;
            }

            const details = activeAnimationsLookup.get(parentNode) || {};

            // either an enter, leave or move animation will commence
            // therefore we can't allow any animations to take place
            // but if a parent animation is class-based then that's ok
            if (!parentAnimationDetected) {
              const parentNodeDisabled = disabledElementsLookup.get(parentNode);

              if (parentNodeDisabled === true && elementDisabled !== false) {
                // disable animations if the user hasn't explicitly enabled animations on the
                // current element
                elementDisabled = true;
                // element is disabled via parent element, no need to check anything else
                break;
              } else if (parentNodeDisabled === false) {
                elementDisabled = false;
              }
              parentAnimationDetected = details.structural;
            }

            if (isUndefined(animateChildren) || animateChildren === true) {
              const value = getOrSetCacheData(
                parentNode,
                NG_ANIMATE_CHILDREN_DATA,
              );

              if (isDefined(value)) {
                animateChildren = value;
              }
            }

            // there is no need to continue traversing at this point
            if (parentAnimationDetected && animateChildren === false) break;

            if (!bodyNodeDetected) {
              // we also need to ensure that the element is or will be a part of the body element
              // otherwise it is pointless to even issue an animation to be rendered
              bodyNodeDetected = parentNode === bodyNode;
            }

            if (bodyNodeDetected && rootNodeDetected) {
              // If both body and root have been found, any other checks are pointless,
              // as no animation data should live outside the application
              break;
            }

            if (!rootNodeDetected) {
              // If `rootNode` is not detected, check if `parentNode` is pinned to another element
              parentHost = getOrSetCacheData(parentNode, NG_ANIMATE_PIN_DATA);

              if (parentHost) {
                // The pin target element becomes the next parent element
                parentNode = parentHost;
                continue;
              }
            }

            // eslint-disable-next-line prefer-destructuring
            parentNode = parentNode.parentNode;
          }

          const allowAnimation =
            (!parentAnimationDetected || animateChildren) &&
            elementDisabled !== true;

          return allowAnimation && rootNodeDetected && bodyNodeDetected;
        }

        function markElementAnimationState(node, state, details) {
          details = details || {};
          details.state = state;

          node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

          const oldValue = activeAnimationsLookup.get(node);

          const newValue = oldValue ? extend(oldValue, details) : details;

          activeAnimationsLookup.set(node, newValue);
        }
      },
    ];
  }

  AnimateJsProvider.$inject = provider([$injectTokens._animate]);

  function AnimateJsProvider($animateProvider) {
    this.$get = [
      $injectTokens._injector,
      /**
       * @param {ng.InjectorService} $injector
       * @returns {import("./interface.ts").AnimateJsFn}
       */
      function ($injector) {
        const applyAnimationClasses = applyAnimationClassesFactory();

        return function animateJs(element, event, classes, options) {
          // Optional arguments
          if (arguments.length === 3 && isObject(classes)) {
            options = /** @type {Object} */ (classes);
            classes = null;
          }

          options = prepareAnimationOptions(options);

          if (!classes) {
            classes = element.getAttribute("class") || "";

            if (options.addClass) classes += ` ${options.addClass}`;

            if (options.removeClass) classes += ` ${options.removeClass}`;
          }

          const classesToAdd = options.addClass;

          const classesToRemove = options.removeClass;

          // Lookup animation objects
          const animations = lookupAnimations(classes);

          let before, after;

          if (animations.length) {
            let beforeFn, afterFn;

            if (event === "leave") {
              beforeFn = "leave";
              afterFn = "afterLeave";
            } else {
              beforeFn = `before${event.charAt(0).toUpperCase()}${event.substring(1)}`;
              afterFn = event;
            }

            if (event !== "enter" && event !== "move") {
              before = packageAnimations(element, options, animations, beforeFn, {
                add: classesToAdd,
                remove: classesToRemove,
              });
            }
            after = packageAnimations(element, options, animations, afterFn, {
              add: classesToAdd,
              remove: classesToRemove,
            });
          }

          if (!before && !after) return undefined;

          function applyOptions() {
            options.domOperation();
            applyAnimationClasses(element, options);
          }

          function close() {
            applyOptions();
            applyAnimationStyles(element, options);
          }

          let runner;

          return {
            $$willAnimate: true,

            start() {
              if (runner) return runner;

              runner = new AnimateRunner({
                end: () => onComplete(true),
                cancel: () => onComplete(false),
              });

              // Run before animations
              if (before) before(runner.done.bind(runner));
              else applyOptions();

              // Run after animations
              if (after) after(runner.done.bind(runner));

              function onComplete(success) {
                close();
                runner.complete(success);
              }

              return runner;
            },

            end() {
              if (runner) runner.end();
              else {
                close();
                runner = new AnimateRunner();
                runner.complete(true);
              }

              return runner;
            },
          };

          // ---- helpers ----
          function lookupAnimations(classList) {
            classList = isArray(classList) ? classList : classList.split(" ");
            const matches = [];

            const flagMap = {};

            for (let i = 0; i < classList.length; i++) {
              const klass = classList[i];

              const animationFactory =
                $animateProvider.$$registeredAnimations[klass];

              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }

            return matches;
          }

          function packageAnimations(
            elementParam,
            optionsParam,
            animationsParam,
            fnName,
            classNames,
          ) {
            const operations = [];

            animationsParam.forEach((ani) => {
              const animationFn = ani[fnName];

              if (!animationFn) return;

              operations.push((done) => {
                if (isFunction(animationFn)) {
                  let args;

                  switch (fnName) {
                    case "addClass":
                      args = [elementParam, classNames.add, done];
                      break;
                    case "removeClass":
                      args = [elementParam, classNames.remove, done];
                      break;
                    case "setClass":
                      args = [
                        elementParam,
                        classNames.add,
                        classNames.remove,
                        done,
                      ];
                      break;
                    case "animate":
                      args = [
                        elementParam,
                        optionsParam.from,
                        optionsParam.to,
                        done,
                      ];
                      break;
                    default:
                      args = [elementParam, done];
                  }

                  const value = animationFn.apply(ani, args);

                  if (value instanceof AnimateRunner) value.done(done);
                } else done();
              });
            });

            if (!operations.length) return undefined;

            return (done) => {
              let completed = 0;

              const total = operations.length;

              operations.forEach((op) => {
                op(() => {
                  if (++completed === total && isFunction(done)) done();
                });
              });
            };
          }
        };
      },
    ];
  }

  const RUNNER_STORAGE_KEY = "$$animationRunner";

  const PREPARE_CLASSES_KEY = "$$animatePrepareClasses";

  function AnimationProvider() {
    const NG_ANIMATE_REF_ATTR = "ng-animate-ref";

    const drivers = (this.drivers = []);

    function setRunner(element, runner) {
      setCacheData(element, RUNNER_STORAGE_KEY, runner);
    }

    function removeRunner(element) {
      deleteCacheData(element, RUNNER_STORAGE_KEY);
    }

    function getRunner(element) {
      return getCacheData(element, RUNNER_STORAGE_KEY);
    }

    this.$get = [
      $injectTokens._rootScope,
      $injectTokens._injector,
      $injectTokens._rAFScheduler,
      $injectTokens._animateCache,
      /**
       *
       * @param {ng.RootScopeService} $rootScope
       * @param {ng.InjectorService} $injector
       * @param {import("./raf-scheduler.js").RafScheduler} $$rAFScheduler
       * @param {*} $$animateCache
       * @returns
       */
      function ($rootScope, $injector, $$rAFScheduler, $$animateCache) {
        const animationQueue = [];

        const applyAnimationClasses = applyAnimationClassesFactory();

        function sortAnimations(animations) {
          const tree = { children: [] };

          let i;

          const lookup = new Map();

          // this is done first beforehand so that the map
          // is filled with a list of the elements that will be animated

          for (i = 0; i < animations.length; i++) {
            const animation = animations[i];

            lookup.set(
              animation.domNode,
              (animations[i] = {
                domNode: animation.domNode,
                element: animation.element,
                fn: animation.fn,
                children: [],
              }),
            );
          }

          for (i = 0; i < animations.length; i++) {
            processNode(animations[i]);
          }

          return flatten(tree);

          function processNode(entry) {
            if (entry.processed) return entry;
            entry.processed = true;

            const elementNode = entry.domNode;

            let { parentNode } = elementNode;

            lookup.set(elementNode, entry);

            let parentEntry;

            while (parentNode) {
              parentEntry = lookup.get(parentNode);

              if (parentEntry) {
                if (!parentEntry.processed) {
                  parentEntry = processNode(parentEntry);
                }
                break;
              }
              // eslint-disable-next-line prefer-destructuring
              parentNode = parentNode.parentNode;
            }

            (parentEntry || tree).children.push(entry);

            return entry;
          }

          function flatten(theeParam) {
            const result = [];

            const queue = [];

            for (i = 0; i < theeParam.children.length; i++) {
              queue.push(theeParam.children[i]);
            }

            let remainingLevelEntries = queue.length;

            let nextLevelEntries = 0;

            let row = [];

            for (let j = 0; j < queue.length; j++) {
              const entry = queue[j];

              if (remainingLevelEntries <= 0) {
                remainingLevelEntries = nextLevelEntries;
                nextLevelEntries = 0;
                result.push(row);
                row = [];
              }
              row.push(entry);
              entry.children.forEach((childEntry) => {
                nextLevelEntries++;
                queue.push(childEntry);
              });
              remainingLevelEntries--;
            }

            if (row.length) {
              result.push(row);
            }

            return result;
          }
        }

        // TODO(matsko): document the signature in a better way
        return function (elementParam, event, options) {
          options = prepareAnimationOptions(options);
          const isStructural = ["enter", "move", "leave"].indexOf(event) >= 0;

          // there is no animation at the current moment, however
          // these runner methods will get later updated with the
          // methods leading into the driver's end/cancel methods
          // for now they just stop the animation from starting
          const runner = new AnimateRunner({
            end() {
              close();
            },
            cancel() {
              close(true);
            },
          });

          if (!drivers.length) {
            close();

            return runner;
          }

          let classes = mergeClasses(
            elementParam.getAttribute("class"),
            mergeClasses(options.addClass, options.removeClass),
          );

          let { tempClasses } = options;

          if (tempClasses) {
            classes += ` ${tempClasses}`;
            options.tempClasses = null;
          }

          if (isStructural) {
            setCacheData(
              elementParam,
              PREPARE_CLASSES_KEY,
              `ng-${event}${PREPARE_CLASS_SUFFIX}`,
            );
          }

          setRunner(elementParam, runner);

          animationQueue.push({
            // this data is used by the postDigest code and passed into
            // the driver step function
            element: elementParam,
            classes,
            event,
            structural: isStructural,
            options,
            beforeStart,
            close,
          });

          elementParam.addEventListener("$destroy", handleDestroyedElement);

          // we only want there to be one function called within the post digest
          // block. This way we can group animations for all the animations that
          // were apart of the same postDigest flush call.
          if (animationQueue.length > 1) return runner;
          $rootScope.$postUpdate(() => {
            const animations = [];

            animationQueue.forEach((entry) => {
              // the element was destroyed early on which removed the runner
              // form its storage. This means we can't animate this element
              // at all and it already has been closed due to destruction.
              if (getRunner(entry.element)) {
                animations.push(entry);
              } else {
                entry.close();
              }
            });

            // now any future animations will be in another postDigest
            animationQueue.length = 0;

            const groupedAnimations = groupAnimations(animations);

            const toBeSortedAnimations = [];

            groupedAnimations.forEach((animationEntry) => {
              const fromElement = animationEntry.from
                ? animationEntry.from.element
                : animationEntry.element;

              let extraClasses = options.addClass;

              extraClasses =
                (extraClasses ? `${extraClasses} ` : "") + NG_ANIMATE_CLASSNAME;
              const cacheKey = $$animateCache.cacheKey(
                fromElement,
                animationEntry.event,
                extraClasses,
                options.removeClass,
              );

              toBeSortedAnimations.push({
                element: fromElement,
                domNode: fromElement,
                fn: function triggerAnimationStart() {
                  let startAnimationFn;

                  const closeFn = animationEntry.close;

                  // in the event that we've cached the animation status for this element
                  // and it's in fact an invalid animation (something that has duration = 0)
                  // then we should skip all the heavy work from here on
                  if (
                    $$animateCache.containsCachedAnimationWithoutDuration(
                      cacheKey,
                    )
                  ) {
                    closeFn();

                    return;
                  }

                  // it's important that we apply the `ng-animate` CSS class and the
                  // temporary classes before we do any driver invoking since these
                  // CSS classes may be required for proper CSS detection.
                  animationEntry.beforeStart();

                  // in the event that the element was removed before the digest runs or
                  // during the RAF sequencing then we should not trigger the animation.
                  const targetElement = animationEntry.anchors
                    ? animationEntry.from.element || animationEntry.to.element
                    : animationEntry.element;

                  if (getRunner(targetElement)) {
                    const operation = invokeFirstDriver(animationEntry);

                    if (operation) {
                      startAnimationFn = operation.start;
                    }
                  }

                  if (!startAnimationFn) {
                    closeFn();
                  } else {
                    const animationRunner = startAnimationFn();

                    animationRunner.done((status) => {
                      closeFn(!status);
                    });
                    updateAnimationRunners(animationEntry, animationRunner);
                  }
                },
              });
            });

            // we need to sort each of the animations in order of parent to child
            // relationships. This ensures that the child classes are applied at the
            // right time.
            const finalAnimations = sortAnimations(toBeSortedAnimations);

            for (let i = 0; i < finalAnimations.length; i++) {
              const innerArray = finalAnimations[i];

              for (let j = 0; j < innerArray.length; j++) {
                const entry = innerArray[j];

                const { element } = entry;

                // the RAFScheduler code only uses functions
                finalAnimations[i][j] = entry.fn;

                // the first row of elements shouldn't have a prepare-class added to them
                // since the elements are at the top of the animation hierarchy and they
                // will be applied without a RAF having to pass...
                if (i === 0) {
                  removeElementData(element, PREPARE_CLASSES_KEY);
                  continue;
                }

                const prepareClassName = getCacheData(
                  element,
                  PREPARE_CLASSES_KEY,
                );

                if (prepareClassName) {
                  element.classList.add(prepareClassName);
                }
              }
            }
            // @ts-ignore
            $$rAFScheduler(finalAnimations);
          });

          return runner;

          // TODO(matsko): change to reference nodes
          function getAnchorNodes(node) {
            const SELECTOR = `[${NG_ANIMATE_REF_ATTR}]`;

            const items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
              ? [node]
              : node.querySelectorAll(SELECTOR);

            const anchors = [];

            items.forEach((nodeItem) => {
              const attr = nodeItem.getAttribute(NG_ANIMATE_REF_ATTR);

              if (attr && attr.length) {
                anchors.push(nodeItem);
              }
            });

            return anchors;
          }

          function groupAnimations(animations) {
            const preparedAnimations = [];

            const refLookup = {};

            animations.forEach((animation, index) => {
              // eslint-disable-next-line no-shadow
              const { element, event } = animation;

              const node = element;

              const enterOrMove = ["enter", "move"].indexOf(event) >= 0;

              const anchorNodes = animation.structural
                ? getAnchorNodes(node)
                : [];

              if (anchorNodes.length) {
                const direction = enterOrMove ? "to" : "from";

                anchorNodes.forEach((anchor) => {
                  const key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);

                  refLookup[key] = refLookup[key] || {};
                  refLookup[key][direction] = {
                    animationID: index,
                    element: anchor,
                  };
                });
              } else {
                preparedAnimations.push(animation);
              }
            });

            const usedIndicesLookup = {};

            const anchorGroups = {};

            Object.values(refLookup).forEach((operations) => {
              const { from } = operations;

              const { to } = operations;

              if (!from || !to) {
                // only one of these is set therefore we can't have an
                // anchor animation since all three pieces are required
                const index = from ? from.animationID : to.animationID;

                const indexKey = index.toString();

                if (!usedIndicesLookup[indexKey]) {
                  usedIndicesLookup[indexKey] = true;
                  preparedAnimations.push(animations[index]);
                }

                return;
              }

              const fromAnimation = animations[from.animationID];

              const toAnimation = animations[to.animationID];

              const lookupKey = from.animationID.toString();

              if (!anchorGroups[lookupKey]) {
                const group = (anchorGroups[lookupKey] = {
                  structural: true,
                  beforeStart() {
                    fromAnimation.beforeStart();
                    toAnimation.beforeStart();
                  },
                  close() {
                    fromAnimation.close();
                    toAnimation.close();
                  },
                  classes: cssClassesIntersection(
                    fromAnimation.classes,
                    toAnimation.classes,
                  ),
                  from: fromAnimation,
                  to: toAnimation,
                  anchors: [], // TODO(matsko): change to reference nodes
                });

                // the anchor animations require that the from and to elements both have at least
                // one shared CSS class which effectively marries the two elements together to use
                // the same animation driver and to properly sequence the anchor animation.
                if (group.classes.length) {
                  preparedAnimations.push(group);
                } else {
                  preparedAnimations.push(fromAnimation);
                  preparedAnimations.push(toAnimation);
                }
              }

              anchorGroups[lookupKey].anchors.push({
                out: from.element,
                in: to.element,
              });
            });

            return preparedAnimations;
          }

          function cssClassesIntersection(a, b) {
            a = a.split(" ");
            b = b.split(" ");
            const matches = [];

            for (let i = 0; i < a.length; i++) {
              const aa = a[i];

              if (aa.substring(0, 3) === "ng-") continue;

              for (let j = 0; j < b.length; j++) {
                if (aa === b[j]) {
                  matches.push(aa);
                  break;
                }
              }
            }

            return matches.join(" ");
          }

          function invokeFirstDriver(animationDetails) {
            // we loop in reverse order since the more general drivers (like CSS and JS)
            // may attempt more elements, but custom drivers are more particular
            for (let i = drivers.length - 1; i >= 0; i--) {
              const driverName = drivers[i];

              const factory = $injector.get(driverName);

              const driver = factory(animationDetails);

              if (driver) {
                return driver;
              }
            }

            return undefined;
          }

          function beforeStart() {
            tempClasses =
              (tempClasses ? `${tempClasses} ` : "") + NG_ANIMATE_CLASSNAME;
            elementParam.className += ` ${tempClasses}`;
            let prepareClassName = getCacheData(
              elementParam,
              PREPARE_CLASSES_KEY,
            );

            if (prepareClassName) {
              elementParam.classList.remove(prepareClassName);
              prepareClassName = null;
            }
          }

          function updateAnimationRunners(animation, newRunner) {
            if (animation.from && animation.to) {
              update(animation.from.element);
              update(animation.to.element);
            } else {
              update(animation.element);
            }

            function update(el) {
              getRunner(el).setHost(newRunner);
            }
          }

          function handleDestroyedElement() {
            (event !== "leave" || !options.$$domOperationFired) &&
              getRunner(elementParam)?.end();
          }

          function close(rejected) {
            removeRunner(elementParam);

            applyAnimationClasses(elementParam, options);
            applyAnimationStyles(elementParam, options);
            options.domOperation();

            if (tempClasses) {
              tempClasses
                .split(" ")
                .forEach((cls) => elementParam.classList.remove(cls));
            }

            runner.complete(!rejected);
          }
        };
      },
    ];
  }

  /**
   * @typedef {import('./interface.ts').RafScheduler} RafScheduler
   */

  /**
   * Service provider that creates a requestAnimationFrame-based scheduler.
   * @type {ng.ServiceProvider}
   */
  class RafSchedulerProvider {
    constructor() {
      /**
       * Internal task queue, where each item is an array of functions to run.
       * @type {Array<Array<() => void>>}
       */
      this._queue = [];

      /**
       * ID of the currently scheduled animation frame (if any).
       * Used for cancellation and tracking.
       * @type {number|null}
       */
      this._cancelFn = null;
    }

    /**
     * Processes the next batch of tasks in the animation frame.
     * Executes the first group of functions in the queue, then
     * schedules the next frame if needed.
     */
    _nextTick() {
      if (!this._queue.length) return;

      const items = this._queue.shift();

      items.forEach((fn) => fn());

      if (!this._cancelFn) {
        this._cancelFn = window.requestAnimationFrame(() => {
          this._cancelFn = null;
          this._nextTick();
        });
      }
    }

    /**
     * Returns the scheduler function.
     * This function allows tasks to be queued for execution on future animation frames.
     * It also has helper methods and state attached.
     *
     * @returns {RafScheduler} The scheduler function with `queue` and `waitUntilQuiet`.
     */
    $get() {
      /**
       * The main scheduler function.
       * Accepts an array of functions and schedules them to run in the next available frame(s).
       *
       * @type {RafScheduler}
       */
      const scheduler = (tasks) => {
        // Clone the input array to avoid mutating the original.
        this._queue = this._queue.concat(tasks);
        this._nextTick();
      };

      /**
       * Exposes the internal queue to consumers (read-only use preferred).
       * This matches the type signature for RafScheduler.
       */
      scheduler._queue = this._queue;

      /**
       * Cancels any pending frame and runs the given function once the frame is idle.
       * Useful for debounced updates.
       *
       * @param {Function} fn - Function to run when the animation frame is quiet.
       */
      scheduler._waitUntilQuiet = (fn) => {
        if (this._cancelFn !== null) {
          window.cancelAnimationFrame(this._cancelFn);
          this._cancelFn = null;
        }

        this._cancelFn = window.requestAnimationFrame(() => {
          this._cancelFn = null;
          fn();
          this._nextTick();
        });
      };

      return scheduler;
    }
  }

  const KEY = "$animId";

  let parentCounter = 0;

  const cache = new Map();

  function animateCache() {
    return {
      /**
       * Generates a unique cache key based on the node's parent and other parameters.
       * @param {HTMLElement} node - The DOM node to generate the cache key for.
       * @param {string} method - The animation method being applied.
       * @param {string} [addClass] - Class to add during the animation.
       * @param {string} [removeClass] - Class to remove during the animation.
       * @returns {string} - The generated cache key.
       */
      cacheKey(node, method, addClass, removeClass) {
        const { parentNode } = node;

        const parentID = parentNode[KEY] ?? (parentNode[KEY] = ++parentCounter);

        const parts = [parentID, method, node.getAttribute("class")];

        if (addClass) parts.push(addClass);

        if (removeClass) parts.push(removeClass);

        return parts.join(" ");
      },

      /**
       * Checks if a cached animation without a duration exists.
       * @param {string} key - The cache key to check.
       * @returns {boolean} - True if an invalid animation is cached, false otherwise.
       */
      containsCachedAnimationWithoutDuration(key) {
        const entry = cache.get(key);

        return entry ? !entry.isValid : false;
      },

      /**
       * Clears the cache.
       * @returns {void}
       */
      flush() {
        cache.clear();
      },

      /**
       * Gets the count of a specific cache entry.
       * @param {string} key - The cache key to count.
       * @returns {number} - The count of the cache entry.
       */
      count(key) {
        return cache.get(key)?.total ?? 0;
      },

      /**
       * Retrieves a value associated with a specific cache key.
       * @param {string} key - The cache key to retrieve.
       * @returns {any} - The value associated with the cache key.
       */
      get(key) {
        return cache.get(key)?.value;
      },

      /**
       * Adds or updates a cache entry.
       * @param {string} key - The cache key to add or update.
       * @param {any} value - The value to store.
       * @param {boolean} isValid - Whether the cache entry is valid.
       */
      put(key, value, isValid) {
        const entry = cache.get(key);

        if (entry) {
          entry.total++;
          entry.value = value;
        } else {
          cache.set(key, { total: 1, value, isValid });
        }
      },
    };
  }

  class AnimateCacheProvider {
    $get() {
      return animateCache();
    }
  }

  const NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim";

  const NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor";

  const NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out";

  const NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";

  AnimateCssDriverProvider.$inject = provider([$injectTokens._animation]);
  function AnimateCssDriverProvider($$animationProvider) {
    $$animationProvider.drivers.push($injectTokens._animateCssDriver);

    function isDocumentFragment(node) {
      // eslint-disable-next-line no-magic-numbers
      return node.parentNode && node.parentNode.nodeType === 11;
    }

    /**
     * @returns {Function}
     */
    this.$get = [
      $injectTokens._animateCss,
      $injectTokens._rootElement,
      /**
       *
       * @param {*} $animateCss
       * @param {Element} $rootElement
       * @returns
       */
      function ($animateCss, $rootElement) {
        const bodyNode = document.body;

        const rootNode = $rootElement;

        const rootBodyElement =
          // this is to avoid using something that exists outside of the body
          // we also special case the doc fragment case because our unit test code
          // appends the $rootElement to the body after the app has been bootstrapped
          isDocumentFragment(rootNode) || bodyNode.contains(rootNode)
            ? rootNode
            : bodyNode;

        return function initDriverFn(animationDetails) {
          return animationDetails.from && animationDetails.to
            ? prepareFromToAnchorAnimation(
                animationDetails.from,
                animationDetails.to,
                animationDetails.anchors,
              )
            : prepareRegularAnimation(animationDetails);
        };

        function prepareAnchoredAnimation(outAnchor, inAnchor) {
          const clone = outAnchor.cloneNode(true);

          const startingClasses = filterCssClasses(getClassVal(clone));

          outAnchor[0].classList.add(NG_ANIMATE_SHIM_CLASS_NAME);
          inAnchor[0].classList.add(NG_ANIMATE_SHIM_CLASS_NAME);

          clone.classList.add(NG_ANIMATE_ANCHOR_CLASS_NAME);

          rootBodyElement.append(clone);

          let animatorIn;

          const animatorOut = prepareOutAnimation();

          // the user may not end up using the `out` animation and
          // only making use of the `in` animation or vice-versa.
          // In either case we should allow this and not assume the
          // animation is over unless both animations are not used.
          if (!animatorOut) {
            animatorIn = prepareInAnimation();

            if (!animatorIn) {
              return end();
            }
          }

          const startingAnimator = animatorOut || animatorIn;

          return {
            start() {
              const runner = new AnimateRunner({
                end: endFn,
                cancel: endFn,
              });

              let currentAnimation = startingAnimator.start();

              currentAnimation.done(() => {
                currentAnimation = null;

                if (!animatorIn) {
                  animatorIn = prepareInAnimation();

                  if (animatorIn) {
                    currentAnimation = animatorIn.start();
                    currentAnimation.done(() => {
                      currentAnimation = null;
                      end();
                      runner.complete();
                    });

                    return currentAnimation;
                  }
                }
                // in the event that there is no `in` animation
                end();
                runner.complete();

                return undefined;
              });

              return runner;

              function endFn() {
                if (currentAnimation) {
                  currentAnimation.end();
                }
              }
            },
          };

          function calculateAnchorStyles(anchor) {
            const styles = {};

            const coords = anchor.getBoundingClientRect();

            // we iterate directly since safari messes up and doesn't return
            // all the keys for the coords object when iterated
            ["width", "height", "top", "left"].forEach((key) => {
              let value = coords[key];

              switch (key) {
                case "top":
                  value += bodyNode.scrollTop;
                  break;
                case "left":
                  value += bodyNode.scrollLeft;
                  break;
              }
              styles[key] = `${Math.floor(value)}px`;
            });

            return styles;
          }

          function prepareOutAnimation() {
            const animator = $animateCss(clone, {
              addClass: NG_OUT_ANCHOR_CLASS_NAME,
              delay: true,
              from: calculateAnchorStyles(outAnchor),
            });

            // read the comment within `prepareRegularAnimation` to understand
            // why this check is necessary
            return animator.$$willAnimate ? animator : null;
          }

          function getClassVal(element) {
            return element.getAttribute("class") || "";
          }

          function prepareInAnimation() {
            const endingClasses = filterCssClasses(getClassVal(inAnchor));

            const toAdd = getUniqueValues(endingClasses, startingClasses);

            const toRemove = getUniqueValues(startingClasses, endingClasses);

            const animator = $animateCss(clone, {
              to: calculateAnchorStyles(inAnchor),
              addClass: `${NG_IN_ANCHOR_CLASS_NAME} ${toAdd}`,
              removeClass: `${NG_OUT_ANCHOR_CLASS_NAME} ${toRemove}`,
              delay: true,
            });

            // read the comment within `prepareRegularAnimation` to understand
            // why this check is necessary
            return animator.$$willAnimate ? animator : null;
          }

          function end() {
            clone.remove();
            outAnchor[0].classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor[0].classList.remove(NG_ANIMATE_SHIM_CLASS_NAME);
          }
        }

        function prepareFromToAnchorAnimation(from, to, anchors) {
          const fromAnimation = prepareRegularAnimation(from);

          const toAnimation = prepareRegularAnimation(to);

          const anchorAnimations = [];

          anchors.forEach((anchor) => {
            const outElement = anchor.out;

            const inElement = anchor.in;

            const animator = prepareAnchoredAnimation(outElement, inElement);

            if (animator) {
              anchorAnimations.push(animator);
            }
          });

          // no point in doing anything when there are no elements to animate
          if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
            return undefined;

          return {
            start() {
              const animationRunners = [];

              if (fromAnimation) {
                animationRunners.push(fromAnimation.start());
              }

              if (toAnimation) {
                animationRunners.push(toAnimation.start());
              }

              anchorAnimations.forEach((animation) => {
                animationRunners.push(animation.start());
              });

              const runner = new AnimateRunner({
                end: endFn,
                cancel: endFn, // CSS-driven animations cannot be cancelled, only ended
              });

              AnimateRunner._all(animationRunners, (status) => {
                runner.complete(status);
              });

              return runner;

              function endFn() {
                animationRunners.forEach((runnerItem) => {
                  runnerItem.end();
                });
              }
            },
          };
        }

        function prepareRegularAnimation(animationDetails) {
          const options = animationDetails.options || {};

          if (animationDetails.structural) {
            options.event = animationDetails.event;
            options.structural = true;
            options.applyClassesEarly = true;

            // we special case the leave animation since we want to ensure that
            // the element is removed as soon as the animation is over. Otherwise
            // a flicker might appear or the element may not be removed at all
            if (animationDetails.event === "leave") {
              options.onDone = options.domOperation;
            }
          }

          // We assign the preparationClasses as the actual animation event since
          // the internals of $animateCss will just suffix the event token values
          // with `-active` to trigger the animation.
          if (options.preparationClasses) {
            options.event = concatWithSpace(
              options.event,
              options.preparationClasses,
            );
          }

          const animator = $animateCss(animationDetails.element, options);

          // the driver lookup code inside of $$animation attempts to spawn a
          // driver one by one until a driver returns a.$$willAnimate animator object.
          // $animateCss will always return an object, however, it will pass in
          // a flag as a hint as to whether an animation was detected or not

          return animator.$$willAnimate ? animator : null;
        }
      },
    ];
  }

  function filterCssClasses(classes) {
    // remove all the `ng-` stuff
    return classes.replace(/\bng-\S+\b/g, "");
  }

  function getUniqueValues(a, b) {
    if (isString(a)) a = a.split(" ");

    if (isString(b)) b = b.split(" ");

    return a.filter((val) => b.indexOf(val) === -1).join(" ");
  }

  AnimateJsDriverProvider.$inject = provider([$injectTokens._animation]);
  function AnimateJsDriverProvider($$animationProvider) {
    $$animationProvider.drivers.push($injectTokens._animateJsDriver);
    this.$get = [
      $injectTokens._animateJs,
      /**
       *
       * @param {*} $$animateJs
       */
      function ($$animateJs) {
        return function initDriverFn(animationDetails) {
          if (animationDetails.from && animationDetails.to) {
            const fromAnimation = prepareAnimation(animationDetails.from);

            const toAnimation = prepareAnimation(animationDetails.to);

            if (!fromAnimation && !toAnimation) return undefined;

            return {
              start() {
                const animationRunners = [];

                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }

                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }

                AnimateRunner._all(animationRunners, done);

                const runner = new AnimateRunner({
                  end: endFnFactory(),
                  cancel: endFnFactory(),
                });

                return runner;

                function endFnFactory() {
                  return function () {
                    animationRunners.forEach((x) => {
                      // at this point we cannot cancel animations for groups just yet. 1.5+
                      x.end();
                    });
                  };
                }

                function done(status) {
                  runner.complete(status);
                }
              },
            };
          }

          return prepareAnimation(animationDetails);
        };

        function prepareAnimation(animationDetails) {
          // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
          const { element, event, options, classes } = animationDetails;

          return $$animateJs(element, event, classes, options);
        }
      },
    ];
  }

  ngAnimateSwapDirective.$inject = [$injectTokens._animate];
  /**
   * @returns {ng.Directive}
   */
  function ngAnimateSwapDirective($animate) {
    return {
      restrict: "A",
      transclude: "element",
      terminal: true,
      priority: 550, // We use 550 here to ensure that the directive is caught before others,
      // but after `ngIf` (at priority 600).
      link(scope, $element, attrs, _ctrl, $transclude) {
        let previousElement;

        let previousScope;

        scope.$watch(attrs.ngAnimateSwap || attrs.for, (value) => {
          if (previousElement) {
            $animate.leave(previousElement);
          }

          if (previousScope) {
            previousScope.$destroy();
            previousScope = null;
          }

          if (value) {
            $transclude((clone, childScope) => {
              previousElement = clone;
              previousScope = childScope;
              $animate.enter(clone, null, $element);
            });
          }
        });
      },
    };
  }

  $$AnimateChildrenDirective.$inject = [$injectTokens._interpolate];

  /**
   * @param {ng.InterpolateService} $interpolate
   * @returns {ng.Directive}
   */
  function $$AnimateChildrenDirective($interpolate) {
    return {
      link(scope, element, attrs) {
        const val = attrs.ngAnimateChildren;

        if (isString(val) && val.length === 0) {
          // empty attribute
          setCacheData(element, NG_ANIMATE_CHILDREN_DATA, true);
        } else {
          // Interpolate and set the value, so that it is available to
          // animations that run right after compilation
          setData($interpolate(val)(scope));
          attrs.$observe("ngAnimateChildren", setData);
        }

        function setData(value) {
          value = value === "on" || value === "true";
          setCacheData(element, NG_ANIMATE_CHILDREN_DATA, value);
        }
      },
    };
  }

  function equals(o1, o2) {
    if (o1 === o2) return true;

    if (o1 === null || o2 === null) return false;

    if (Number.isNaN(o1) && Number.isNaN(o2)) return true; // NaN === NaN
    const t1 = typeof o1,
      t2 = typeof o2;

    if (t1 !== t2 || t1 !== "object") return false;
    const tup = [o1, o2];

    if (tup.every(isArray)) return _arraysEq(o1, o2);

    if (tup.every(isDate)) return o1.getTime() === o2.getTime();

    if (tup.every(isRegExp)) return o1.toString() === o2.toString();

    if (tup.every(isFunction)) return true; // meh

    if ([isFunction, isArray, isDate, isRegExp].some((fn) => !!fn(tup))) {
      return false;
    }
    const keys = {};

    for (const key in o1) {
      if (!equals(o1[key], o2[key])) return false;
      keys[key] = true;
    }

    for (const key in o2) {
      if (!keys[key]) return false;
    }

    return true;
  }

  /**
   * prototypal inheritance helper.
   * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
   */

  /**
   * prototypal inheritance helper.
   * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it.
   *
   * @param {Object} parent - The object to be used as the prototype.
   * @param {Object} [extra] - The object containing additional properties to be copied.
   * @returns {Object} - A new object with `parent` as its prototype and properties from `extra`.
   */
  function inherit(parent, extra) {
    const newObj = Object.create(parent);

    if (extra) {
      Object.assign(newObj, extra);
    }

    return newObj;
  }

  /**
   * Given an array, and an item, if the item is found in the array, it removes it (in-place).
   * The same array is returned
   * @param {Array} array
   * @param {any} obj
   * @returns {Array}
   */
  function removeFrom(array, obj) {
    const i = array.indexOf(obj);

    if (i !== -1) array.splice(i, 1);

    return array;
  }

  /**
   * Applies a set of defaults to an options object.  The options object is filtered
   * to only those properties of the objects in the defaultsList.
   * Earlier objects in the defaultsList take precedence when applying defaults.
   */
  function defaults(opts, ...defaultsList) {
    const defaultVals = Object.assign({}, ...defaultsList.reverse());

    return Object.assign(defaultVals, pick(opts || {}, Object.keys(defaultVals)));
  }

  /**
   * Finds the common ancestor path between two states.
   *
   * @param {Object} first The first state.
   * @param {Object} second The second state.
   * @return {Array} Returns an array of state names in descending order, not including the root.
   */
  function ancestors(first, second) {
    const path = [];

    for (const i in first.path) {
      if (first.path[i] !== second.path[i]) break;
      path.push(first.path[i]);
    }

    return path;
  }
  /**
   * Return a copy of the object only containing the whitelisted properties.
   *
   * #### Example:
   * ```
   * var foo = { a: 1, b: 2, c: 3 };
   * var ab = pick(foo, ['a', 'b']); // { a: 1, b: 2 }
   * ```
   * @param obj the source object
   * @param propNames an Array of strings, which are the whitelisted property names
   */
  function pick(obj, propNames) {
    const objCopy = {};

    for (const _prop in obj) {
      if (propNames.indexOf(_prop) !== -1) {
        objCopy[_prop] = obj[_prop];
      }
    }

    return objCopy;
  }
  /**
   * Return a copy of the object omitting the blacklisted properties.
   *
   * @example
   * ```
   *
   * var foo = { a: 1, b: 2, c: 3 };
   * var ab = omit(foo, ['a', 'b']); // { c: 3 }
   * ```
   * @param obj the source object
   * @param propNames an Array of strings, which are the blacklisted property names
   */
  function omit(obj, propNames) {
    return Object.keys(obj)
      .filter((x) => !propNames.includes(x))
      .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});
  }

  /** Filters an Array or an Object's properties based on a predicate */
  function filter(collection, callback) {
    const arr = isArray(collection),
      result = arr ? [] : {};

    const accept = arr ? (x) => result.push(x) : (x, key) => (result[key] = x);

    entries(collection).forEach(([i, item]) => {
      if (callback(item, i)) accept(item, i);
    });

    return result;
  }

  /** Finds an object from an array, or a property of an object, that matches a predicate */
  function find(collection, callback) {
    let result;

    entries(collection).forEach(([i, item]) => {
      if (result) return;

      if (callback(item, i)) result = item;
    });

    return result;
  }

  /** Maps an array or object properties using a callback function */
  function map(collection, callback, target) {
    target = target || (isArray(collection) ? [] : {});
    entries(collection).forEach(([i, item]) => (target[i] = callback(item, i)));

    return target;
  }

  /**
   * Reduce function that returns true if all of the values are truthy.
   *
   * @example
   * ```
   *
   * let vals = [ 1, true, {}, "hello world"];
   * vals.reduce(allTrueR, true); // true
   *
   * vals.push(0);
   * vals.reduce(allTrueR, true); // false
   * ```
   */
  const allTrueR = (memo, elem) => memo && elem;
  /**
   * Reduce function that returns true if any of the values are truthy.
   *
   *  * @example
   * ```
   *
   * let vals = [ 0, null, undefined ];
   * vals.reduce(anyTrueR, true); // false
   *
   * vals.push("hello world");
   * vals.reduce(anyTrueR, true); // true
   * ```
   */
  const anyTrueR = (memo, elem) => memo || elem;
  /**
   * Reduce function which un-nests a single level of arrays
   * @example
   * ```
   *
   * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
   * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
   * ```
   */
  const unnestR = (memo, elem) => memo.concat(elem);
  /**
   * Reduce function that pushes an object to an array, then returns the array.
   * Mostly just for [[flattenR]] and [[uniqR]]
   */
  function pushR(arr, obj) {
    arr.push(obj);

    return arr;
  }
  /** Reduce function that filters out duplicates */
  const uniqR = (acc, token) =>
    acc.includes(token) ? acc : pushR(acc, token);
  /**
   * Return a new array with a single level of arrays unnested.
   *
   * @example
   * ```
   *
   * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];
   * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]
   * ```
   */
  const unnest = (arr) => arr.reduce(unnestR, []);

  /**
   * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
   * @example
   * ```
   *
   * let isNumber = (obj) => typeof(obj) === 'number';
   * let allNumbers = [ 1, 2, 3, 4, 5 ];
   * allNumbers.filter(assertPredicate(isNumber)); //OK
   *
   * let oneString = [ 1, 2, 3, 4, "5" ];
   * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");
   * ```
   */
  const assertPredicate = assertFn;

  function assertFn(predicateOrMap, errMsg = "assert failure") {
    return (obj) => {
      const result = predicateOrMap(obj);

      if (!result) {
        throw new Error(errMsg);
      }

      return result;
    };
  }
  /**
   * Given two or more parallel arrays, returns an array of tuples where
   * each tuple is composed of [ a[i], b[i], ... z[i] ]
   *
   * @example
   * ```
   *
   * let foo = [ 0, 2, 4, 6 ];
   * let bar = [ 1, 3, 5, 7 ];
   * let baz = [ 10, 30, 50, 70 ];
   * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
   * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
   * ```
   */
  function arrayTuples(...args) {
    if (args.length === 0) return [];
    const maxArrayLen = args.reduce(
      (min, arr) => Math.min(arr.length, min),
      Number.MAX_SAFE_INTEGER,
    );

    const result = [];

    for (let i = 0; i < maxArrayLen; i++) {
      // This is a hot function
      // Unroll when there are 1-4 arguments
      switch (args.length) {
        case 1:
          result.push([args[0][i]]);
          break;
        case 2:
          result.push([args[0][i], args[1][i]]);
          break;
        case 3:
          result.push([args[0][i], args[1][i], args[2][i]]);
          break;
        case 4:
          result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
          break;
        default:
          result.push(args.map((array) => array[i]));
          break;
      }
    }

    return result;
  }
  /**
   * Reduce function which builds an object from an array of [key, value] pairs.
   *
   * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
   *
   * Each keyValueTuple should be an array with values [ key: string, value: any ]
   *
   * @example
   * ```
   *
   * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]
   *
   * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
   * // pairsToObj == { fookey: "fooval", barkey: "barval" }
   *
   * // Or, more simply:
   * var pairsToObj = pairs.reduce(applyPairs, {})
   * // pairsToObj == { fookey: "fooval", barkey: "barval" }
   * ```
   */
  function applyPairs(memo, keyValTuple) {
    let key, value;

    if (isArray(keyValTuple)) [key, value] = keyValTuple;

    if (!isString(key)) throw new Error("invalid parameters to applyPairs");
    memo[key] = value;

    return memo;
  }

  /**
   * Returns the last element of an array, or undefined if the array is empty.
   * @template T
   * @param {T[]} arr - The input array.
   * @returns {T | undefined} The last element or undefined.
   */
  function tail(arr) {
    return arr.length > 0 ? arr[arr.length - 1] : undefined;
  }

  /**
   * shallow copy from src to dest
   */
  function copy(src, dest) {
    if (dest) Object.keys(dest).forEach((key) => delete dest[key]);

    if (!dest) dest = {};

    return Object.assign(dest, src);
  }

  function _arraysEq(a1, a2) {
    if (a1.length !== a2.length) return false;

    for (let i = 0; i < a1.length; i++) {
      if (!equals(a1[i], a2[i])) return false;
    }

    return true;
  }
  // issue #2676
  const silenceUncaughtInPromise = (promise) =>
    promise.catch(() => 0) && promise;
  const silentRejection = (error) =>
    silenceUncaughtInPromise(Promise.reject(error));

  /**
   * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.
   *
   * Given a function with N parameters, returns a new function that supports partial application.
   * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,
   * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to
   * accept more parameters until all N parameters have been supplied.
   *
   *
   * This contrived example uses a partially applied function as an predicate, which returns true
   * if an object is found in both arrays.
   * @example
   * ```
   * // returns true if an object is in both of the two arrays
   * function inBoth(array1, array2, object) {
   *   return array1.indexOf(object) !== -1 &&
   *          array2.indexOf(object) !== 1;
   * }
   * let obj1, obj2, obj3, obj4, obj5, obj6, obj7
   * let foos = [obj1, obj3]
   * let bars = [obj3, obj4, obj5]
   *
   * // A curried "copy" of inBoth
   * let curriedInBoth = curry(inBoth);
   * // Partially apply both the array1 and array2
   * let inFoosAndBars = curriedInBoth(foos, bars);
   *
   * // Supply the final argument; since all arguments are
   * // supplied, the original inBoth function is then called.
   * let obj1InBoth = inFoosAndBars(obj1); // false
   *
   * // Use the inFoosAndBars as a predicate.
   * // Filter, on each iteration, supplies the final argument
   * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];
   * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]
   *
   * ```
   *
   * @param fn
   * @returns {*|function(): (*|any)}
   */
  function curry(fn) {
    const curried = (...args) => {
      if (args.length >= fn.length) {
        return fn(...args);
      }

      return (...nextArgs) => curried(...args, ...nextArgs);
    };

    return curried;
  }

  /**
   * Given a property name and a value, returns a function that returns a boolean based on whether
   * the passed object has a property that matches the value
   * let obj = { foo: 1, name: "blarg" };
   * let getName = propEq("name", "blarg");
   * getName(obj) === true
   */
  const propEq = curry((name, _val, obj) => obj && obj[name] === _val);
  /**
   * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
   * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
   * let getName = prop("nestedObj.name");
   * getName(obj) === "blarg"
   * let propNotFound = prop("this.property.doesnt.exist");
   * propNotFound(obj) === undefined
   */
  const parse = (path) => {
    const parts = path.split(".");

    return (obj) => parts.reduce((acc, key) => acc && acc[key], obj);
  };

  /**
   * Given a class constructor, returns a predicate function that checks
   * whether a given object is an instance of that class.
   *
   * @param {new (...args: any[]) => any} ctor - The class constructor to check against.
   * @returns {(obj: any) => boolean} A predicate function that returns true if the object is of the given class.
   */
  function is(ctor) {
    /**
     * Checks if the provided object is an instance of the given constructor.
     *
     * @param {any} obj - The object to test.
     * @returns {boolean} True if the object is an instance of the given class.
     */
    return function (obj) {
      return (
        (obj !== null && obj !== undefined && obj.constructor === ctor) ||
        obj instanceof ctor
      );
    };
  }

  /** Given a value, returns a function which returns the value */
  const val = (value) => () => value;

  /**
   * Sorta like Pattern Matching (a functional programming conditional construct)
   *
   * See http://c2.com/cgi/wiki?PatternMatching
   *
   * This is a conditional construct which allows a series of predicates and output functions
   * to be checked and then applied.  Each predicate receives the input.  If the predicate
   * returns truthy, then its matching output function (mapping function) is provided with
   * the input and, then the result is returned.
   *
   * Each combination (2-tuple) of predicate + output function should be placed in an array
   * of size 2: [ predicate, mapFn ]
   *
   * These 2-tuples should be put in an outer array.
   *
   * @example
   * ```
   *
   * // Here's a 2-tuple where the first element is the isString predicate
   * // and the second element is a function that returns a description of the input
   * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];
   *
   * // Second tuple: predicate "isNumber", mapfn returns a description
   * let secondTuple = [ angular.isNumber, (input) => `(${input}) That's a number!` ];
   *
   * let third = [ (input) => input === null,  (input) => `Oh, null...` ];
   *
   * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];
   *
   * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);
   *
   * console.log(descriptionOf(undefined)); // 'notdefined'
   * console.log(descriptionOf(55)); // '(55) That's a number!'
   * console.log(descriptionOf("foo")); // 'Here's your string foo'
   * ```
   *
   * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,
   * with a Predicate and a mapping/output function
   * @returns {function(any): *}
   */
  function pattern(struct) {
    return function (item) {
      for (let i = 0; i < struct.length; i++) {
        if (struct[i][0](item)) return struct[i][1](item);
      }

      return undefined;
    };
  }

  /**
   * An internal class which implements [[ParamTypeDefinition]].
   *
   * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.
   * When a param type definition is registered, an instance of this class is created internally.
   *
   * This class has naive implementations for all the [[ParamTypeDefinition]] methods.
   *
   * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.
   *
   * #### Example:
   * ```js
   * var paramTypeDef = {
   *   decode: function(val) { return parseInt(val, 10); },
   *   encode: function(val) { return val && val.toString(); },
   *   equals: function(a, b) { return this.is(a) && a === b; },
   *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },
   *   pattern: /\d+/
   * }
   *
   * var paramType = new ParamType(paramTypeDef);
   * ```
   */
  class ParamType {
    /**
     * @param def  A configuration object which contains the custom type definition.  The object's
     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.
     */
    constructor(def) {
      this.pattern = /.*/;
      this.inherit = true;
      Object.assign(this, def);
      this.name = undefined;
    }
    // consider these four methods to be "abstract methods" that should be overridden

    is(val) {
      return !!val;
    }

    encode(val) {
      return val;
    }

    decode(val) {
      return val;
    }

    equals(a, b) {
      return a === b;
    }

    $subPattern() {
      const sub = this.pattern.toString();

      return sub.substring(1, sub.length - 2);
    }

    toString() {
      return `{ParamType:${this.name}}`;
    }

    /** Given an encoded string, or a decoded object, returns a decoded object */
    $normalize(val) {
      return this.is(val) ? val : this.decode(val);
    }

    /**
     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.
     * e.g.:
     * - urlmatcher pattern "/path?{queryParam[]:int}"
     * - url: "/path?queryParam=1&queryParam=2
     * - $stateParams.queryParam will be [1, 2]
     * if `mode` is "auto", then
     * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
     * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
     */
    $asArray(mode, isSearch) {
      if (!mode) return this;

      if (mode === "auto" && !isSearch)
        throw new Error("'auto' array mode is for query parameters only");

      return new ArrayType(this, mode);
    }
  }
  /** Wraps up a `ParamType` object to handle array values. */
  function ArrayType(type, mode) {
    // Wrap non-array value as array
    function arrayWrap(val) {
      return isArray(val) ? val : isDefined(val) ? [val] : [];
    }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
      switch (val.length) {
        case 0:
          return undefined;
        case 1:
          return mode === "auto" ? val[0] : val;
        default:
          return val;
      }
    }
    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
      return function handleArray(val) {
        if (isArray(val) && val.length === 0) return val;
        const arr = arrayWrap(val);

        const result = map(arr, callback);

        return allTruthyMode === true
          ? filter(result, (x) => !x).length === 0
          : arrayUnwrap(result);
      };
    }
    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
      return function handleArray(val1, val2) {
        const left = arrayWrap(val1),
          right = arrayWrap(val2);

        if (left.length !== right.length) return false;

        for (let i = 0; i < left.length; i++) {
          if (!callback(left[i], right[i])) return false;
        }

        return true;
      };
    }
    ["encode", "decode", "equals", "$normalize"].forEach((name) => {
      const paramTypeFn = type[name].bind(type);

      const wrapperFn = name === "equals" ? arrayEqualsHandler : arrayHandler;

      this[name] = wrapperFn(paramTypeFn);
    });
    Object.assign(this, {
      dynamic: type.dynamic,
      name: type.name,
      pattern: type.pattern,
      inherit: type.inherit,
      raw: type.raw,
      is: arrayHandler(type.is.bind(type), true),
      $arrayMode: mode,
    });
  }

  /**
   * A registry for parameter types.
   *
   * This registry manages the built-in (and custom) parameter types.
   *
   * The built-in parameter types are:
   *
   * - [[string]]
   * - [[path]]
   * - [[query]]
   * - [[hash]]
   * - [[int]]
   * - [[bool]]
   * - [[date]]
   * - [[json]]
   * - [[any]]
   *
   * To register custom parameter types, use [[UrlConfig.type]], i.e.,
   *
   * ```js
   * router.urlService.config.type(customType)
   * ```
   */
  class ParamTypes {
    constructor() {
      this.enqueue = true;
      this.typeQueue = [];
      this.defaultTypes = pick(ParamTypes.prototype, [
        "hash",
        "string",
        "query",
        "path",
        "int",
        "bool",
        "date",
        "json",
        "any",
      ]);
      // Register default types. Store them in the prototype of this.types.
      const makeType = (definition, name) =>
        new ParamType(Object.assign({ name }, definition));

      this.types = inherit(map(this.defaultTypes, makeType), {});
    }

    /**
     * Registers a parameter type
     *
     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.
     */
    type(name, definition, definitionFn) {
      if (!isDefined(definition)) return this.types[name];

      if (hasOwn(this.types, name))
        throw new Error(`A type named '${name}' has already been defined.`);
      this.types[name] = new ParamType(Object.assign({ name }, definition));

      if (definitionFn) {
        this.typeQueue.push({ name, def: definitionFn });

        if (!this.enqueue) this._flushTypeQueue();
      }

      return this;
    }

    _flushTypeQueue() {
      while (this.typeQueue.length) {
        const type = this.typeQueue.shift();

        if (type.pattern)
          throw new Error("You cannot override a type's .pattern at runtime.");
        Object.assign(
          this.types[type.name],
          window.angular.$injector.invoke(type.def),
        );
      }
    }
  }
  function initDefaultTypes() {
    const makeDefaultType = (def) => {
      const valToString = (val) =>
        !isNullOrUndefined(val) ? val.toString() : val;

      const defaultTypeBase = {
        encode: valToString,
        decode: valToString,
        is: is(String),
        pattern: /.*/,

        equals: (a, b) => a === b, // allow coersion for null/undefined/""
      };

      return Object.assign({}, defaultTypeBase, def);
    };

    // Default Parameter Type Definitions
    Object.assign(ParamTypes.prototype, {
      string: makeDefaultType({}),
      path: makeDefaultType({
        pattern: /[^/]*/,
      }),
      query: makeDefaultType({}),
      hash: makeDefaultType({
        inherit: false,
      }),
      int: makeDefaultType({
        decode: (val) => parseInt(val, 10),
        is(val) {
          return !isNullOrUndefined(val) && this.decode(val.toString()) === val;
        },
        pattern: /-?\d+/,
      }),
      bool: makeDefaultType({
        encode: (val) => (val && 1) || 0,
        decode: (val) => parseInt(val, 10) !== 0,
        is: is(Boolean),
        pattern: /[01]/,
      }),
      date: makeDefaultType({
        encode(val) {
          return !this.is(val)
            ? undefined
            : [
                val.getFullYear(),
                `0${val.getMonth() + 1}`.slice(-2),
                `0${val.getDate()}`.slice(-2),
              ].join("-");
        },
        decode(val) {
          if (this.is(val)) return val;
          const match = this.capture.exec(val);

          return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
        },
        is: (val) => val instanceof Date && !isNaN(val.valueOf()),
        equals(left, right) {
          return ["getFullYear", "getMonth", "getDate"].reduce(
            (acc, fn) => acc && left[fn]() === right[fn](),
            true,
          );
        },
        pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
        capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,
      }),
      json: makeDefaultType({
        encode: JSON.stringify,
        decode: JSON.parse,
        is: is(Object),
        equals,
        pattern: /[^/]*/,
      }),
      // does not encode/decode
      any: makeDefaultType({
        encode: (x) => x,
        decode: (x) => x,
        is: () => true,
        equals,
      }),
    });
  }
  initDefaultTypes();

  /**
   * An API to customize the URL behavior and retrieve URL configuration
   *
   * This API is used to customize the behavior of the URL.
   * This includes optional trailing slashes ([[strictMode]]), case sensitivity ([[caseInsensitive]]),
   * and custom parameter encoding (custom [[type]]).
   *
   * It also has information about the location (url) configuration such as [[port]] and [[baseHref]].
   * This information can be used to build absolute URLs, such as
   * `https://example.com:443/basepath/state/substate?param1=a#hashvalue`;
   *
   * This API is found at `router.urlService.config` (see: [[UIRouter.urlService]], [[URLService.config]])
   */
  class UrlConfigProvider {
    constructor() {
      /** @type {ParamTypes} */
      this.paramTypes = new ParamTypes();
      /** @type {boolean} */
      this._isCaseInsensitive = false;
      /** @type {boolean} */
      this._isStrictMode = true;
      /** @type {boolean} */
      this._defaultSquashPolicy = false;
      /**
       * Applys ng1-specific path parameter encoding
       *
       * The Angular 1 `$location` service is a bit weird.
       * It doesn't allow slashes to be encoded/decoded bi-directionally.
       *
       * See the writeup at https://github.com/angular-ui/ui-router/issues/2598
       *
       * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F
       *
       */
      const pathType = this.type("path");

      pathType.encode = (x) =>
        !isNullOrUndefined(x)
          ? x
              .toString()
              .replace(/([~/])/g, (match) => ({ "~": "~~", "/": "~2F" })[match])
          : x;
      pathType.decode = (x) =>
        !isNullOrUndefined(x)
          ? x
              .toString()
              .replace(/(~~|~2F)/g, (match) => ({ "~~": "~", "~2F": "/" })[match])
          : x;
      this.paramTypes.enqueue = false;
      this.paramTypes._flushTypeQueue();
    }

    $get = () => this;

    /**
     * Defines whether URL matching should be case sensitive (the default behavior), or not.
     *
     * #### Example:
     * ```js
     * // Allow case insensitive url matches
     * urlService.config.caseInsensitive(true);
     * ```
     *
     * @param value `false` to match URL in a case sensitive manner; otherwise `true`;
     * @returns the current value of caseInsensitive
     */
    caseInsensitive(value) {
      return (this._isCaseInsensitive = isDefined(value)
        ? value
        : this._isCaseInsensitive);
    }

    /**
     * Sets the default behavior when generating or matching URLs with default parameter values.
     *
     * #### Example:
     * ```js
     * // Remove default parameter values from the url
     * urlService.config.defaultSquashPolicy(true);
     * ```
     *
     * @param value A string that defines the default parameter URL squashing behavior.
     *    - `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
     *    - `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
     *      parameter is surrounded by slashes, squash (remove) one slash from the URL
     *    - any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
     *      the parameter value from the URL and replace it with this string.
     * @returns the current value of defaultSquashPolicy
     */
    defaultSquashPolicy(value) {
      if (
        isDefined(value) &&
        value !== true &&
        value !== false &&
        !isString(value)
      )
        throw new Error(
          `Invalid squash policy: ${value}. Valid policies: false, true, arbitrary-string`,
        );

      return (this._defaultSquashPolicy = isDefined(value)
        ? value
        : this._defaultSquashPolicy);
    }

    /**
     * Defines whether URLs should match trailing slashes, or not (the default behavior).
     *
     * #### Example:
     * ```js
     * // Allow optional trailing slashes
     * urlService.config.strictMode(false);
     * ```
     *
     * @param value `false` to match trailing slashes in URLs, otherwise `true`.
     * @returns the current value of strictMode
     */
    strictMode(value) {
      return (this._isStrictMode = isDefined(value) ? value : this._isStrictMode);
    }

    /**
     * Creates and registers a custom [[ParamType]] object
     *
     * A custom parameter type can be used to generate URLs with typed parameters or custom encoding/decoding.
     *
     * #### Note: Register custom types *before using them* in a state definition.
     *
     * #### Example:
     * ```js
     * // Encode object parameter as JSON string
     * urlService.config.type('myjson', {
     *   encode: (obj) => JSON.stringify(obj),
     *   decode: (str) => JSON.parse(str),
     *   is: (val) => typeof(val) === 'object',
     *   pattern: /[^/]+/,
     *   equals: (a, b) => _.isEqual(a, b),
     * });
     * ```
     *
     * See [[ParamTypeDefinition]] for more examples
     *
     * @param name The type name.
     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.
     * @param definitionFn A function that is injected before the app runtime starts.
     *        The result of this function should be a [[ParamTypeDefinition]].
     *        The result is merged into the existing `definition`.
     *        See [[ParamType]] for information on the values accepted.
     *
     * @returns if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined
     */
    type(name, definition, definitionFn) {
      const type = this.paramTypes.type(name, definition, definitionFn);

      return !isDefined(definition) ? type : this;
    }
  }

  class StateParams {
    constructor(params = {}) {
      Object.assign(this, params);
    }

    /**
     * Merges a set of parameters with all parameters inherited between the common parents of the
     * current state and a given destination state.
     *
     * @param {Object} newParams The set of parameters which will be composited with inherited params.
     * @param {Object} $current Internal definition of object representing the current state.
     * @param {Object} $to Internal definition of object representing state to transition to.
     */
    $inherit(newParams, $current, $to) {
      const parents = ancestors($current, $to),
        inherited = {},
        inheritList = [];

      for (const i in parents) {
        if (!parents[i] || !parents[i].params) continue;
        const parentParams = parents[i].params;

        const parentParamsKeys = keys(parentParams);

        if (!parentParamsKeys.length) continue;

        for (const j in parentParamsKeys) {
          if (
            parentParams[parentParamsKeys[j]].inherit === false ||
            inheritList.indexOf(parentParamsKeys[j]) >= 0
          )
            continue;
          inheritList.push(parentParamsKeys[j]);
          inherited[parentParamsKeys[j]] = this[parentParamsKeys[j]];
        }
      }

      return Object.assign({}, inherited, newParams);
    }
  }

  /**
   * A simple bounded FIFO queue with optional eviction notifications.
   * @template T
   */
  class Queue {
    /**
     * @param {T[]} [items=[]] - Initial queue items.
     * @param {number|null} [limit=null] - Maximum allowed items before eviction (null = unlimited).
     */
    constructor(items = [], limit = null) {
      /** @type {T[]} */
      this._items = isArray(items) ? [...items] : [];

      /** @type {number|null} */
      this._limit =
        Number.isInteger(limit) && /** @type {number} */ (limit) > 0
          ? limit
          : null;

      /** @type {Array<(item: T) => void>} */
      this._evictListeners = [];
    }

    /**
     * Register a listener that will be called with the evicted item.
     * @param {(item: T) => void} listener
     */
    onEvict(listener) {
      this._evictListeners.push(listener);
    }

    /**
     * Adds an item to the end of the queue, evicting the head if over limit.
     * @param {T} item
     * @returns {T}
     */
    enqueue(item) {
      this._items.push(item);

      if (this._limit !== null && this._items.length > this._limit) {
        this.evict();
      }

      return item;
    }

    /**
     * Removes the head item and notifies eviction listeners.
     * @returns {T|undefined}
     */
    evict() {
      const item = this._items.shift();

      if (item !== undefined) {
        this._evictListeners.forEach((fn) => fn(item));
      }

      return item;
    }

    /**
     * Removes and returns the first item in the queue.
     * @returns {T|undefined}
     */
    dequeue() {
      return this._items.length > 0 ? this._items.shift() : undefined;
    }

    /**
     * Clears all items from the queue.
     * @returns {T[]} The previously stored items.
     */
    clear() {
      const cleared = [...this._items];

      this._items.length = 0;

      return cleared;
    }

    /**
     * Returns the current number of items.
     * @returns {number}
     */
    size() {
      return this._items.length;
    }

    /**
     * Removes a specific item from the queue.
     * @param {T} item
     * @returns {T|false} The removed item, or false if not found.
     */
    remove(item) {
      const index = this._items.indexOf(item);

      return index !== -1 ? this._items.splice(index, 1)[0] : false;
    }

    /**
     * Returns the item at the tail (last).
     * @returns {T|undefined}
     */
    peekTail() {
      return this._items[this._items.length - 1];
    }

    /**
     * Returns the item at the head (first).
     * @returns {T|undefined}
     */
    peekHead() {
      return this._items[0];
    }
  }

  /** @typedef {import('../interface.ts').ServiceProvider} ServiceProvider } */

  /**
   * Global router state
   *
   * This is where we hold the global mutable state such as current state, current
   * params, current transition, etc.
   */
  class RouterProvider {
    constructor() {
      /**
       * Current parameter values
       *
       * The parameter values from the latest successful transition
       * @type {StateParams}
       */
      this.params = new StateParams();

      /**
       * @type {number}
       */
      this.lastStartedTransitionId = -1;

      /**
       * @type {Queue<import("./transition/transition.js").Transition>}
       */
      this.transitionHistory = new Queue([], 1);

      /**
       * @type {Queue<import("./transition/transition.js").Transition>}
       */
      this.successfulTransitions = new Queue([], 1);

      /**
       * @type {import("./state/interface.ts").StateDeclaration|undefined}
       */
      this.current = undefined;

      /**
       * @type {import("./state/state-object.js").StateObject|undefined}
       */
      this.$current = undefined;

      /**
       * @type {import("./transition/transition.js").Transition|undefined}
       */
      this.transition = undefined;
    }

    $get = () => this;
  }

  /**
   * Functions that manipulate strings
   */

  const DOTS = "...";

  /**
   * Returns a string shortened to a maximum length
   *
   * If the string is already less than the `max` length, return the string.
   * Else return the string, shortened to `max - 3` and append three dots ("...").
   *
   * @param {number} max the maximum length of the string to return
   * @param {string} str the input string
   * @returns {string}
   */
  function maxLength(max, str) {
    if (str.length <= max) return str;

    return `${str.substring(0, max - DOTS.length)}${DOTS}`;
  }
  /**
   * Returns a string, with spaces added to the end, up to a desired str length
   *
   * If the string is already longer than the desired length, return the string.
   * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.
   *
   * @param {number} length the desired length of the string to return
   * @param {string} str the input string
   */
  function padString(length, str) {
    while (str.length < length) str += " ";

    return str;
  }

  /**
   * @param {string} camelCase
   * @returns {string}
   */
  function kebobString(camelCase) {
    return camelCase
      .replace(/^([A-Z])/, ($1) => $1.toLowerCase()) // replace first char
      .replace(/([A-Z])/g, ($1) => `-${$1.toLowerCase()}`); // replace rest
  }

  const FN_LENGTH = 9;

  /**
   * @param {Function} fn
   * @returns {string}
   */
  function functionToString(fn) {
    const fnStr = fnToString(fn);

    const namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/);

    const toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;

    const fnName = fn.name || "";

    if (fnName && toStr.match(/function \(/)) {
      return `function ${fnName}${toStr.substring(FN_LENGTH)}`;
    }

    return toStr;
  }

  /**
   * @param {[]|Function} fn
   * @returns {string}
   */
  function fnToString(fn) {
    const _fn = isArray(fn) ? fn.slice(-1)[0] : fn;

    return (_fn && _fn.toString()) || "undefined";
  }

  function stringify(value) {
    const seen = [];

    const isRejection = (obj) => {
      return (
        obj &&
        typeof obj.then === "function" &&
        obj.constructor.name === "Rejection"
      );
    };

    const hasToString = (obj) =>
      isObject(obj) &&
      !isArray(obj) &&
      obj.constructor !== Object &&
      isFunction(obj.toString);

    const stringifyPattern = pattern([
      [isUndefined, val("undefined")],
      [isNull, val("null")],
      [isPromise, val("[Promise]")],
      [isRejection, (reg) => reg._transitionRejection.toString()],
      [hasToString, (str) => str.toString()],
      [isInjectable, functionToString],
      [val(true), (bool) => bool],
    ]);

    function format(item) {
      if (isObject(item)) {
        if (seen.indexOf(item) !== -1) return "[circular ref]";
        seen.push(item);
      }

      return stringifyPattern(item);
    }

    if (isUndefined(value)) {
      // Workaround for IE & Edge Spec incompatibility where replacer function would not be called when JSON.stringify
      // is given `undefined` as value. To work around that, we simply detect `undefined` and bail out early by
      // manually stringifying it.
      return format(value);
    }

    return JSON.stringify(value, (_key, item) => format(item)).replace(
      /\\"/g,
      '"',
    );
  }

  const stripLastPathElement = (str) => str.replace(/\/[^/]*$/, "");
  /**
   * Splits on a delimiter, but returns the delimiters in the array
   *
   * #### Example:
   * ```js
   * var splitOnSlashes = splitOnDelim('/');
   * splitOnSlashes("/foo"); // ["/", "foo"]
   * splitOnSlashes("/foo/"); // ["/", "foo", "/"]
   * ```
   */
  function splitOnDelim(delim) {
    const re = new RegExp(`(${delim})`, "g");

    return (str) => str.split(re).filter(Boolean);
  }
  /**
   * Reduce fn that joins neighboring strings
   *
   * Given an array of strings, returns a new array
   * where all neighboring strings have been joined.
   *
   * #### Example:
   * ```js
   * let arr = ["foo", "bar", 1, "baz", "", "qux" ];
   * arr.reduce(joinNeighborsR, []) // ["foobar", 1, "bazqux" ]
   * ```
   */
  function joinNeighborsR(acc, str) {
    if (isString(tail(acc)) && isString(str))
      return acc.slice(0, -1).concat(tail(acc) + str);

    return pushR(acc, str);
  }

  /**
   * # Transition tracing (debug)
   *
   * Enable transition tracing to print transition information to the console,
   * in order to help debug your application.
   * Tracing logs detailed information about each Transition to your console.
   *
   * To enable tracing, import the [[Trace]] singleton and enable one or more categories.
   *
   * ### ES6
   * ```js
   * import {trace} from "@uirouter/core/index";
   * trace.enable(1, 5); // TRANSITION and VIEWCONFIG
   * ```
   *
   * ### CJS
   * ```js
   * let trace = require("@uirouter/core").trace;
   * trace.enable("TRANSITION", "VIEWCONFIG");
   * ```
   *
   * ### Globals
   * ```js
   * let trace = window["@uirouter/core"].trace;
   * trace.enable(); // Trace everything (very verbose)
   * ```
   *
   * ### Angular 1:
   * ```js
   * app.run($trace => $trace.enable());
   * ```
   *
   * @packageDocumentation
   */

  const MAX_PAD_LENGTH = 30;

  function ngViewString(ngView) {
    if (!ngView) return "ng-view (defunct)";
    const state = ngView.creationContext
      ? ngView.creationContext.name || "(root)"
      : "(none)";

    return `[ng-view#${ngView.id}:${ngView.fqn} (${ngView.name}@${state})]`;
  }

  const viewConfigString = (viewConfig) => {
    const view = viewConfig.viewDecl;

    const state = view.$context.name || "(root)";

    return `[View#${viewConfig.$id} from '${state}' state]: target ng-view: '${view.$ngViewName}@${view.$ngViewContextAnchor}'`;
  };

  function normalizedCat(input) {
    return isNumber(input) ? Category[input] : Category[Category[input]];
  }
  /**
   * Trace categories Enum
   *
   * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]
   *
   * `trace.enable(Category.TRANSITION)`
   *
   * These can also be provided using a matching string, or position ordinal
   *
   * `trace.enable("TRANSITION")`
   *
   * `trace.enable(1)`
   */

  /**
   * @enum {number}
   */
  const Category = {
    _RESOLVE: 0,
    _TRANSITION: 1,
    _HOOK: 2,
    _UIVIEW: 3,
    _VIEWCONFIG: 4,
  };

  const _tid = parse("$id");

  const _rid = parse("router.$id");

  const transLbl = (trans) => `Transition #${_tid(trans)}-${_rid(trans)}`;

  /**
   * Prints ng-router Transition trace information to the console.
   */
  class Trace {
    constructor() {
      this._enabled = {};
      this.approximateDigests = 0;
      this.$logger = window.angular?.$injector?.get($injectTokens._log);
    }

    _set(enabled, categories) {
      if (!categories.length) {
        categories = keys(Category)
          .map((k) => parseInt(k, 10))
          .filter((k) => !isNaN(k))
          .map((key) => Category[key]);
      }
      categories
        .map(normalizedCat)
        .forEach((category) => (this._enabled[category] = enabled));
    }

    enable(...categories) {
      this._set(true, categories);
    }

    disable(...categories) {
      this._set(false, categories);
    }

    /**
     * Retrieves the enabled stateus of a [[Category]]
     *
     * ```js
     * trace.enabled("VIEWCONFIG"); // true or false
     * ```
     *
     * @returns boolean true if the category is enabled
     */
    enabled(category) {
      return !!this._enabled[normalizedCat(category)];
    }

    /** @internal called by ng-router code */
    traceTransitionStart(trans) {
      if (!this.enabled(Category._TRANSITION)) return;
      this.$logger.log(`${transLbl(trans)}: Started  -> ${stringify(trans)}`);
    }

    /** @internal called by ng-router code */
    traceTransitionIgnored(trans) {
      if (!this.enabled(Category._TRANSITION)) return;
      this.$logger.log(`${transLbl(trans)}: Ignored  <> ${stringify(trans)}`);
    }

    /** @internal called by ng-router code */
    traceHookInvocation(step, trans, options) {
      if (!this.enabled(Category._HOOK)) return;
      const event = parse("traceData.hookType")(options) || "internal",
        context =
          parse("traceData.context.state.name")(options) ||
          parse("traceData.context")(options) ||
          "unknown",
        name = functionToString(step.registeredHook.callback);

      this.$logger.log(
        `${transLbl(trans)}:   Hook -> ${event} context: ${context}, ${maxLength(200, name)}`,
      );
    }

    /** @internal called by ng-router code */
    traceHookResult(hookResult, trans) {
      if (!this.enabled(Category._HOOK)) return;
      this.$logger.log(
        `${transLbl(trans)}:   <- Hook returned: ${maxLength(200, stringify(hookResult))}`,
      );
    }

    /** @internal called by ng-router code */
    traceResolvePath(path, when, trans) {
      if (!this.enabled(Category._RESOLVE)) return;
      this.$logger.log(`${transLbl(trans)}:         Resolving ${path} (${when})`);
    }

    /** @internal called by ng-router code */
    traceResolvableResolved(resolvable, trans) {
      if (!this.enabled(Category._RESOLVE)) return;
      this.$logger.log(
        `${transLbl(trans)}:               <- Resolved  ${resolvable} to: ${maxLength(200, stringify(resolvable.data))}`,
      );
    }

    /** @internal called by ng-router code */
    traceError(reason, trans) {
      if (!this.enabled(Category._TRANSITION)) return;
      this.$logger.log(
        `${transLbl(trans)}: <- Rejected ${stringify(trans)}, reason: ${reason}`,
      );
    }

    /** @internal called by ng-router code */
    traceSuccess(finalState, trans) {
      if (!this.enabled(Category._TRANSITION)) return;
      this.$logger.log(
        `${transLbl(trans)}: <- Success  ${stringify(trans)}, final state: ${finalState.name}`,
      );
    }

    /** @internal called by ng-router code */
    traceUIViewEvent(event, viewData, extra = "") {
      if (!this.enabled(Category._UIVIEW)) return;
      this.$logger.log(
        `ng-view: ${padString(MAX_PAD_LENGTH, event)} ${ngViewString(viewData)}${extra}`,
      );
    }

    /** @internal called by ng-router code */
    traceUIViewConfigUpdated(viewData, context) {
      if (!this.enabled(Category._UIVIEW)) return;
      this.traceUIViewEvent(
        "Updating",
        viewData,
        ` with ViewConfig from context='${context}'`,
      );
    }

    /** @internal called by ng-router code */
    traceUIViewFill(viewData, html) {
      if (!this.enabled(Category._UIVIEW)) return;
      this.traceUIViewEvent("Fill", viewData, ` with: ${maxLength(200, html)}`);
    }

    /** @internal called by ng-router code */
    traceViewSync(pairs) {
      if (!this.enabled(Category._VIEWCONFIG)) return;
      const uivheader = "uiview component fqn";

      const cfgheader = "view config state (view name)";

      const mapping = pairs
        .map(({ ngView, viewConfig }) => {
          const uiv = ngView && ngView.fqn;

          const cfg =
            viewConfig &&
            `${viewConfig.viewDecl.$context.name}: (${viewConfig.viewDecl.$name})`;

          return { [uivheader]: uiv, [cfgheader]: cfg };
        })
        .sort((a, b) => (a[uivheader] || "").localeCompare(b[uivheader] || ""));

      this.$logger.table(mapping);
    }

    /** @internal called by ng-router code */
    traceViewServiceEvent(event, viewConfig) {
      if (!this.enabled(Category._VIEWCONFIG)) return;
      this.$logger.log(`VIEWCONFIG: ${event} ${viewConfigString(viewConfig)}`);
    }

    /** @internal called by ng-router code */
    traceViewServiceUIViewEvent(event, viewData) {
      if (!this.enabled(Category._VIEWCONFIG)) return;
      this.$logger.log(`VIEWCONFIG: ${event} ${ngViewString(viewData)}`);
    }
  }
  /**
   * The [[Trace]] singleton
   *
   * #### Example:
   * ```js
   * import {trace} from "@uirouter/core/index";
   * trace.enable(1, 5);
   * ```
   */
  const trace = new Trace();

  // TODO: explicitly make this user configurable
  const defaultResolvePolicy = {
    when: "LAZY",
    async: "WAIT",
  };
  /**
   * The basic building block for the resolve system.
   *
   * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),
   * and the unwrapped-when-complete (.data) result of the resolveFn.
   *
   * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the
   * resolveFn) and returns the resulting promise.
   *
   * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first
   * parameter to those fns.
   */
  class Resolvable {
    constructor(arg1, resolveFn, deps, policy, data) {
      this.resolved = false;
      this.promise = undefined;

      if (arg1 instanceof Resolvable) {
        Object.assign(this, arg1);
      } else if (isFunction(resolveFn)) {
        assert(!isNullOrUndefined(arg1), "token argument is required");
        this.token = arg1;
        this.policy = policy;
        this.resolveFn = resolveFn;
        this.deps = deps || [];
        this.data = data;
        this.resolved = data !== undefined;
        this.promise = this.resolved ? Promise.resolve(this.data) : undefined;
      } else if (
        isObject(arg1) &&
        arg1.token &&
        (hasOwn(arg1, "resolveFn") || hasOwn(arg1, "data"))
      ) {
        this.token = arg1.token;
        this.resolveFn = arg1.resolveFn;
        this.deps = arg1.deps;
        this.policy = arg1.policy;
        this.data = arg1.data;
      }
    }

    getPolicy(state) {
      const thisPolicy = this.policy || {};

      const statePolicy = (state && state.resolvePolicy) || {};

      return {
        when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,
        async:
          thisPolicy.async || statePolicy.async || defaultResolvePolicy.async,
      };
    }

    /**
     * Asynchronously resolve this Resolvable's data
     *
     * Given a ResolveContext that this Resolvable is found in:
     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function
     * and update the Resolvable's state
     */
    resolve(resolveContext, trans) {
      // Gets all dependencies from ResolveContext and wait for them to be resolved
      const getResolvableDependencies = () =>
        Promise.all(
          resolveContext
            .getDependencies(this)
            .map((resolvable) => resolvable.get(resolveContext, trans)),
        );

      // Invokes the resolve function passing the resolved dependencies as arguments
      const invokeResolveFn = (resolvedDeps) =>
        this.resolveFn.apply(null, resolvedDeps);

      const node = resolveContext.findNode(this);

      const state = node && node.state;

      const asyncPolicy = this.getPolicy(state).async;

      const customAsyncPolicy = isFunction(asyncPolicy) ? asyncPolicy : (x) => x;

      // After the final value has been resolved, update the state of the Resolvable
      const applyResolvedValue = (resolvedValue) => {
        this.data = resolvedValue;
        this.resolved = true;
        this.resolveFn = null;
        trace.traceResolvableResolved(this, trans);

        return this.data;
      };

      // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.
      this.promise = Promise.resolve()
        .then(getResolvableDependencies)
        .then(invokeResolveFn)
        .then(customAsyncPolicy)
        .then(applyResolvedValue);

      return this.promise;
    }

    /**
     * Gets a promise for this Resolvable's data.
     *
     * Fetches the data and returns a promise.
     * Returns the existing promise if it has already been fetched once.
     */
    get(resolveContext, trans) {
      return this.promise || this.resolve(resolveContext, trans);
    }

    toString() {
      return `Resolvable(token: ${stringify(this.token)}, requires: [${this.deps.map(stringify)}])`;
    }

    clone() {
      return new Resolvable(this);
    }
  }
  Resolvable.fromData = (token, data) =>
    new Resolvable(token, () => data, null, null, data);

  /**
   * Encapsulate the target (destination) state/params/options of a [[Transition]].
   *
   * This class is frequently used to redirect a transition to a new destination.
   *
   * See:
   *
   * - [[HookResult]]
   * - [[TransitionHookFn]]
   * - [[TransitionService.onStart]]
   *
   * To create a `TargetState`, use [[StateService.target]].
   *
   * ---
   *
   * This class wraps:
   *
   * 1) an identifier for a state
   * 2) a set of parameters
   * 3) and transition options
   * 4) the registered state object (the [[StateDeclaration]])
   *
   * Many ng-router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can
   * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).
   * The `TargetState` class normalizes those options.
   *
   * A `TargetState` may be valid (the state being targeted exists in the registry)
   * or invalid (the state being targeted is not registered).
   */
  class TargetState {
    /**
     * The TargetState constructor
     *
     * Note: Do not construct a `TargetState` manually.
     * To create a `TargetState`, use the [[StateService.target]] factory method.
     *
     * @param _stateRegistry The StateRegistry to use to look up the _definition
     * @param _identifier An identifier for a state.
     *    Either a fully-qualified state name, or the object used to define the state.
     * @param _params Parameters for the target state
     * @param _options Transition options.
     *
     * @internal
     */
    constructor(_stateRegistry, _identifier, _params, _options) {
      this._stateRegistry = _stateRegistry;
      this._identifier = _identifier;
      this._identifier = _identifier;
      this._params = Object.assign({}, _params || {});
      this._options = Object.assign({}, _options || {});
      this._definition = _stateRegistry.matcher.find(
        _identifier,
        this._options.relative,
      );
    }

    /** The name of the state this object targets */
    name() {
      return (this._definition && this._definition.name) || this._identifier;
    }

    /** The identifier used when creating this TargetState */
    identifier() {
      return this._identifier;
    }

    /** The target parameter values */
    params() {
      return this._params;
    }

    /** The internal state object (if it was found) */
    $state() {
      return this._definition;
    }

    /** The internal state declaration (if it was found) */
    state() {
      return this._definition && this._definition.self;
    }

    /** The target options */
    options() {
      return this._options;
    }

    /** True if the target state was found */
    exists() {
      return !!(this._definition && this._definition.self);
    }

    /** True if the object is valid */
    valid() {
      return !this.error();
    }

    /** If the object is invalid, returns the reason why */
    error() {
      const base = this.options().relative;

      if (!this._definition && !!base) {
        const stateName = base.name ? base.name : base;

        return `Could not resolve '${this.name()}' from state '${stateName}'`;
      }

      if (!this._definition) return `No such state '${this.name()}'`;

      if (!this._definition.self)
        return `State '${this.name()}' has an invalid definition`;

      return undefined;
    }

    toString() {
      return `'${this.name()}'${stringify(this.params())}`;
    }

    /**
     * Returns a copy of this TargetState which targets a different state.
     * The new TargetState has the same parameter values and transition options.
     *
     * @param state The new state that should be targeted
     */
    withState(state) {
      return new TargetState(
        this._stateRegistry,
        state,
        this._params,
        this._options,
      );
    }

    /**
     * Returns a copy of this TargetState, using the specified parameter values.
     *
     * @param params the new parameter values to use
     * @param replace When false (default) the new parameter values will be merged with the current values.
     *                When true the parameter values will be used instead of the current values.
     */
    withParams(params, replace = false) {
      const newParams = replace
        ? params
        : Object.assign({}, this._params, params);

      return new TargetState(
        this._stateRegistry,
        this._identifier,
        newParams,
        this._options,
      );
    }

    /**
     * Returns a copy of this TargetState, using the specified Transition Options.
     *
     * @param options the new options to use
     * @param replace When false (default) the new options will be merged with the current options.
     *                When true the options will be used instead of the current options.
     */
    withOptions(options, replace = false) {
      const newOpts = replace
        ? options
        : Object.assign({}, this._options, options);

      return new TargetState(
        this._stateRegistry,
        this._identifier,
        this._params,
        newOpts,
      );
    }
  }
  /** Returns true if the object has a state property that might be a state or state name */
  TargetState.isDef = (obj) => {
    return (
      obj &&
      obj.state &&
      (isString(obj.state) || (isObject(obj.state) && isString(obj.state.name)))
    );
  };

  const isShorthand = (cfg) =>
    ["value", "type", "squash", "array", "dynamic"].filter(
      Object.prototype.hasOwnProperty.bind(cfg || {}),
    ).length === 0;

  /**
   * @internal
   * @enum {number}
   */
  const DefType = {
    _PATH: 0,
    _SEARCH: 1,
    _CONFIG: 2,
  };

  function getParamDeclaration(paramName, location, state) {
    const noReloadOnSearch =
      (state.reloadOnSearch === false && location === DefType._SEARCH) ||
      undefined;

    const dynamic = find([state.dynamic, noReloadOnSearch], isDefined);

    const defaultConfig = isDefined(dynamic) ? { dynamic } : {};

    const paramConfig = unwrapShorthand(
      state && state.params && state.params[paramName],
    );

    return Object.assign(defaultConfig, paramConfig);
  }

  function unwrapShorthand(cfg) {
    cfg = isShorthand(cfg) ? { value: cfg } : cfg;
    getStaticDefaultValue.__cacheable = true;
    function getStaticDefaultValue() {
      return cfg.value;
    }
    const $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;

    return Object.assign(cfg, { $$fn });
  }

  function getType(cfg, urlType, location, id, paramTypes) {
    if (cfg.type && urlType && urlType.name !== "string")
      throw new Error(`Param '${id}' has two type configurations.`);

    if (
      cfg.type &&
      urlType &&
      urlType.name === "string" &&
      paramTypes.type(cfg.type)
    )
      return paramTypes.type(cfg.type);

    if (urlType) return urlType;

    if (!cfg.type) {
      const type =
        location === DefType._CONFIG
          ? "any"
          : location === DefType._PATH
            ? "path"
            : location === DefType._SEARCH
              ? "query"
              : "string";

      return paramTypes.type(type);
    }

    return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);
  }

  /** returns false, true, or the squash value to indicate the "default parameter url squash policy". */
  function getSquashPolicy(config, isOptional, defaultPolicy) {
    const { squash } = config;

    if (!isOptional || squash === false) return false;

    if (!isDefined(squash) || isNullOrUndefined(squash)) return defaultPolicy;

    if (squash === true || isString(squash)) return squash;
    throw new Error(
      `Invalid squash policy: '${squash}'. Valid policies: false, true, or arbitrary string`,
    );
  }

  function getReplace(config, arrayMode, isOptional, squash) {
    const defaultPolicy = [
      { from: "", to: isOptional || arrayMode ? undefined : "" },
      { from: null, to: isOptional || arrayMode ? undefined : "" },
    ];

    const replace = isArray(config.replace) ? config.replace : [];

    if (isString(squash)) replace.push({ from: squash, to: undefined });
    const configuredKeys = map(replace, (x) => x.from);

    return filter(
      defaultPolicy,
      (item) => configuredKeys.indexOf(item.from) === -1,
    ).concat(replace);
  }

  class Param {
    /**
     *
     * @param {*} id
     * @param {*} type
     * @param {DefType} location
     * @param {import("../url/url-config.js").UrlConfigProvider} urlConfig
     * @param {*} state
     */
    constructor(id, type, location, urlConfig, state) {
      const config = getParamDeclaration(id, location, state);

      type = getType(config, type, location, id, urlConfig.paramTypes);
      const arrayMode = getArrayMode();

      type = arrayMode
        ? type.$asArray(arrayMode, location === DefType._SEARCH)
        : type;
      const isOptional =
        config.value !== undefined || location === DefType._SEARCH;

      const dynamic = isDefined(config.dynamic)
        ? !!config.dynamic
        : !!type.dynamic;

      const raw = isDefined(config.raw) ? !!config.raw : !!type.raw;

      const squash = getSquashPolicy(
        config,
        isOptional,
        urlConfig.defaultSquashPolicy(),
      );

      const replace = getReplace(config, arrayMode, isOptional, squash);

      const inherit = isDefined(config.inherit)
        ? !!config.inherit
        : !!type.inherit;

      // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
      function getArrayMode() {
        const arrayDefaults = {
          array: location === DefType._SEARCH ? "auto" : false,
        };

        const arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};

        return Object.assign(arrayDefaults, arrayParamNomenclature, config).array;
      }
      this.isOptional = isOptional;
      this.type = type;
      this.location = location;
      this.id = id;
      this.dynamic = dynamic;
      this.raw = raw;
      this.squash = squash;
      this.replace = replace;
      this.inherit = inherit;
      this.array = arrayMode;
      this.config = config;
    }

    isDefaultValue(value) {
      return this.isOptional && this.type.equals(this.value(), value);
    }

    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    value(value) {
      /**
       * [Internal] Get the default value of a parameter, which may be an injectable function.
       */
      const getDefaultValue = () => {
        if (this._defaultValueCache) return this._defaultValueCache.defaultValue;

        if (!window.angular.$injector)
          throw new Error(
            "Injectable functions cannot be called at configuration time",
          );
        const defaultValue = window.angular.$injector.invoke(this.config.$$fn);

        if (
          defaultValue !== null &&
          defaultValue !== undefined &&
          !this.type.is(defaultValue)
        )
          throw new Error(
            `Default value (${defaultValue}) for parameter '${this.id}' is not an instance of ParamType (${this.type.name})`,
          );

        if (this.config.$$fn.__cacheable) {
          this._defaultValueCache = { defaultValue };
        }

        return defaultValue;
      };

      const replaceSpecialValues = (val) => {
        for (const tuple of this.replace) {
          if (tuple.from === val) return tuple.to;
        }

        return val;
      };

      value = replaceSpecialValues(value);

      return isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
    }

    isSearch() {
      return this.location === DefType._SEARCH;
    }

    validates(value) {
      // There was no parameter value, but the param is optional
      if ((isUndefined(value) || value === null) && this.isOptional) return true;
      // The value was not of the correct ParamType, and could not be decoded to the correct ParamType
      const normalized = this.type.$normalize(value);

      if (!this.type.is(normalized)) return false;
      // The value was of the correct type, but when encoded, did not match the ParamType's regexp
      const encoded = normalized; // this.type.encode(normalized);

      return !(isString(encoded) && !this.type.pattern.exec(encoded));
    }

    toString() {
      return `{Param:${this.id} ${this.type} squash: '${this.squash}' optional: ${this.isOptional}}`;
    }

    static values(params, values = {}) {
      const paramValues = {};

      for (const param of params) {
        paramValues[param.id] = param.value(values[param.id]);
      }

      return paramValues;
    }

    /**
     * Finds [[Param]] objects which have different param values
     *
     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects
     *
     * @param params: The list of Param objects to filter
     * @param values1: The first set of parameter values
     * @param values2: the second set of parameter values
     *
     * @returns any Param objects whose values were different between values1 and values2
     */
    static changed(params, values1 = {}, values2 = {}) {
      return params.filter(
        (param) => !param.type.equals(values1[param.id], values2[param.id]),
      );
    }

    /**
     * Checks if two param value objects are equal (for a set of [[Param]] objects)
     *
     * @param params The list of [[Param]] objects to check
     * @param values1 The first set of param values
     * @param values2 The second set of param values
     *
     * @returns true if the param values in values1 and values2 are equal
     */
    static equals(params, values1 = {}, values2 = {}) {
      return Param.changed(params, values1, values2).length === 0;
    }

    /** Returns true if a the parameter values are valid, according to the Param definitions */
    static validates(params, values = {}) {
      return params
        .map((param) => param.validates(values[param.id]))
        .reduce(allTrueR, true);
    }
  }

  /**
   * A node in a [[TreeChanges]] path
   *
   * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.
   * Each PathNode corresponds to a state being entered, exited, or retained.
   * The stateful information includes parameter values and resolve data.
   */
  class PathNode {
    constructor(stateOrNode) {
      if (stateOrNode instanceof PathNode) {
        const node = stateOrNode;

        this.state = node.state;
        this.paramSchema = node.paramSchema.slice();
        this.paramValues = Object.assign({}, node.paramValues);
        this.resolvables = node.resolvables.slice();
        this.views = node.views && node.views.slice();
      } else {
        const state = stateOrNode;

        this.state = state;
        this.paramSchema = state.parameters({ inherit: false });
        this.paramValues = {};

        this.resolvables = state.resolvables.map((res) => res.clone());
      }
    }

    clone() {
      return new PathNode(this);
    }

    /** Sets [[paramValues]] for the node, from the values of an object hash */
    applyRawParams(params) {
      const getParamVal = (paramDef) => [
        paramDef.id,
        paramDef.value(params[paramDef.id]),
      ];

      this.paramValues = this.paramSchema.reduce(
        (memo, pDef) => applyPairs(memo, getParamVal(pDef)),
        {},
      );

      return this;
    }

    /** Gets a specific [[Param]] metadata that belongs to the node */
    parameter(name) {
      return find(this.paramSchema, propEq("id", name));
    }

    /**
     * @returns true if the state and parameter values for another PathNode are
     * equal to the state and param values for this PathNode
     */
    equals(node, paramsFn) {
      const diff = this.diff(node, paramsFn);

      return diff && diff.length === 0;
    }

    /**
     * Finds Params with different parameter values on another PathNode.
     *
     * Given another node (of the same state), finds the parameter values which differ.
     * Returns the [[Param]] (schema objects) whose parameter values differ.
     *
     * Given another node for a different state, returns `false`
     *
     * @param node The node to compare to
     * @param paramsFn A function that returns which parameters should be compared.
     * @returns The [[Param]]s which differ, or null if the two nodes are for different states
     */
    diff(node, paramsFn) {
      if (this.state !== node.state) return false;
      const params = paramsFn ? paramsFn(this) : this.paramSchema;

      return Param.changed(params, this.paramValues, node.paramValues);
    }
  }

  /**
   * This class contains functions which convert TargetStates, Nodes and paths from one type to another.
   */
  class PathUtils {
    static buildPath(targetState) {
      const toParams = targetState.params();

      return targetState
        .$state()
        .path.map((state) => new PathNode(state).applyRawParams(toParams));
    }

    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */
    static buildToPath(fromPath, targetState) {
      const toPath = PathUtils.buildPath(targetState);

      if (targetState.options().inherit) {
        return PathUtils.inheritParams(
          fromPath,
          toPath,
          Object.keys(targetState.params()),
        );
      }

      return toPath;
    }

    /**
     * Creates ViewConfig objects and adds to nodes.
     *
     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state
     */
    static applyViewConfigs($view, path, states) {
      // Only apply the viewConfigs to the nodes for the given states
      path
        .filter((node) => states.includes(node.state))
        .forEach((node) => {
          const viewDecls = Object.values(node.state.views || {});

          const subPath = PathUtils.subPath(path, (x) => x === node);

          const viewConfigs = viewDecls.map((view) => {
            return $view._createViewConfig(subPath, view);
          });

          node.views = viewConfigs.reduce(unnestR, []);
        });
    }

    /**
     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath
     *
     * For a parameter in a node to be inherited from the from path:
     * - The toPath's node must have a matching node in the fromPath (by state).
     * - The parameter name must not be found in the toKeys parameter array.
     *
     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some
     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,
     * it is not inherited from the fromPath.
     */
    static inheritParams(fromPath, toPath, toKeys = []) {
      function nodeParamVals(path, state) {
        /** @type {PathNode} */
        const node = find(path, propEq("state", state));

        return Object.assign({}, node && node.paramValues);
      }
      const noInherit = fromPath
        .map((node) => node.paramSchema)
        .reduce(unnestR, [])
        .filter((param) => !param.inherit)
        .map((x) => x.id);

      /**
       * Given an [[PathNode]] "toNode", return a new [[PathNode]] with param values inherited from the
       * matching node in fromPath.  Only inherit keys that aren't found in "toKeys" from the node in "fromPath""
       */
      function makeInheritedParamsNode(toNode) {
        // All param values for the node (may include default key/vals, when key was not found in toParams)
        let toParamVals = Object.assign({}, toNode && toNode.paramValues);

        // limited to only those keys found in toParams
        const incomingParamVals = pick(toParamVals, toKeys);

        toParamVals = omit(toParamVals, toKeys);
        const fromParamVals = omit(
          nodeParamVals(fromPath, toNode.state) || {},
          noInherit,
        );

        // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals
        const ownParamVals = Object.assign(
          toParamVals,
          fromParamVals,
          incomingParamVals,
        );

        return new PathNode(toNode.state).applyRawParams(ownParamVals);
      }

      // The param keys specified by the incoming toParams
      return toPath.map(makeInheritedParamsNode);
    }

    /**
     * Computes the tree changes (entering, exiting) between a fromPath and toPath.
     * @param {PathNode[]} fromPath
     * @param {PathNode[]} toPath
     * @param {boolean} [reloadState]
     * @returns {import("../transition/interface.ts").TreeChanges}
     */
    static treeChanges(fromPath, toPath, reloadState) {
      const max = Math.min(fromPath.length, toPath.length);

      let keep = 0;

      const nodesMatch = (node1, node2) =>
        node1.equals(node2, PathUtils.nonDynamicParams);

      while (
        keep < max &&
        fromPath[keep].state !== reloadState &&
        nodesMatch(fromPath[keep], toPath[keep])
      ) {
        keep++;
      }
      /** Given a retained node, return a new node which uses the to node's param values */
      function applyToParams(retainedNode, idx) {
        const cloned = retainedNode.clone();

        cloned.paramValues = toPath[idx].paramValues;

        return cloned;
      }

      const from = fromPath;

      const retained = from.slice(0, keep);

      const exiting = from.slice(keep);

      // Create a new retained path (with shallow copies of nodes) which have the params of the toPath mapped
      const retainedWithToParams = retained.map(applyToParams);

      const entering = toPath.slice(keep);

      const to = retainedWithToParams.concat(entering);

      return { from, to, retained, retainedWithToParams, exiting, entering };
    }

    /**
     * Returns a new path which is: the subpath of the first path which matches the second path.
     *
     * The new path starts from root and contains any nodes that match the nodes in the second path.
     * It stops before the first non-matching node.
     *
     * Nodes are compared using their state property and their parameter values.
     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.
     *
     * @param pathA the first path
     * @param pathB the second path
     * @param paramsFn a function which returns the parameters to consider when comparing
     *
     * @returns an array of PathNodes from the first path which match the nodes in the second path
     */
    static matching(pathA, pathB, paramsFn) {
      let done = false;

      const tuples = arrayTuples(pathA, pathB);

      return tuples.reduce((matching, [nodeA, nodeB]) => {
        done = done || !nodeA.equals(nodeB, paramsFn);

        return done ? matching : matching.concat(nodeA);
      }, []);
    }

    /**
     * Returns true if two paths are identical.
     *
     * @param pathA
     * @param pathB
     * @param paramsFn a function which returns the parameters to consider when comparing
     * @returns true if the the states and parameter values for both paths are identical
     */
    static equals(pathA, pathB, paramsFn) {
      return (
        pathA.length === pathB.length &&
        PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length
      );
    }

    /**
     * Return a subpath of a path, which stops at the first matching node
     *
     * Given an array of nodes, returns a subset of the array starting from the first node,
     * stopping when the first node matches the predicate.
     *
     * @param path a path of [[PathNode]]s
     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s
     * @returns a subpath up to the matching node, or undefined if no match is found
     */
    static subPath(path, predicate) {
      const node = find(path, predicate);

      const elementIdx = path.indexOf(node);

      return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);
    }

    static nonDynamicParams(node) {
      return node.state
        .parameters({ inherit: false })
        .filter((param) => !param.dynamic);
    }

    /** Gets the raw parameter values from a path */
    static paramValues(path) {
      return path.reduce((acc, node) => Object.assign(acc, node.paramValues), {});
    }
  }

  /** Given a PathNode[], create an TargetState
   * @param {import("../state/state-registry.js").StateRegistryProvider} registry
   * @param {Array<PathNode>} path
   * @returns
   */
  function makeTargetState(registry, path) {
    return new TargetState(
      registry,
      path.at(-1).state,
      path
        .map((x) => x.paramValues)
        .reduce((acc, obj) => ({ ...acc, ...obj }), {}),
      {},
    );
  }

  const resolvePolicies = {
    when: {
      LAZY: "LAZY",
      EAGER: "EAGER",
    }};

  const ALL_WHENS = [resolvePolicies.when.EAGER, resolvePolicies.when.LAZY];

  const EAGER_WHENS = [resolvePolicies.when.EAGER];

  /**
   * Encapsulates Dependency Injection for a path of nodes
   *
   * ng-router states are organized as a tree.
   * A nested state has a path of ancestors to the root of the tree.
   * When a state is being activated, each element in the path is wrapped as a [[PathNode]].
   * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.
   *
   * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.
   */
  class ResolveContext {
    constructor(_path) {
      this._path = _path;
    }

    /** Gets all the tokens found in the resolve context, de-duplicated */
    getTokens() {
      return this._path
        .reduce(
          (acc, node) =>
            acc.concat(node.resolvables.map((resolve) => resolve.token)),
          [],
        )
        .reduce(uniqR, []);
    }

    /**
     * Gets the Resolvable that matches the token
     *
     * Gets the last Resolvable that matches the token in this context, or undefined.
     * Throws an error if it doesn't exist in the ResolveContext
     */
    getResolvable(token) {
      const matching = this._path
        .map((node) => node.resolvables)
        .reduce(unnestR, [])
        .filter((resolve) => resolve.token === token);

      return tail(matching);
    }

    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */
    getPolicy(resolvable) {
      const node = this.findNode(resolvable);

      return resolvable.getPolicy(node);
    }

    /**
     * Returns a ResolveContext that includes a portion of this one
     *
     * Given a state, this method creates a new ResolveContext from this one.
     * The new context starts at the first node (root) and stops at the node for the `state` parameter.
     *
     * #### Why
     *
     * When a transition is created, the nodes in the "To Path" are injected from a ResolveContext.
     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.
     * The "To State" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).
     * This method is used to create a narrower context when injecting ancestor nodes.
     *
     * @example
     * `let ABCD = new ResolveContext([A, B, C, D]);`
     *
     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:
     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.
     * However, `B` should only be able to access resolvables from `A`, `B`.
     *
     * When resolving for the `B` node, first take the full "To Path" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.
     * `let AB = ABCD.subcontext(a)`
     */
    subContext(state) {
      return new ResolveContext(
        PathUtils.subPath(this._path, (node) => node.state === state),
      );
    }

    /**
     * Adds Resolvables to the node that matches the state
     *
     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).
     * The resolvable is added to the node matching the `state` parameter.
     *
     * These new resolvables are not automatically fetched.
     * The calling code should either fetch them, fetch something that depends on them,
     * or rely on [[resolvePath]] being called when some state is being entered.
     *
     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.
     *
     * @param {Resolvable[]} newResolvables the new Resolvables
     * @param state Used to find the node to put the resolvable on
     */
    addResolvables(newResolvables, state) {
      /** @type {import('../path/path-node').PathNode} */
      const node = find(this._path, propEq("state", state));

      const keys = newResolvables.map((resolve) => resolve.token);

      node.resolvables = node.resolvables
        .filter((resolve) => keys.indexOf(resolve.token) === -1)
        .concat(newResolvables);
    }

    /**
     * Returns a promise for an array of resolved path Element promises
     *
     * @param {string} when
     * @param trans
     * @returns {Promise<any>|any}
     */
    resolvePath(when = "LAZY", trans) {
      // This option determines which 'when' policy Resolvables we are about to fetch.
      const whenOption = ALL_WHENS.includes(when) ? when : "LAZY";

      // If the caller specified EAGER, only the EAGER Resolvables are fetched.
      // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`
      const matchedWhens =
        whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;

      // get the subpath to the state argument, if provided
      trace.traceResolvePath(this._path, when, trans);
      const matchesPolicy = (acceptedVals, whenOrAsync) => (resolvable) =>
        acceptedVals.includes(this.getPolicy(resolvable)[whenOrAsync]);

      // Trigger all the (matching) Resolvables in the path
      // Reduce all the "WAIT" Resolvables into an array
      const promises = this._path.reduce((acc, node) => {
        const nodeResolvables = node.resolvables.filter(
          matchesPolicy(matchedWhens, "when"),
        );

        const nowait = nodeResolvables.filter(matchesPolicy(["NOWAIT"], "async"));

        const wait = nodeResolvables.filter(
          (x) => !matchesPolicy(["NOWAIT"], "async")(x),
        );

        // For the matching Resolvables, start their async fetch process.
        const subContext = this.subContext(node.state);

        const getResult = (resolve) =>
          resolve
            .get(subContext, trans)
            // Return a tuple that includes the Resolvable's token
            .then((value) => ({ token: resolve.token, value }));

        nowait.forEach(getResult);

        return acc.concat(wait.map(getResult));
      }, []);

      // Wait for all the "WAIT" resolvables
      return Promise.all(promises);
    }

    findNode(resolvable) {
      return find(this._path, (node) => node.resolvables.includes(resolvable));
    }

    /**
     * Gets the async dependencies of a Resolvable
     *
     * Given a Resolvable, returns its dependencies as a Resolvable[]
     * @param {Resolvable} resolvable
     * @returns {Resolvable[]}
     */
    getDependencies(resolvable) {
      const node = this.findNode(resolvable);

      // Find which other resolvables are "visible" to the `resolvable` argument
      // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)
      const subPath =
        PathUtils.subPath(this._path, (x) => x === node) || this._path;

      const availableResolvables = subPath
        .reduce((acc, _node) => acc.concat(_node.resolvables), []) // all of subpath's resolvables
        .filter((res) => res !== resolvable); // filter out the `resolvable` argument

      return resolvable.deps.map((token) => {
        const matching = availableResolvables.filter(
          (resolve) => resolve.token === token,
        );

        if (matching.length) return tail(matching);
        const fromInjector = window.angular.$injector.get(token);

        if (isUndefined(fromInjector)) {
          throw new Error(
            `Could not find Dependency Injection token: ${stringify(token)}`,
          );
        }

        return new Resolvable(token, () => fromInjector, [], fromInjector);
      });
    }
  }

  function getViewConfigFactory() {
    let templateFactory = null;

    return (path, view) => {
      templateFactory =
        templateFactory || window.angular.$injector.get("$templateFactory"); // TODO: remove static injector

      return new ViewConfig(path, view, templateFactory);
    };
  }

  const hasAnyKey = (keys, obj) =>
    keys.reduce((acc, key) => acc || isDefined(obj[key]), false);

  /**
   * This is a [[StateBuilder.builder]] function for angular1 `views`.
   *
   * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
   * handles the `views` property with logic specific to @uirouter/angularjs (ng1).
   *
   * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object
   * and applies the state-level configuration to a view named `$default`.
   *
   */
  function ng1ViewsBuilder(state) {
    // Do not process root state
    if (!state.parent) return {};
    const tplKeys = [
        "templateProvider",
        "templateUrl",
        "template",
        "notify",
        "async",
      ],
      ctrlKeys = [
        "controller",
        "controllerProvider",
        "controllerAs",
        "resolveAs",
      ],
      compKeys = ["component", "bindings", "componentProvider"],
      nonCompKeys = tplKeys.concat(ctrlKeys),
      allViewKeys = compKeys.concat(nonCompKeys);

    // Do not allow a state to have both state-level props and also a `views: {}` property.
    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.
    // However, the `$default` approach should not be mixed with a separate `views: ` block.
    if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) {
      throw new Error(
        `State '${state.name}' has a 'views' object. ` +
          `It cannot also have "view properties" at the state level.  ` +
          `Move the following properties into a view (in the 'views' object): ` +
          ` ${allViewKeys.filter((key) => isDefined(state[key])).join(", ")}`,
      );
    }
    const views = {},
      viewsObject = state.views || { $default: pick(state, allViewKeys) };

    entries(viewsObject).forEach(([name, config]) => {
      // Account for views: { "": { template... } }
      name = name || "$default";

      // Account for views: { header: "headerComponent" }
      if (isString(config)) config = { component: config };
      // Make a shallow copy of the urlConfig object
      config = Object.assign({}, config);

      // Do not allow a view to mix props for component-style view with props for template/controller-style view
      if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {
        throw new Error(
          `Cannot combine: ${compKeys.join("|")} with: ${nonCompKeys.join("|")} in stateview: '${name}@${state.name}'`,
        );
      }
      config.resolveAs = config.resolveAs || "$resolve";
      config.$context = state;
      config.$name = name;
      const normalized = ViewConfig.normalizeUIViewTarget(
        config.$context,
        config.$name,
      );

      config.$ngViewName = normalized.ngViewName;
      config.$ngViewContextAnchor = normalized.ngViewContextAnchor;
      views[name] = config;
    });

    return views;
  }

  /**
   * @type {Number}
   */
  let id$1 = 0;

  class ViewConfig {
    /**
     * @param {Array<import('../path/path-node.js').PathNode>} path
     * @param viewDecl
     * @param {import('../template-factory.js').TemplateFactoryProvider} factory
     */
    constructor(path, viewDecl, factory) {
      this.path = path;
      this.viewDecl = viewDecl;
      this.factory = factory;
      this.component = undefined;
      this.template = undefined;

      /** @type {Number} */ this.$id = id$1++;
      this.loaded = false;
      this.getTemplate = (ngView, context) =>
        this.component
          ? this.factory.makeComponentTemplate(
              ngView,
              context,
              this.component,
              this.viewDecl.bindings,
            )
          : this.template;
    }

    load() {
      const context = new ResolveContext(this.path);

      const params = this.path.reduce(
        (acc, node) => Object.assign(acc, node.paramValues),
        {},
      );

      const promises = [
        Promise.resolve(this.factory.fromConfig(this.viewDecl, params, context)),
        Promise.resolve(this.getController(context)),
      ];

      return Promise.all(promises).then((results) => {
        trace.traceViewServiceEvent("Loaded", this);
        this.controller = results[1];
        Object.assign(this, results[0]); // Either { template: "tpl" } or { component: "cmpName" }

        return this;
      });
    }

    /**
     * Gets the controller for a view configuration.
     *
     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
     */
    getController(context) {
      const provider = this.viewDecl.controllerProvider;

      if (!isInjectable(provider)) return this.viewDecl.controller;
      const deps = annotate(provider);

      const providerFn = isArray(provider) ? tail(provider) : provider;

      const resolvable = new Resolvable("", providerFn, deps);

      return resolvable.get(context);
    }

    /**
     * Normalizes a view's name from a state.views configuration block.
     *
     * This should be used by a framework implementation to calculate the values for
     * [[_ViewDeclaration.$ngViewName]] and [[_ViewDeclaration.$ngViewContextAnchor]].
     *
     * @param context the context object (state declaration) that the view belongs to
     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]
     *
     * @returns the normalized ngViewName and ngViewContextAnchor that the view targets
     */
    static normalizeUIViewTarget(context, rawViewName = "") {
      // TODO: Validate incoming view name with a regexp to allow:
      // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
      // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
      const viewAtContext = rawViewName.split("@");

      let ngViewName = viewAtContext[0] || "$default"; // default to unnamed view

      let ngViewContextAnchor = isString(viewAtContext[1])
        ? viewAtContext[1]
        : "^"; // default to parent context

      // Handle relative view-name sugar syntax.
      // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
      const relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(ngViewName);

      if (relativeViewNameSugar) {
        // Clobbers existing contextAnchor (rawViewName validation will fix this)
        ngViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
        ngViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
      }

      if (ngViewName.charAt(0) === "!") {
        ngViewName = ngViewName.substring(1);
        ngViewContextAnchor = ""; // target absolutely from root
      }
      // handle parent relative targeting "^.^.^"
      const relativeMatch = /^(\^(?:\.\^)*)$/;

      if (relativeMatch.exec(ngViewContextAnchor)) {
        const anchorState = ngViewContextAnchor
          .split(".")
          .reduce((anchor) => anchor.parent, context);

        ngViewContextAnchor = anchorState.name;
      } else if (ngViewContextAnchor === ".") {
        ngViewContextAnchor = context.name;
      }

      return { ngViewName, ngViewContextAnchor };
    }
  }

  /**
   * The View service
   *
   * This service pairs existing `ng-view` components (which live in the DOM)
   * with view configs (from the state declaration objects: [[StateDeclaration.views]]).
   *
   * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].
   *   The views from exited states are deactivated via [[deactivateViewConfig]].
   *   (See: the [[registerActivateViews]] Transition Hook)
   *
   * - As `ng-view` components pop in and out of existence, they register themselves using [[registerUIView]].
   *
   * - When the [[sync]] function is called, the registered `ng-view`(s) ([[ActiveUIView]])
   * are configured with the matching [[ViewConfig]](s)
   *
   */

  const FQN_MULTIPLIER = 10_000;

  class ViewService {
    constructor() {
      this._ngViews = [];
      this._viewConfigs = [];
      this._listeners = [];
      this._viewConfigFactory(getViewConfigFactory());
    }

    $get = () => this;

    /**
     * @param {?import('../state/state-object.js').StateObject} [context]
     * @return {?import('../state/state-object.js').StateObject}
     */
    rootViewContext(context) {
      return (this._rootContext = context || this._rootContext);
    }

    _viewConfigFactory(factory) {
      this._viewConfigFactory = factory;
    }

    /**
     * @param path
     * @param decl
     * @return {import("../state/views.js").ViewConfig}
     */
    _createViewConfig(path, decl) {
      /** @type {function(any, any): any} */
      const cfgFactory = this._viewConfigFactory;

      if (!cfgFactory)
        throw new Error(
          `ViewService: No view config factory registered for type ${decl.$type}`,
        );

      return cfgFactory(path, decl);
    }

    /**
     * Deactivates a ViewConfig.
     *
     * This function deactivates a `ViewConfig`.
     * After calling [[sync]], it will un-pair from any `ng-view` with which it is currently paired.
     *
     * @param viewConfig The ViewConfig view to deregister.
     */
    deactivateViewConfig(viewConfig) {
      trace.traceViewServiceEvent("<- Removing", viewConfig);
      removeFrom(this._viewConfigs, viewConfig);
    }

    activateViewConfig(viewConfig) {
      trace.traceViewServiceEvent("-> Registering", viewConfig);
      this._viewConfigs.push(viewConfig);
    }

    sync() {
      const ngViewsByFqn = this._ngViews
        .map((uiv) => [uiv.fqn, uiv])
        .reduce(applyPairs, {});

      // Return a weighted depth value for a ngView.
      // The depth is the nesting depth of ng-views (based on FQN; times 10,000)
      // plus the depth of the state that is populating the ngView
      function ngViewDepth(ngView) {
        const stateDepth = (context) =>
          context && context.parent ? stateDepth(context.parent) + 1 : 1;

        return (
          ngView.fqn.split(".").length * FQN_MULTIPLIER +
          stateDepth(ngView.creationContext)
        );
      }
      // Return the ViewConfig's context's depth in the context tree.
      function viewConfigDepth(config) {
        let context = config.viewDecl.$context,
          count = 0;

        while (++count && context.parent) context = context.parent;

        return count;
      }
      // Given a depth function, returns a compare function which can return either ascending or descending order
      const depthCompare = curry(
        (depthFn, posNeg, left, right) =>
          posNeg * (depthFn(left) - depthFn(right)),
      );

      const matchingConfigPair = (ngView) => {
        const matchingConfigs = this._viewConfigs.filter(
          ViewService.matches(ngViewsByFqn, ngView),
        );

        if (matchingConfigs.length > 1) {
          // This is OK.  Child states can target a ng-view that the parent state also targets (the child wins)
          // Sort by depth and return the match from the deepest child
          // console.log(`Multiple matching view configs for ${ngView.fqn}`, matchingConfigs);
          matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
        }

        return { ngView, viewConfig: matchingConfigs[0] };
      };

      const configureUIView = (tuple) => {
        // If a parent ng-view is reconfigured, it could destroy child ng-views.
        // Before configuring a child ng-view, make sure it's still in the active ngViews array.
        if (this._ngViews.indexOf(tuple.ngView) !== -1) {
          tuple.ngView.configUpdated(tuple.viewConfig);
        }
      };

      // Sort views by FQN and state depth. Process uiviews nearest the root first.
      const ngViewTuples = this._ngViews
        .sort(depthCompare(ngViewDepth, 1))
        .map(matchingConfigPair);

      const matchedViewConfigs = ngViewTuples.map((tuple) => tuple.viewConfig);

      const unmatchedConfigTuples = this._viewConfigs
        .filter((config) => !matchedViewConfigs.includes(config))
        .map((viewConfig) => ({ ngView: undefined, viewConfig }));

      ngViewTuples.forEach((tuple) => {
        configureUIView(tuple);
      });
      const allTuples = ngViewTuples.concat(unmatchedConfigTuples);

      this._listeners.forEach((cb) => cb(allTuples));
      trace.traceViewSync(allTuples);
    }

    /**
     * Registers a `ng-view` component
     *
     * When a `ng-view` component is created, it uses this method to register itself.
     * After registration the [[sync]] method is used to ensure all `ng-view` are configured with the proper [[ViewConfig]].
     *
     * Note: the `ng-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ng-view`,
     * and what the view's state context is.
     *
     * Note: There is no corresponding `deregisterUIView`.
     *       A `ng-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.
     *
     * @param ngView The metadata for a UIView
     * @return a de-registration function used when the view is destroyed.
     */
    registerUIView(ngView) {
      trace.traceViewServiceUIViewEvent("-> Registering", ngView);
      const ngViews = this._ngViews;

      const fqnAndTypeMatches = (uiv) => uiv.fqn === ngView.fqn;

      if (ngViews.filter(fqnAndTypeMatches).length)
        trace.traceViewServiceUIViewEvent("!!!! duplicate ngView named:", ngView);
      ngViews.push(ngView);
      this.sync();

      return () => {
        const idx = ngViews.indexOf(ngView);

        if (idx === -1) {
          trace.traceViewServiceUIViewEvent(
            "Tried removing non-registered ngView",
            ngView,
          );

          return;
        }
        trace.traceViewServiceUIViewEvent("<- Deregistering", ngView);
        removeFrom(ngViews, ngView);
      };
    }

    /**
     * Returns the list of views currently available on the page, by fully-qualified name.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    available() {
      return this._ngViews.map((view) => view.fqn);
    }

    /**
     * Returns the list of views on the page containing loaded content.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    active() {
      return this._ngViews
        .filter((view) => view.$config)
        .map((view) => view.name);
    }
  }
  /**
   * Given a ng-view and a ViewConfig, determines if they "match".
   *
   * A ng-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
   * the DOM, describing its nesting relationship to any parent ng-view tags it is nested inside of.
   *
   * A ViewConfig has a target ng-view name and a context anchor.  The ng-view name can be a simple name, or
   * can be a segmented ng-view path, describing a portion of a ng-view fqn.
   *
   * In order for a ng-view to match ViewConfig, ng-view's $type must match the ViewConfig's $type
   *
   * If the ViewConfig's target ng-view name is a simple name (no dots), then a ng-view matches if:
   * - the ng-view's name matches the ViewConfig's target name
   * - the ng-view's context matches the ViewConfig's anchor
   *
   * If the ViewConfig's target ng-view name is a segmented name (with dots), then a ng-view matches if:
   * - There exists a parent ng-view where:
   *    - the parent ng-view's name matches the first segment (index 0) of the ViewConfig's target name
   *    - the parent ng-view's context matches the ViewConfig's anchor
   * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ng-view's fqn
   *
   * Example:
   *
   * DOM:
   * <ng-view>                        <!-- created in the root context (name: "") -->
   *   <ng-view name="foo">                <!-- created in the context named: "A"      -->
   *     <ng-view>                    <!-- created in the context named: "A.B"    -->
   *       <ng-view name="bar">            <!-- created in the context named: "A.B.C"  -->
   *       </ng-view>
   *     </ng-view>
   *   </ng-view>
   * </ng-view>
   *
   * ngViews: [
   *  { fqn: "$default",                  creationContext: { name: "" } },
   *  { fqn: "$default.foo",              creationContext: { name: "A" } },
   *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
   *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
   * ]
   *
   * These four view configs all match the ng-view with the fqn: "$default.foo.$default.bar":
   *
   * - ViewConfig1: { ngViewName: "bar",                       ngViewContextAnchor: "A.B.C" }
   * - ViewConfig2: { ngViewName: "$default.bar",              ngViewContextAnchor: "A.B" }
   * - ViewConfig3: { ngViewName: "foo.$default.bar",          ngViewContextAnchor: "A" }
   * - ViewConfig4: { ngViewName: "$default.foo.$default.bar", ngViewContextAnchor: "" }
   *
   * Using ViewConfig3 as an example, it matches the ng-view with fqn "$default.foo.$default.bar" because:
   * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
   * - There exists a parent ng-view (which has fqn: "$default.foo") where:
   *    - the parent ng-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
   *    - the parent ng-view's context "A" matches the ViewConfig's anchor context "A"
   * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
   *   the tail of the ng-view's fqn "default.bar"
   *
   * @internal
   */
  ViewService.matches = (ngViewsByFqn, ngView) => (viewConfig) => {
    // Don't supply an ng1 ng-view with an ng2 ViewConfig, etc
    if (ngView.$type !== viewConfig.viewDecl.$type) return false;
    // Split names apart from both viewConfig and ngView into segments
    const vc = viewConfig.viewDecl;

    const vcSegments = vc.$ngViewName.split(".");

    const uivSegments = ngView.fqn.split(".");

    // Check if the tails of the segment arrays match. ex, these arrays' tails match:
    // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
    if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
      return false;
    // Now check if the fqn ending at the first segment of the viewConfig matches the context:
    // ["$default", "foo"].join(".") == "$default.foo", does the ng-view $default.foo context match?
    const negOffset = 1 - vcSegments.length || undefined;

    const fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");

    const ngViewContext = ngViewsByFqn[fqnToFirstSegment].creationContext;

    return vc.$ngViewContextAnchor === (ngViewContext && ngViewContext.name);
  };

  /**
   * An object for Transition Rejection reasons.
   * @internal
   * @enum {number}
   */
  const RejectType = {
    /**
     * A new transition superseded this one.
     *
     * While this transition was running, a new transition started.
     * This transition is cancelled because it was superseded by a new transition.
     * @type {number}
     */
    _SUPERSEDED: 2,

    /**
     * The transition was aborted.
     *
     * The transition was aborted by a hook which returned `false`.
     * @type {number}
     */
    _ABORTED: 3,

    /**
     * The transition was invalid.
     *
     * The transition was never started because it was invalid.
     * @type {number}
     */
    _INVALID: 4,

    /**
     * The transition was ignored.
     *
     * The transition was ignored because it would have no effect.
     * Either:
     * - The transition is targeting the current state and parameter values.
     * - The transition is targeting the same state and parameter values as the currently running transition.
     * @type {number}
     */
    _IGNORED: 5,

    /**
     * The transition errored.
     *
     * This generally means a hook threw an error or returned a rejected promise.
     * @type {number}
     */
    _ERROR: 6,
  };

  let id = 0;

  class Rejection {
    /** Returns a Rejection due to transition superseded */
    static superseded(detail, options) {
      const message =
        "The transition has been superseded by a different transition";

      const rejection = new Rejection(RejectType._SUPERSEDED, message, detail);

      if (options && options.redirected) {
        rejection.redirected = true;
      }

      return rejection;
    }

    /** Returns a Rejection due to redirected transition */
    static redirected(detail) {
      return Rejection.superseded(detail, { redirected: true });
    }

    /** Returns a Rejection due to invalid transition */
    static invalid(detail) {
      const message = "This transition is invalid";

      return new Rejection(RejectType._INVALID, message, detail);
    }

    /** Returns a Rejection due to ignored transition */
    static ignored(detail) {
      const message = "The transition was ignored";

      return new Rejection(RejectType._IGNORED, message, detail);
    }

    /** Returns a Rejection due to aborted transition */
    static aborted(detail) {
      const message = "The transition has been aborted";

      return new Rejection(RejectType._ABORTED, message, detail);
    }

    /** Returns a Rejection due to aborted transition */
    static errored(detail) {
      const message = "The transition errored";

      return new Rejection(RejectType._ERROR, message, detail);
    }

    /**
     * Returns a Rejection
     *
     * Normalizes a value as a Rejection.
     * If the value is already a Rejection, returns it.
     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).
     *
     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.
     */
    static normalize(detail) {
      return is(Rejection)(detail) ? detail : Rejection.errored(detail);
    }

    constructor(type, message, detail) {
      this.$id = id++;
      this.type = type;
      this.message = message;
      this.detail = detail;
      this.redirected = false;
    }

    toString() {
      const detailString = (data) =>
        data && data.toString !== Object.prototype.toString
          ? data.toString()
          : stringify(data);

      const detail = detailString(this.detail);

      const { $id, type, message } = this;

      return `Transition Rejection($id: ${$id} type: ${type}, message: ${message}, detail: ${detail})`;
    }

    toPromise() {
      return Object.assign(silentRejection(this), { _transitionRejection: this });
    }
  }

  const defaultOptions = {
    current: () => {
      /* empty */
    },
    transition: null,
    traceData: {},
    bind: null,
  };

  /**
   * Enum representing the different phases of a transition hook.
   * @internal
   * @enum {number}
   */
  const TransitionHookPhase = {
    _CREATE: 0,
    _BEFORE: 1,
    _RUN: 2,
    _SUCCESS: 3,
    _ERROR: 4,
  };

  /**
   * Enum representing the scope in which a transition hook operates.
   * @enum {number}
   */
  const TransitionHookScope = {
    _TRANSITION: 0,
    _STATE: 1,
  };

  class TransitionHook {
    /**
     * Chains together an array of TransitionHooks.
     *
     * Given a list of [[TransitionHook]] objects, chains them together.
     * Each hook is invoked after the previous one completes.
     *
     * #### Example:
     * ```js
     * var hooks: TransitionHook[] = getHooks();
     * let promise: Promise<any> = TransitionHook.chain(hooks);
     *
     * promise.then(handleSuccess, handleError);
     * ```
     *
     * @param hooks the list of hooks to chain together
     * @param waitFor if provided, the chain is `.then()`'ed off this promise
     * @returns a `Promise` for sequentially invoking the hooks (in order)
     */
    static chain(hooks, waitFor) {
      // Chain the next hook off the previous
      const createHookChainR = (prev, nextHook) =>
        prev.then(() => nextHook.invokeHook());

      return hooks.reduce(createHookChainR, waitFor || Promise.resolve());
    }

    /**
     * Invokes all the provided TransitionHooks, in order.
     * Each hook's return value is checked.
     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.
     * If no hook returns a promise, then all hooks are processed synchronously.
     *
     * @param hooks the list of TransitionHooks to invoke
     * @param doneCallback a callback that is invoked after all the hooks have successfully completed
     *
     * @returns a promise for the async result, or the result of the callback
     */
    static invokeHooks(hooks, doneCallback) {
      for (let idx = 0; idx < hooks.length; idx++) {
        const hookResult = hooks[idx].invokeHook();

        if (isPromise(hookResult)) {
          const remainingHooks = hooks.slice(idx + 1);

          return TransitionHook.chain(remainingHooks, hookResult).then(() => {
            doneCallback();
          });
        }
      }

      return doneCallback();
    }

    /**
     * Run all TransitionHooks, ignoring their return value.
     */
    static runAllHooks(hooks) {
      hooks.forEach((hook) => hook.invokeHook());
    }

    /**
     *
     * @param {*} transition
     * @param {*} stateContext
     * @param {*} registeredHook
     * @param {*} options
     * @param {ng.ExceptionHandlerService} exceptionHandler
     */
    constructor(
      transition,
      stateContext,
      registeredHook,
      options,
      exceptionHandler,
    ) {
      this.transition = transition;
      this.stateContext = stateContext;
      this.registeredHook = registeredHook;
      this.options = options;
      this.isSuperseded = () =>
        this.type.hookPhase === TransitionHookPhase._RUN &&
        !this.options.transition.isActive();
      this.options = defaults(options, defaultOptions);
      this.type = registeredHook.eventType;

      /** @type {ng.ExceptionHandlerService} */
      this._exceptionHandler = exceptionHandler;
    }

    logError(err) {
      this._exceptionHandler(err);
    }

    invokeHook() {
      const hook = this.registeredHook;

      if (hook._deregistered) return undefined;
      const notCurrent = this.getNotCurrentRejection();

      if (notCurrent) return notCurrent;
      const { options } = this;

      trace.traceHookInvocation(this, this.transition, options);
      const invokeCallback = () =>
        hook.callback.call(options.bind, this.transition, this.stateContext);

      const normalizeErr = (err) => Rejection.normalize(err).toPromise();

      const handleError = (err) => hook.eventType.getErrorHandler(this)(err);

      const handleResult = (result) =>
        hook.eventType.getResultHandler(this)(result);

      try {
        const result = invokeCallback();

        if (!this.type.synchronous && isPromise(result)) {
          return result.catch(normalizeErr).then(handleResult, handleError);
        } else {
          return handleResult(result);
        }
      } catch (err) {
        // If callback throws (synchronously)
        return handleError(Rejection.normalize(err));
      } finally {
        if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {
          hook.deregister();
        }
      }
    }

    /**
     * This method handles the return value of a Transition Hook.
     *
     * A hook can return false (cancel), a TargetState (redirect),
     * or a promise (which may later resolve to false or a redirect)
     *
     * This also handles "transition superseded" -- when a new transition
     * was started while the hook was still running
     */
    handleHookResult(result) {
      const notCurrent = this.getNotCurrentRejection();

      if (notCurrent) return notCurrent;

      // Hook returned a promise
      if (isPromise(result)) {
        // Wait for the promise, then reprocess with the resulting value
        return result.then((val) => this.handleHookResult(val));
      }
      trace.traceHookResult(result, this.transition);

      // Hook returned false
      if (result === false) {
        // Abort this Transition
        return Rejection.aborted("Hook aborted transition").toPromise();
      }

      // hook returned a TargetState
      if (result instanceof TargetState) {
        // Halt the current Transition and redirect (a new Transition) to the TargetState.
        return Rejection.redirected(result).toPromise();
      }

      return undefined;
    }

    /**
     * Return a Rejection promise if the transition is no longer current due
     * a new transition has started and superseded this one.
     */
    getNotCurrentRejection() {
      if (this.transition._aborted) {
        return Rejection.aborted().toPromise();
      }

      // This transition is no longer current.
      // Another transition started while this hook was still running.
      if (this.isSuperseded()) {
        // Abort this transition
        return Rejection.superseded(this.options.current()).toPromise();
      }

      return undefined;
    }

    toString() {
      const { options, registeredHook } = this;

      const event = parse("traceData.hookType")(options) || "internal",
        context =
          parse("traceData.context.state.name")(options) ||
          parse("traceData.context")(options) ||
          "unknown",
        name = fnToString(registeredHook.callback);

      return `${event} context: ${context}, ${maxLength(200, name)}`;
    }
  }
  /**
   * These GetResultHandler(s) are used by [[invokeHook]] below
   * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])
   */
  TransitionHook.HANDLE_RESULT = (hook) => (result) =>
    hook.handleHookResult(result);
  /**
   * If the result is a promise rejection, log it.
   * Otherwise, ignore the result.
   */
  TransitionHook.LOG_REJECTED_RESULT = (hook) => (result) => {
    isPromise(result) &&
      result.catch((err) => hook.logError(Rejection.normalize(err)));

    return undefined;
  };
  /**
   * These GetErrorHandler(s) are used by [[invokeHook]] below
   * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])
   */
  TransitionHook.LOG_ERROR = (hook) => (error) => hook.logError(error);
  TransitionHook.REJECT_ERROR = () => (error) => silentRejection(error);
  TransitionHook.THROW_ERROR = () => (error) => {
    throw error;
  };

  /**
   * Matches state names using glob-like pattern strings.
   *
   * Globs can be used in specific APIs including:
   *
   * - [[StateService.is]]
   * - [[StateService.includes]]
   * - The first argument to Hook Registration functions like [[TransitionService.onStart]]
   *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]
   *
   * A `Glob` string is a pattern which matches state names.
   * Nested state names are split into segments (separated by a dot) when processing.
   * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']
   *
   * Globs work according to the following rules:
   *
   * ### Exact match:
   *
   * The glob `'A.B'` matches the state named exactly `'A.B'`.
   *
   * | Glob        |Matches states named|Does not match state named|
   * |:------------|:--------------------|:---------------------|
   * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |
   * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |
   * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|
   *
   * ### Single star (`*`)
   *
   * A single star (`*`) is a wildcard that matches exactly one segment.
   *
   * | Glob        |Matches states named  |Does not match state named |
   * |:------------|:---------------------|:--------------------------|
   * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |
   * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |
   * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|
   *
   * ### Double star (`**`)
   *
   * A double star (`'**'`) is a wildcard that matches *zero or more segments*
   *
   * | Glob        |Matches states named                           |Does not match state named         |
   * |:------------|:----------------------------------------------|:----------------------------------|
   * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |
   * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |
   * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |
   * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |
   *
   */
  class Glob {
    /** Returns a glob from the string, or null if the string isn't Glob-like
     * @param {string} text
     * @returns {?Glob}
     */
    static fromString(text) {
      return hasGlobs(text) ? new Glob(text) : null;
    }

    /**
     * @param {string} text
     */
    constructor(text) {
      /**
       * @type {string}
       */
      this._text = text;

      const regexpString = this._text
        .split(".")
        .map((seg) => {
          if (seg === "**") return "(?:|(?:\\.[^.]*)*)";

          if (seg === "*") return "\\.[^.]*";

          return `\\.${seg}`;
        })
        .join("");

      /**
       * @type {RegExp}
       */
      this._regexp = new RegExp(`^${regexpString}$`);
    }

    /**
     * @param {string} name
     * @return {boolean}
     */
    matches(name) {
      return this._regexp.test(`.${name}`);
    }
  }

  /** Returns true if the string has glob-like characters in it
   *  @param {string} text
   *  @returns {boolean}
   */
  function hasGlobs(text) {
    return !!/[!,*]+/.exec(text);
  }

  /**
   * Determines if the given state matches the matchCriteria
   *
   * @internal
   *
   * @param state a State Object to test against
   * @param criterion
   * - If a string, matchState uses the string as a glob-matcher against the state name
   * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name
   *   and returns a positive match if any of the globs match.
   * - If a function, matchState calls the function with the state and returns true if the function's result is truthy.
   * @returns {boolean}
   */
  function matchState(state, criterion, transition) {
    const toMatch = isString(criterion) ? [criterion] : criterion;

    function matchGlobs(_state) {
      const globStrings = toMatch;

      for (let i = 0; i < globStrings.length; i++) {
        const glob = new Glob(globStrings[i]);

        if (
          (glob && glob.matches(_state.name)) ||
          (!glob && globStrings[i] === _state.name)
        ) {
          return true;
        }
      }

      return false;
    }
    const matchFn = isFunction(toMatch) ? toMatch : matchGlobs;

    return !!matchFn(state, transition);
  }
  /**
   * The registration data for a registered transition hook
   */
  class RegisteredHook {
    /**
     * @param {import("./transition-service.js").TransitionProvider} tranSvc
     * @param eventType
     * @param callback
     * @param matchCriteria
     * @param removeHookFromRegistry
     * @param options
     */
    constructor(
      tranSvc,
      eventType,
      callback,
      matchCriteria,
      removeHookFromRegistry,
      options = {},
    ) {
      /** @type {import("./transition-service.js").TransitionProvider} */
      this.tranSvc = tranSvc;
      this.eventType = eventType;
      this.callback = callback;
      this.matchCriteria = matchCriteria;
      this.removeHookFromRegistry = removeHookFromRegistry;
      this.invokeCount = 0;
      this._deregistered = false;
      this.priority = options.priority || 0;
      this.bind = options.bind || null;
      this.invokeLimit = options.invokeLimit;
    }

    /**
     * Gets the matching [[PathNode]]s
     *
     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing
     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.
     *
     * Returning `null` is significant to distinguish between the default
     * "match-all criterion value" of `true` compared to a `() => true` function,
     * when the nodes is an empty array.
     *
     * This is useful to allow a transition match criteria of `entering: true`
     * to still match a transition, even when `entering === []`.  Contrast that
     * with `entering: (state) => true` which only matches when a state is actually
     * being entered.
     */
    _matchingNodes(nodes, criterion, transition) {
      if (criterion === true) return nodes;
      const matching = nodes.filter((node) =>
        matchState(node.state, criterion, transition),
      );

      return matching.length ? matching : null;
    }

    /**
     * Gets the default match criteria (all `true`)
     *
     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:
     *
     * ```js
     * {
     *   to: true,
     *   from: true,
     *   entering: true,
     *   exiting: true,
     *   retained: true,
     * }
     */
    _getDefaultMatchCriteria() {
      return map(this.tranSvc._getPathTypes(), () => true);
    }

    /**
     * Gets matching nodes as [[IMatchingNodes]]
     *
     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:
     *
     * ```js
     * let matches: IMatchingNodes = {
     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),
     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),
     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),
     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),
     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),
     * };
     * ```
     */
    _getMatchingNodes(treeChanges, transition) {
      const criteria = Object.assign(
        this._getDefaultMatchCriteria(),
        this.matchCriteria,
      );

      const paths = Object.values(this.tranSvc._getPathTypes());

      return paths.reduce((mn, pathtype) => {
        // STATE scope criteria matches against every node in the path.
        // TRANSITION scope criteria matches against only the last node in the path
        const isStateHook = pathtype.scope === TransitionHookScope._STATE;

        const path = treeChanges[pathtype.name] || [];

        const nodes = isStateHook ? path : [tail(path)];

        mn[pathtype.name] = this._matchingNodes(
          nodes,
          criteria[pathtype.name],
          transition,
        );

        return mn;
      }, {});
    }

    /**
     * Determines if this hook's [[matchCriteria]] match the given [[TreeChanges]]
     *
     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values
     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)
     */
    matches(treeChanges, transition) {
      const matches = this._getMatchingNodes(treeChanges, transition);

      // Check if all the criteria matched the TreeChanges object
      const allMatched = Object.values(matches).every((x) => x);

      return allMatched ? matches : null;
    }

    deregister() {
      this.removeHookFromRegistry(this);
      this._deregistered = true;
    }
  }
  /** Return a registration function of the requested type. */
  function makeEvent(registry, transitionService, eventType) {
    // Create the object which holds the registered transition hooks.
    const _registeredHooks = (registry._registeredHooks =
      registry._registeredHooks || {});

    const hooks = (_registeredHooks[eventType.name] = []);

    const removeHookFn = (x) => removeFrom(hooks, x);

    // Create hook registration function on the HookRegistry for the event
    registry[eventType.name] = hookRegistrationFn;
    function hookRegistrationFn(matchObject, callback, options = {}) {
      const registeredHook = new RegisteredHook(
        transitionService,
        eventType,
        callback,
        matchObject,
        removeHookFn,
        options,
      );

      hooks.push(registeredHook);

      return registeredHook.deregister.bind(registeredHook);
    }

    return hookRegistrationFn;
  }

  /**
   * This class returns applicable TransitionHooks for a specific Transition instance.
   *
   * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
   * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is
   * determined by the type of hook)
   *
   * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.
   *
   * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
   * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
   * in the Transition class, so we must also provide the Transition's _treeChanges)
   */
  class HookBuilder {
    /**
     * @param {import("./transition.js").Transition} transition
     */
    constructor(transition) {
      this.transition = transition;
    }

    /**
     * @param {TransitionHookPhase} phase
     * @returns
     */
    buildHooksForPhase(phase) {
      return this.transition._transitionService
        ._getEvents(phase)
        .map((type) => this.buildHooks(type))
        .reduce(unnestR, [])
        .filter(Boolean);
    }

    /**
     * Returns an array of newly built TransitionHook objects.
     *
     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].
     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)
     * - For each of the [[PathNode]]s, creates a TransitionHook
     *
     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.
     */
    buildHooks(hookType) {
      const { transition } = this;

      const treeChanges = transition.treeChanges();

      // Find all the matching registered hooks for a given hook type
      const matchingHooks = this.getMatchingHooks(
        hookType,
        treeChanges,
        transition,
      );

      if (!matchingHooks) return [];
      const baseHookOptions = {
        transition,
        current: transition.options().current,
      };

      const makeTransitionHooks = (hook) => {
        // Fetch the Nodes that caused this hook to match.
        const matches = hook.matches(treeChanges, transition);

        // Select the PathNode[] that will be used as TransitionHook context objects
        const matchingNodes = matches[hookType.criteriaMatchPath.name];

        // Return an array of HookTuples
        return matchingNodes.map((node) => {
          const _options = Object.assign(
            {
              bind: hook.bind,
              traceData: { hookType: hookType.name, context: node },
            },
            baseHookOptions,
          );

          const state =
            hookType.criteriaMatchPath.scope === TransitionHookScope._STATE
              ? node.state.self
              : null;

          const transitionHook = new TransitionHook(
            transition,
            state,
            hook,
            _options,
            this.transition._transitionService._$exceptionHandler,
          );

          return { hook, node, transitionHook };
        });
      };

      return matchingHooks
        .map(makeTransitionHooks)
        .reduce(unnestR, [])
        .sort(tupleSort(hookType.reverseSort))
        .map((tuple) => tuple.transitionHook);
    }

    /**
     * Finds all RegisteredHooks from:
     * - The Transition object instance hook registry
     * - The TransitionService ($transitions) global hook registry
     *
     * which matched:
     * - the eventType
     * - the matchCriteria (to, from, exiting, retained, entering)
     *
     * @returns an array of matched [[RegisteredHook]]s
     */
    getMatchingHooks(hookType, treeChanges, transition) {
      const isCreate = hookType.hookPhase === TransitionHookPhase._CREATE;

      // Instance and Global hook registries
      const $transitions = this.transition._transitionService;

      const registries = isCreate
        ? [$transitions]
        : [this.transition, $transitions];

      return registries
        .map((reg) => reg.getHooks(hookType.name)) // Get named hooks from registries
        .filter(assertPredicate(isArray, `broken event named: ${hookType.name}`)) // Sanity check
        .reduce(unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array
        .filter((hook) => hook.matches(treeChanges, transition)); // Only those satisfying matchCriteria
    }
  }
  /**
   * A factory for a sort function for HookTuples.
   *
   * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares
   * the EventHook priority.
   *
   * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth
   * @returns a tuple sort function
   */
  function tupleSort(reverseDepthSort = false) {
    return function nodeDepthThenPriority(left, right) {
      const factor = reverseDepthSort ? -1 : 1;

      const depthDelta =
        (left.node.state.path.length - right.node.state.path.length) * factor;

      return depthDelta !== 0
        ? depthDelta
        : right.hook.priority - left.hook.priority;
    };
  }

  /** @typedef {import('./interface.ts').HookRegistry} HookRegistry */

  const REDIRECT_MAX = 20;

  /**
   * Represents a transition between two states.
   *
   * When navigating to a state, we are transitioning **from** the current state **to** the new state.
   *
   * This object contains all contextual information about the to/from states, parameters, resolves.
   * It has information about all states being entered and exited as a result of the transition.
   * @implements {HookRegistry}
   */
  class Transition {
    /**
     * Creates a new Transition object.
     *
     * If the target state is not valid, an error is thrown.
     *
     * @param {Array<import('../path/path-node.js').PathNode>} fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`
     *        encapsulates the "from state".
     * @param {import('../state/target-state.js').TargetState} targetState The target state and parameters being transitioned to (also, the transition options)
     * @param {ng.TransitionProvider} transitionService The [[TransitionService]] instance
     * @param {ng.RouterService} globals
     */
    constructor(fromPath, targetState, transitionService, globals) {
      /**
       * @type {import('../router.js').RouterProvider}
       */
      this._globals = globals;
      this._transitionService = transitionService;
      this._deferred = Promise.withResolvers();

      /**
       * This promise is resolved or rejected based on the outcome of the Transition.
       *
       * When the transition is successful, the promise is resolved
       * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error
       */
      this.promise = this._deferred.promise;
      /** @internal Holds the hook registration functions such as those passed to Transition.onStart() */
      this._registeredHooks = {};

      this._hookBuilder = new HookBuilder(this);
      /** Checks if this transition is currently active/running. */
      this.isActive = () => this._globals.transition === this;
      this._targetState = targetState;

      if (!targetState.valid()) {
        throw new Error(targetState.error());
      }
      // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.
      this._options = Object.assign(
        { current: val(this) },
        targetState.options(),
      );
      this.$id = transitionService._transitionCount++;
      const toPath = PathUtils.buildToPath(fromPath, targetState);

      this._treeChanges = PathUtils.treeChanges(
        fromPath,
        toPath,
        this._options.reloadState,
      );
      this.createTransitionHookRegFns();
      const onCreateHooks = this._hookBuilder.buildHooksForPhase(
        TransitionHookPhase._CREATE,
      );

      TransitionHook.invokeHooks(onCreateHooks, () => null);
      this.applyViewConfigs();
      this.onStart = undefined;
      this.onBefore = undefined;
      this.onSuccess = undefined;
      this.onEnter = undefined;
      this.onRetain = undefined;
      this.onExit = undefined;
      this.onFinish = undefined;
      this.onError = undefined;
    }

    /**
     * Creates the transition-level hook registration functions
     * (which can then be used to register hooks)
     */
    createTransitionHookRegFns() {
      this._transitionService
        ._getEvents()
        .filter((type) => type.hookPhase !== TransitionHookPhase._CREATE)
        .forEach((type) => makeEvent(this, this._transitionService, type));
    }

    getHooks(hookName) {
      return this._registeredHooks[hookName];
    }

    applyViewConfigs() {
      const enteringStates = this._treeChanges.entering.map((node) => node.state);

      PathUtils.applyViewConfigs(
        this._transitionService.$view,
        this._treeChanges.to,
        enteringStates,
      );
    }

    /**
     * @returns {import('../state/state-object.js').StateObject} the internal from [State] object
     */
    $from() {
      return tail(this._treeChanges.from).state;
    }

    /**
     * @returns {import('../state/state-object.js').StateObject} the internal to [State] object
     */
    $to() {
      return tail(this._treeChanges.to).state;
    }

    /**
     * Returns the "from state"
     *
     * Returns the state that the transition is coming *from*.
     *
     * @returns The state declaration object for the Transition's ("from state").
     */
    from() {
      return this.$from().self;
    }

    /**
     * Returns the "to state"
     *
     * Returns the state that the transition is going *to*.
     *
     * @returns The state declaration object for the Transition's target state ("to state").
     */
    to() {
      return this.$to().self;
    }

    /**
     * Gets the Target State
     *
     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.
     *
     * @returns the [[TargetState]] of this Transition
     */
    targetState() {
      return this._targetState;
    }

    /**
     * Determines whether two transitions are equivalent.
     * @deprecated
     */
    is(compare) {
      if (compare instanceof Transition) {
        // TODO: Also compare parameters
        return this.is({ to: compare.$to().name, from: compare.$from().name });
      }

      return !(
        (compare.to && !matchState(this.$to(), compare.to, this)) ||
        (compare.from && !matchState(this.$from(), compare.from, this))
      );
    }

    params(pathname = "to") {
      return Object.freeze(
        this._treeChanges[pathname]
          .map((x) => x.paramValues)
          .reduce((acc, obj) => ({ ...acc, ...obj }), {}),
      );
    }

    /**
     * Gets all available resolve tokens (keys)
     *
     * This method can be used in conjunction with [[injector]] to inspect the resolve values
     * available to the Transition.
     *
     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states
     * in the Transition's [[TreeChanges.to]] path.
     *
     * #### Example:
     * This example logs all resolve values
     * ```js
     * let tokens = trans.getResolveTokens();
     * tokens.forEach(token => console.log(token + " = " + trans.injector().get(token)));
     * ```
     *
     * #### Example:
     * This example creates promises for each resolve value.
     * This triggers fetches of resolves (if any have not yet been fetched).
     * When all promises have all settled, it logs the resolve values.
     * ```js
     * let tokens = trans.getResolveTokens();
     * let promise = tokens.map(token => trans.injector().getAsync(token));
     * Promise.all(promises).then(values => console.log("Resolved values: " + values));
     * ```
     *
     * Note: Angular 1 users whould use `$q.all()`
     *
     * @param pathname resolve context's path name (e.g., `to` or `from`)
     *
     * @returns an array of resolve tokens (keys)
     */
    getResolveTokens(pathname = "to") {
      return new ResolveContext(this._treeChanges[pathname]).getTokens();
    }

    /**
     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.
     *
     * Allows a transition hook to dynamically add a Resolvable to this Transition.
     *
     * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).
     *
     * If a `state` argument is provided, the Resolvable is processed when that state is being entered.
     * If no `state` is provided then the root state is used.
     * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.
     * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.
     *
     * The `state` argument also scopes the resolved data.
     * The resolved data is available from the injector for that `state` and any children states.
     *
     * #### Example:
     * ```js
     * transitionService.onBefore({}, transition => {
     *   transition.addResolvable({
     *     token: 'myResolve',
     *     deps: ['MyService'],
     *     resolveFn: myService => myService.getData()
     *   });
     * });
     * ```
     *
     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])
     * @param state the state in the "to path" which should receive the new resolve (otherwise, the root state)
     */
    addResolvable(resolvable, state) {
      if (state === void 0) {
        state = "";
      }
      resolvable = is(Resolvable)(resolvable)
        ? resolvable
        : new Resolvable(resolvable);
      const stateName = typeof state === "string" ? state : state.name;

      const topath = this._treeChanges.to;

      const targetNode = find(topath, (node) => {
        return node.state.name === stateName;
      });

      assert(!!targetNode, `targetNode not found ${stateName}`);
      const resolveContext = new ResolveContext(topath);

      resolveContext.addResolvables(
        [resolvable],
        /** @type {import("../path/path-node.js").PathNode} */ (targetNode).state,
      );
    }

    /**
     * Gets the transition from which this transition was redirected.
     *
     * If the current transition is a redirect, this method returns the transition that was redirected.
     *
     * #### Example:
     * ```js
     * let transitionA = $state.go('A').transition
     * transitionA.onStart({}, () => $state.target('B'));
     * $transitions.onSuccess({ to: 'B' }, (trans) => {
     *   trans.to().name === 'B'; // true
     *   trans.redirectedFrom() === transitionA; // true
     * });
     * ```
     *
     * @returns The previous Transition, or null if this Transition is not the result of a redirection
     */
    redirectedFrom() {
      return this._options.redirectedFrom || null;
    }

    /**
     * Gets the original transition in a redirect chain
     *
     * A transition might belong to a long chain of multiple redirects.
     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.
     *
     * #### Example:
     * ```js
     * // states
     * registry.register({ name: 'A', redirectTo: 'B' });
     * registry.register({ name: 'B', redirectTo: 'C' });
     * registry.register({ name: 'C', redirectTo: 'D' });
     * registry.register({ name: 'D' });
     *
     * let transitionA = $state.go('A').transition
     *
     * $transitions.onSuccess({ to: 'D' }, (trans) => {
     *   trans.to().name === 'D'; // true
     *   trans.redirectedFrom().to().name === 'C'; // true
     *   trans.originalTransition() === transitionA; // true
     *   trans.originalTransition().to().name === 'A'; // true
     * });
     * ```
     *
     * @returns The original Transition that started a redirect chain
     */
    originalTransition() {
      const rf = this.redirectedFrom();

      return (rf && rf.originalTransition()) || this;
    }

    /**
     * Get the transition options
     *
     * @returns the options for this Transition.
     */
    options() {
      return this._options;
    }

    /**
     * Gets the states being entered.
     *
     * @returns an array of states that will be entered during this transition.
     */
    entering() {
      return map(this._treeChanges.entering, (x) => x.state).map((x) => x.self);
    }

    /**
     * Gets the states being exited.
     *
     * @returns an array of states that will be exited during this transition.
     */
    exiting() {
      return map(this._treeChanges.exiting, (x) => x.state)
        .map((x) => x.self)
        .reverse();
    }

    /**
     * Gets the states being retained.
     *
     * @returns an array of states that are already entered from a previous Transition, that will not be
     *    exited during this Transition
     */
    retained() {
      return map(this._treeChanges.retained, (x) => x.state).map((x) => x.self);
    }

    /**
     * Get the [[ViewConfig]]s associated with this Transition
     *
     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.
     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., "to" or "entering").
     *
     * @param pathname the name of the path to fetch views for:
     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)
     * @param state If provided, only returns the `ViewConfig`s for a single state in the path
     *
     * @returns a list of ViewConfig objects for the given path.
     */
    views(pathname = "entering", state) {
      let path = this._treeChanges[pathname];

      path = !state ? path : path.filter(propEq("state", state));

      return path.map((x) => x.views).reduce(unnestR, []);
    }

    treeChanges(pathname) {
      return pathname ? this._treeChanges[pathname] : this._treeChanges;
    }

    /**
     * Creates a new transition that is a redirection of the current one.
     *
     * This transition can be returned from a [[TransitionService]] hook to
     * redirect a transition to a new state and/or set of parameters.
     *
     * @internal
     *
     * @returns Returns a new [[Transition]] instance.
     */
    redirect(targetState) {
      let redirects = 1,
        trans = this;

      while (!isNullOrUndefined((trans = trans.redirectedFrom()))) {
        if (++redirects > REDIRECT_MAX)
          throw new Error(`Too many consecutive Transition redirects (20+)`);
      }
      const redirectOpts = { redirectedFrom: this, source: "redirect" };

      // If the original transition was caused by URL sync, then use { location: 'replace' }
      // on the new transition (unless the target state explicitly specifies location: false).
      // This causes the original url to be replaced with the url for the redirect target
      // so the original url disappears from the browser history.
      if (
        this.options().source === "url" &&
        targetState.options().location !== false
      ) {
        redirectOpts.location = "replace";
      }
      const newOptions = Object.assign(
        {},
        this.options(),
        targetState.options(),
        redirectOpts,
      );

      targetState = targetState.withOptions(newOptions, true);
      const newTransition = this._transitionService.create(
        this._treeChanges.from,
        targetState,
      );

      const originalEnteringNodes = this._treeChanges.entering;

      const redirectEnteringNodes = newTransition._treeChanges.entering;

      // --- Re-use resolve data from original transition ---
      // When redirecting from a parent state to a child state where the parent parameter values haven't changed
      // (because of the redirect), the resolves fetched by the original transition are still valid in the
      // redirected transition.
      //
      // This allows you to define a redirect on a parent state which depends on an async resolve value.
      // You can wait for the resolve, then redirect to a child state based on the result.
      // The redirected transition does not have to re-fetch the resolve.
      // ---------------------------------------------------------
      const nodeIsReloading = (reloadState) => (node) => {
        return reloadState && node.state.includes[reloadState.name];
      };

      // Find any "entering" nodes in the redirect path that match the original path and aren't being reloaded
      const matchingEnteringNodes = PathUtils.matching(
        redirectEnteringNodes,
        originalEnteringNodes,
        PathUtils.nonDynamicParams,
      ).filter((x) => !nodeIsReloading(targetState.options().reloadState)(x));

      // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.
      matchingEnteringNodes.forEach((node, idx) => {
        node.resolvables = originalEnteringNodes[idx].resolvables;
      });

      return newTransition;
    }

    /** @internal If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */
    _changedParams() {
      const tc = this._treeChanges;

      /** Return undefined if it's not a "dynamic" transition, for the following reasons */
      // If user explicitly wants a reload
      if (this._options.reload) return undefined;

      // If any states are exiting or entering
      if (tc.exiting.length || tc.entering.length) return undefined;

      // If to/from path lengths differ
      if (tc.to.length !== tc.from.length) return undefined;
      // If the to/from paths are different
      const pathsDiffer = arrayTuples(tc.to, tc.from)
        .map((tuple) => tuple[0].state !== tuple[1].state)
        .reduce(anyTrueR, false);

      if (pathsDiffer) return undefined;
      // Find any parameter values that differ
      const nodeSchemas = tc.to.map((node) => node.paramSchema);

      const [toValues, fromValues] = [tc.to, tc.from].map((path) =>
        path.map((x) => x.paramValues),
      );

      const tuples = arrayTuples(nodeSchemas, toValues, fromValues);

      return tuples
        .map(([schema, toVals, fromVals]) =>
          Param.changed(schema, toVals, fromVals),
        )
        .reduce(unnestR, []);
    }

    /**
     * Returns true if the transition is dynamic.
     *
     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.
     *
     * @returns true if the Transition is dynamic
     */
    dynamic() {
      const changes = this._changedParams();

      return !changes
        ? false
        : changes.map((x) => x.dynamic).reduce(anyTrueR, false);
    }

    /**
     * Returns true if the transition is ignored.
     *
     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.
     *
     * @returns true if the Transition is ignored.
     */
    ignored() {
      return !!this._ignoredReason();
    }

    _ignoredReason() {
      const pending = this._globals.transition;

      const { reloadState } = this._options;

      const same = (pathA, pathB) => {
        if (pathA.length !== pathB.length) return false;
        const matching = PathUtils.matching(pathA, pathB);

        return (
          pathA.length ===
          matching.filter(
            (node) => !reloadState || !node.state.includes[reloadState.name],
          ).length
        );
      };

      const newTC = this._treeChanges;

      const pendTC = pending && pending._treeChanges;

      if (
        pendTC &&
        same(pendTC.to, newTC.to) &&
        same(pendTC.exiting, newTC.exiting)
      )
        return "SameAsPending";

      if (
        newTC.exiting.length === 0 &&
        newTC.entering.length === 0 &&
        same(newTC.from, newTC.to)
      )
        return "SameAsCurrent";

      return undefined;
    }

    /**
     * Runs the transition
     *
     * This method is generally called from the [[StateService.transitionTo]]
     *
     * @internal
     *
     * @returns {Promise} a promise for a successful transition.
     */
    run() {
      // Gets transition hooks array for the given phase
      const getHooksFor = (phase) => this._hookBuilder.buildHooksForPhase(phase);

      // When the chain is complete, then resolve or reject the deferred
      const transitionSuccess = () => {
        trace.traceSuccess(this.$to(), this);
        this.success = true;
        this._deferred.resolve(this.to());
        const hooks = this._hookBuilder.buildHooksForPhase(
          TransitionHookPhase._SUCCESS,
        );

        hooks.forEach((hook) => {
          hook.invokeHook();
        });
      };

      const transitionError = (reason) => {
        trace.traceError(reason, this);
        this.success = false;
        this._deferred.reject(reason);
        this._error = reason;
        const hooks = getHooksFor(TransitionHookPhase._ERROR);

        hooks.forEach((hook) => hook.invokeHook());
      };

      const runTransition = () => {
        // Wait to build the RUN hook chain until the BEFORE hooks are done
        // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.
        const allRunHooks = getHooksFor(TransitionHookPhase._RUN);

        const resolved = Promise.resolve();

        return TransitionHook.invokeHooks(allRunHooks, () => resolved);
      };

      const startTransition = () => {
        const { _globals } = this;

        _globals.lastStartedTransitionId = this.$id;
        _globals.transition = this;
        _globals.transitionHistory.enqueue(this);
        trace.traceTransitionStart(this);

        return Promise.resolve();
      };

      const allBeforeHooks = getHooksFor(TransitionHookPhase._BEFORE);

      TransitionHook.invokeHooks(allBeforeHooks, startTransition)
        .then(runTransition)
        .then(transitionSuccess, transitionError);

      return this.promise;
    }

    /**
     * Checks if the Transition is valid
     *
     * @returns true if the Transition is valid
     */
    valid() {
      return !this.error() || this.success !== undefined;
    }

    /**
     * Aborts this transition
     *
     * Imperative API to abort a Transition.
     * This only applies to Transitions that are not yet complete.
     */
    abort() {
      // Do not set flag if the transition is already complete
      if (isUndefined(this.success)) {
        this._aborted = true;
      }
    }

    /**
     * The Transition error reason.
     *
     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.
     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.
     *
     * @returns a transition rejection explaining why the transition is invalid, or the reason the transition failed.
     */
    error() {
      const state = this.$to();

      if (state.self.abstract) {
        return Rejection.invalid(
          `Cannot transition to abstract state '${state.name}'`,
        );
      }
      const paramDefs = state.parameters();

      const values = this.params();

      const invalidParams = paramDefs.filter(
        (param) => !param.validates(values[param.id]),
      );

      if (invalidParams.length) {
        const invalidValues = invalidParams
          .map((param) => `[${param.id}:${stringify(values[param.id])}]`)
          .join(", ");

        const detail = `The following parameter values are not valid for state '${state.name}': ${invalidValues}`;

        return Rejection.invalid(detail);
      }

      if (this.success === false) return this._error;

      return undefined;
    }

    /**
     * A string representation of the Transition
     *
     * @returns A string representation of the Transition
     */
    toString() {
      const fromStateOrName = this.from();

      const toStateOrName = this.to();

      const avoidEmptyHash = (params) =>
        params["#"] !== null && params["#"] !== undefined
          ? params
          : omit(params, ["#"]);

      // (X) means the to state is invalid.
      const id = this.$id,
        from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName,
        fromParams = stringify(
          avoidEmptyHash(
            this._treeChanges.from
              .map((x) => x.paramValues)
              .reduce((acc, obj) => ({ ...acc, ...obj }), {}),
          ),
        ),
        toValid = this.valid() ? "" : "(X) ",
        to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName,
        toParams = stringify(avoidEmptyHash(this.params()));

      return `Transition#${id}( '${from}'${fromParams} -> ${toValid}'${to}'${toParams} )`;
    }
  }

  Transition.diToken = Transition;

  function registerAddCoreResolvables(transitionService) {
    transitionService.onCreate({}, function addCoreResolvables(trans) {
      trans.addResolvable(Resolvable.fromData(Transition, trans), "");
      trans.addResolvable(Resolvable.fromData("$transition$", trans), "");
      trans.addResolvable(
        Resolvable.fromData("$stateParams", trans.params()),
        "",
      );
      trans.entering().forEach((state) => {
        trans.addResolvable(Resolvable.fromData("$state$", state), state);
      });
    });
  }

  const TRANSITION_TOKENS = ["$transition$", Transition];

  // References to Transition in the treeChanges pathnodes makes all
  // previous Transitions reachable in memory, causing a memory leak
  // This function removes resolves for '$transition$' and `Transition` from the treeChanges.
  // Do not use this on current transitions, only on old ones.
  function treeChangesCleanup(trans) {
    const nodes = Object.values(trans.treeChanges())
      .reduce(unnestR, [])
      .reduce(uniqR, []);

    // If the resolvable is a Transition, return a new resolvable with null data
    const replaceTransitionWithNull = (resolve) => {
      return TRANSITION_TOKENS.includes(resolve.token)
        ? Resolvable.fromData(resolve.token, null)
        : resolve;
    };

    nodes.forEach((node) => {
      node.resolvables = node.resolvables.map(replaceTransitionWithNull);
    });
  }

  /**
   * A factory which creates an onEnter, onExit or onRetain transition hook function
   *
   * The returned function invokes the (for instance) state.onEnter hook when the
   * state is being entered.
   */
  function makeEnterExitRetainHook(hookName) {
    return (transition, state) => {
      const _state = state.$$state();

      const hookFn = _state[hookName];

      return hookFn(transition, state);
    };
  }
  /**
   * The [[TransitionStateHookFn]] for onExit
   *
   * When the state is being exited, the state's .onExit function is invoked.
   *
   * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`
   *
   * See: [[HookRegistry.onExit]]
   */
  const onExitHook = makeEnterExitRetainHook("onExit");

  const registerOnExitHook = (transitionService) =>
    transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);
  /**
   * The [[TransitionStateHookFn]] for onRetain
   *
   * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.
   *
   * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`
   *
   * See: [[HookRegistry.onRetain]]
   */
  const onRetainHook = makeEnterExitRetainHook("onRetain");

  const registerOnRetainHook = (transitionService) =>
    transitionService.onRetain(
      { retained: (state) => !!state.onRetain },
      onRetainHook,
    );
  /**
   * The [[TransitionStateHookFn]] for onEnter
   *
   * When the state is being entered, the state's .onEnter function is invoked.
   *
   * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`
   *
   * See: [[HookRegistry.onEnter]]
   */
  const onEnterHook = makeEnterExitRetainHook("onEnter");

  const registerOnEnterHook = (transitionService) =>
    transitionService.onEnter(
      { entering: (state) => !!state.onEnter },
      onEnterHook,
    );

  const RESOLVE_HOOK_PRIORITY = 1000;
  /**
   * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path
   *
   * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`
   *
   * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.
   *
   * See [[StateDeclaration.resolve]]
   */
  const eagerResolvePath = (trans) =>
    new ResolveContext(trans.treeChanges().to)
      .resolvePath("EAGER", trans)
      .then(() => {
        /* empty */
      });

  const registerEagerResolvePath = (transitionService) =>
    transitionService.onStart({}, eagerResolvePath, {
      priority: RESOLVE_HOOK_PRIORITY,
    });
  /**
   * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path
   *
   * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`
   *
   * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.
   *
   * See [[StateDeclaration.resolve]]
   */
  const lazyResolveState = (trans, state) =>
    new ResolveContext(trans.treeChanges().to)
      .subContext(state.$$state())
      .resolvePath("LAZY", trans)
      .then(() => {
        /* empty */
      });

  const registerLazyResolveState = (transitionService) =>
    transitionService.onEnter({ entering: val(true) }, lazyResolveState, {
      priority: RESOLVE_HOOK_PRIORITY,
    });
  /**
   * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.
   *
   * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`
   *
   * After all entering states have been entered, this hook resolves any remaining Resolvables.
   * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].
   *
   * See [[StateDeclaration.resolve]]
   */
  const resolveRemaining = (trans) =>
    new ResolveContext(trans.treeChanges().to)
      .resolvePath("LAZY", trans)
      .then(() => {
        /* empty */
      });

  const registerResolveRemaining = (transitionService) =>
    transitionService.onFinish({}, resolveRemaining, {
      priority: RESOLVE_HOOK_PRIORITY,
    });

  /**
   * A [[TransitionHookFn]] which waits for the views to load
   *
   * Registered using `transitionService.onStart({}, loadEnteringViews);`
   *
   * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.
   * In angular 1, this includes loading the templates.
   */
  const loadEnteringViews = (transition) => {
    const enteringViews = transition.views("entering");

    if (!enteringViews.length) return undefined;

    return Promise.all(
      enteringViews.map((view) => Promise.resolve(view.load())),
    ).then(() => {
      /* empty */
    });
  };

  const registerLoadEnteringViews = (transitionService) =>
    transitionService.onFinish({}, loadEnteringViews);

  const registerActivateViews = (transitionService, viewService) => {
    /**
     * A [[TransitionHookFn]] which activates the new views when a transition is successful.
     *
     * Registered using `transitionService.onSuccess({}, activateViews);`
     *
     * After a transition is complete, this hook deactivates the old views from the previous state,
     * and activates the new views from the destination state.
     *
     * See [[ViewService]]
     */
    const activateViews = (transition) => {
      const enteringViews = transition.views("entering");

      const exitingViews = transition.views("exiting");

      if (!enteringViews.length && !exitingViews.length) return;
      exitingViews.forEach((vc) => viewService.deactivateViewConfig(vc));
      enteringViews.forEach((vc) => {
        viewService.activateViewConfig(vc);
      });
      viewService.sync();
    };

    transitionService.onSuccess({}, activateViews);
  };

  /**
   * A [[TransitionHookFn]] which updates global ng-router state
   *
   * Registered using `transitionService.onBefore({}, updateGlobalState);`
   *
   * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).
   * After a successful [[Transition]], updates the global values of "the current state"
   * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).
   *
   * See also the deprecated properties:
   * [[StateService.transition]], [[StateService.current]], [[StateService.params]]
   *
   * @param {import('../transition/transition.js').Transition} trans
   */
  const updateGlobalState = (trans) => {
    const globals = trans._globals;

    const transitionSuccessful = () => {
      globals.successfulTransitions.enqueue(trans);
      globals.$current = trans.$to();
      globals.current = globals.$current.self;
      copy(trans.params(), globals.params);
    };

    const clearCurrentTransition = () => {
      // Do not clear globals.transition if a different transition has started in the meantime
      if (globals.transition === trans) globals.transition = null;
    };

    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });
    trans.promise.then(clearCurrentTransition, clearCurrentTransition);
  };

  const registerUpdateGlobalState = (transitionService) =>
    transitionService.onCreate({}, updateGlobalState);

  /**
   * A [[TransitionHookFn]] that performs lazy loading
   *
   * When entering a state "abc" which has a `lazyLoad` function defined:
   * - Invoke the `lazyLoad` function (unless it is already in process)
   *   - Flag the hook function as "in process"
   *   - The function should return a promise (that resolves when lazy loading is complete)
   * - Wait for the promise to settle
   *   - If the promise resolves to a [[LazyLoadResult]], then register those states
   *   - Flag the hook function as "not in process"
   * - If the hook was successful
   *   - Remove the `lazyLoad` function from the state declaration
   * - If all the hooks were successful
   *   - Retry the transition (by returning a TargetState)
   *
   * ```
   * .state('abc', {
   *   component: 'fooComponent',
   *   lazyLoad: () => import('./fooComponent')
   *   });
   * ```
   *
   * See [[StateDeclaration.lazyLoad]]
   */
  function registerLazyLoadHook(
    transitionService,
    stateService,
    urlService,
    stateRegistry,
  ) {
    return transitionService.onBefore(
      { entering: (state) => !!state.lazyLoad },
      (transition) => {
        function retryTransition() {
          if (transition.originalTransition().options().source !== "url") {
            // The original transition was not triggered via url sync
            // The lazy state should be loaded now, so re-try the original transition
            const orig = transition.targetState();

            return stateService.target(
              orig.identifier(),
              orig.params(),
              orig.options(),
            );
          }
          // The original transition was triggered via url sync
          // Run the URL rules and find the best match
          const result = urlService.match(urlService.parts());

          const rule = result && result.rule;

          // If the best match is a state, redirect the transition (instead
          // of calling sync() which supersedes the current transition)
          if (rule && rule.type === "STATE") {
            const { state } = rule;

            const params = result.match;

            return stateService.target(state, params, transition.options());
          }
          // No matching state found, so let .sync() choose the best non-state match/otherwise
          urlService.sync();

          return undefined;
        }
        const promises = transition
          .entering()
          .filter((state) => !!state.$$state().lazyLoad)
          .map((state) => lazyLoadState(transition, state, stateRegistry));

        return Promise.all(promises).then(retryTransition);
      },
    );
  }

  /**
   * Invokes a state's lazy load function
   *
   * @param transition a Transition context
   * @param state the state to lazy load
   * @returns A promise for the lazy load result
   */
  function lazyLoadState(transition, state, stateRegistry) {
    const lazyLoadFn = state.$$state().lazyLoad;

    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked
    let promise = lazyLoadFn._promise;

    if (!promise) {
      const success = (result) => {
        delete state.lazyLoad;
        delete state.$$state().lazyLoad;
        delete lazyLoadFn._promise;

        return result;
      };

      const error = (err) => {
        delete lazyLoadFn._promise;

        return Promise.reject(err);
      };

      promise = lazyLoadFn._promise = Promise.resolve(
        lazyLoadFn(transition, state),
      )
        .then(updateStateRegistry)
        .then(success, error);
    }
    /** Register any lazy loaded state definitions */
    function updateStateRegistry(result) {
      if (result && isArray(result.states)) {
        result.states.forEach((_state) => stateRegistry.register(_state));
      }

      return result;
    }

    return promise;
  }

  /**
   * This class defines a type of hook, such as `onBefore` or `onEnter`.
   * Plugins can define custom hook types, such as sticky states does for `onInactive`.
   */
  class TransitionEventType {
    constructor(
      name,
      hookPhase,
      hookOrder,
      criteriaMatchPath,
      reverseSort = false,
      getResultHandler = TransitionHook.HANDLE_RESULT,
      getErrorHandler = TransitionHook.REJECT_ERROR,
      synchronous = false,
    ) {
      this.name = name;
      this.hookPhase = hookPhase;
      this.hookOrder = hookOrder;
      this.criteriaMatchPath = criteriaMatchPath;
      this.reverseSort = reverseSort;
      this.getResultHandler = getResultHandler;
      this.getErrorHandler = getErrorHandler;
      this.synchronous = synchronous;
    }
  }

  /**
   * A [[TransitionHookFn]] that skips a transition if it should be ignored
   *
   * This hook is invoked at the end of the onBefore phase.
   *
   * If the transition should be ignored (because no parameter or states changed)
   * then the transition is ignored and not processed.
   * @param {import("../transition/transition.js").Transition} trans
   */
  function ignoredHook(trans) {
    const ignoredReason = trans._ignoredReason();

    if (!ignoredReason) return undefined;
    trace.traceTransitionIgnored(trans);
    const pending = trans._globals.transition;

    // The user clicked a link going back to the *current state* ('A')
    // However, there is also a pending transition in flight (to 'B')
    // Abort the transition to 'B' because the user now wants to be back at 'A'.
    if (ignoredReason === "SameAsCurrent" && pending) {
      pending.abort();
    }

    return Rejection.ignored().toPromise();
  }
  const registerIgnoredTransitionHook = (transitionService) =>
    transitionService.onBefore({}, ignoredHook, { priority: -9999 });

  /**
   * A [[TransitionHookFn]] that rejects the Transition if it is invalid
   *
   * This hook is invoked at the end of the onBefore phase.
   * If the transition is invalid (for example, param values do not validate)
   * then the transition is rejected.
   */
  function invalidTransitionHook(trans) {
    if (!trans.valid()) {
      throw new Error(trans.error().toString());
    }
  }
  const registerInvalidTransitionHook = (transitionService) =>
    transitionService.onBefore({}, invalidTransitionHook, { priority: -1e4 });

  const registerRedirectToHook = (transitionService, stateService) => {
    /**
     * A [[TransitionHookFn]] that redirects to a different state or params
     *
     * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`
     *
     * See [[StateDeclaration.redirectTo]]
     */
    const redirectToHook = (trans) => {
      const redirect = trans.to().redirectTo;

      if (!redirect) return undefined;
      const $state = stateService;

      function handleResult(result) {
        if (!result) return undefined;

        if (result instanceof TargetState) {
          return result;
        }

        if (isString(result)) {
          return $state.target(result, trans.params(), trans.options());
        }

        if (result.state || result.params) {
          return $state.target(
            result.state || trans.to(),
            result.params || trans.params(),
            trans.options(),
          );
        }

        return undefined;
      }

      if (isFunction(redirect)) {
        return Promise.resolve(redirect(trans)).then(handleResult);
      }

      return handleResult(redirect);
    };

    transitionService.onStart(
      { to: (state) => !!state.redirectTo },
      redirectToHook,
    );
  };

  const registerUpdateUrl = (
    transitionService,
    stateService,
    urlService,
  ) => {
    /**
     * A [[TransitionHookFn]] which updates the URL after a successful transition
     *
     * Registered using `transitionService.onSuccess({}, updateUrl);`
     */
    const updateUrl = (transition) => {
      const options = transition.options();

      const $state = stateService;

      // Dont update the url in these situations:
      // The transition was triggered by a URL sync (options.source === 'url')
      // The user doesn't want the url to update (options.location === false)
      // The destination state, and all parents have no navigable url
      if (
        options.source !== "url" &&
        options.location &&
        $state.$current.navigable
      ) {
        const urlOptions = { replace: options.location === "replace" };

        urlService.push(
          $state.$current.navigable.url,
          $state.globals.params,
          urlOptions,
        );
      }
      urlService.update(true);
    };

    transitionService.onSuccess({}, updateUrl, { priority: 9999 });
  };

  /**
   * The default [[Transition]] options.
   *
   * Include this object when applying custom defaults:
   * let reloadOpts = { reload: true, notify: true }
   * let options = defaults(theirOpts, customDefaults, defaultOptions);
   */
  const defaultTransOpts = {
    location: true,
    relative: null,
    inherit: false,
    notify: true,
    reload: false,
    supercede: true,
    custom: {},
    current: () => null,
    source: "unknown",
  };
  /**
   * This class provides services related to Transitions.
   *
   * - Most importantly, it allows global Transition Hooks to be registered.
   * - It allows the default transition error handler to be set.
   * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).
   *
   * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.
   *
   * This API is located at `router.transitionService` ([[UIRouter.transitionService]])
   */
  class TransitionProvider {
    /* @ignore */ static $inject = provider([
      $injectTokens._router,
      $injectTokens._view,
      $injectTokens._exceptionHandler,
    ]);

    /**
     * @param {ng.RouterService} globals
     * @param {ng.ViewService} viewService
     * @param {ng.ExceptionHandlerProvider} $exceptionHandler
     */
    constructor(globals, viewService, $exceptionHandler) {
      this._transitionCount = 0;
      /** The transition hook types, such as `onEnter`, `onStart`, etc */
      this._eventTypes = [];
      /** @internal The registered transition hooks */
      this._registeredHooks = {};
      /** The  paths on a criteria object */
      this._criteriaPaths = {};
      this.globals = globals;
      this.$view = viewService;
      this._deregisterHookFns = {};
      this._defineCorePaths();
      this._defineCoreEvents();
      this._registerCoreTransitionHooks();

      /** @type {ng.ExceptionHandlerService} */
      this._$exceptionHandler = $exceptionHandler.handler;
      globals.successfulTransitions.onEvict(treeChangesCleanup);
    }

    $get = [
      $injectTokens._state,
      $injectTokens._url,
      $injectTokens._stateRegistry,
      $injectTokens._view,
      (stateService, urlService, stateRegistry, viewService) => {
        // Lazy load state trees
        this._deregisterHookFns.lazyLoad = registerLazyLoadHook(
          this,
          stateService,
          urlService,
          stateRegistry,
        );

        // After globals.current is updated at priority: 10000
        this._deregisterHookFns.updateUrl = registerUpdateUrl(
          this,
          stateService,
          urlService,
        );

        // Wire up redirectTo hook
        this._deregisterHookFns.redirectTo = registerRedirectToHook(
          this,
          stateService,
        );

        this._deregisterHookFns.activateViews = registerActivateViews(
          this,
          viewService,
        );

        return this;
      },
    ];
    /**
     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.
     *
     * Registers a transition lifecycle hook, which is invoked during transition construction.
     *
     * This low level hook should only be used by plugins.
     * This can be a useful time for plugins to add resolves or mutate the transition as needed.
     * The Sticky States plugin uses this hook to modify the treechanges.
     *
     * ### Lifecycle
     *
     * `onCreate` hooks are invoked *while a transition is being constructed*.
     *
     * ### Return value
     *
     * The hook's return value is ignored
     *
     * @internal
     * @param criteria defines which Transitions the Hook should be invoked for.
     * @param callback the hook function which will be invoked.
     * @param options the registration options
     * @returns a function which deregisters the hook.
     */

    /**
     * Creates a new [[Transition]] object
     *
     * This is a factory function for creating new Transition objects.
     * It is used internally by the [[StateService]] and should generally not be called by application code.
     *
     * @internal
     * @param fromPath the path to the current state (the from state)
     * @param targetState the target state (destination)
     * @returns a Transition
     */
    create(fromPath, targetState) {
      return new Transition(fromPath, targetState, this, this.globals);
    }

    _defineCoreEvents() {
      const TH = TransitionHook;

      const paths = this._criteriaPaths;

      const NORMAL_SORT = false,
        REVERSE_SORT = true;

      const SYNCHRONOUS = true;

      this._defineEvent(
        "onCreate",
        TransitionHookPhase._CREATE,
        0,
        paths.to,
        NORMAL_SORT,
        TH.LOG_REJECTED_RESULT,
        TH.THROW_ERROR,
        SYNCHRONOUS,
      );
      this._defineEvent("onBefore", TransitionHookPhase._BEFORE, 0, paths.to);
      this._defineEvent("onStart", TransitionHookPhase._RUN, 0, paths.to);
      this._defineEvent(
        "onExit",
        TransitionHookPhase._RUN,
        100,
        paths.exiting,
        REVERSE_SORT,
      );
      this._defineEvent(
        "onRetain",
        TransitionHookPhase._RUN,
        200,
        paths.retained,
      );
      this._defineEvent("onEnter", TransitionHookPhase._RUN, 300, paths.entering);
      this._defineEvent("onFinish", TransitionHookPhase._RUN, 400, paths.to);
      this._defineEvent(
        "onSuccess",
        TransitionHookPhase._SUCCESS,
        0,
        paths.to,
        NORMAL_SORT,
        TH.LOG_REJECTED_RESULT,
        TH.LOG_ERROR,
        SYNCHRONOUS,
      );
      this._defineEvent(
        "onError",
        TransitionHookPhase._ERROR,
        0,
        paths.to,
        NORMAL_SORT,
        TH.LOG_REJECTED_RESULT,
        TH.LOG_ERROR,
        SYNCHRONOUS,
      );
    }

    _defineCorePaths() {
      const { _STATE: STATE, _TRANSITION: TRANSITION } = TransitionHookScope;

      this._definePathType("to", TRANSITION);
      this._definePathType("from", TRANSITION);
      this._definePathType("exiting", STATE);
      this._definePathType("retained", STATE);
      this._definePathType("entering", STATE);
    }

    _defineEvent(
      name,
      hookPhase,
      hookOrder,
      criteriaMatchPath,
      reverseSort = false,
      getResultHandler = TransitionHook.HANDLE_RESULT,
      getErrorHandler = TransitionHook.REJECT_ERROR,
      synchronous = false,
    ) {
      const eventType = new TransitionEventType(
        name,
        hookPhase,
        hookOrder,
        criteriaMatchPath,
        reverseSort,
        getResultHandler,
        getErrorHandler,
        synchronous,
      );

      this._eventTypes.push(eventType);
      makeEvent(this, this, eventType);
    }

    /**
     * @param {TransitionHookPhase} [phase]
     * @return {any[]}
     */
    _getEvents(phase) {
      const transitionHookTypes = isDefined(phase)
        ? this._eventTypes.filter((type) => type.hookPhase === phase)
        : this._eventTypes.slice();

      return transitionHookTypes.sort((left, right) => {
        const cmpByPhase = left.hookPhase - right.hookPhase;

        return cmpByPhase === 0 ? left.hookOrder - right.hookOrder : cmpByPhase;
      });
    }

    /**
     * Adds a Path to be used as a criterion against a TreeChanges path
     *
     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.
     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`
     * Each state in the exiting path is checked against the criteria and returned as part of the match.
     *
     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.
     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`
     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.
     *
     * @internal
     */
    _definePathType(name, hookScope) {
      this._criteriaPaths[name] = { name, scope: hookScope };
    }

    _getPathTypes() {
      return this._criteriaPaths;
    }

    getHooks(hookName) {
      return this._registeredHooks[hookName];
    }

    _registerCoreTransitionHooks() {
      const fns = this._deregisterHookFns;

      fns.addCoreResolves = registerAddCoreResolvables(this);
      fns.ignored = registerIgnoredTransitionHook(this);
      fns.invalid = registerInvalidTransitionHook(this);

      // Wire up onExit/Retain/Enter state hooks
      fns.onExit = registerOnExitHook(this);
      fns.onRetain = registerOnRetainHook(this);
      fns.onEnter = registerOnEnterHook(this);
      // Wire up Resolve hooks
      fns.eagerResolve = registerEagerResolvePath(this);
      fns.lazyResolve = registerLazyResolveState(this);
      fns.resolveAll = registerResolveRemaining(this);
      // Wire up the View management hooks
      fns.loadViews = registerLoadEnteringViews(this);

      // Updates global state after a transition
      fns.updateGlobals = registerUpdateGlobalState(this);
      // Lazy load state trees
      fns.lazyLoad = registerLazyLoadHook(this);
    }
  }

  const stdErr = minErr("$stateProvider");

  /**
   * Provides services related to ng-router states.
   *
   * This API is located at `router.stateService` ([[UIRouter.stateService]])
   */
  class StateProvider {
    /**
     * The latest successful state parameters
     *
     * @deprecated This is a passthrough through to [[Router.params]]
     */
    get params() {
      return this.globals.params;
    }

    /**
     * The current [[StateDeclaration]]
     *
     * @deprecated This is a passthrough through to [[Router.current]]
     */
    get current() {
      return this.globals.current;
    }

    /**
     * The current [[StateObject]] (an internal API)
     *
     * @deprecated This is a passthrough through to [[Router.$current]]
     */
    get $current() {
      return this.globals.$current;
    }

    /* @ignore */ static $inject = provider([
      $injectTokens._router,
      $injectTokens._transitions,
      $injectTokens._exceptionHandler,
    ]);

    /**
     *
     * @param {ng.RouterProvider} globals
     * @param {ng.TransitionProvider} transitionService
     * @param {ng.ExceptionHandlerProvider} exceptionHandlerProvider
     */
    constructor(globals, transitionService, exceptionHandlerProvider) {
      this.globals = globals;
      this.transitionService = transitionService;
      this.stateRegistry = undefined;

      /** @type {ng.UrlService} */
      this.urlService = undefined;
      /** @type {ng.InjectorService} */
      this.$injector = undefined;
      this.invalidCallbacks = [];

      /** @type {ng.ExceptionHandlerService} */
      this._defaultErrorHandler = exceptionHandlerProvider.handler;
    }

    $get = [
      $injectTokens._injector,
      $injectTokens._url,
      /**
       * @param {ng.InjectorService} $injector
       * @returns {StateProvider}
       */
      ($injector, $url) => {
        this.urlService = $url;
        this.$injector = $injector;

        return this;
      },
    ];

    /**
     * Decorates states when they are registered
     *
     * Allows you to extend (carefully) or override (at your own peril) the
     * `stateBuilder` object used internally by [[StateRegistry]].
     * This can be used to add custom functionality to ng-router,
     * for example inferring templateUrl based on the state name.
     *
     * When passing only a name, it returns the current (original or decorated) builder
     * function that matches `name`.
     *
     * The builder functions that can be decorated are listed below. Though not all
     * necessarily have a good use case for decoration, that is up to you to decide.
     *
     * In addition, users can attach custom decorators, which will generate new
     * properties within the state's internal definition. There is currently no clear
     * use-case for this beyond accessing internal states (i.e. $state.$current),
     * however, expect this to become increasingly relevant as we introduce additional
     * meta-programming features.
     *
     * **Warning**: Decorators should not be interdependent because the order of
     * execution of the builder functions in non-deterministic. Builder functions
     * should only be dependent on the state definition object and super function.
     *
     *
     * Existing builder functions and current return values:
     *
     * - **parent** `{object}` - returns the parent state object.
     * - **data** `{object}` - returns state data, including any inherited data that is not
     *   overridden by own values (if any).
     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
     *   or `null`.
     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is
     *   navigable).
     * - **params** `{object}` - returns an array of state params that are ensured to
     *   be a super-set of parent's params.
     * - **views** `{object}` - returns a views object where each key is an absolute view
     *   name (i.e. "viewName@stateName") and each value is the urlConfig object
     *   (template, controller) for the view. Even when you don't use the views object
     *   explicitly on a state urlConfig, one is still created for you internally.
     *   So by decorating this builder function you have access to decorating template
     *   and controller properties.
     * - **ownParams** `{object}` - returns an array of params that belong to the state,
     *   not including any params defined by ancestor states.
     * - **path** `{string}` - returns the full path from the root down to this state.
     *   Needed for state activation.
     * - **includes** `{object}` - returns an object that includes every state that
     *   would pass a `$state.includes()` test.
     *
     * #### Example:
     * Override the internal 'views' builder with a function that takes the state
     * definition, and a reference to the internal function being overridden:
     * ```js
     * $stateProvider.decorator('views', function (state, parent) {
     *   let result = {},
     *       views = parent(state);
     *
     *   angular.forEach(views, function (urlConfig, name) {
     *     let autoName = (state.name + '.' + name).replace('.', '/');
     *     urlConfig.templateUrl = urlConfig.templateUrl || '/partials/' + autoName + '.html';
     *     result[name] = urlConfig;
     *   });
     *   return result;
     * });
     *
     * $stateProvider.state('home', {
     *   views: {
     *     'contact.list': { controller: 'ListController' },
     *     'contact.item': { controller: 'ItemController' }
     *   }
     * });
     * ```
     *
     *
     * ```js
     * // Auto-populates list and item views with /partials/home/contact/list.html,
     * // and /partials/home/contact/item.html, respectively.
     * $state.go('home');
     * ```
     *
     * @param {string} name The name of the builder function to decorate.
     * @param {object} func A function that is responsible for decorating the original
     * builder function. The function receives two parameters:
     *
     *   - `{object}` - state - The state urlConfig object.
     *   - `{object}` - super - The original builder function.
     *
     * @return {object} $stateProvider - $stateProvider instance
     */
    decorator(name, func) {
      return this.stateRegistry.decorator(name, func) || this;
    }

    /**
     *
     * @param {import("./interface.ts").StateDeclaration} definition
     */
    state(definition) {
      if (!definition.name) {
        throw stdErr("stateinvalid", `'name' required`);
      }

      try {
        this.stateRegistry.register(definition);
      } catch (err) {
        throw stdErr("stateinvalid", err.message);
      }

      return this;
    }

    /**
     * Handler for when [[transitionTo]] is called with an invalid state.
     *
     * Invokes the [[onInvalid]] callbacks, in natural order.
     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.
     * The results of the callbacks are wrapped in Promise.resolve(), so the callbacks may return promises.
     *
     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.
     *
     * @internal
     */
    _handleInvalidTargetState(fromPath, toState) {
      const fromState = makeTargetState(this.stateRegistry, fromPath);

      const { globals } = this;

      const latestThing = () => globals.transitionHistory.peekTail();

      const latest = latestThing();

      /** @type {Queue<Function>} */
      const callbackQueue = new Queue(this.invalidCallbacks.slice());

      const injector = this.$injector;

      const checkForRedirect = (result) => {
        if (!(result instanceof TargetState)) {
          return undefined;
        }
        let target = result;

        // Recreate the TargetState, in case the state is now defined.
        target = this.target(
          target.identifier(),
          target.params(),
          target.options(),
        );

        if (!target.valid()) {
          return Rejection.invalid(target.error()).toPromise();
        }

        if (latestThing() !== latest) {
          return Rejection.superseded().toPromise();
        }

        return this.transitionTo(
          target.identifier(),
          target.params(),
          target.options(),
        );
      };

      function invokeNextCallback() {
        const nextCallback = callbackQueue.dequeue();

        if (nextCallback === undefined)
          return Rejection.invalid(toState.error()).toPromise();
        const callbackResult = Promise.resolve(
          nextCallback(toState, fromState, injector),
        );

        return callbackResult
          .then(checkForRedirect)
          .then((result) => result || invokeNextCallback());
      }

      return invokeNextCallback();
    }

    /**
     * Registers an Invalid State handler
     *
     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]
     * has been called with an invalid state reference parameter
     *
     * Example:
     * ```js
     * stateService.onInvalid(function(to, from, injector) {
     *   if (to.name() === 'foo') {
     *     let lazyLoader = injector.get('LazyLoadService');
     *     return lazyLoader.load('foo')
     *         .then(() => stateService.target('foo'));
     *   }
     * });
     * ```
     *
     * @param {function} callback invoked when the toState is invalid
     *   This function receives the (invalid) toState, the fromState, and an injector.
     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.
     *   If one is returned, it is treated as a redirect.
     *
     * @returns a function which deregisters the callback
     */
    onInvalid(callback) {
      this.invalidCallbacks.push(callback);

      return function deregisterListener() {
        removeFrom(this.invalidCallbacks, callback);
      }.bind(this);
    }

    /**
     * Reloads the current state
     *
     * A method that force reloads the current state, or a partial state hierarchy.
     * All resolves are re-resolved, and components reinstantiated.
     *
     * #### Example:
     * ```js
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * ```
     *
     * Note: `reload()` is just an alias for:
     *
     * ```js
     * $state.transitionTo($state.current, $state.params, {
     *   reload: true, inherit: false
     * });
     * ```
     *
     * @param reloadState A state name or a state object.
     *    If present, this state and all its children will be reloaded, but ancestors will not reload.
     *
     * #### Example:
     * ```js
     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'
     * //and current state is 'contacts.detail.item'
     * let app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     //will reload 'contact.detail' and nested 'contact.detail.item' states
     *     $state.reload('contact.detail');
     *   }
     * });
     * ```
     *
     * @returns A promise representing the state of the new transition. See [[StateService.go]]
     */
    reload(reloadState) {
      return this.transitionTo(this.globals.current, this.globals.params, {
        reload: isDefined(reloadState) ? reloadState : true,
        inherit: false,
        notify: false,
      });
    }

    /**
     * Transition to a different state and/or parameters
     *
     * Convenience method for transitioning to a new state.
     *
     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to
     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.
     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).
     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters
     * inherit from the current parameter values (because of `inherit: true`).
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to Absolute state name, state object, or relative state path (relative to current state).
     *
     * Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to the parent state
     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state
     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state
     *
     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.
     *
     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).
     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.
     *
     * @param options Transition options
     *
     * @returns {promise} A promise representing the state of the new transition.
     */
    go(to, params, options) {
      const defautGoOpts = { relative: this.$current, inherit: true };

      const transOpts = defaults(options, defautGoOpts, defaultTransOpts);

      return this.transitionTo(to, params, transOpts);
    }

    /**
     * Creates a [[TargetState]]
     *
     * This is a factory method for creating a TargetState
     *
     * This may be returned from a Transition Hook to redirect a transition, for example.
     */
    target(identifier, params, options = {}) {
      // If we're reloading, find the state object to reload from
      if (isObject(options.reload) && !options.reload.name)
        throw new Error("Invalid reload state object");
      const reg = this.stateRegistry;

      options.reloadState =
        options.reload === true
          ? reg.root()
          : reg.matcher.find(options.reload, options.relative);

      if (options.reload && !options.reloadState)
        throw new Error(
          `No such reload state '${isString(options.reload) ? options.reload : options.reload.name}'`,
        );

      return new TargetState(this.stateRegistry, identifier, params, options);
    }

    getCurrentPath() {
      const { globals } = this;

      const latestSuccess = globals.successfulTransitions.peekTail();

      const rootPath = () => [new PathNode(this.stateRegistry.root())];

      return latestSuccess ? latestSuccess._treeChanges.to : rootPath();
    }

    /**
     * Low-level method for transitioning to a new state.
     *
     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.
     *
     * #### Example:
     * ```js
     * let app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * ```
     *
     * @param to State name or state object.
     * @param toParams A map of the parameters that will be sent to the state,
     *      will populate $stateParams.
     * @param options Transition options
     *
     * @returns A promise representing the state of the new transition. See [[go]]
     */
    transitionTo(to, toParams = {}, options = {}) {
      options = defaults(options, defaultTransOpts);
      const getCurrent = () => this.globals.transition;

      options = Object.assign(options, { current: getCurrent });
      const ref = this.target(to, toParams, options);

      const currentPath = this.getCurrentPath();

      if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);

      if (!ref.valid()) return silentRejection(ref.error());

      if (options.supercede === false && getCurrent()) {
        return Rejection.ignored(
          "Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.",
        ).toPromise();
      }
      /**
       * Special handling for Ignored, Aborted, and Redirected transitions
       *
       * The semantics for the transition.run() promise and the StateService.transitionTo()
       * promise differ. For instance, the run() promise may be rejected because it was
       * IGNORED, but the transitionTo() promise is resolved because from the user perspective
       * no error occurred.  Likewise, the transition.run() promise may be rejected because of
       * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.
       */
      const rejectedTransitionHandler = (trans) => (error) => {
        if (error instanceof Rejection) {
          const isLatest = this.globals.lastStartedTransitionId <= trans.$id;

          if (error.type === RejectType._IGNORED) {
            isLatest && this.urlService.update();

            // Consider ignored `Transition.run()` as a successful `transitionTo`
            return Promise.resolve(this.globals.current);
          }
          const { detail } = error;

          if (
            error.type === RejectType._SUPERSEDED &&
            error.redirected &&
            detail instanceof TargetState
          ) {
            // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully
            // by returning the promise for the new (redirect) `Transition.run()`.
            const redirect = trans.redirect(detail);

            return redirect.run().catch(rejectedTransitionHandler(redirect));
          }

          if (error.type === RejectType._ABORTED) {
            isLatest && this.urlService.update();

            return Promise.reject(error);
          }
        }
        const errorHandler = this.defaultErrorHandler();

        errorHandler(error);

        return Promise.reject(error);
      };

      const transition = this.transitionService.create(currentPath, ref);

      const transitionToPromise = transition
        .run()
        .catch(rejectedTransitionHandler(transition));

      silenceUncaughtInPromise(transitionToPromise); // issue #2676

      // Return a promise for the transition, which also has the transition object on it.
      return Object.assign(transitionToPromise, { transition });
    }

    /**
     * Checks if the current state *is* the provided state
     *
     * Similar to [[includes]] but only checks for the full state name.
     * If params is supplied then it will be tested for strict equality against the current
     * active params object, so all params must match with none missing and no extras.
     *
     * #### Example:
     * ```js
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     * ```
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * ```html
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * ```
     *
     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns Returns true if it is the state.
     */
    is(stateOrName, params, options) {
      options = defaults(options, { relative: this.$current });
      const state = this.stateRegistry.matcher.find(
        stateOrName,
        options.relative,
      );

      if (!isDefined(state)) return undefined;

      if (this.$current !== state) return false;

      if (!params) return true;
      const schema = state.parameters({ inherit: true, matchingKeys: params });

      return Param.equals(
        schema,
        Param.values(schema, params),
        this.globals.params,
      );
    }

    /**
     * Checks if the current state *includes* the provided state
     *
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * #### Example when `$state.$current.name === 'contacts.details.item'`
     * ```js
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     * ```
     *
     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:
     * ```js
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * ```
     *
     * @param stateOrName A partial name, relative name, glob pattern,
     *   or state object to be searched for within the current state name.
     * @param params A param object, e.g. `{sectionId: section.id}`,
     *   that you'd like to test against the current active state.
     * @param options An options object. The options are:
     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will
     *     test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    includes(stateOrName, params, options) {
      options = defaults(options, { relative: this.$current });
      const glob = isString(stateOrName) && Glob.fromString(stateOrName);

      if (glob) {
        if (!glob.matches(this.$current.name)) return false;
        stateOrName = this.$current.name;
      }
      const state = this.stateRegistry.matcher.find(
        stateOrName,
        options.relative,
      );

      const include = this.$current.includes;

      if (!isDefined(state)) return undefined;

      if (!isDefined(include[state.name])) return false;

      if (!params) return true;
      const schema = state.parameters({ inherit: true, matchingKeys: params });

      return Param.equals(
        schema,
        Param.values(schema, params),
        this.globals.params,
      );
    }

    /**
     * Generates a URL for a state and parameters
     *
     * Returns the url for the given state populated with the given params.
     *
     * #### Example:
     * ```js
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * ```
     *
     * @param stateOrName The state name or state object you'd like to generate a url from.
     * @param params An object of parameter values to fill the state's required parameters.
     * @param options Options object. The options are:
     *
     * @returns {string} compiled state url
     */
    href(stateOrName, params, options) {
      const defaultHrefOpts = {
        lossy: true,
        inherit: true,
        absolute: false,
        relative: this.$current,
      };

      options = defaults(options, defaultHrefOpts);
      params = params || {};
      const state = this.stateRegistry.matcher.find(
        stateOrName,
        options.relative,
      );

      if (!isDefined(state)) return null;

      if (options.inherit)
        params = this.globals.params.$inherit(params, this.$current, state);
      const nav = state && options.lossy ? state.navigable : state;

      if (!nav || nav.url === undefined || nav.url === null) {
        return null;
      }

      return this.urlService.href(nav.url, params, {
        absolute: options.absolute,
      });
    }

    /**
     * Sets or gets the default [[transitionTo]] error handler.
     *
     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.
     * This includes errors caused by resolves and transition hooks.
     *
     * Note:
     * This handler does not receive certain Transition rejections.
     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].
     *
     * The built-in default error handler logs the error to the console.
     *
     * You can provide your own custom handler.
     *
     * #### Example:
     * ```js
     * stateService.defaultErrorHandler(function() {
     *   // Do not log transitionTo errors
     * });
     * ```
     *
     * @param handler a global error handler function
     * @returns the current global error handler
     */
    defaultErrorHandler(handler) {
      return (this._defaultErrorHandler = handler || this._defaultErrorHandler);
    }

    get(stateOrName, base) {
      const reg = this.stateRegistry;

      if (arguments.length === 0) return reg.get();

      return reg.get(stateOrName, base || this.$current);
    }

    /**
     * Lazy loads a state
     *
     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.
     *
     * @param stateOrName the state that should be lazy loaded
     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)
     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.
     * This noop transition is not actually run.
     *
     * @returns a promise to lazy load
     */
    lazyLoad(stateOrName, transition) {
      const state = this.get(stateOrName);

      if (!state || !state.lazyLoad)
        throw new Error(`Can not lazy load ${stateOrName}`);
      const currentPath = this.getCurrentPath();

      const target = makeTargetState(this.stateRegistry, currentPath);

      transition =
        transition || this.transitionService.create(currentPath, target);

      return lazyLoadState(transition, state);
    }
  }

  class ViewScrollProvider {
    constructor() {
      this.enabled = false;
    }

    useAnchorScroll() {
      this.enabled = true;
    }

    $get = [
      $injectTokens._anchorScroll,
      /**
       * @param {ng.AnchorScrollObject} $anchorScroll
       * @returns {ng.ViewScrollService}
       */
      ($anchorScroll) => {
        if (this.enabled) {
          return $anchorScroll;
        }

        return async function ($element) {
          validateInstanceOf($element, Element, "$element");

          return setTimeout(() => {
            $element.scrollIntoView(false);
          }, 0);
        };
      },
    ];
  }

  /**
   * @typedef BindingTuple
   * @property {string} name
   * @property {string} type
   */

  /**
   * Service which manages loading of templates from a ViewConfig.
   */
  class TemplateFactoryProvider {
    constructor() {
      /** @type {boolean} */
      this._useHttp = false;
    }

    $get = [
      $injectTokens._http,
      $injectTokens._templateCache,
      $injectTokens._templateRequest,
      $injectTokens._injector,
      /**
       * @param {ng.HttpService} $http
       * @param {ng.TemplateCacheService} $templateCache
       * @param {any} $templateRequest
       * @param {import("../core/di/internal-injector.js").InjectorService} $injector
       * @returns
       */
      ($http, $templateCache, $templateRequest, $injector) => {
        this.$templateRequest = $templateRequest;
        this.$http = $http;
        this.$templateCache = $templateCache;
        this.$injector = $injector;

        return this;
      },
    ];

    /**
     * Forces the provider to use $http service directly
     * @param {boolean} value
     */
    useHttpService(value) {
      this._useHttp = value;
    }

    /**
     * Creates a template from a configuration object.
     *
     * @param config Configuration object for which to load a template.
     * The following properties are search in the specified order, and the first one
     * that is defined is used to create the template:
     *
     * @param {any} config
     * @param {any} params  Parameters to pass to the template function.
     * @param {import("./resolve/resolve-context.js").ResolveContext} context The resolve context associated with the template's view
     *
     * @return {string|object}  The template html as a string, or a promise for
     * that string,or `null` if no template is configured.
     */
    fromConfig(config, params, context) {
      const defaultTemplate = "<ng-view></ng-view>";

      const asTemplate = (result) =>
        Promise.resolve(result).then((str) => ({ template: str }));

      const asComponent = (result) =>
        Promise.resolve(result).then((str) => ({ component: str }));

      const getConfigType = (configParam) => {
        if (isDefined(configParam.template)) return "template";

        if (isDefined(configParam.templateUrl)) return "templateUrl";

        if (isDefined(configParam.templateProvider)) return "templateProvider";

        if (isDefined(configParam.component)) return "component";

        if (isDefined(configParam.componentProvider)) return "componentProvider";

        return "default";
      };

      switch (getConfigType(config)) {
        case "template":
          return asTemplate(this.fromString(config.template, params));
        case "templateUrl":
          return asTemplate(this.fromUrl(config.templateUrl, params));
        case "templateProvider":
          return asTemplate(
            this.fromProvider(config.templateProvider, params, context),
          );
        case "component":
          return asComponent(config.component);
        case "componentProvider":
          return asComponent(
            this.fromComponentProvider(config.componentProvider, context),
          );
        default:
          return asTemplate(defaultTemplate);
      }
    }

    /**
     * Creates a template from a string or a function returning a string.
     *
     * @param {string | Function} template html template as a string or function that returns an html template as a string.
     * @param {any} [params] Parameters to pass to the template function.
     *
     * @return {string|object} The template html as a string, or a promise for that
     * string.
     */
    fromString(template, params) {
      return isFunction(template)
        ? /** @type {Function} */ (template)(params)
        : template;
    }

    /**
     * Loads a template from the a URL via `$http` and `$templateCache`.
     *
     * @param {string|Function} url url of the template to load, or a function
     * that returns a url.
     * @param {Object} params Parameters to pass to the url function.
     * @return {string|Promise.<string>} The template html as a string, or a promise
     * for that string.
     */
    fromUrl(url, params) {
      if (isFunction(url)) url = /** @type {Function} */ (url)(params);

      if (isNullOrUndefined(url)) return null;

      if (this._useHttp) {
        return this.$http
          .get(/** @type {string} */ (url), {
            cache: this.$templateCache,
            headers: { Accept: "text/html" },
          })
          .then(function (response) {
            return response.data;
          });
      }

      return this.$templateRequest(url);
    }

    /**
     * Creates a template by invoking an injectable provider function.
     *
     * @param {import('../interface.ts').Injectable<any>} provider Function to invoke via `locals`
     * @param {Function} params a function used to invoke the template provider
     * @param {import("./resolve/resolve-context.js").ResolveContext} context
     * @return {string|Promise.<string>} The template html as a string, or a promise
     * for that string.
     */
    fromProvider(provider, params, context) {
      const deps = annotate(provider);

      const providerFn = isArray(provider) ? tail(provider) : provider;

      const resolvable = new Resolvable("", providerFn, deps);

      return resolvable.get(context);
    }

    /**
     * Creates a component's template by invoking an injectable provider function.
     *
     * @param {import('../interface.ts').Injectable<any>} provider Function to invoke via `locals`
     * @return {Promise<any>} The template html as a string: "<component-name input1='::$resolve.foo'></component-name>".
     */
    fromComponentProvider(provider, context) {
      const deps = annotate(provider);

      const providerFn = isArray(provider) ? tail(provider) : provider;

      const resolvable = new Resolvable("", providerFn, deps);

      return resolvable.get(context); // https://github.com/angular-ui/ui-router/pull/3165/files
    }

    /**
     * Creates a template from a component's name
     *
     * This implements route-to-component.
     * It works by retrieving the component (directive) metadata from the injector.
     * It analyses the component's bindings, then constructs a template that instantiates the component.
     * The template wires input and output bindings to resolves or from the parent component.
     *
     * @param {any} ngView {object} The parent ng-view (for binding outputs to callbacks)
     * @param {import("./resolve/resolve-context.js").ResolveContext} context The ResolveContext (for binding outputs to callbacks returned from resolves)
     * @param {string} component {string} Component's name in camel case.
     * @param {any} [bindings] An object defining the component's bindings: {foo: '<'}
     * @return {string} The template as a string: "<component-name input1='$resolve.foo'></component-name>".
     */
    makeComponentTemplate(ngView, context, component, bindings) {
      bindings = bindings || {};
      // Bind once prefix
      // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`
      const kebob = (camelCase) => {
        const kebobed = kebobString(camelCase);

        return /^(x|data)-/.exec(kebobed) ? `x-${kebobed}` : kebobed;
      };

      const attributeTpl = /** @param {BindingTuple} input*/ (input) => {
        const { name, type } = input;

        const attrName = kebob(name);

        // If the ng-view has an attribute which matches a binding on the routed component
        // then pass that attribute through to the routed component template.
        // Prefer ng-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`
        if (ngView.getAttribute(attrName) && !bindings[name])
          return `${attrName}='${ngView.getAttribute(attrName)}'`;
        const resolveName = bindings[name] || name;

        // Pre-evaluate the expression for "@" bindings by enclosing in {{ }}
        // some-attr="{{$resolve.someResolveName }}"
        if (type === "@") return `${attrName}='{{s$resolve.${resolveName}}}'`;

        // Wire "&" callbacks to resolves that return a callback function
        // Get the result of the resolve (should be a function) and annotate it to get its arguments.
        // some-attr="$resolve.someResolveResultName(foo, bar)"
        if (type === "&") {
          const res = context.getResolvable(resolveName);

          const fn = res && res.data;

          const args = (fn && annotate(fn)) || [];

          // account for array style injection, i.e., ['foo', function(foo) {}]
          const arrayIdxStr = isArray(fn) ? `[${fn.length - 1}]` : "";

          return `${attrName}='$resolve.${resolveName}${arrayIdxStr}(${args.join(",")})'`;
        }

        // some-attr="::$resolve.someResolveName"
        return `${attrName}='$resolve.${resolveName}'`;
      };

      const attrs = getComponentBindings(this.$injector, component)
        .map(attributeTpl)
        .join(" ");

      const kebobName = kebob(component);

      return `<${kebobName} ${attrs}></${kebobName}>`;
    }
  }

  /**
   * Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')
   */
  function getComponentBindings($injector, name) {
    const cmpDefs = $injector.get(name + DirectiveSuffix); // could be multiple

    if (!cmpDefs || !cmpDefs.length)
      throw new Error(`Unable to find component named '${name}'`);

    return cmpDefs.map(getBindings).reduce(unnestR, []);
  }
  // Given a directive definition, find its object input attributes
  // Use different properties, depending on the type of directive (component, bindToController, normal)
  const getBindings = (def) => {
    if (isObject(def.bindToController))
      return scopeBindings(def.bindToController);

    return scopeBindings(def.scope);
  };

  // for ng 1.2 style, process the scope: { input: "=foo" }
  // for ng 1.3 through ng 1.5, process the component's bindToController: { input: "=foo" } object
  const scopeBindings = (bindingsObj) =>
    Object.keys(bindingsObj || {})
      // [ 'input', [ '=foo', '=', 'foo' ] ]
      .map((key) => [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])])
      // skip malformed values
      .filter((tuple) => isDefined(tuple) && isArray(tuple[1]))
      // { name: ('foo' || 'input'), type: '=' }
      .map((tuple) => ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }));

  function quoteRegExp(str, param) {
    let surroundPattern = ["", ""];

    let result = str.replace(/[\\[\]^$*+?.()|{}]/g, "\\$&");

    if (!param) return result;
    switch (param.squash) {
      case false:
        surroundPattern = ["(", `)${param.isOptional ? "?" : ""}`];
        break;
      case true:
        result = result.replace(/\/$/, "");
        surroundPattern = ["(?:/(", ")|/)?"];
        break;
      default:
        surroundPattern = [`(${param.squash}|`, ")?"];
        break;
    }

    return (
      result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1]
    );
  }
  const memoizeTo = (obj, _prop, fn) => (obj[_prop] = obj[_prop] || fn());

  const splitOnSlash = splitOnDelim("/");

  const defaultConfig = {
    state: { params: {} },
    strict: true,
    caseInsensitive: true,
  };

  /**
   * Matches URLs against patterns.
   *
   * Matches URLs against patterns and extracts named parameters from the path or the search
   * part of the URL.
   *
   * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)
   * parameters. Multiple search parameter names are separated by '&'. Search parameters
   * do not influence whether or not a URL is matched, but their values are passed through into
   * the matched parameters returned by [[UrlMatcher.exec]].
   *
   * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)
   * or colon placeholders (`/somePath/:param`).
   *
   * - *A parameter RegExp* may be defined for a param after a colon
   * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.
   * The regexp must match for the url to be matched.
   * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
   *
   * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].
   *
   * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.
   *   See [[UrlMatcherFactory.type]] for more information.
   *
   * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).
   *   A catch-all * parameter value will contain the remainder of the URL.
   *
   * ---
   *
   * Parameter names may contain only word characters (latin letters, digits, and underscore) and
   * must be unique within the pattern (across both path and search parameters).
   * A path parameter matches any number of characters other than '/'. For catch-all
   * placeholders the path parameter matches any number of characters.
   *
   * Examples:
   *
   * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
   *   trailing slashes, and patterns have to match the entire path, not just a prefix.
   * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
   *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
   * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
   * * `'/user/{id:[^/]*}'` - Same as the previous example.
   * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
   *   parameter consists of 1 to 8 hex digits.
   * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
   *   path into the parameter 'path'.
   * * `'/files/*path'` - ditto.
   * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
   *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start
   *
   */
  class UrlMatcher {
    /** @internal Given a matcher, return an array with the matcher's path segments and path params, in order */
    static pathSegmentsAndParams(matcher) {
      const staticSegments = matcher._segments;

      const pathParams = matcher._params.filter(
        (path) => path.location === DefType._PATH,
      );

      return arrayTuples(staticSegments, pathParams.concat(undefined))
        .reduce(unnestR, [])
        .filter((x) => x !== "" && isDefined(x));
    }

    /** @internal Given a matcher, return an array with the matcher's query params */
    static queryParams(matcher) {
      return matcher._params.filter((path) => path.location === DefType._SEARCH);
    }

    /**
     * Compare two UrlMatchers
     *
     * This comparison function converts a UrlMatcher into static and dynamic path segments.
     * Each static path segment is a static string between a path separator (slash character).
     * Each dynamic segment is a path parameter.
     *
     * The comparison function sorts static segments before dynamic ones.
     */
    static compare(a, b) {
      /**
       * Converts a UrlMatcher and all its parent matchers into a flat array of segments.
       *
       * Each segment is one of:
       *  - A slash literal `'/'`
       *  - A string literal (path segment)
       *  - A `Param` object representing a URL parameter
       *
       * Example:
       * ```js
       * // Matches strings like "/foo/:param/tail"
       * var matcher = $umf.compile("/foo")
       *                  .append($umf.compile("/:param"))
       *                  .append($umf.compile("/"))
       *                  .append($umf.compile("tail"));
       *
       * var result = segments(matcher);
       * // result: [ '/', 'foo', '/', Param, '/', 'tail' ]
       * ```
       *
       * The computed segments are cached in `matcher._cache.segments` for faster future access.
       *
       * @param {UrlMatcher} matcher The matcher object to convert into segments. Must have `_cache.path`.
       * @returns {(string | Param)[]} An array of segments representing the URL pattern.
       */
      const segments = (matcher) =>
        (matcher._cache.segments =
          matcher._cache.segments ||
          matcher._cache.path
            .map(UrlMatcher.pathSegmentsAndParams)
            .reduce(unnestR, [])
            .reduce(joinNeighborsR, [])
            .map((x) => (isString(x) ? splitOnSlash(x) : x))
            .reduce(unnestR, []));

      /**
       * Gets the sort weight for each segment of a UrlMatcher
       *
       * Caches the result as `matcher._cache.weights`
       */
      const weights = (matcher) =>
        (matcher._cache.weights =
          matcher._cache.weights ||
          segments(matcher).map((segment) => {
            // Sort slashes first, then static strings, the Params
            if (segment === "/") return 1;

            if (isString(segment)) return 2;

            if (segment instanceof Param) return 3;

            return undefined;
          }));

      /**
       * Pads shorter array in-place (mutates)
       */
      const padArrays = (left, right, padVal) => {
        const len = Math.max(left.length, right.length);

        while (left.length < len) left.push(padVal);

        while (right.length < len) right.push(padVal);
      };

      const weightsA = weights(a),
        weightsB = weights(b);

      padArrays(weightsA, weightsB, 0);
      const _pairs = arrayTuples(weightsA, weightsB);

      let cmp;

      for (let i = 0, l = _pairs.length; i < l; i++) {
        cmp = _pairs[i][0] - _pairs[i][1];

        if (cmp !== 0) return cmp;
      }

      return 0;
    }

    /**
     * @param pattern The pattern to compile into a matcher.
     * @param paramTypes The [[ParamTypes]] registry
     * @param paramFactory A [[ParamFactory]] object
     * @param config  A [[UrlMatcherCompileConfig]] configuration object
     */
    constructor(pattern, paramTypes, paramFactory, config) {
      this._cache = { path: [/** @type {UrlMatcher} */ (this)] };

      this._children = [];

      this._params = [];

      this._segments = [];

      this._compiled = [];
      this.config = config = defaults(config, defaultConfig);
      this.pattern = pattern;
      // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
      //   '*' name
      //   ':' name
      //   '{' name '}'
      //   '{' name ':' regexp '}'
      // The regular expression is somewhat complicated due to the need to allow curly braces
      // inside the regular expression. The placeholder regexp breaks down as follows:
      //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
      //    \{([\w\[\]]+)(?:\:\s*( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
      //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
      //    [^{}\\]+                       - anything other than curly braces or backslash
      //    \\.                            - a backslash escape
      //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms

      const MAX_REGEX_LENGTH = 200; // or any safe limit

      const placeholder = new RegExp(
        `([:*])([\\w[\\]]+)|\\{([\\w[\\]]+)(?::\\s*((?:[^{}\\\\]{1,${
        MAX_REGEX_LENGTH
      }}|\\\\.|\\{(?:[^{}\\\\]{1,${MAX_REGEX_LENGTH}}|\\\\.)*\\})+))?\\}`,
        "g",
      );

      const searchPlaceholder = new RegExp(
        `([:]?)([\\w[\\].-]+)|\\{([\\w[\\].-]+)(?::\\s*((?:[^{}\\\\]{1,${
        MAX_REGEX_LENGTH
      }}|\\\\.|\\{(?:[^{}\\\\]{1,${MAX_REGEX_LENGTH}}|\\\\.)*\\})+))?\\}`,
        "g",
      );

      const patterns = [];

      let last = 0;

      let matchArray;

      const checkParamErrors = (id) => {
        if (!UrlMatcher.nameValidator.test(id))
          throw new Error(
            `Invalid parameter name '${id}' in pattern '${pattern}'`,
          );

        if (find(this._params, propEq("id", id)))
          throw new Error(
            `Duplicate parameter name '${id}' in pattern '${pattern}'`,
          );
      };

      // Split into static segments separated by path parameter placeholders.
      // The number of segments is always 1 more than the number of parameters.
      const matchDetails = (match, isSearch) => {
        // IE[78] returns '' for unmatched groups instead of null
        const id = match[2] || match[3];

        const regexp = isSearch
          ? match[4]
          : match[4] || (match[1] === "*" ? "[\\s\\S]*" : null);

        const makeRegexpType = (str) =>
          inherit(paramTypes.type(isSearch ? "query" : "path"), {
            pattern: new RegExp(
              str,
              this.config.caseInsensitive ? "i" : undefined,
            ),
          });

        return {
          id,
          regexp,
          segment: pattern.substring(last, match.index),
          type: !regexp
            ? null
            : paramTypes.type(regexp) || makeRegexpType(regexp),
        };
      };

      let details;

      let segment;

      while ((matchArray = placeholder.exec(pattern))) {
        details = matchDetails(matchArray, false);

        if (details.segment.indexOf("?") >= 0) break; // we're into the search part
        checkParamErrors(details.id);
        this._params.push(
          paramFactory.fromPath(details.id, details.type, config.state),
        );
        this._segments.push(details.segment);
        patterns.push([details.segment, tail(this._params)]);
        last = placeholder.lastIndex;
      }
      segment = pattern.substring(last);
      // Find any search parameter names and remove them from the last segment
      const i = segment.indexOf("?");

      if (i >= 0) {
        const search = segment.substring(i);

        segment = segment.substring(0, i);

        if (search.length > 0) {
          last = 0;

          while ((matchArray = searchPlaceholder.exec(search))) {
            details = matchDetails(matchArray, true);
            checkParamErrors(details.id);
            this._params.push(
              paramFactory.fromSearch(details.id, details.type, config.state),
            );
            last = placeholder.lastIndex;
            // check if ?&
          }
        }
      }
      this._segments.push(segment);
      this._compiled = patterns
        .map((_pattern) => quoteRegExp.apply(null, _pattern))
        .concat(quoteRegExp(segment));
    }

    /**
     * Creates a new concatenated UrlMatcher
     *
     * Builds a new UrlMatcher by appending another UrlMatcher to this one.
     *
     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.
     */
    append(url) {
      this._children.push(url);
      url._cache = {
        path: this._cache.path.concat(url),
        parent: this,
        pattern: null,
      };

      return url;
    }

    isRoot() {
      return this._cache.path[0] === this;
    }

    /** Returns the input pattern string */
    toString() {
      return this.pattern;
    }

    _getDecodedParamValue(value, param) {
      return param.value(value);
    }

    /**
     * Tests the specified url/path against this matcher.
     *
     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured
     * parameter values.  Returns null if the path does not match.
     *
     * The returned object contains the values
     * of any search parameters that are mentioned in the pattern, but their value may be null if
     * they are not present in `search`. This means that search parameters are always treated
     * as optional.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
     *   x: '1', q: 'hello'
     * });
     * // returns { id: 'bob', q: 'hello', r: null }
     * ```
     *
     * @param path    The URL path to match, e.g. `$location.getPath()`.
     * @param search  URL search parameters, e.g. `$location.getSearch()`.
     * @param hash    URL hash e.g. `$location.getHash()`.
     *
     * @returns The captured parameter values.
     */
    exec(path, search = {}, hash) {
      const match = memoizeTo(this._cache, "pattern", () => {
        return new RegExp(
          [
            "^",
            unnest(this._cache.path.map((x) => x._compiled)).join(""),
            this.config.strict === false ? "/?" : "",
            "$",
          ].join(""),
          this.config.caseInsensitive ? "i" : undefined,
        );
      }).exec(path);

      if (!match) return null;
      // options = defaults(options, { isolate: false });
      const allParams = this.parameters(),
        pathParams = allParams.filter((param) => !param.isSearch()),
        searchParams = allParams.filter((param) => param.isSearch()),
        nPathSegments = this._cache.path
          .map((urlm) => urlm._segments.length - 1)
          .reduce((a, x) => a + x),
        values = {};

      if (nPathSegments !== match.length - 1)
        throw new Error(`Unbalanced capture group in route '${this.pattern}'`);
      function decodePathArray(paramVal) {
        const reverseString = (str) => str.split("").reverse().join("");

        const unquoteDashes = (str) => str.replace(/\\-/g, "-");

        const split = reverseString(paramVal).split(/-(?!\\)/);

        const allReversed = map(split, reverseString);

        return map(allReversed, unquoteDashes).reverse();
      }

      for (let i = 0; i < nPathSegments; i++) {
        const param = pathParams[i];

        let value = match[i + 1];

        // if the param value matches a pre-replace pair, replace the value before decoding.
        for (let j = 0; j < param.replace.length; j++) {
          if (param.replace[j].from === value) value = param.replace[j].to;
        }

        if (value && param.array === true) value = decodePathArray(value);
        values[param.id] = this._getDecodedParamValue(value, param);
      }
      searchParams.forEach((param) => {
        let value = search[param.id];

        for (let j = 0; j < param.replace.length; j++) {
          if (param.replace[j].from === value) value = param.replace[j].to;
        }
        values[param.id] = this._getDecodedParamValue(value, param);
      });

      if (hash) values["#"] = hash;

      return values;
    }

    /**
     * @internal
     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.
     *
     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the
     *    pattern has no parameters, an empty array is returned.
     */
    parameters(opts = {}) {
      if (opts.inherit === false) return this._params;

      return unnest(this._cache.path.map((matcher) => matcher._params));
    }

    /**
     * @internal
     * Returns a single parameter from this UrlMatcher by id
     *
     * @param id
     * @param opts
     * @returns {Param|any|boolean|UrlMatcher|null}
     */
    parameter(id, opts = {}) {
      const findParam = () => {
        for (const param of this._params) {
          if (param.id === id) return param;
        }

        return undefined;
      };

      const { parent } = this._cache;

      return (
        findParam() ||
        (opts.inherit !== false && parent && parent.parameter(id, opts)) ||
        null
      );
    }

    /**
     * Validates the input parameter values against this UrlMatcher
     *
     * Checks an object hash of parameters to validate their correctness according to the parameter
     * types of this `UrlMatcher`.
     *
     * @param params The object hash of parameters to validate.
     * @returns Returns `true` if `params` validates, otherwise `false`.
     */
    validates(params) {
      const validParamVal = (param, val) => !param || param.validates(val);

      params = params || {};
      // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher
      const paramSchema = this.parameters().filter((paramDef) =>
        hasOwn(params, paramDef.id),
      );

      return paramSchema
        .map((paramDef) => validParamVal(paramDef, params[paramDef.id]))
        .reduce(allTrueR, true);
    }

    /**
     * Given a set of parameter values, creates a URL from this UrlMatcher.
     *
     * Creates a URL that matches this pattern by substituting the specified values
     * for the path and search parameters.
     *
     * #### Example:
     * ```js
     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
     * // returns '/user/bob?q=yes'
     * ```
     *
     * @param values  the values to substitute for the parameters in this pattern.
     * @returns the formatted URL (path and optionally search part).
     */
    format(values = {}) {
      // Build the full path of UrlMatchers (including all parent UrlMatchers)
      const urlMatchers = this._cache.path;

      // Extract all the static segments and Params (processed as ParamDetails)
      // into an ordered array
      const pathSegmentsAndParams = urlMatchers
        .map(UrlMatcher.pathSegmentsAndParams)
        .reduce(unnestR, [])
        .map((x) => (isString(x) ? x : getDetails(x)));

      // Extract the query params into a separate array
      const queryParams = urlMatchers
        .map(UrlMatcher.queryParams)
        .reduce(unnestR, [])
        .map(getDetails);

      const isInvalid = (param) => param.isValid === false;

      if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {
        return null;
      }
      /**
       * Given a Param, applies the parameter value, then returns detailed information about it
       */
      function getDetails(param) {
        // Normalize to typed value
        const value = param.value(values[param.id]);

        const isValid = param.validates(value);

        const isDefaultValue = param.isDefaultValue(value);

        // Check if we're in squash mode for the parameter
        const squash = isDefaultValue ? param.squash : false;

        // Allow the Parameter's Type to encode the value
        const encoded = param.type.encode(value);

        return { param, value, isValid, isDefaultValue, squash, encoded };
      }
      // Build up the path-portion from the list of static segments and parameters
      const pathString = pathSegmentsAndParams.reduce((acc, x) => {
        // The element is a static segment (a raw string); just append it
        if (isString(x)) return acc + x;
        // Otherwise, it's a ParamDetails.
        const { squash, encoded, param } = x;

        // If squash is === true, try to remove a slash from the path
        if (squash === true) return acc.match(/\/$/) ? acc.slice(0, -1) : acc;

        // If squash is a string, use the string for the param value
        if (isString(squash)) return acc + squash;

        if (squash !== false) return acc; // ?

        if (isNullOrUndefined(encoded)) return acc;

        // If this parameter value is an array, encode the value using encodeDashes
        if (isArray(encoded)) return acc + map(encoded, encodeDashes).join("-");

        // If the parameter type is "raw", then do not encodeURIComponent
        if (param.raw) {
          return acc + encoded;
        }

        // Encode the value
        return acc + encodeURIComponent(encoded);
      }, "");

      // Build the query string by applying parameter values (array or regular)
      // then mapping to key=value, then flattening and joining using "&"
      const queryString = queryParams
        .map((paramDetails) => {
          const { param, squash, isDefaultValue } = paramDetails;

          let { encoded } = paramDetails;

          if (isNullOrUndefined(encoded) || (isDefaultValue && squash !== false))
            return undefined;

          if (!isArray(encoded)) encoded = [encoded];

          if (encoded.length === 0) return undefined;

          if (!param.raw) encoded = map(encoded, encodeURIComponent);

          return encoded.map((val) => `${param.id}=${val}`);
        })
        .reduce(unnestR, [])
        .join("&");

      // Concat the pathstring with the queryString (if exists) and the hashString (if exists)
      return (
        pathString +
        (queryString ? `?${queryString}` : "") +
        (values["#"] ? `#${values["#"]}` : "")
      );
    }
  }

  UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/;

  function encodeDashes(str) {
    // Replace dashes with encoded "\-"
    return encodeURIComponent(str).replace(
      /-/g,
      (char) => `%5C%${char.charCodeAt(0).toString(16).toUpperCase()}`,
    );
  }

  /** @typedef {import('./interface.ts').StateDeclaration} StateDeclaration */

  /**
   * Internal representation of a ng-router state.
   *
   * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].
   *
   * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.
   *
   * This class prototypally inherits from the corresponding [[StateDeclaration]].
   * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].
   * @implements {StateDeclaration}
   */
  class StateObject {
    name = undefined;
    navigable = undefined;
    /** @type {?StateObject} */
    parent = undefined;
    params = undefined;
    url = undefined;
    includes = undefined;

    /**
     * @param {import('./interface.ts').StateDeclaration} config
     */
    constructor(config) {
      Object.assign(this, config);
      this.$$state = () => {
        return this;
      };
      /**
       * @type {ng.StateDeclaration|ng.BuiltStateDeclaration}
       */
      this.self = config;
      /**
       * @type {?Glob}
       */
      const nameGlob = this.name ? Glob.fromString(this.name) : null;

      this.__stateObjectCache = { nameGlob };
    }

    /**
     * Returns true if the provided parameter is the same state.
     *
     * Compares the identity of the state against the passed value, which is either an object
     * reference to the actual `State` instance, the original definition object passed to
     * `$stateProvider.state()`, or the fully-qualified name.
     *
     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
     * @returns Returns `true` if `ref` matches the current `State` instance.
     */
    is(ref) {
      return this === ref || this.self === ref || this.fqn() === ref;
    }

    /**
     * @deprecated this does not properly handle dot notation
     * @returns Returns a dot-separated name of the state.
     */
    fqn() {
      if (!this.parent || !(this.parent instanceof this.constructor))
        return this.name;
      const name = this.parent.fqn();

      return name ? `${name}.${this.name}` : this.name;
    }

    /**
     * Returns the root node of this state's tree.
     *
     * @returns The root of this state's tree.
     */
    root() {
      return (this.parent && this.parent.root()) || this;
    }

    /**
     * Gets the state's `Param` objects
     *
     * Gets the list of [[Param]] objects owned by the state.
     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.
     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object
     *
     * @param opts options
     */
    parameters(opts) {
      opts = defaults(opts, { inherit: true, matchingKeys: null });
      const inherited =
        (opts.inherit && this.parent && this.parent.parameters()) || [];

      return inherited
        .concat(Object.values(this.params))
        .filter(
          (param) => !opts.matchingKeys || hasOwn(opts.matchingKeys, param.id),
        );
    }

    /**
     * Returns a single [[Param]] that is owned by the state
     *
     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.
     * @param id the name of the [[Param]] to return
     * @param opts options
     */
    parameter(id, opts = {}) {
      return (
        (this.url && this.url.parameter(id, opts)) ||
        find(Object.values(this.params), propEq("id", id)) ||
        (opts.inherit && this.parent && this.parent.parameter(id))
      );
    }

    toString() {
      return this.fqn();
    }
  }
  /** Predicate which returns true if the object is a [[StateDeclaration]] object */
  StateObject.isStateDeclaration = (obj) => isFunction(obj.$$state);
  /** Predicate which returns true if the object is an internal [[StateObject]] object */
  StateObject.isState = (obj) => isObject(obj.__stateObjectCache);

  /**
   * Creates a [[UrlRule]]
   *
   * Creates a [[UrlRule]] from a:
   *
   * - `string`
   * - [[UrlMatcher]]
   * - `RegExp`
   * - [[StateObject]]
   */

  const LOWEST = 0.000001;

  class UrlRuleFactory {
    /**
     * @param {ng.UrlService} urlService
     * @param {ng.StateService} stateService
     * @param {ng.RouterService} routerGlobals
     */
    constructor(urlService, stateService, routerGlobals) {
      /** @type {ng.UrlService} */
      this.urlService = urlService;

      /** @type {ng.StateService} */
      this.stateService = stateService;

      /** @type {ng.RouterService} */
      this.routerGlobals = routerGlobals;
    }

    /**
     *
     * @param {*} what
     * @param {*} handler
     * @returns {BaseUrlRule}
     */
    create(what, handler) {
      const { isState, isStateDeclaration } = StateObject;

      const makeRule = pattern([
        [isString, (_what) => makeRule(this.urlService.compile(_what))],
        [is(UrlMatcher), (_what) => this.fromUrlMatcher(_what, handler)],
        [
          (...args) => isState(...args) || isStateDeclaration(...args),
          (_what) => this.fromState(_what, this.stateService, this.routerGlobals),
        ],
        [is(RegExp), (_what) => this.fromRegExp(_what, handler)],
        [isFunction, (_what) => new BaseUrlRule(_what, handler)],
      ]);

      const rule = makeRule(what);

      if (!rule) throw new Error("invalid 'what' in when()");

      return rule;
    }

    /**
     * A UrlRule which matches based on a UrlMatcher
     *
     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, match => "/home/" + match.fooId + "/" + match.barId);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     *
     * ## Handler as UrlMatcher
     *
     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.
     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.
     * The url is replaced with the result.
     *
     * #### Example:
     * ```js
     * var urlMatcher = $umf.compile("/foo/:fooId/:barId");
     * var handler = $umf.compile("/home/:fooId/:barId");
     * var rule = factory.fromUrlMatcher(urlMatcher, handler);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match); // '/home/123/456'
     * ```
     */
    fromUrlMatcher(urlMatcher, handler) {
      let _handler = handler;

      if (isString(handler)) handler = this.urlService.compile(handler);

      if (is(UrlMatcher)(handler)) _handler = (match) => handler.format(match);
      function matchUrlParamters(url) {
        const params = urlMatcher.exec(url.path, url.search, url.hash);

        return urlMatcher.validates(params) && params;
      }
      // Prioritize URLs, lowest to highest:
      // - Some optional URL parameters, but none matched
      // - No optional parameters in URL
      // - Some optional parameters, some matched
      // - Some optional parameters, all matched
      function matchPriority(params) {
        const optional = urlMatcher
          .parameters()
          .filter((param) => param.isOptional);

        if (!optional.length) return LOWEST;
        const matched = optional.filter((param) => params[param.id]);

        return matched.length / optional.length;
      }
      const details = { urlMatcher, matchPriority, type: "URLMATCHER" };

      return Object.assign(new BaseUrlRule(matchUrlParamters, _handler), details);
    }

    /**
     * A UrlRule which matches a state by its url
     *
     * #### Example:
     * ```js
     * var rule = factory.fromState($state.get('foo'), router);
     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }
     * var result = rule.handler(match);
     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }
     * ```
     */
    fromState(stateOrDecl, stateService, globals) {
      const state = StateObject.isStateDeclaration(stateOrDecl)
        ? stateOrDecl.$$state()
        : stateOrDecl;

      /**
       * Handles match by transitioning to matched state
       *
       * First checks if the router should start a new transition.
       * A new transition is not required if the current state's URL
       * and the new URL are already identical
       */
      const handler = (match) => {
        const $state = stateService;

        if (
          $state.href(state, match) !==
          $state.href(globals.current, globals.params)
        ) {
          $state.transitionTo(state, match, { inherit: true, source: "url" });
        }
      };

      const details = { state, type: "STATE" };

      return Object.assign(this.fromUrlMatcher(state.url, handler), details);
    }

    /**
     * A UrlRule which matches based on a regular expression
     *
     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.
     *
     * ## Handler as a function
     *
     * If `handler` is a function, the function is invoked with:
     *
     * - regexp match array (from `regexp`)
     * - url: the current Url ([[UrlParts]])
     * - router: the router object ([[UIRouter]])
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, match => "/home/" + match[1])
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     *
     * ## Handler as string
     *
     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.
     * The string is first interpolated using `string.replace()` style pattern.
     *
     * #### Example:
     * ```js
     * var rule = factory.fromRegExp(/^\/foo\/(bar|baz)$/, "/home/$1")
     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]
     * var result = rule.handler(match); // '/home/bar'
     * ```
     */
    fromRegExp(regexp, handler) {
      if (regexp.global || regexp.sticky)
        throw new Error("Rule RegExp must not be global or sticky");
      /**
       * If handler is a string, the url will be replaced by the string.
       * If the string has any String.replace() style variables in it (like `$2`),
       * they will be replaced by the captures from [[match]]
       */
      const redirectUrlTo = (match) =>
        // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern
        handler.replace(
          /\$(\$|\d{1,2})/,
          (_, what) => match[what === "$" ? 0 : Number(what)],
        );

      const _handler = isString(handler) ? redirectUrlTo : handler;

      const matchParamsFromRegexp = (url) => regexp.exec(url.path);

      const details = { regexp, type: "REGEXP" };

      return Object.assign(
        new BaseUrlRule(matchParamsFromRegexp, _handler),
        details,
      );
    }
  }
  UrlRuleFactory.isUrlRule = (obj) =>
    obj && ["type", "match", "handler"].every((key) => isDefined(obj[key]));

  /**
   * A base rule which calls `match`
   *
   * The value from the `match` function is passed through to the `handler`.
   */
  class BaseUrlRule {
    constructor(match, handler) {
      this.match = match;
      this.type = "RAW";
      this.$id = -1;
      this._group = undefined;
      this.handler = handler || ((x) => x);
      this.priority = undefined;
    }

    /**
     * This function should be overridden
     * @param {*} [params]
     * @returns {number}
     */
    matchPriority(params) {
      assert(isUndefined(params));

      return 0 - this.$id;
    }
  }

  function prioritySort(a, b) {
    return (b.priority || 0) - (a.priority || 0);
  }

  const typeSort = (a, b) => {
    const weights = { STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1 };

    return (weights[a.type] || 0) - (weights[b.type] || 0);
  };

  const urlMatcherSort = (a, b) =>
    !a.urlMatcher || !b.urlMatcher
      ? 0
      : UrlMatcher.compare(a.urlMatcher, b.urlMatcher);

  const idSort = (a, b) => {
    // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL
    const useMatchPriority = { STATE: true, URLMATCHER: true };

    const equal = useMatchPriority[a.type] && useMatchPriority[b.type];

    return equal ? 0 : (a.$id || 0) - (b.$id || 0);
  };

  /**
   * Default rule priority sorting function.
   *
   * Sorts rules by:
   *
   * - Explicit priority (set rule priority using [[UrlRules.when]])
   * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)
   * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.
   * - Rule registration order (for rule types other than STATE and URLMATCHER)
   *   - Equally sorted State and UrlMatcher rules will each match the URL.
   *     Then, the *best* match is chosen based on how many parameter values were matched.
   */
  function defaultRuleSortFn(a, b) {
    let cmp = prioritySort(a, b);

    if (cmp !== 0) return cmp;
    cmp = typeSort(a, b);

    if (cmp !== 0) return cmp;
    cmp = urlMatcherSort(a, b);

    if (cmp !== 0) return cmp;

    return idSort(a, b);
  }

  function getHandlerFn(handler) {
    if (
      !isFunction(handler) &&
      !isString(handler) &&
      !is(TargetState)(handler) &&
      !TargetState.isDef(handler)
    ) {
      throw new Error(
        "'handler' must be a string, function, TargetState, or have a state: 'newtarget' property",
      );
    }

    return isFunction(handler) ? handler : val(handler);
  }
  /**
   * API for managing URL rules
   *
   * This API is used to create and manage URL rules.
   * URL rules are a mechanism to respond to specific URL patterns.
   *
   * The most commonly used methods are [[otherwise]] and [[when]].
   *
   * This API is found at `$url.rules` (see: [[UIRouter.urlService]], [[URLService.rules]])
   */
  class UrlRules {
    /** @param {UrlRuleFactory} urlRuleFactory */
    constructor(urlRuleFactory) {
      this._sortFn = defaultRuleSortFn;
      this._rules = [];
      this._id = 0;
      this.urlRuleFactory = urlRuleFactory;
    }

    /**
     * Defines the initial state, path, or behavior to use when the app starts.
     *
     * This rule defines the initial/starting state for the application.
     *
     * This rule is triggered the first time the URL is checked (when the app initially loads).
     * The rule is triggered only when the url matches either `""` or `"/"`.
     *
     * Note: The rule is intended to be used when the root of the application is directly linked to.
     * When the URL is *not* `""` or `"/"` and doesn't match other rules, the [[otherwise]] rule is triggered.
     * This allows 404-like behavior when an unknown URL is deep-linked.
     *
     * #### Example:
     * Start app at `home` state.
     * ```js
     * .initial({ state: 'home' });
     * ```
     *
     * #### Example:
     * Start app at `/home` (by url)
     * ```js
     * .initial('/home');
     * ```
     *
     * #### Example:
     * When no other url rule matches, go to `home` state
     * ```js
     * .initial((matchValue, url, router) => {
     *   console.log('initial state');
     *   return { state: 'home' };
     * })
     * ```
     *
     * @param handler The initial state or url path, or a function which returns the state or url path (or performs custom logic).
     */
    initial(handler) {
      const handlerFn = getHandlerFn(handler);

      const matchFn = (urlParts, router) =>
        router.globals.transitionHistory.size() === 0 &&
        !!/^\/?$/.exec(urlParts.path);

      this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
    }

    /**
     * Defines the state, url, or behavior to use when no other rule matches the URL.
     *
     * This rule is matched when *no other rule* matches.
     * It is generally used to handle unknown URLs (similar to "404" behavior, but on the client side).
     *
     * - If `handler` a string, it is treated as a url redirect
     *
     * #### Example:
     * When no other url rule matches, redirect to `/index`
     * ```js
     * .otherwise('/index');
     * ```
     *
     * - If `handler` is an object with a `state` property, the state is activated.
     *
     * #### Example:
     * When no other url rule matches, redirect to `home` and provide a `dashboard` parameter value.
     * ```js
     * .otherwise({ state: 'home', params: { dashboard: 'default' } });
     * ```
     *
     * - If `handler` is a function, the function receives the current url ([[UrlParts]]) and the [[UIRouter]] object.
     *   The function can perform actions, and/or return a value.
     *
     * #### Example:
     * When no other url rule matches, manually trigger a transition to the `home` state
     * ```js
     * .otherwise((matchValue, urlParts, router) => {
     *   router.stateService.go('home');
     * });
     * ```
     *
     * #### Example:
     * When no other url rule matches, go to `home` state
     * ```js
     * .otherwise((matchValue, urlParts, router) => {
     *   return { state: 'home' };
     * });
     * ```
     *
     * @param handler The url path to redirect to, or a function which returns the url path (or performs custom logic).
     */
    otherwise(handler) {
      const handlerFn = getHandlerFn(handler);

      this._otherwiseFn = this.urlRuleFactory.create(val(true), handlerFn);
      this._sorted = false;
    }

    /**
     * Remove a rule previously registered
     *
     * @param rule the matcher rule that was previously registered using [[rule]]
     */
    removeRule(rule) {
      removeFrom(this._rules, rule);
    }

    /**
     * Manually adds a URL Rule.
     *
     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].
     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).
     * Rules can be created using [[urlRuleFactory]], or created manually as simple objects.
     *
     * A rule should have a `match` function which returns truthy if the rule matched.
     * It should also have a `handler` function which is invoked if the rule is the best match.
     *
     * @return a function that deregisters the rule
     */
    rule(rule) {
      if (!UrlRuleFactory.isUrlRule(rule)) throw new Error("invalid rule");
      rule.$id = this._id++;
      rule.priority = rule.priority || 0;
      this._rules.push(rule);
      this._sorted = false;

      return () => this.removeRule(rule);
    }

    /**
     * Gets all registered rules
     *
     * @returns an array of all the registered rules
     */
    rules() {
      this.ensureSorted();

      return this._rules.concat(this._otherwiseFn ? [this._otherwiseFn] : []);
    }

    /**
     * Defines URL Rule priorities
     *
     * More than one rule ([[UrlRule]]) might match a given URL.
     * This `compareFn` is used to sort the rules by priority.
     * Higher priority rules should sort earlier.
     *
     * The [[defaultRuleSortFn]] is used by default.
     *
     * You only need to call this function once.
     * The `compareFn` will be used to sort the rules as each is registered.
     *
     * If called without any parameter, it will re-sort the rules.
     *
     * ---
     *
     * Url rules may come from multiple sources: states's urls ([[StateDeclaration.url]]), [[when]], and [[rule]].
     * Each rule has a (user-provided) [[UrlRule.priority]], a [[UrlRule.type]], and a [[UrlRule.$id]]
     * The `$id` is is the order in which the rule was registered.
     *
     * The sort function should use these data, or data found on a specific type
     * of [[UrlRule]] (such as [[StateRule.state]]), to order the rules as desired.
     *
     * #### Example:
     * This compare function prioritizes rules by the order in which the rules were registered.
     * A rule registered earlier has higher priority.
     *
     * ```js
     * function compareFn(a, b) {
     *   return a.$id - b.$id;
     * }
     * ```
     *
     * @param compareFn a function that compares to [[UrlRule]] objects.
     *    The `compareFn` should abide by the `Array.sort` compare function rules.
     *    Given two rules, `a` and `b`, return a negative number if `a` should be higher priority.
     *    Return a positive number if `b` should be higher priority.
     *    Return `0` if the rules are identical.
     *
     *    See the [mozilla reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Description)
     *    for details.
     */
    sort(compareFn) {
      const sorted = this.stableSort(
        this._rules,
        (this._sortFn = compareFn || this._sortFn),
      );

      // precompute _sortGroup values and apply to each rule
      let group = 0;

      for (let i = 0; i < sorted.length; i++) {
        sorted[i]._group = group;

        if (
          i < sorted.length - 1 &&
          this._sortFn(sorted[i], sorted[i + 1]) !== 0
        ) {
          group++;
        }
      }
      this._rules = sorted;
      this._sorted = true;
    }

    ensureSorted() {
      this._sorted || this.sort();
    }

    stableSort(arr, compareFn) {
      const arrOfWrapper = arr.map((elem, idx) => ({ elem, idx }));

      arrOfWrapper.sort((wrapperA, wrapperB) => {
        const cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);

        return cmpDiff === 0 ? wrapperA.idx - wrapperB.idx : cmpDiff;
      });

      return arrOfWrapper.map((wrapper) => wrapper.elem);
    }

    /**
     * Registers a `matcher` and `handler` for custom URLs handling.
     *
     * The `matcher` can be:
     *
     * - a [[UrlMatcher]]: See: [[UrlMatcherFactory.compile]]
     * - a `string`: The string is compiled to a [[UrlMatcher]]
     * - a `RegExp`: The regexp is used to match the url.
     *
     * The `handler` can be:
     *
     * - a string: The url is redirected to the value of the string.
     * - a function: The url is redirected to the return value of the function.
     *
     * ---
     *
     * When the `handler` is a `string` and the `matcher` is a `UrlMatcher` (or string), the redirect
     * string is interpolated with parameter values.
     *
     * #### Example:
     * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
     * ```js
     * .when("/foo/:param1", "/bar/:param1")
     * ```
     *
     * ---
     *
     * When the `handler` is a string and the `matcher` is a `RegExp`, the redirect string is
     * interpolated with capture groups from the RegExp.
     *
     * #### Example:
     * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
     * ```js
     * .when(new RegExp("^/foo/(.*)$"), "/bar/$1");
     * ```
     *
     * ---
     *
     * When the handler is a function, it receives the matched value, the current URL, and the `UIRouter` object (See [[UrlRuleHandlerFn]]).
     * The "matched value" differs based on the `matcher`.
     * For [[UrlMatcher]]s, it will be the matched state params.
     * For `RegExp`, it will be the match array from `regexp.exec()`.
     *
     * If the handler returns a string, the URL is redirected to the string.
     *
     * #### Example:
     * When the URL is `/foo/123` the rule will redirect to `/bar/123`.
     * ```js
     * .when(new RegExp("^/foo/(.*)$"), match => "/bar/" + match[1]);
     * ```
     *
     * Note: the `handler` may also invoke arbitrary code, such as `$state.go()`
     *
     * @param matcher A pattern `string` to match, compiled as a [[UrlMatcher]], or a `RegExp`.
     * @param handler The path to redirect to, or a function that returns the path.
     * @param options `{ priority: number }`
     *
     * @return the registered [[UrlRule]]
     */
    when(matcher, handler, options) {
      const rule = this.urlRuleFactory.create(matcher, handler);

      if (isDefined(options && options.priority))
        rule.priority = options.priority;
      this.rule(rule);

      return rule;
    }
  }

  class ParamFactory {
    /**
     * @param {import("../url/url-config.js").UrlConfigProvider} urlServiceConfig
     */
    constructor(urlServiceConfig) {
      /**
       * @type {import("../url/url-config.js").UrlConfigProvider}
       */
      this.urlServiceConfig = urlServiceConfig;
    }

    fromConfig(id, type, state) {
      return new Param(id, type, DefType._CONFIG, this.urlServiceConfig, state);
    }

    fromPath(id, type, state) {
      return new Param(id, type, DefType._PATH, this.urlServiceConfig, state);
    }

    fromSearch(id, type, state) {
      return new Param(id, type, DefType._SEARCH, this.urlServiceConfig, state);
    }
  }

  /**
   * API for URL management
   */
  class UrlService {
    /* @ignore */ static $inject = provider([
      $injectTokens._location,
      $injectTokens._state,
      $injectTokens._router,
      $injectTokens._urlConfig,
    ]);

    /** @type {ng.LocationService} */
    $location;

    /**
     * @param {ng.LocationProvider} $locationProvider
     * @param {import("../../router/state/state-service.js").StateProvider} stateService
     * @param {import("../router.js").RouterProvider} globals
     * @param {import("../../router/url/url-config.js").UrlConfigProvider} urlConfigProvider
     */
    constructor($locationProvider, stateService, globals, urlConfigProvider) {
      /** @private */
      this._locationProvider = $locationProvider;
      this.stateService = stateService;

      /** Provides services related to the URL */
      this.urlRuleFactory = new UrlRuleFactory(this, this.stateService, globals);

      /**
       * The nested [[UrlRules]] API for managing URL rules and rewrites
       * @type {UrlRules}
       */
      this.rules = new UrlRules(this.urlRuleFactory);
      /**
       * The nested [[UrlConfig]] API to configure the URL and retrieve URL information
       * @type {import("./url-config.js").UrlConfigProvider}
       */
      this.config = urlConfigProvider;

      /** Creates a new [[Param]] for a given location (DefType) */
      this.paramFactory = new ParamFactory(this.config);

      this._urlListeners = [];
    }

    /**
     * Gets the path part of the current url
     *
     * If the current URL is `/some/path?query=value#anchor`, this returns `/some/path`
     *
     * @return {string} the path portion of the url
     */
    getPath() {
      return this.$location.getPath();
    }

    /**
     * Gets the search part of the current url as an object
     *
     * If the current URL is `/some/path?query=value#anchor`, this returns `{ query: 'value' }`
     *
     * @return {Object} the search (query) portion of the url, as an object
     */
    getSearch() {
      return this.$location.getSearch();
    }

    /**
     * Gets the hash part of the current url
     *
     * If the current URL is `/some/path?query=value#anchor`, this returns `anchor`
     *
     * @return {string} the hash (anchor) portion of the url
     */
    getHash() {
      return this.$location.getHash();
    }

    $get = [
      $injectTokens._location,
      $injectTokens._rootScope,
      /**
       *
       * @param {ng.LocationService} $location
       * @param {ng.RootScopeService} $rootScope
       * @returns {ng.UrlService}
       */
      ($location, $rootScope) => {
        this.$location = $location;
        $rootScope.$on("$locationChangeSuccess", (evt) => {
          for (let i = 0, j = this._urlListeners.length; i < j; i++) {
            this._urlListeners[i](evt);
          }
        });
        this.listen(true);

        return this;
      },
    ];

    /**
     * @returns {string}
     */
    baseHref() {
      return (
        this._baseHref ||
        (this._baseHref = getBaseHref() || window.location.pathname)
      );
    }

    /**
     * Gets the current url, or updates the url
     *
     * ### Getting the current URL
     *
     * When no arguments are passed, returns the current URL.
     * The URL is normalized using the internal [[path]]/[[search]]/[[hash]] values.
     *
     * For example, the URL may be stored in the hash ([[HashLocationServices]]) or
     * have a base HREF prepended ([[PushStateLocationServices]]).
     *
     * The raw URL in the browser might be:
     *
     * ```
     * http://mysite.com/somepath/index.html#/internal/path/123?param1=foo#anchor
     * ```
     *
     * or
     *
     * ```
     * http://mysite.com/basepath/internal/path/123?param1=foo#anchor
     * ```
     *
     * then this method returns:
     *
     * ```
     * /internal/path/123?param1=foo#anchor
     * ```
     *
     *
     * #### Example:
     * ```js
     * locationServices.url(); // "/some/path?query=value#anchor"
     * ```
     *
     * ### Updating the URL
     *
     * When `newurl` arguments is provided, changes the URL to reflect `newurl`
     *
     * #### Example:
     * ```js
     * locationServices.url("/some/path?query=value#anchor", true);
     * ```
     *
     * @param {string} [newUrl] The new value for the URL.
     *               This url should reflect only the new internal [[path]], [[search]], and [[hash]] values.
     *               It should not include the protocol, site, port, or base path of an absolute HREF.
     * @param {any} [state] The history's state object, i.e., pushState (if the LocationServices implementation supports it)
     *
     * @return the url (after potentially being processed)
     */
    url(newUrl, state) {
      if (isDefined(newUrl)) {
        const decodeUri = decodeURIComponent(newUrl);

        this.$location.setUrl(decodeUri);
      }

      if (state) this.$location.setState(state);

      return this.$location.getUrl();
    }

    /**
     * @private
     *
     * Registers a low level url change handler
     *
     * Note: Because this is a low level handler, it's not recommended for general use.
     *
     * #### Example:
     * ```js
     * let deregisterFn = locationServices.onChange((evt) => console.log("url change", evt));
     * ```
     *
     * @param {Function} callback a function that will be called when the url is changing
     * @return {Function} a function that de-registers the callback
     */
    onChange(callback) {
      this._urlListeners.push(callback);

      return () => removeFrom(this._urlListeners, callback);
    }

    /**
     * Gets the current URL parts.
     *
     * Returns an object with the `path`, `search`, and `hash` components
     * of the current browser location.
     *
     * @returns {import("../../services/location/interface.ts").UrlParts} The current URL's path, search, and hash.
     */
    parts() {
      return {
        path: this.$location.getPath(),
        search: this.$location.getSearch(),
        hash: this.$location.getHash(),
      };
    }

    /**
     * Activates the best rule for the current URL
     *
     * Checks the current URL for a matching [[UrlRule]], then invokes that rule's handler.
     * This method is called internally any time the URL has changed.
     *
     * This effectively activates the state (or redirect, etc) which matches the current URL.
     *
     * #### Example:
     * ```js
     *
     * fetch('/states.json').then(resp => resp.json()).then(data => {
     *   data.forEach(state => $stateRegistry.register(state));
     *   urlService.listen();
     *   // Find the matching URL and invoke the handler.
     *   urlService.sync();
     * });
     * ```
     */
    sync(evt) {
      if (evt && evt.defaultPrevented) return;
      const { stateService } = this;

      const url = {
        path: this.$location.getPath(),
        search: this.$location.getSearch(),
        hash: this.$location.getHash(),
      };

      /**
       * @type {*}
       */
      const best = this.match(url);

      const applyResult = pattern([
        [isString, (newurl) => this.url(newurl)],
        [
          TargetState.isDef,
          (def) => stateService.go(def.state, def.params, def.options),
        ],
        [
          is(TargetState),
          (target) =>
            stateService.go(target.state(), target.params(), target.options()),
        ],
      ]);

      applyResult(best && best.rule.handler(best.match, url));
    }

    /**
     * Starts or stops listening for URL changes
     *
     * Call this sometime after calling [[deferIntercept]] to start monitoring the url.
     * This causes ng-router to start listening for changes to the URL, if it wasn't already listening.
     *
     * If called with `false`, ng-router will stop listening (call listen(true) to start listening again).
     *
     * #### Example:
     * ```js
     *
     * fetch('/states.json').then(resp => resp.json()).then(data => {
     *   data.forEach(state => $stateRegistry.register(state));
     *   // Start responding to URL changes
     *   urlService.listen();
     *   urlService.sync();
     * });
     * ```
     *
     * @param {boolean} enabled `true` or `false` to start or stop listening to URL changes
     */
    listen(enabled) {
      if (enabled === false) {
        this._stopListeningFn && this._stopListeningFn();
        delete this._stopListeningFn;

        return undefined;
      } else {
        return (this._stopListeningFn =
          this._stopListeningFn || this.onChange((evt) => this.sync(evt)));
      }
    }

    /**
     * Matches a URL
     *
     * Given a URL (as a [[UrlParts]] object), check all rules and determine the best matching rule.
     * Return the result as a [[MatchResult]].
     * @returns {any}
     */
    match(url) {
      url = Object.assign({ path: "", search: {}, hash: "" }, url);
      const rules = this.rules.rules();

      // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined
      /**
       *
       * @param {import("./url-rule").BaseUrlRule} rule
       */
      const checkRule = (rule) => {
        const match = rule.match(url);

        return match && { match, rule, weight: rule.matchPriority(match) };
      };

      // The rules are pre-sorted.
      // - Find the first matching rule.
      // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.
      // - Choose the rule with the highest match weight.
      let best;

      for (let i = 0; i < rules.length; i++) {
        // Stop when there is a 'best' rule and the next rule sorts differently than it.
        if (best && best.rule._group !== rules[i]._group) break;
        const current = checkRule(rules[i]);

        // Pick the best MatchResult
        best =
          !best || (current && current.weight > best.weight) ? current : best;
      }

      return best;
    }

    update(read) {
      if (read) {
        this.location = this.url();

        return;
      }

      if (this.url() === this.location) return;
      this.url(/** @type {string} */ (this.location), true);
    }

    /**
     * Internal API.
     *
     * Pushes a new location to the browser history.
     *
     * @internal
     * @param urlMatcher
     * @param params
     * @param options
     */
    push(urlMatcher, params, options) {
      const replace = options && !!options.replace;

      this.url(urlMatcher.format(params || {}), replace);
    }

    /**
     * Builds and returns a URL with interpolated parameters
     *
     * #### Example:
     * ```js
     * matcher = $umf.compile("/about/:person");
     * params = { person: "bob" };
     * $bob = $url.href(matcher, params);
     * // $bob == "/about/bob";
     * ```
     *
     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.
     * @param params An object of parameter values to fill the matcher's required parameters.
     * @param options Options object. The options are:
     *
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     *
     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
     */
    href(urlMatcher, params, options) {
      let url = urlMatcher.format(params);

      if (isNull(url)) return null;
      options = options || { absolute: false };
      const isHtml5 = this._locationProvider.html5ModeConf.enabled;

      if (!isHtml5) {
        url = `#${this._locationProvider.hashPrefixConf}${url}`;
      }
      url = appendBasePath(url, isHtml5, options.absolute, this.baseHref());

      if (!options.absolute || !url) {
        return url;
      }
      const slash = !isHtml5 && url ? "/" : "";

      return [
        `${window.location.protocol}//`,
        window.location.host,
        slash,
        url,
      ].join("");
    }

    /**
     * Creates a [[UrlMatcher]] for the specified pattern.
     *
     * @param urlPattern  The URL pattern.
     * @param config  The config object hash.
     * @returns The UrlMatcher.
     */
    compile(urlPattern, config) {
      const urlConfig = this.config;

      // backward-compatible support for config.params -> config.state.params
      const params = config && !config.state && config.params;

      config = params ? Object.assign({ state: { params } }, config) : config;
      const globalConfig = {
        strict: urlConfig._isStrictMode,
        caseInsensitive: urlConfig._isCaseInsensitive,
      };

      return new UrlMatcher(
        urlPattern,
        urlConfig.paramTypes,
        this.paramFactory,
        Object.assign(globalConfig, config),
      );
    }

    /**
     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.
     *
     * @param object  The object to perform the type check against.
     * @returns `true` if the object matches the `UrlMatcher` interface, by
     *          implementing all the same methods.
     */
    isMatcher(object) {
      // TODO: typeof?
      if (!isObject(object)) return false;
      let result = true;

      entries(UrlMatcher.prototype).forEach(([name, val]) => {
        if (isFunction(val))
          result = result && isDefined(object[name]) && isFunction(object[name]);
      });

      return result;
    }
  }

  function appendBasePath(url, isHtml5, absolute, baseHref) {
    if (baseHref === "/") return url;

    if (isHtml5) return stripLastPathElement(baseHref) + url;

    if (absolute) return baseHref.slice(1) + url;

    return url;
  }

  class StateMatcher {
    constructor(_states) {
      this._states = _states;
    }

    isRelative(stateName) {
      stateName = stateName || "";

      return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
    }

    find(stateOrName, base, matchGlob = true) {
      if (!stateOrName && stateOrName !== "") return undefined;
      const isStr = isString(stateOrName);

      let name = isStr ? stateOrName : stateOrName.name;

      if (this.isRelative(name)) name = this.resolvePath(name, base);
      const state = this._states[name];

      if (
        state &&
        (isStr ||
          (!isStr && (state === stateOrName || state.self === stateOrName)))
      ) {
        return state;
      } else if (isStr && matchGlob) {
        const _states = Object.values(this._states);

        const matches = _states.filter(
          (_state) =>
            _state.__stateObjectCache.nameGlob &&
            _state.__stateObjectCache.nameGlob.matches(name),
        );

        if (matches.length > 1) {
          throw new Error(
            `stateMatcher.find: Found multiple matches for ${name} using glob: ${matches.map((match) => match.name)}`,
          );
        }

        return matches[0];
      }

      return undefined;
    }

    resolvePath(name, base) {
      if (!base) throw new Error(`No reference point given for path '${name}'`);
      const baseState = this.find(base);

      const splitName = name.split(".");

      const pathLength = splitName.length;

      let i = 0,
        current = baseState;

      for (; i < pathLength; i++) {
        if (splitName[i] === "" && i === 0) {
          current = baseState;
          continue;
        }

        if (splitName[i] === "^") {
          if (!current.parent)
            throw new Error(
              `Path '${name}' not valid for state '${baseState.name}'`,
            );
          current = current.parent;
          continue;
        }
        break;
      }
      const relName = splitName.slice(i).join(".");

      return current.name + (current.name && relName ? "." : "") + relName;
    }
  }

  function parseUrl(url) {
    if (!isString(url)) return false;
    const root = url.charAt(0) === "^";

    return { val: root ? url.substring(1) : url, root };
  }

  function selfBuilder(state) {
    state.self.$$state = () => state;

    return state.self;
  }

  function dataBuilder(state) {
    if (state.parent && state.parent.data) {
      state.data = state.self.data = inherit(state.parent.data, state.data);
    }

    return state.data;
  }

  function getUrlBuilder($url, root) {
    return function (stateObject) {
      let stateDec = stateObject.self;

      // For future states, i.e., states whose name ends with `.**`,
      // match anything that starts with the url prefix
      if (
        stateDec &&
        stateDec.url &&
        stateDec.name &&
        stateDec.name.match(/\.\*\*$/)
      ) {
        const newStateDec = {};

        copy(stateDec, newStateDec);
        newStateDec.url += "{remainder:any}"; // match any path (.*)
        stateDec = newStateDec;
      }
      const { parent } = stateObject;

      const parsed = parseUrl(stateDec.url);

      const url = !parsed
        ? stateDec.url
        : $url.compile(parsed.val, { state: stateDec });

      if (!url) return null;

      if (!$url.isMatcher(url))
        throw new Error(`Invalid url '${url}' in state '${stateObject}'`);

      return parsed && parsed.root
        ? url
        : ((parent && parent.navigable) || root()).url.append(url);
    };
  }

  function getNavigableBuilder(rootFn) {
    return function (state) {
      return !rootFn(state) && state.url
        ? state
        : state.parent
          ? state.parent.navigable
          : null;
    };
  }

  /**
   * @param {import("../params/param-factory.js").ParamFactory} paramFactory
   */
  function getParamsBuilder(paramFactory) {
    return function (state) {
      const makeConfigParam = (_config, id) =>
        paramFactory.fromConfig(id, null, state.self);

      const urlParams =
        (state.url && state.url.parameters({ inherit: false })) || [];

      const nonUrlParams = Object.values(
        map(
          omit(
            state.params || {},
            urlParams.map((x) => x.id),
          ),
          makeConfigParam,
        ),
      );

      return urlParams
        .concat(nonUrlParams)
        .map((x) => [x.id, x])
        .reduce(applyPairs, {});
    };
  }

  function pathBuilder(state) {
    return state.parent ? state.parent.path.concat(state) : [state];
  }

  function includesBuilder(state) {
    const includes = state.parent ? Object.assign({}, state.parent.includes) : {};

    includes[state.name] = true;

    return includes;
  }

  /**
   * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].
   *
   * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
   * validates the `resolve` property and converts it to a [[Resolvable]] array.
   *
   * resolve: input value can be:
   *
   * {
   *   // analyzed but not injected
   *   myFooResolve: function() { return "myFooData"; },
   *
   *   // function.toString() parsed, "DependencyName" dep as string (not min-safe)
   *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },
   *
   *   // Array split; "DependencyName" dep as string
   *   myBazResolve: [ "DependencyName", function(dep) { return dep.fetchSomethingAsPromise() },
   *
   *   // Array split; DependencyType dep as token (compared using ===)
   *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },
   *
   *   // val.$inject used as deps
   *   // where:
   *   //     corgeResolve.$inject = ["DependencyName"];
   *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }
   *   // then "DependencyName" dep as string
   *   myCorgeResolve: corgeResolve,
   *
   *  // inject service by name
   *  // When a string is found, desugar creating a resolve that injects the named service
   *   myGraultResolve: "SomeService"
   * }
   *
   * or:
   *
   * [
   *   new Resolvable("myFooResolve", function() { return "myFooData" }),
   *   new Resolvable("myBarResolve", function(dep) { return dep.fetchSomethingAsPromise() }, [ "DependencyName" ]),
   *   { provide: "myBazResolve", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ "DependencyName" ] }
   * ]
   * @param {ng.StateObject & ng.StateDeclaration} state
   */
  function resolvablesBuilder(state) {
    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */
    const objects2Tuples = (resolveObj, resolvePolicies) =>
      Object.keys(resolveObj || {}).map((token) => ({
        token,
        val: resolveObj[token],
        deps: undefined,
        policy: resolvePolicies[token],
      }));

    /** fetch DI annotations from a function or ng1-style array */
    const annotateFn = (fn) => {
      const { $injector } = window.angular;

      // ng1 doesn't have an $injector until runtime.
      // If the $injector doesn't exist, use "deferred" literal as a
      // marker indicating they should be annotated when runtime starts
      return (
        fn.$inject ||
        ($injector && annotate(fn, $injector.strictDi)) ||
        "deferred"
      );
    };

    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */
    const isResolveLiteral = (obj) => !!(obj.token && obj.resolveFn);

    /** true if the object looks like a tuple from obj2Tuples */
    const isTupleFromObj = (obj) =>
      !!(
        obj &&
        obj.val &&
        (isString(obj.val) || isArray(obj.val) || isFunction(obj.val))
      );

    // Given a literal resolve or provider object, returns a Resolvable
    const literal2Resolvable = pattern([
      [
        (x) => x.resolveFn,
        (y) => new Resolvable(getToken(y), y.resolveFn, y.deps, y.policy),
      ],
      [
        (x) => x.useFactory,
        (y) =>
          new Resolvable(
            getToken(y),
            y.useFactory,
            y.deps || y.dependencies,
            y.policy,
          ),
      ],
      [
        (x) => x.useClass,
        (y) => new Resolvable(getToken(y), () => new y.useClass(), [], y.policy),
      ],
      [
        (x) => x.useValue,
        (y) =>
          new Resolvable(getToken(y), () => y.useValue, [], y.policy, y.useValue),
      ],
      [
        (x) => x.useExisting,
        (y) => new Resolvable(getToken(y), (x) => x, [y.useExisting], y.policy),
      ],
    ]);

    const tuple2Resolvable = pattern([
      [
        (x) => isString(x.val),
        (tuple) =>
          new Resolvable(tuple.token, (x) => x, [tuple.val], tuple.policy),
      ],
      [
        (x) => isArray(x.val),
        (tuple) =>
          new Resolvable(
            tuple.token,
            tail(tuple.val),
            tuple.val.slice(0, -1),
            tuple.policy,
          ),
      ],
      [
        (x) => isFunction(x.val),
        (tuple) =>
          new Resolvable(
            tuple.token,
            tuple.val,
            annotateFn(tuple.val),
            tuple.policy,
          ),
      ],
    ]);

    const item2Resolvable = pattern([
      [is(Resolvable), (x) => x],
      [isResolveLiteral, literal2Resolvable],
      [isTupleFromObj, tuple2Resolvable],
      [
        val(true),
        (obj) => {
          throw new Error(`Invalid resolve value: ${stringify(obj)}`);
        },
      ],
    ]);

    // If resolveBlock is already an array, use it as-is.
    // Otherwise, assume it's an object and convert to an Array of tuples
    const decl = state.resolve;

    const items = isArray(decl)
      ? decl
      : objects2Tuples(decl, state.resolvePolicy || {});

    return items.map(item2Resolvable);
  }
  /**
   * A internal global service
   *
   * StateBuilder is a factory for the internal [[StateObject]] objects.
   *
   * When you register a state with the [[StateRegistry]], you register a plain old javascript object which
   * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding
   * [[StateObject]] object, which has an API and is used internally.
   *
   * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function
   * using the [[builder]] method.
   */
  class StateBuilder {
    /**
     * @param {import('./state-matcher.js').StateMatcher} matcher
     * @param urlService
     */
    constructor(matcher, urlService) {
      this.matcher = matcher;
      this.$injector = undefined;
      const self = this;

      const root = () => matcher.find("");

      function parentBuilder(state) {
        if (isRoot(state)) return null;

        return matcher.find(self.parentName(state)) || root();
      }
      this.builders = {
        name: [(state) => state.name],
        self: [selfBuilder],
        parent: [parentBuilder],
        data: [dataBuilder],
        // Build a URLMatcher if necessary, either via a relative or absolute URL
        url: [getUrlBuilder(urlService, root)],
        // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
        navigable: [getNavigableBuilder(isRoot)],
        // TODO
        params: [getParamsBuilder(urlService.paramFactory)],
        // Each framework-specific ng-router implementation should define its own `views` builder
        // e.g., src/ng1/statebuilders/views.ts
        views: [],
        // Keep a full path from the root down to this state as this is needed for state activation.
        path: [pathBuilder],
        // Speed up $state.includes() as it's used a lot
        includes: [includesBuilder],
        resolvables: [resolvablesBuilder],
      };
    }

    builder(name, fn) {
      const { builders } = this;

      const array = builders[name] || [];

      // Backwards compat: if only one builder exists, return it, else return whole arary.
      if (isString(name) && !isDefined(fn))
        return array.length > 1 ? array : array[0];

      if (!isString(name) || !isFunction(fn)) return undefined;
      builders[name] = array;
      builders[name].push(fn);

      return () => builders[name].splice(builders[name].indexOf(fn, 1)) && null;
    }

    /**
     * Builds all of the properties on an essentially blank State object, returning a State object which has all its
     * properties and API built.
     *
     * @param state an uninitialized State object
     * @returns the built State object
     */
    build(state) {
      const { matcher, builders } = this;

      const parent = this.parentName(state);

      if (parent && !matcher.find(parent, undefined, false)) {
        return null;
      }

      for (const key in builders) {
        if (!hasOwn(builders, key)) continue;
        const chain = builders[key].reduce(
          (parentFn, step) => (_state) => step(_state, parentFn),
          () => {
            /* empty */
          },
        );

        state[key] = chain(state);
      }

      return state;
    }

    parentName(state) {
      // name = 'foo.bar.baz.**'
      const name = state.name || "";

      // segments = ['foo', 'bar', 'baz', '.**']
      const segments = name.split(".");

      // segments = ['foo', 'bar', 'baz']
      const lastSegment = segments.pop();

      // segments = ['foo', 'bar'] (ignore .** segment for future states)
      if (lastSegment === "**") segments.pop();

      if (segments.length) {
        if (state.parent) {
          throw new Error(
            `States that specify the 'parent:' property should not have a '.' in their name (${name})`,
          );
        }

        // 'foo.bar'
        return segments.join(".");
      }

      if (!state.parent) return "";

      return isString(state.parent) ? state.parent : state.parent.name;
    }

    name(state) {
      const { name } = state;

      if (name.indexOf(".") !== -1 || !state.parent) return name;
      const parentName = isString(state.parent)
        ? state.parent
        : state.parent.name;

      return parentName ? `${parentName}.${name}` : name;
    }
  }

  function isRoot(state) {
    return state.name === "";
  }

  /** extracts the token from a Provider or provide literal */
  function getToken(provider) {
    return provider.provide || provider.token;
  }

  class StateQueueManager {
    /**
     * @param {import("./state-registry.js").StateRegistryProvider} stateRegistry
     * @param {*} urlServiceRules
     * @param {Record<string, ng.StateObject>} states
     * @param {*} builder
     * @param {*} listeners
     */
    constructor(stateRegistry, urlServiceRules, states, builder, listeners) {
      this.stateRegistry = stateRegistry;
      this.urlServiceRules = urlServiceRules;
      this.states = states;
      this.builder = builder;
      this.listeners = listeners;
      /**
       * @type {Array<StateObject>}
       */
      this.queue = [];
    }

    register(stateDecl) {
      const state = new StateObject(stateDecl);

      if (!isString(name)) throw new Error("State must have a valid name");

      if (
        hasOwn(this.states, state.name) ||
        this.queue.map((x) => x.name).includes(state.name)
      )
        throw new Error(`State '${state.name}' is already defined`);
      this.queue.push(state);
      this.flush();

      return state;
    }

    flush() {
      const { queue, states, builder } = this;

      const registered = [], // states that got registered
        orphans = [], // states that don't yet have a parent registered
        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered

      const getState = (name) => hasOwn(this.states, name) && this.states[name];

      const notifyListeners = () => {
        if (registered.length) {
          this.listeners.forEach((listener) =>
            listener(
              "registered",
              registered.map((x) => x.self),
            ),
          );
        }
      };

      while (queue.length > 0) {
        const state = queue.shift();

        const { name } = state;

        const result = builder.build(state);

        const orphanIdx = orphans.indexOf(state);

        if (result) {
          const existingState = getState(name);

          if (existingState && existingState.name === name) {
            throw new Error(`State '${name}' is already defined`);
          }
          const existingFutureState = getState(`${name}.**`);

          if (existingFutureState) {
            // Remove future state of the same name
            this.stateRegistry.deregister(existingFutureState);
          }
          states[name] = state;
          this.attachRoute(state);

          if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);
          registered.push(state);
          continue;
        }
        const prev = previousQueueLength[name];

        previousQueueLength[name] = queue.length;

        if (orphanIdx >= 0 && prev === queue.length) {
          // Wait until two consecutive iterations where no additional states were dequeued successfully.
          // throw new Error(`Cannot register orphaned state '${name}'`);
          queue.push(state);
          notifyListeners();

          return states;
        } else if (orphanIdx < 0) {
          orphans.push(state);
        }
        queue.push(state);
      }
      notifyListeners();

      return states;
    }

    attachRoute(state) {
      if (state.abstract || !state.url) return;
      const rulesApi = this.urlServiceRules;

      rulesApi.rule(rulesApi.urlRuleFactory.create(state));
    }
  }

  /** @typedef {import('../../interface.ts').ServiceProvider} ServiceProvider } */
  /**
   * A registry for all of the application's [[StateDeclaration]]s
   *
   * This API is found at `$stateRegistry` ([[UIRouter.stateRegistry]])
   *
   */
  class StateRegistryProvider {
    /* @ignore */ static $inject = provider([
      $injectTokens._url,
      $injectTokens._state,
      $injectTokens._router,
      $injectTokens._view,
    ]);

    /**
     * @param {ng.UrlService} urlService
     * @param {ng.StateService} stateService
     * @param {ng.RouterService} globals
     * @param {ng.ViewService} viewService
     */
    constructor(urlService, stateService, globals, viewService) {
      /** @type {Record<string, import("./state-object.js").StateObject>} */
      this.states = {};

      stateService.stateRegistry = this; // <- circular wiring
      this.urlService = urlService;
      this.urlServiceRules = urlService.rules;
      this.$injector = undefined;
      this.listeners = [];
      this.matcher = new StateMatcher(this.states);
      this.builder = new StateBuilder(this.matcher, urlService);
      // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties
      // TODO we can probably move this inside buildr
      this.builder.builder("views", ng1ViewsBuilder);
      this.builder.builder("onExit", this.getStateHookBuilder("onExit"));
      this.builder.builder("onRetain", this.getStateHookBuilder("onRetain"));
      this.builder.builder("onEnter", this.getStateHookBuilder("onEnter"));

      this.stateQueue = new StateQueueManager(
        this,
        this.urlServiceRules,
        this.states,
        this.builder,
        this.listeners,
      );

      this.registerRoot();

      viewService.rootViewContext(this.root());
      globals.$current = this.root();
      globals.current = globals.$current.self;
    }

    $get = [
      $injectTokens._injector,
      /**
       * @param {import("../../core/di/internal-injector").InjectorService} $injector
       * @returns {StateRegistryProvider}
       */
      ($injector) => {
        this.$injector = $injector;
        this.builder.$injector = $injector;

        return this;
      },
    ];

    /**
     * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,
     * `onRetain` callback hooks on a [[StateDeclaration]].
     *
     * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder
     * ensures that those hooks are injectable for @uirouter/angularjs (ng1).
     *
     * @internalapi
     */
    getStateHookBuilder(hookName) {
      const that = this;

      return function stateHookBuilder(stateObject) {
        const hook = stateObject[hookName];

        const pathname = hookName === "onExit" ? "from" : "to";

        function decoratedNg1Hook(trans, state) {
          const resolveContext = new ResolveContext(trans.treeChanges(pathname));

          const subContext = resolveContext.subContext(state.$$state());

          const locals = Object.assign(getLocals(subContext), {
            $state$: state,
            $transition$: trans,
          });

          return that.$injector.invoke(hook, that, locals);
        }

        return hook ? decoratedNg1Hook : undefined;
      };
    }

    /**
     * @private
     */
    registerRoot() {
      const rootStateDef = {
        name: "",
        url: "^",
        views: null,
        params: {
          "#": { value: null, type: "hash", dynamic: true },
        },
        abstract: true,
      };

      this._root = this.stateQueue.register(rootStateDef);
      this._root.navigable = null;
    }

    /**
     * Listen for a State Registry events
     *
     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.
     *
     * #### Example:
     * ```js
     * let allStates = registry.get();
     *
     * // Later, invoke deregisterFn() to remove the listener
     * let deregisterFn = registry.onStatesChanged((event, states) => {
     *   switch(event) {
     *     case: 'registered':
     *       states.forEach(state => allStates.push(state));
     *       break;
     *     case: 'deregistered':
     *       states.forEach(state => {
     *         let idx = allStates.indexOf(state);
     *         if (idx !== -1) allStates.splice(idx, 1);
     *       });
     *       break;
     *   }
     * });
     * ```
     *
     * @param listener a callback function invoked when the registered states changes.
     *        The function receives two parameters, `event` and `state`.
     *        See [[StateRegistryListener]]
     * @return a function that deregisters the listener
     */
    onStatesChanged(listener) {
      this.listeners.push(listener);

      return function deregisterListener() {
        removeFrom(this.listeners, listener);
      }.bind(this);
    }

    /**
     * Gets the implicit root state
     *
     * Gets the root of the state tree.
     * The root state is implicitly created by ng-router.
     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]
     *
     * @return the root [[StateObject]]
     */
    root() {
      return this._root;
    }

    /**
     * Adds a state to the registry
     *
     * Registers a [[StateDeclaration]] or queues it for registration.
     *
     * Note: a state will be queued if the state's parent isn't yet registered.
     *
     * @param stateDefinition the definition of the state to register.
     * @returns the internal [[StateObject]] object.
     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).
     *          If the state was only queued, then the object is not fully built.
     */
    register(stateDefinition) {
      return this.stateQueue.register(stateDefinition);
    }

    _deregisterTree(state) {
      const all = this.get().map((x) => x.$$state());

      const getChildren = (states) => {
        const _children = all.filter((x) => states.indexOf(x.parent) !== -1);

        return _children.length === 0
          ? _children
          : _children.concat(getChildren(_children));
      };

      const children = getChildren([state]);

      const deregistered = [state].concat(children).reverse();

      deregistered.forEach((_state) => {
        const rulesApi = this.urlServiceRules;

        // Remove URL rule
        rulesApi
          .rules()
          .filter(propEq("state", _state))
          .forEach((rule) => rulesApi.removeRule(rule));
        // Remove state from registry
        delete this.states[_state.name];
      });

      return deregistered;
    }

    /**
     * Removes a state from the registry
     *
     * This removes a state from the registry.
     * If the state has children, they are are also removed from the registry.
     *
     * @param stateOrName the state's name or object representation
     * @returns {import('./state-object').StateObject[]} a list of removed states
     */
    deregister(stateOrName) {
      const _state = this.get(stateOrName);

      if (!_state)
        throw new Error(`Can't deregister state; not found: ${stateOrName}`);
      const deregisteredStates = this._deregisterTree(_state.$$state());

      this.listeners.forEach((listener) =>
        listener(
          "deregistered",
          deregisteredStates.map((x) => x.self),
        ),
      );

      return deregisteredStates;
    }

    /**
     * @return {ng.BuiltStateDeclaration[]}
     */
    getAll() {
      return keys(this.states).map(
        (name) =>
          /** @type {ng.BuiltStateDeclaration} */ (this.states[name].self),
      );
    }

    get(stateOrName, base) {
      if (arguments.length === 0)
        return keys(this.states).map((name) => this.states[name].self);
      const found = this.matcher.find(stateOrName, base);

      return (found && found.self) || null;
    }

    /**
     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).
     * More than one BuilderFunction can be registered for a given property.
     *
     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.
     *
     * @param property The name of the State property being registered for.
     * @param builderFunction The BuilderFunction which will be used to build the State property
     * @returns a function which deregisters the BuilderFunction
     */
    decorator(property, builderFunction) {
      return this.builder.builder(property, builderFunction);
    }
  }

  const getLocals = (ctx) => {
    const tokens = ctx.getTokens().filter(isString);

    const tuples = tokens.map((key) => {
      const resolvable = ctx.getResolvable(key);

      const waitPolicy = ctx.getPolicy(resolvable).async;

      return [
        key,
        waitPolicy === "NOWAIT" ? resolvable.promise : resolvable.data,
      ];
    });

    return tuples.reduce(applyPairs, {});
  };

  function parseStateRef(ref) {
    const paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);

    if (paramsOnly) ref = `(${paramsOnly[1]})`;
    const parsed = ref
      .replace(/\n/g, " ")
      .match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);

    if (!parsed || parsed.length !== 4)
      throw new Error(`Invalid state ref '${ref}'`);

    return { state: parsed[1] || null, paramExpr: parsed[3] || null };
  }

  function stateContext(el) {
    const $ngView = getInheritedData(el, "$ngView");

    const path = parse("$cfg.path")($ngView);

    return path ? tail(path).state.name : undefined;
  }

  function processedDef($state, $element, def) {
    const ngState = def.ngState || $state.current.name;

    const ngStateOpts = Object.assign(
      defaultOpts($element, $state),
      def.ngStateOpts || {},
    );

    const href = $state.href(ngState, def.ngStateParams, ngStateOpts);

    return { ngState, ngStateParams: def.ngStateParams, ngStateOpts, href };
  }

  function getTypeInfo(el) {
    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.
    const isSvg =
      Object.prototype.toString.call(el.getAttribute("href")) ===
      "[object SVGAnimatedString]";

    const isForm = el.nodeName === "FORM";

    return {
      attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
      isAnchor: el.nodeName === "A",
      clickable: !isForm,
    };
  }

  function clickHook(el, $state, type, getDef, scope) {
    return function (event) {
      const button = event.which || event.button,
        target = getDef();

      const res =
        button > 1 ||
        event.ctrlKey ||
        event.metaKey ||
        event.shiftKey ||
        event.altKey ||
        el.getAttribute("target");

      if (!res) {
        // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
        const transition = setTimeout(function () {
          if (!el.getAttribute("disabled")) {
            $state
              .go(target.ngState, target.ngStateParams, target.ngStateOpts)
              .then(() => {
                scope.$emit("$updateBrowser");
              });
          }
        });

        event.preventDefault();
        // if the state has no URL, ignore one preventDefault from the <a> directive.
        let ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;

        event.preventDefault = function () {
          if (ignorePreventDefaultCount-- <= 0) clearTimeout(transition);
        };
      } else {
        // ignored
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    };
  }

  function defaultOpts(el, $state) {
    return {
      relative: stateContext(el) || $state.$current,
      inherit: true,
      source: "sref",
    };
  }

  function bindEvents(element, scope, hookFn, ngStateOpts) {
    let events = ngStateOpts ? ngStateOpts.events : undefined;

    if (!isArray(events)) {
      events = ["click"];
    }
    //const on = element.on ? "on" : "bind";

    for (const event of events) {
      element.addEventListener(event, hookFn);
    }
    scope.$on("$destroy", function () {
      // const off = element.off ? "off" : "unbind";
      for (const event of events) {
        element.removeEventListener(event, hookFn);
      }
    });
  }

  // // TODO: SEPARATE THESE OUT

  $StateRefDirective.$inject = [
    $injectTokens._state,
    $injectTokens._stateRegistry,
    $injectTokens._transitions,
  ];

  /**
   * @param {ng.StateService} $stateService
   * @param {ng.StateRegistryService} $stateRegistry
   * @param {ng.TransitionService} $transitions
   * @returns {ng.Directive}
   */
  function $StateRefDirective(
    $stateService,
    $stateRegistry,
    $transitions,
  ) {
    const $state = $stateService;

    return {
      restrict: "A",
      require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
      link: (scope, element, attrs, ngSrefActive) => {
        const type = getTypeInfo(element);

        const active = ngSrefActive[1] || ngSrefActive[0];

        let unlinkInfoFn = null;

        const rawDef = {};

        const getDef = () => processedDef($state, element, rawDef);

        const ref = parseStateRef(attrs.ngSref);

        rawDef.ngState = ref.state;
        rawDef.ngStateOpts = attrs.ngSrefOpts
          ? scope.$eval(attrs.ngSrefOpts)
          : {};

        function update() {
          rawDef.ngStateParams = Object.assign({}, scope.$eval(ref.paramExpr));
          const def = getDef();

          if (unlinkInfoFn) {
            unlinkInfoFn();
          }

          if (active) {
            unlinkInfoFn = active.$$addStateInfo(def.ngState, def.ngStateParams);
          }

          if (!isNullOrUndefined(def.href)) {
            attrs.$set(type.attr, def.href);
          }
        }

        if (ref.paramExpr) {
          scope.$watch(
            ref.paramExpr,
            function (val) {
              rawDef.ngStateParams = Object.assign({}, val);
              update();
            },
            true,
          );
          rawDef.ngStateParams = Object.assign({}, scope.$eval(ref.paramExpr));
        }

        update();
        scope.$on("$destroy", $stateRegistry.onStatesChanged(update));
        scope.$on("$destroy", $transitions.onSuccess({}, update));

        if (!type.clickable) {
          return;
        }
        bindEvents(
          element,
          scope,
          clickHook(element, $state, type, getDef, scope),
          rawDef.ngStateOpts,
        );
      },
    };
  }

  $StateRefDynamicDirective.$inject = [
    $injectTokens._state,
    $injectTokens._stateRegistry,
    $injectTokens._transitions,
  ];

  /**
   * @param {ng.StateService} $state
   * @param {ng.StateRegistryService} $stateRegistry
   * @param {ng.TransitionService} $transitions
   * @returns {ng.Directive}
   */
  function $StateRefDynamicDirective(
    $state,
    $stateRegistry,
    $transitions,
  ) {
    return {
      restrict: "A",
      require: ["?^ngSrefActive", "?^ngSrefActiveEq"],
      link(scope, element, attrs, ngSrefActive) {
        const type = getTypeInfo(element);

        const active = ngSrefActive[1] || ngSrefActive[0];

        let unlinkInfoFn = null;

        const rawDef = {};

        const getDef = () => processedDef($state, element, rawDef);

        const inputAttrs = ["ngState", "ngStateParams", "ngStateOpts"];

        const watchDeregFns = inputAttrs.reduce(
          (acc, attr) => (
            (acc[attr] = () => {
              /* empty */
            }),
            acc
          ),
          {},
        );

        function update() {
          const def = getDef();

          if (unlinkInfoFn) {
            unlinkInfoFn();
          }

          if (active) {
            unlinkInfoFn = active.$$addStateInfo(def.ngState, def.ngStateParams);
          }

          if (!isNullOrUndefined(def.href)) {
            attrs.$set(type.attr, def.href);
          }
        }
        inputAttrs.forEach((field) => {
          rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;
          attrs.$observe(field, (expr) => {
            watchDeregFns[field]();
            watchDeregFns[field] = scope.$watch(expr, (newval) => {
              rawDef[field] = newval;
              update();
            });
          });
        });
        update();
        scope.$on("$destroy", $stateRegistry.onStatesChanged(update));
        scope.$on("$destroy", $transitions.onSuccess({}, update));

        if (!type.clickable) return;
        const hookFn = clickHook(element, $state, type, getDef, scope);

        bindEvents(element, scope, hookFn, rawDef.ngStateOpts);
      },
    };
  }

  $StateRefActiveDirective.$inject = [
    $injectTokens._state,
    $injectTokens._router,
    $injectTokens._interpolate,
    $injectTokens._stateRegistry,
    $injectTokens._transitions,
  ];

  /**
   * @param {ng.StateService} $state
   * @param {ng.RouterService} $router
   * @param {ng.InterpolateService} $interpolate
   * @param {*} $stateRegistry
   * @param {*} $transitions
   * @returns {ng.Directive}
   */
  function $StateRefActiveDirective(
    $state,
    $router,
    $interpolate,
    $stateRegistry,
    $transitions,
  ) {
    return {
      restrict: "A",
      controller($scope, $element, $attrs) {
        let states = [];

        let ngSrefActive;

        // There probably isn't much point in $observing this
        // ngSrefActive and ngSrefActiveEq share the same directive object with some
        // slight difference in logic routing
        const activeEqClass = $interpolate(
          $attrs.ngSrefActiveEq || "",
          false,
        )($scope);

        try {
          ngSrefActive = $scope.$eval($attrs.ngSrefActive);
        } catch {
          // Do nothing. ngSrefActive is not a valid expression.
          // Fall back to using $interpolate below
        }
        ngSrefActive =
          ngSrefActive || $interpolate($attrs.ngSrefActive || "", false)($scope);
        setStatesFromDefinitionObject(ngSrefActive);
        // Allow ngSref to communicate with ngSrefActive[Equals]
        this.$$addStateInfo = function (newState, newParams) {
          // we already got an explicit state provided by ng-sref-active, so we
          // shadow the one that comes from ng-sref
          if (isObject(ngSrefActive) && states.length > 0) {
            return undefined;
          }
          const deregister = addState(newState, newParams, ngSrefActive);

          update();

          return deregister;
        };
        function updateAfterTransition(trans) {
          trans.promise.then(update, () => {
            /* empty */
          });
        }
        $scope.$on("$destroy", setupEventListeners());

        if ($router.transition) {
          updateAfterTransition($router.transition);
        }
        function setupEventListeners() {
          const deregisterStatesChangedListener =
            $stateRegistry.onStatesChanged(handleStatesChanged);

          const deregisterOnStartListener = $transitions.onStart(
            {},
            updateAfterTransition,
          );

          const deregisterStateChangeSuccessListener = $scope.$on(
            "$stateChangeSuccess",
            update,
          );

          return function cleanUp() {
            deregisterStatesChangedListener();
            deregisterOnStartListener();
            deregisterStateChangeSuccessListener();
          };
        }
        function handleStatesChanged() {
          setStatesFromDefinitionObject(ngSrefActive);
        }
        function setStatesFromDefinitionObject(statesDefinition) {
          if (isObject(statesDefinition)) {
            states = [];
            entries(statesDefinition).forEach(([activeClass, stateOrName]) => {
              // Helper function to abstract adding state.
              /**
               * @param {string|string[]} stateOrNameParam
               * @param {string} activeClassParam
               */
              const addStateForClass = function (
                stateOrNameParam,
                activeClassParam,
              ) {
                const ref = parseStateRef(stateOrNameParam);

                addState(
                  ref.state,
                  $scope.$eval(ref.paramExpr),
                  activeClassParam,
                );
              };

              if (isString(stateOrName)) {
                // If state is string, just add it.
                addStateForClass(stateOrName, activeClass);
              } else if (isArray(stateOrName)) {
                // If state is an array, iterate over it and add each array item individually.
                stateOrName.forEach((stateOrNameParam) => {
                  addStateForClass(stateOrNameParam, activeClass);
                });
              }
            });
          }
        }
        function addState(stateName, stateParams, activeClass) {
          const state = $state.get(stateName, stateContext($element));

          const stateInfo = {
            state: state || { name: stateName },
            params: stateParams,
            activeClass,
          };

          states.push(stateInfo);

          return function removeState() {
            removeFrom(states, stateInfo);
          };
        }
        // Update route state
        function update() {
          const splitClasses = (str) => str.split(/\s/).filter(Boolean);

          const getClasses = (stateList) =>
            stateList
              .map((x) => x.activeClass)
              .map(splitClasses)
              .reduce(unnestR, []);

          const allClasses = getClasses(states)
            .concat(splitClasses(activeEqClass))
            .reduce(uniqR, []);

          const fuzzyClasses = getClasses(
            states.filter((x) => $state.includes(x.state.name, x.params)),
          );

          const exactlyMatchesAny = !!states.filter((x) =>
            $state.is(x.state.name, x.params),
          ).length;

          const exactClasses = exactlyMatchesAny
            ? splitClasses(activeEqClass)
            : [];

          const addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []);

          const removeClasses = allClasses.filter(
            (cls) => !addClasses.includes(cls),
          );

          addClasses.forEach((className) => $element.classList.add(className));
          removeClasses.forEach((className) =>
            $element.classList.remove(className),
          );
        }
        update();
      },
    };
  }

  /**
   * `ng-view`: A viewport directive which is filled in by a view from the active state.
   *
   * ### Attributes
   *
   * - `name`: (Optional) A view name.
   *   The name should be unique amongst the other views in the same state.
   *   You can have views of the same name that live in different states.
   *   The ng-view can be targeted in a View using the name ([[StateDeclaration.views]]).
   *
   * - `autoscroll`: an expression. When it evaluates to true, the `ng-view` will be scrolled into view when it is activated.
   *   Uses [[$viewScroll]] to do the scrolling.
   *
   * - `onload`: Expression to evaluate whenever the view updates.
   *
   * #### Example:
   * A view can be unnamed or named.
   * ```html
   * <!-- Unnamed -->
   * <div ng-view></div>
   *
   * <!-- Named -->
   * <div ng-view="viewName"></div>
   *
   * <!-- Named (different style) -->
   * <ng-view name="viewName"></ng-view>
   * ```
   *
   * You can only have one unnamed view within any template (or root html). If you are only using a
   * single view and it is unnamed then you can populate it like so:
   *
   * ```html
   * <div ng-view></div>
   * $stateProvider.state("home", {
   *   template: "<h1>HELLO!</h1>"
   * })
   * ```
   *
   * The above is a convenient shortcut equivalent to specifying your view explicitly with the
   * [[StateDeclaration.views]] config property, by name, in this case an empty name:
   *
   * ```js
   * $stateProvider.state("home", {
   *   views: {
   *     "": {
   *       template: "<h1>HELLO!</h1>"
   *     }
   *   }
   * })
   * ```
   *
   * But typically you'll only use the views property if you name your view or have more than one view
   * in the same template. There's not really a compelling reason to name a view if its the only one,
   * but you could if you wanted, like so:
   *
   * ```html
   * <div ng-view="main"></div>
   * ```
   *
   * ```js
   * $stateProvider.state("home", {
   *   views: {
   *     "main": {
   *       template: "<h1>HELLO!</h1>"
   *     }
   *   }
   * })
   * ```
   *
   * Really though, you'll use views to set up multiple views:
   *
   * ```html
   * <div ng-view></div>
   * <div ng-view="chart"></div>
   * <div ng-view="data"></div>
   * ```
   *
   * ```js
   * $stateProvider.state("home", {
   *   views: {
   *     "": {
   *       template: "<h1>HELLO!</h1>"
   *     },
   *     "chart": {
   *       template: "<chart_thing/>"
   *     },
   *     "data": {
   *       template: "<data_thing/>"
   *     }
   *   }
   * })
   * ```
   *
   * #### Examples for `autoscroll`:
   * ```html
   * <!-- If autoscroll present with no expression,
   *      then scroll ng-view into view -->
   * <ng-view autoscroll/>
   *
   * <!-- If autoscroll present with valid expression,
   *      then scroll ng-view into view if expression evaluates to true -->
   * <ng-view autoscroll='true'/>
   * <ng-view autoscroll='false'/>
   * <ng-view autoscroll='scopeVariable'/>
   * ```
   *
   * Resolve data:
   *
   * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this
   * can be customized using [[ViewDeclaration.resolveAs]]).  This can be then accessed from the template.
   *
   * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the
   * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which
   * depends on `$resolve` data.
   *
   * #### Example:
   * ```js
   * $stateProvider.state('home', {
   *   template: '<my-component user="$resolve.user"></my-component>',
   *   resolve: {
   *     user: function(UserService) { return UserService.fetchUser(); }
   *   }
   * });
   * ```
   */

  $ViewDirective.$inject = [
    $injectTokens._view,
    $injectTokens._animate,
    $injectTokens._viewScroll,
    $injectTokens._interpolate,
  ];

  /**
   * @param {ng.ViewService} $view
   * @param {ng.AnimateService} $animate
   * @param {ng.AnchorScrollService} $viewScroll
   * @param {ng.InterpolateService} $interpolate
   * @returns {ng.Directive}
   */
  function $ViewDirective($view, $animate, $viewScroll, $interpolate) {
    function getRenderer() {
      return {
        enter(element, target, cb) {
          if (hasAnimate(element)) {
            $animate.enter(element, null, target).then(cb);
          } else {
            target.after(element);
            cb();
          }
        },
        leave(element, cb) {
          if (hasAnimate(element)) {
            $animate.leave(element).then(cb);
          } else {
            element.parentElement.removeChild(element);
            cb();
          }
        },
      };
    }
    function configsEqual(config1, config2) {
      return config1 === config2;
    }
    const rootData = {
      $cfg: { viewDecl: { $context: $view.rootViewContext() } },
      $ngView: {},
    };

    const directive = {
      count: 0,
      terminal: true,
      priority: 400,
      transclude: "element",
      compile(_tElement, _tAttrs, $transclude) {
        return function (scope, $element, attrs) {
          const onloadExp = attrs.onload || "",
            autoScrollExp = attrs.autoscroll,
            renderer = getRenderer(),
            inherited = getInheritedData($element, "$ngView") || rootData,
            name =
              $interpolate(attrs.ngView || attrs.name || "")(scope) || "$default";

          let previousEl, currentEl, currentScope, viewConfig;

          const activeUIView = {
            id: directive.count++, // Global sequential ID for ng-view tags added to DOM
            name, // ng-view name (<div ng-view="name"></div>
            fqn: inherited.$ngView.fqn
              ? `${inherited.$ngView.fqn}.${name}`
              : name, // fully qualified name, describes location in DOM
            config: null, // The ViewConfig loaded (from a state.views definition)
            configUpdated: configUpdatedCallback, // Called when the matching ViewConfig changes
            get creationContext() {
              // The context in which this ng-view "tag" was created
              const fromParentTagConfig = parse("$cfg.viewDecl.$context")(
                inherited,
              );

              // Allow <ng-view name="foo"><ng-view name="bar"></ng-view></ng-view>
              // See https://github.com/angular-ui/ui-router/issues/3355
              const fromParentTag = parse("$ngView.creationContext")(inherited);

              return fromParentTagConfig || fromParentTag;
            },
          };

          trace.traceUIViewEvent("Linking", activeUIView);
          function configUpdatedCallback(config) {
            if (config && !(config instanceof ViewConfig)) return;

            if (configsEqual(viewConfig, config)) return;
            trace.traceUIViewConfigUpdated(
              activeUIView,
              config && config.viewDecl && config.viewDecl.$context,
            );
            viewConfig = config;
            updateView(config);
          }

          setCacheData($element, "$ngView", { $ngView: activeUIView });
          updateView();
          const unregister = $view.registerUIView(activeUIView);

          scope.$on("$destroy", function () {
            trace.traceUIViewEvent("Destroying/Unregistering", activeUIView);
            unregister();
          });
          function cleanupLastView() {
            if (previousEl) {
              trace.traceUIViewEvent(
                "Removing (previous) el",
                getCacheData(previousEl, "$ngView"),
              );
              previousEl.remove();
              previousEl = null;
            }

            if (currentScope) {
              trace.traceUIViewEvent("Destroying scope", activeUIView);
              currentScope.$destroy();
              currentScope = null;
            }

            if (currentEl) {
              const _viewData = getCacheData(currentEl, "$ngViewAnim");

              trace.traceUIViewEvent("Animate out", _viewData);
              renderer.leave(currentEl, function () {
                _viewData.$$animLeave.resolve();
                previousEl = null;
              });
              previousEl = currentEl;
              currentEl = null;
            }
          }
          function updateView(config) {
            const newScope = scope.$new();

            const animEnter = Promise.withResolvers();

            const animLeave = Promise.withResolvers();

            const $ngViewData = {
              $cfg: config,
              $ngView: activeUIView,
            };

            const $ngViewAnim = {
              $animEnter: animEnter.promise,
              $animLeave: animLeave.promise,
              $$animLeave: animLeave,
            };

            /**
             * Fired once the view **begins loading**, *before* the DOM is rendered.
             *
             * @param {Object} event Event object.
             * @param {string} viewName Name of the view.
             */
            newScope.$emit("$viewContentLoading", name);
            currentEl = $transclude(newScope, function (clone) {
              setCacheData(clone, "$ngViewAnim", $ngViewAnim);
              setCacheData(clone, "$ngView", $ngViewData);
              renderer.enter(clone, $element, function () {
                animEnter.resolve();

                if (currentScope)
                  currentScope.$emit("$viewContentAnimationEnded");

                if (
                  (isDefined(autoScrollExp) && !autoScrollExp) ||
                  scope.$eval(autoScrollExp)
                ) {
                  /** @type {ng.AnchorScrollFunction} */ ($viewScroll)(clone);
                }
              });
              cleanupLastView();
            });
            currentScope = newScope;
            /**
             * Fired once the view is **loaded**, *after* the DOM is rendered.
             *
             * @param {Object} event Event object.
             */
            currentScope.$emit("$viewContentLoaded", config || viewConfig);
            currentScope.$eval(onloadExp);
          }
        };
      },
    };

    return directive;
  }

  $ViewDirectiveFill.$inject = [
    $injectTokens._compile,
    $injectTokens._controller,
    $injectTokens._transitions,
  ];

  /**
   * @param {ng.CompileService} $compile
   * @param {ng.ControllerService} $controller
   * @param {ng.TransitionService} $transitions
   * @returns
   */
  function $ViewDirectiveFill($compile, $controller, $transitions) {
    const getControllerAs = parse("viewDecl.controllerAs");

    const getResolveAs = parse("viewDecl.resolveAs");

    return {
      priority: -400,
      compile(tElement) {
        const initial = tElement.innerHTML;

        dealoc(tElement, true);

        return function (scope, $element) {
          const data = getCacheData($element, "$ngView");

          if (!data) {
            $element.innerHTML = initial;
            $compile($element.contentDocument || $element.childNodes)(scope);

            return;
          }
          const cfg = data.$cfg || {
            viewDecl: {},
            getTemplate: () => {
              /* empty */
            },
          };

          const resolveCtx = cfg.path && new ResolveContext(cfg.path);

          $element.innerHTML = cfg.getTemplate($element, resolveCtx) || initial;
          trace.traceUIViewFill(data.$ngView, $element.innerHTML);
          const link = $compile($element.contentDocument || $element.childNodes);

          const { controller } = cfg;

          const controllerAs = getControllerAs(cfg);

          const resolveAs = getResolveAs(cfg);

          const locals = resolveCtx && getLocals(resolveCtx);

          if (resolveAs) {
            scope.$target[resolveAs] = locals;
          }

          if (controller) {
            const controllerInstance = $controller(
              controller,
              Object.assign({}, locals, { $scope: scope, $element }),
            );

            if (controllerAs) {
              scope.$target[controllerAs] = controllerInstance;
              scope.$target[controllerAs][resolveAs] = locals;
            }
            // TODO: Use $view service as a central point for registering component-level hooks
            // Then, when a component is created, tell the $view service, so it can invoke hooks
            // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });
            // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));
            setCacheData($element, "$ngControllerController", controllerInstance);
            Array.from($element.children).forEach((ell) => {
              setCacheData(ell, "$ngControllerController", controllerInstance);
            });
            registerControllerCallbacks(
              $transitions,
              controllerInstance,
              scope,
              cfg,
            );
          }
          // Wait for the component to appear in the DOM
          // if (isString(cfg.component)) {
          //const kebobName = kebobString(cfg.component);
          // const tagRegexp = new RegExp(`^(x-|data-)?${kebobName}$`, "i");
          // const getComponentController = () => {
          //   const directiveEl = [].slice
          //     .call($element.children)
          //     .filter((el) => el && el.tagName && tagRegexp.exec(el.tagName));
          //   return (
          //     directiveEl &&
          //     getCacheData(directiveEl, `$${cfg.component}Controller`)
          //   );
          // };
          //console.error(getComponentController());
          // const deregisterWatch = scope.$watch(
          //   getComponentController,
          //   function (ctrlInstance) {
          //     if (!ctrlInstance) return;
          //     registerControllerCallbacks(
          //       $transitions,
          //       ctrlInstance,
          //       scope,
          //       cfg,
          //     );
          //     deregisterWatch();
          //   },
          // );
          // }
          link(scope);
        };
      },
    };
  }
  /** @ignore */
  /** @ignore incrementing id */
  let _uiCanExitId = 0;

  /** @ignore TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */
  function registerControllerCallbacks(
    $transitions,
    controllerInstance,
    $scope,
    cfg,
  ) {
    // Call $onInit() ASAP
    if (
      isFunction(controllerInstance.$onInit) &&
      !(cfg.viewDecl.component || cfg.viewDecl.componentProvider)
    ) {
      controllerInstance.$onInit();
    }
    const viewState = tail(cfg.path).state.self;

    const hookOptions = { bind: controllerInstance };

    // Add component-level hook for onUiParamsChanged
    if (isFunction(controllerInstance.uiOnParamsChanged)) {
      const resolveContext = new ResolveContext(cfg.path);

      const viewCreationTrans = resolveContext.getResolvable("$transition$").data;

      // Fire callback on any successful transition
      const paramsUpdated = ($transition$) => {
        // Exit early if the $transition$ is the same as the view was created within.
        // Exit early if the $transition$ will exit the state the view is for.
        if (
          $transition$ === viewCreationTrans ||
          $transition$.exiting().indexOf(viewState) !== -1
        )
          return;
        const toParams = $transition$.params("to");

        const fromParams = $transition$.params("from");

        const getNodeSchema = (node) => node.paramSchema;

        const toSchema = $transition$
          .treeChanges("to")
          .map(getNodeSchema)
          .reduce(unnestR, []);

        const fromSchema = $transition$
          .treeChanges("from")
          .map(getNodeSchema)
          .reduce(unnestR, []);

        // Find the to params that have different values than the from params
        const changedToParams = toSchema.filter((param) => {
          const idx = fromSchema.indexOf(param);

          return (
            idx === -1 ||
            !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id])
          );
        });

        // Only trigger callback if a to param has changed or is new
        if (changedToParams.length) {
          const changedKeys = changedToParams.map((x) => x.id);

          // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.
          const newValues = filter(
            toParams,
            (val, key) => changedKeys.indexOf(key) !== -1,
          );

          controllerInstance.uiOnParamsChanged(newValues, $transition$);
        }
      };

      $scope.$on(
        "$destroy",
        $transitions.onSuccess({}, paramsUpdated, hookOptions),
      );
    }

    // Add component-level hook for uiCanExit
    if (isFunction(controllerInstance.uiCanExit)) {
      const id = _uiCanExitId++;

      const cacheProp = "_uiCanExitIds";

      // Returns true if a redirect transition already answered truthy
      const prevTruthyAnswer = (trans) =>
        !!trans &&
        ((trans[cacheProp] && trans[cacheProp][id] === true) ||
          prevTruthyAnswer(trans.redirectedFrom()));

      // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition
      const wrappedHook = (trans) => {
        let promise;

        const ids = (trans[cacheProp] = trans[cacheProp] || {});

        if (!prevTruthyAnswer(trans)) {
          promise = Promise.resolve(controllerInstance.uiCanExit(trans));
          promise.then((val) => (ids[id] = val !== false));
        }

        return promise;
      };

      const criteria = { exiting: viewState.name };

      $scope.$on(
        "$destroy",
        $transitions.onBefore(criteria, wrappedHook, hookOptions),
      );
    }
  }

  ngChannelDirective.$inject = [$injectTokens._eventBus];
  /**
   * @param {ng.PubSubService} $eventBus
   * @returns {ng.Directive}
   */
  function ngChannelDirective($eventBus) {
    return {
      link: (scope, element, attrs) => {
        const channel = attrs.ngChannel;

        const hasTemplateContent = element.childNodes.length > 0;

        const unsubscribe = $eventBus.subscribe(channel, (value) => {
          if (hasTemplateContent) {
            if (isObject(value)) {
              scope.$merge(value);
            }
          } else {
            element.innerHTML = value;
          }
        });

        scope.$on("$destroy", () => unsubscribe());
      },
    };
  }

  ngSetterDirective.$inject = [$injectTokens._parse, $injectTokens._log];

  /**
   * @param {ng.ParseService} $parse
   * @param {ng.LogService} $log
   * @returns {import('interface.ts').Directive}
   */
  function ngSetterDirective($parse, $log) {
    return {
      restrict: "A",
      link(scope, element, attrs) {
        const modelExpression = attrs.ngSetter;

        if (!modelExpression) {
          $log.warn("ng-setter: expression null");

          return;
        }

        const assignModel = $parse(modelExpression).assign;

        if (!assignModel) {
          $log.warn("ng-setter: expression invalid");

          return;
        }

        const updateModel = (value) => {
          assignModel(scope, value.trim());
        };

        const observer = new MutationObserver((mutationsList) => {
          let contentChanged = false;

          for (const mutation of mutationsList) {
            if (
              mutation.type === "childList" ||
              mutation.type === "characterData"
            ) {
              contentChanged = true;
              break;
            }
          }

          if (contentChanged) {
            updateModel(element.innerHTML);
          }
        });

        observer.observe(element, {
          childList: true,
          subtree: true,
          characterData: true,
        });

        scope.$on("$destroy", () => observer.disconnect());
        updateModel(element.innerHTML);
      },
    };
  }

  /**
   * Configurable provider for an injectable event bus
   * @implements {ng.ServiceProvider}
   */
  class PubSubProvider {
    static $inject = provider([
      $injectTokens._exceptionHandler,
      $injectTokens._angular,
    ]);

    /**
     * @param {ng.ExceptionHandlerProvider} $exceptionHandler
     * @param {ng.ServiceProvider} angularProvider
     */
    constructor($exceptionHandler, angularProvider) {
      /**
       * @type {PubSub}
       */
      this.eventBus = new PubSub($exceptionHandler.handler);
      /** @type {ng.Angular} */ (angularProvider.$get()).$eventBus =
        this.eventBus;
    }

    $get = () => this.eventBus;
  }

  class PubSub {
    /**
     * @param {ng.ExceptionHandlerService} $exceptionHandler
     */
    constructor($exceptionHandler) {
      /** @private {Object<string, Array<{fn: Function, context: any}>>} */
      this._topics = Object.create(null);

      /** @private */
      this._disposed = false;

      /** @public @type {ng.ExceptionHandlerService} */
      this.$exceptionHandler = $exceptionHandler;
    }

    /**
     * Set instance to initial state
     */
    reset() {
      /** @private {Object<string, Array<{fn: Function, context: any}>>} */
      this._topics = Object.create(null);

      /** @private */
      this._disposed = false;
    }

    /**
     * Checks if instance has been disposed.
     * @returns {boolean} True if disposed.
     */
    isDisposed() {
      return this._disposed;
    }

    /**
     * Dispose the instance, removing all topics and listeners.
     */
    dispose() {
      if (this._disposed) return;
      this._disposed = true;
      this._topics = Object.create(null);
    }

    /**
     * Subscribe a function to a topic.
     * @param {string} topic - The topic to subscribe to.
     * @param {Function} fn - The callback function to invoke when published.
     * @param {*} [context] - Optional `this` context for the callback.
     * @returns {() => boolean} A function that unsubscribes this listener.
     */
    subscribe(topic, fn, context = undefined) {
      if (this._disposed) return () => false;

      /** @type {Array<{fn: Function, context: any}>} */
      let listeners = this._topics[topic];

      if (!listeners) this._topics[topic] = listeners = [];

      const entry = { fn, context };

      listeners.push(entry);

      return () => this.unsubscribe(topic, fn, context);
    }

    /**
     * Subscribe a function to a topic only once.
     * Listener is removed before the first invocation.
     * @param {string} topic - The topic to subscribe to.
     * @param {Function} fn - The callback function.
     * @param {*} [context] - Optional `this` context for the callback.
     * @returns {() => boolean} A function that unsubscribes this listener.
     */
    subscribeOnce(topic, fn, context = undefined) {
      if (this._disposed) return () => false;

      let called = false;

      const wrapper = (...args) => {
        if (called) return;
        called = true;

        unsub(); // unsubscribe before running
        fn.apply(context, args);
      };

      const unsub = this.subscribe(topic, wrapper);

      return unsub;
    }

    /**
     * Unsubscribe a specific function from a topic.
     * Matches by function reference and optional context.
     * @param {string} topic - The topic to unsubscribe from.
     * @param {Function} fn - The listener function.
     * @param {*} [context] - Optional `this` context.
     * @returns {boolean} True if the listener was found and removed.
     */
    unsubscribe(topic, fn, context = undefined) {
      if (this._disposed) return false;

      const listeners = this._topics[topic];

      if (!listeners || listeners.length === 0) return false;

      for (let i = 0; i < listeners.length; i++) {
        const l = listeners[i];

        if (l.fn === fn && l.context === context) {
          listeners.splice(i, 1);

          return true;
        }
      }

      return false;
    }

    /**
     * Get the number of subscribers for a topic.
     * @param {string} topic
     * @returns {number}
     */
    getCount(topic) {
      const listeners = this._topics[topic];

      return listeners ? listeners.length : 0;
    }

    /**
     * Publish a value to a topic asynchronously.
     * All listeners are invoked in the order they were added.
     * @param {string} topic - The topic to publish.
     * @param {...*} args - Arguments to pass to listeners.
     * @returns {boolean} True if any listeners exist for this topic.
     */
    publish(topic, ...args) {
      if (this._disposed) return false;

      const listeners = this._topics[topic];

      if (!listeners || listeners.length === 0) return false;

      // snapshot to prevent modifications during publish from affecting this call
      const snapshot = listeners.slice();

      queueMicrotask(() => {
        for (const { fn, context } of snapshot) {
          try {
            fn.apply(context, args);
          } catch (err) {
            this.$exceptionHandler(err);
          }
        }
      });

      return true;
    }
  }

  ngInjectDirective.$inject = [$injectTokens._log, $injectTokens._injector];

  /**
   * @param {ng.LogService} $log
   * @param {ng.InjectorService} $injector
   * @returns {ng.Directive}
   */
  function ngInjectDirective($log, $injector) {
    return {
      restrict: "A",
      link(scope, _element, attrs) {
        const expr = attrs.ngInject;

        if (!expr) return;
        const tokens = expr
          .split(";")
          .map((x) => x.trim())
          .filter(Boolean);

        for (const name of tokens) {
          if ($injector.has(name)) {
            scope[name] = $injector.get(name);
          } else {
            $log.warn(`Injectable ${name} not found in $injector`);
          }
        }
      },
    };
  }

  /**
   * @returns {ng.Directive}
   */
  function ngElDirective() {
    return {
      restrict: "A",
      link(scope, element, attrs) {
        const expr = attrs.ngEl;

        const key = !expr ? element.id : expr;

        scope.$target[key] = element;
        const parent = element.parentNode;

        if (!parent) return;

        const observer = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            Array.from(mutation.removedNodes).forEach((removedNode) => {
              if (removedNode === element) {
                //
                delete scope.$target[key];
                observer.disconnect();
              }
            });
          }
        });

        observer.observe(parent, { childList: true });
      },
    };
  }

  /**
   * SSE Provider
   *
   * Usage:
   *   const source = $sse('/events', {
   *     onMessage: (data) => console.log(data),
   *     onError: (err) => console.error(err),
   *     retryDelay: 2000,
   *     heartbeatTimeout: 10000,
   *   });
   *
   *   source.close();
   */
  class SseProvider {
    constructor() {
      /**
       * Optional provider-level defaults
       * @type {ng.SseConfig}
       */
      this.defaults = {
        retryDelay: 1000,
        maxRetries: Infinity,
        heartbeatTimeout: 15000, // 15 seconds
        transformMessage(data) {
          try {
            return JSON.parse(data);
          } catch {
            return data;
          }
        },
      };
    }

    $get = [
      $injectTokens._log,
      /**
       * Returns the $sse service function
       * @param {ng.LogService} log
       * @returns {ng.SseService}
       */
      (log) => {
        this._$log = log;

        return (url, config = {}) => {
          const mergedConfig = { ...this.defaults, ...config };

          const finalUrl = this.#buildUrl(url, mergedConfig.params);

          return this.#createConnection(finalUrl, mergedConfig);
        };
      },
    ];

    /**
     * Build URL with query parameters
     * @param {string} url
     * @param {Record<string, any>=} params
     * @returns {string}
     */
    #buildUrl(url, params) {
      if (!params) return url;
      const query = entries(params)
        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
        .join("&");

      return url + (url.includes("?") ? "&" : "?") + query;
    }

    /**
     * Creates a managed SSE connection with reconnect and heartbeat
     * @param {string} url
     * @param {ng.SseConfig} config
     * @returns {import("./interface.ts").SseConnection}
     */
    #createConnection(url, config) {
      let es;

      let retryCount = 0;

      let closed = false;

      let heartbeatTimer;

      const connect = () => {
        if (closed) return;

        es = new EventSource(url, {
          withCredentials: !!config.withCredentials,
        });

        es.addEventListener("open", (event) => {
          retryCount = 0;
          config.onOpen?.(event);

          if (config.heartbeatTimeout) resetHeartbeat();
        });

        es.addEventListener("message", (event) => {
          let { data } = event;

          try {
            data = config.transformMessage ? config.transformMessage(data) : data;
          } catch {
            /* empty */
          }
          config.onMessage?.(data, event);

          if (config.heartbeatTimeout) resetHeartbeat();
        });

        es.addEventListener("error", (err) => {
          config.onError?.(err);

          if (closed) return;
          es.close();

          if (retryCount < config.maxRetries) {
            retryCount++;
            config.onReconnect?.(retryCount);
            setTimeout(connect, config.retryDelay);
          } else {
            this._$log.warn("SSE: Max retries reached");
          }
        });
      };

      const resetHeartbeat = () => {
        clearTimeout(heartbeatTimer);
        heartbeatTimer = setTimeout(() => {
          this._$log.warn("SSE: heartbeat timeout, reconnecting...");
          es.close();
          config.onReconnect?.(++retryCount);
          connect();
        }, config.heartbeatTimeout);
      };

      connect();

      return {
        close() {
          closed = true;
          clearTimeout(heartbeatTimer);
          es.close();
        },
        connect() {
          if (closed === false) {
            close();
          }
          connect();
        },
      };
    }
  }

  /**
   * @returns {ng.Directive}
   */
  function ngViewportDirective() {
    return {
      restrict: "A",
      link(scope, element, attrs) {
        const enterExpr = attrs.onEnter;

        const leaveExpr = attrs.onLeave;

        const observer = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                if (enterExpr) scope.$eval(enterExpr);
              } else {
                if (leaveExpr) scope.$eval(leaveExpr);
              }
            });
          },
          {
            root: null, // viewport
            threshold: 0.1, // consider "in view" if 10% visible
          },
        );

        observer.observe(element);

        // Clean up when the element is removed from DOM
        const parent = element.parentNode;

        let mutationObserver;

        if (parent) {
          mutationObserver = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              Array.from(mutation.removedNodes).forEach((removedNode) => {
                if (removedNode === element) {
                  observer.disconnect();
                  mutationObserver.disconnect();
                }
              });
            }
          });
          mutationObserver.observe(parent, { childList: true });
        }

        scope.$on("$destroy", () => {
          observer.disconnect();

          if (mutationObserver) mutationObserver.disconnect();
        });
      },
    };
  }

  /**
   * @return {ng.Directive}
   */
  function ngWasmDirective() {
    return {
      async link($scope, _, $attrs) {
        $scope.$target[$attrs.as || "wasm"] = (
          await instantiateWasm($attrs.src)
        ).exports;
      },
    };
  }

  /**
   * @return {ng.Directive}
   */
  function ngScopeDirective() {
    return {
      scope: false,
      async link($scope, _, $attrs) {
        $scope.$scopename = $attrs.ngScope;
      },
    };
  }

  /**
   * Service provider that creates a {@link CookieService $cookie} service.
   * @type {ng.ServiceProvider}
   */
  class CookieProvider {
    constructor() {
      /** @type {ng.CookieOptions} */
      this.defaults = {};
    }

    $get = [
      $injectTokens._exceptionHandler,
      /** @param {ng.ExceptionHandlerService} $exceptionHandler  */
      ($exceptionHandler) => new CookieService(this.defaults, $exceptionHandler),
    ];
  }

  /**
   *
   * Provides high-level APIs for interacting with browser cookies:
   *  - Raw get/set/remove
   *  - JSON serialization helpers
   *  - Global defaults supplied by $cookiesProvider
   */
  class CookieService {
    /**
     * @param {ng.CookieOptions} defaults
     *   Default cookie attributes defined by `$cookiesProvider.defaults`.
     * @param {ng.ExceptionHandlerService} $exceptionHandler
     */
    constructor(defaults, $exceptionHandler) {
      /** @private @type {ng.CookieOptions} */
      this._defaults = Object.freeze({ ...defaults });

      /** @private @type {ng.ExceptionHandlerService} */
      this._$exceptionHandler = $exceptionHandler;
    }

    /**
     * Retrieves a raw cookie value.
     *
     * @param {string} key
     * @returns {string|null}
     * @throws {URIError} – If decodeURIComponent fails.
     */
    get(key) {
      validateIsString(key, "key");

      try {
        const all = parseCookies();

        return all[key] || null;
      } catch (err) {
        throw this._$exceptionHandler(err);
      }
    }

    /**
     * Retrieves a cookie and deserializes its JSON content.
     *
     * @template T
     * @param {string} key
     * @returns {T|null}
     * @throws {SyntaxError} if cookie JSON is invalid
     */
    getObject(key) {
      validateIsString(key, "key");

      const raw = this.get(key);

      if (!raw) return null;

      try {
        return /** @type {T} */ (JSON.parse(raw));
      } catch (err) {
        this._$exceptionHandler(err);

        return null;
      }
    }

    /**
     * Returns an object containing all raw cookies.
     *
     * @returns {Record<string, string>}
     * @throws {URIError} – If decodeURIComponent fails
     */
    getAll() {
      try {
        return parseCookies();
      } catch (err) {
        return this._$exceptionHandler(err);
      }
    }

    /**
     * Sets a raw cookie value.
     *
     * @param {string} key
     * @param {string} value
     * @param {ng.CookieOptions} [options]
     */
    put(key, value, options = {}) {
      validateIsString(key, "key");
      validateIsString(value, "value");
      const encodedKey = encodeURIComponent(key);

      const encodedVal = encodeURIComponent(value);

      try {
        document.cookie = `${encodedKey}=${encodedVal}${buildOptions({
        ...this._defaults,
        ...options,
      })}`;
      } catch (err) {
        this._$exceptionHandler(err);
      }
    }

    /**
     * Serializes an object as JSON and stores it as a cookie.
     *
     * @param {string} key
     * @param {any} value
     * @param {ng.CookieOptions} [options]
     * @throws {TypeError} if Object cannot be converted to JSON
     */
    putObject(key, value, options) {
      validateIsString(key, "key");
      validateRequired(value, "value");
      assert(!isNullOrUndefined(value), BADARGVALUE);

      try {
        const str = JSON.stringify(value);

        this.put(key, str, options);
      } catch (err) {
        this._$exceptionHandler(
          new TypeError(
            `badserialize: "${key}" => ${/** @type {Error} */ (err).message}`,
          ),
        );
      }
    }

    /**
     * Removes a cookie by setting an expired date.
     *
     * @param {string} key
     * @param {ng.CookieOptions} [options]
     */
    remove(key, options = {}) {
      validateIsString(key, "key");
      this.put(key, "", {
        ...this._defaults,
        ...options,
        expires: new Date(0),
      });
    }
  }

  /*----------Helpers----------*/

  // Internal cache
  let _lastCookieString = "";

  /** @type {Record<string, string>} */
  let _lastCookieMap = Object.create(null);

  /**
   * @returns {Record<string,string>}
   * @throws {URIError} – If decodeURIComponent fails
   */
  function parseCookies() {
    const current = document.cookie;

    // Fast path: return cached object if nothing changed
    if (current === _lastCookieString) {
      return _lastCookieMap;
    }

    _lastCookieString = current;

    /** @type {Record<string, string>} */
    const out = Object.create(null);

    if (!current) {
      _lastCookieMap = out;

      return out;
    }

    const parts = current.split("; ");

    for (const part of parts) {
      const eq = part.indexOf("=");

      if (eq === -1) continue; // skip malformed cookie

      const key = decodeURIComponent(part.substring(0, eq));

      const val = decodeURIComponent(part.substring(eq + 1));

      out[key] = val; // last wins
    }

    _lastCookieMap = out;

    return out;
  }

  /**
   * Build cookie options string from an options object.
   * Safely validates types for path, domain, expires, secure, and samesite.
   *
   * @param {ng.CookieOptions} opts
   * @returns {string}
   * @throws {TypeError} if any of options are invalid
   */
  function buildOptions(opts = {}) {
    const parts = [];

    // Path
    if (isDefined(opts.path)) {
      if (!isString(opts.path))
        throw new TypeError(`${BADARG}:path ${opts.path}`);
      parts.push(`path=${opts.path}`);
    }

    // Domain
    if (isDefined(opts.domain)) {
      if (!isString(opts.domain))
        throw new TypeError(`${BADARG}:domain ${opts.domain}`);
      parts.push(`domain=${opts.domain}`);
    }

    // Expires
    if (!isNullOrUndefined(opts.expires)) {
      let expDate;

      if (opts.expires instanceof Date) {
        expDate = opts.expires;
      } else if (isNumber(opts.expires) || isString(opts.expires)) {
        expDate = new Date(opts.expires);
      } else {
        throw new TypeError(`${BADARG}:expires ${String(opts.expires)}`);
      }

      if (isNaN(expDate.getTime())) {
        throw new TypeError(`${BADARG}:expires ${String(opts.expires)}`);
      }

      parts.push(`expires=${expDate.toUTCString()}`);
    }

    // Secure
    if (opts.secure) {
      parts.push("secure");
    }

    // SameSite
    if (isDefined(opts.samesite)) {
      if (!isString(opts.samesite))
        throw new TypeError(`${BADARG}:samesite ${opts.samesite}`);
      const samesite = opts.samesite.toLowerCase();

      if (!["lax", "strict", "none"].includes(samesite)) {
        throw new TypeError(`${BADARG}:samesite ${opts.samesite}`);
      }
      parts.push(`samesite=${samesite}`);
    }

    // Join all parts with semicolons
    return parts.length ? `;${parts.join(";")}` : "";
  }

  /**
   * RFC 6570 Level 4 URI Template expander
   *
   * Supports operators: (none), +, #, ., /, ;, ?, &
   * Supports varspec modifiers: explode (*) and prefix (:len)
   *
   * Usage:
   *   expandUriTemplate("/users/{id}", { id: 10 }) === "/users/10"
   *   expandUriTemplate("/search{?q,lang}", { q: "a b", lang: "en" }) === "/search?q=a%20b&lang=en"
   *   expandUriTemplate("/repos/{owner}/{repo}/issues{?labels*}", { labels: ["bug","ui"] }) === "/repos/x/y/issues?labels=bug&labels=ui"
   *
   * @param {string} template
   * @param {Object<string, any>} vars
   * @returns {string}
   */
  function expandUriTemplate(template, vars = {}) {
    if (typeof template !== "string")
      throw new TypeError("template must be a string");

    return template.replace(/\{([^}]+)\}/g, (match, expression) => {
      return expandExpression(expression, vars);
    });
  }

  /**
   * Helper: percent-encode a string. If allowReserved true, reserved chars are NOT encoded.
   * @param {string} str
   * @param {boolean} allowReserved
   * @returns {string}
   */
  function pctEncode(str, allowReserved) {
    // encodeURIComponent, then restore reserved if allowed
    const encoded = encodeURIComponent(String(str));

    if (allowReserved) {
      // Reserved characters per RFC 3986
      return encoded.replace(
        /(%3A|%2F|%3F|%23|%5B|%5D|%40|%21|%24|%26|%27|%28|%29|%2A|%2B|%2C|%3B|%3D)/gi,
        (char) => decodeURIComponent(char),
      );
    }

    return encoded;
  }

  /**
   * Parse and expand a single expression (content between { and }).
   * @param {string} expression
   * @param {Object<string, any>} vars
   * @returns {string}
   */
  function expandExpression(expression, vars) {
    // Operator if first char in operator set
    const operator = /^[+#./;?&]/.test(expression) ? expression[0] : "";

    const op = operator;

    const varlist = op ? expression.slice(1) : expression;

    // operator configuration (separator, prefix, named, ifEmpty, allowReserved)
    /** @type {Record<string, any>} */
    const OP = {
      "": {
        sep: ",",
        prefix: "",
        named: false,
        ifEmpty: "",
        allowReserved: false,
      },
      "+": {
        sep: ",",
        prefix: "",
        named: false,
        ifEmpty: "",
        allowReserved: true,
      },
      "#": {
        sep: ",",
        prefix: "#",
        named: false,
        ifEmpty: "",
        allowReserved: true,
      },
      ".": {
        sep: ".",
        prefix: ".",
        named: false,
        ifEmpty: "",
        allowReserved: false,
      },
      "/": {
        sep: "/",
        prefix: "/",
        named: false,
        ifEmpty: "",
        allowReserved: false,
      },
      ";": {
        sep: ";",
        prefix: ";",
        named: true,
        ifEmpty: "",
        allowReserved: false,
      },
      "?": {
        sep: "&",
        prefix: "?",
        named: true,
        ifEmpty: "=",
        allowReserved: false,
      },
      "&": {
        sep: "&",
        prefix: "&",
        named: true,
        ifEmpty: "=",
        allowReserved: false,
      },
    };

    const conf = OP[op];

    if (!conf) throw new Error(`Unsupported operator: ${op}`);

    // split varspecs by comma, preserve whitespace trimmed
    const varspecs = varlist
      .split(",")
      .map((str) => str.trim())
      .filter(Boolean);

    const expandedParts = [];

    for (const spec of varspecs) {
      // parse varspec: name, explode (*), prefix (:len)
      const varspec = /^([A-Za-z0-9_.]+)(\*|(?::(\d+)))?$/.exec(spec);

      if (!varspec) throw new Error(`Invalid varspec: ${spec}`);
      const varname = varspec[1];

      const explode = varspec[2] === "*";

      const prefixLength = varspec[3] ? parseInt(varspec[3], 10) : undefined;

      const value = vars[varname];

      // undefined or null = skip (no expansion)
      if (value === undefined || value === null) {
        continue;
      }

      // PROCESS arrays
      if (isArray(value)) {
        if (value.length === 0) {
          // empty array: for named operators, emit key with empty ifEmpty, otherwise skip
          if (conf.named) {
            // emit key without value or with = depending on ifEmpty
            if (conf.ifEmpty === "=") {
              expandedParts.push(
                `${pctEncode(varname, conf.allowReserved)}${conf.ifEmpty}`,
              );
            } else {
              expandedParts.push(pctEncode(varname, conf.allowReserved));
            }
          }
          continue;
        }

        if (explode) {
          // each item becomes either 'k=v' (named) or 'v' (unnamed)
          for (const item of value) {
            if (item === null || item === undefined) continue;

            if (conf.named) {
              expandedParts.push(
                `${pctEncode(varname, conf.allowReserved)}=${pctEncode(item, conf.allowReserved)}`,
              );
            } else {
              expandedParts.push(pctEncode(item, conf.allowReserved));
            }
          }
        } else {
          // join by comma (or operator.sep?) — RFC: simple join with ','
          const joined = value
            .filter((val) => val !== null && val !== undefined)
            .map((val) => pctEncode(val, conf.allowReserved))
            .join(",");

          if (conf.named) {
            if (joined === "") {
              expandedParts.push(
                pctEncode(varname, conf.allowReserved) +
                  (conf.ifEmpty === "=" ? conf.ifEmpty : ""),
              );
            } else {
              expandedParts.push(
                `${pctEncode(varname, conf.allowReserved)}=${joined}`,
              );
            }
          } else {
            expandedParts.push(joined);
          }
        }
        continue;
      }

      // PROCESS objects (associative arrays)
      if (typeof value === "object") {
        const keys = Object.keys(value);

        if (keys.length === 0) {
          if (conf.named) {
            expandedParts.push(
              pctEncode(varname, conf.allowReserved) +
                (conf.ifEmpty === "=" ? conf.ifEmpty : ""),
            );
          }
          continue;
        }

        if (explode) {
          // each key/value pair becomes k=v (named) or k,v? For explode + named, RFC says 'k=v'
          for (const key of keys) {
            const encVal = value[key];

            if (encVal === null || encVal === undefined) continue;

            if (conf.named) {
              expandedParts.push(
                `${pctEncode(key, conf.allowReserved)}=${pctEncode(encVal, conf.allowReserved)}`,
              );
            } else {
              // unnamed explode => k,encVal form pairs
              expandedParts.push(
                `${pctEncode(key, conf.allowReserved)}=${pctEncode(encVal, conf.allowReserved)}`,
              );
            }
          }
        } else {
          // not exploded: join k,v pairs by ','
          const pairs = keys
            .map(
              (key) =>
                `${pctEncode(key, conf.allowReserved)},${pctEncode(value[key], conf.allowReserved)}`,
            )
            .join(",");

          if (conf.named) {
            if (pairs === "") {
              expandedParts.push(
                pctEncode(varname, conf.allowReserved) +
                  (conf.ifEmpty === "=" ? conf.ifEmpty : ""),
              );
            } else {
              expandedParts.push(
                `${pctEncode(varname, conf.allowReserved)}=${pairs}`,
              );
            }
          } else {
            expandedParts.push(pairs);
          }
        }
        continue;
      }

      // PROCESS scalar (string/number/boolean)
      let str = String(value);

      // apply prefix modifier if present
      if (typeof prefixLength === "number") {
        str = str.substring(0, prefixLength);
      }

      // empty string handling
      if (str === "") {
        if (conf.named) {
          // for named operators, emit key or key= depending on ifEmpty
          if (conf.ifEmpty === "=") {
            expandedParts.push(
              `${pctEncode(varname, conf.allowReserved)}${conf.ifEmpty}`,
            );
          } else {
            expandedParts.push(pctEncode(varname, conf.allowReserved));
          }
        } else {
          // unnamed operators: empty string -> nothing (skip)
          if (op === "+" || op === "#") {
            // these allow empty expansions (produce nothing)
            expandedParts.push(pctEncode(str, conf.allowReserved));
          } else {
            // skip adding anything
            expandedParts.push(pctEncode(str, conf.allowReserved));
          }
        }
        continue;
      }

      // default scalar behavior
      if (conf.named) {
        expandedParts.push(
          `${pctEncode(varname, conf.allowReserved)}=${pctEncode(str, conf.allowReserved)}`,
        );
      } else {
        expandedParts.push(pctEncode(str, conf.allowReserved));
      }
    } // end for varspecs

    if (expandedParts.length === 0) return "";

    // join parts with operator separator; prefix if needed
    return conf.prefix + expandedParts.join(conf.sep);
  }

  /**
   * @template T, ID
   */
  class RestService {
    static $nonscope = true;

    /**
     * Core REST service for CRUD operations.
     * Safe, predictable, and optionally maps raw JSON to entity class instances.
     *
     * @param {ng.HttpService} $http Angular-like $http service
     * @param {string} baseUrl Base URL or URI template
     * @param {ng.EntityClass<T>} [entityClass] Optional constructor to map JSON to objects
     * @param {Object} [options] Optional settings (interceptors, headers, etc.)
     */
    constructor($http, baseUrl, entityClass, options = {}) {
      assert(isString(baseUrl) && baseUrl.length > 0, "baseUrl required");

      /** @private */
      this._$http = $http;
      /** @private */
      this._baseUrl = baseUrl;
      /** @private */
      this._entityClass = entityClass;
      /** @private */
      this._options = options;
    }

    /**
     * Build full URL from template and parameters
     * @param {string} template
     * @param {Record<string, any>} params
     * @returns {string}
     */
    buildUrl(template, params) {
      // Safe: ensure params is an object
      return expandUriTemplate(template, params || {});
    }

    /**
     * Map raw JSON to entity instance or return as-is
     * @param {any} data
     * @returns {T|any}
     */
    #mapEntity(data) {
      if (!data) return data;

      return this._entityClass ? new this._entityClass(data) : data;
    }

    /**
     * List entities
     * @param {Record<string, any>=} params
     * @returns {Promise<T[]>}
     */
    async list(params = {}) {
      const url = this.buildUrl(this._baseUrl, params);

      const resp = await this.#request("get", url, null, params);

      if (!isArray(resp.data)) return [];

      return resp.data.map(
        /** @param {unknown} data */ (data) => this.#mapEntity(data),
      );
    }

    /**
     * Read single entity by ID
     * @param {ID} id
     * @param {Record<string, any>=} params
     * @returns {Promise<T|null>}
     */
    async read(id, params = {}) {
      assert(!isNullOrUndefined(id), `${BADARG}:id ${id}`);
      const url = this.buildUrl(`${this._baseUrl}/${id}`, params);

      const resp = await this.#request("get", url, null, params);

      return this.#mapEntity(resp.data);
    }

    /**
     * Create a new entity
     * @param {T} item
     * @returns {Promise<T>}
     */
    async create(item) {
      assert(!isNullOrUndefined(item), `${BADARG}:item ${item}`);
      const resp = await this.#request("post", this._baseUrl, item);

      return this.#mapEntity(resp.data);
    }

    /**
     * Update entity by ID
     * @param {ID} id
     * @param {Partial<T>} item
     * @returns {Promise<T|null>}
     */
    async update(id, item) {
      assert(!isNullOrUndefined(id), `${BADARG}:id ${id}`);
      const url = `${this._baseUrl}/${id}`;

      try {
        const resp = await this.#request("put", url, item);

        return this.#mapEntity(resp.data);
      } catch {
        return null;
      }
    }

    /**
     * Delete entity by ID
     * @param {ID} id
     * @returns {Promise<boolean>}
     */
    async delete(id) {
      assert(!isNullOrUndefined(id), `${BADARG}:id ${id}`);
      const url = `${this._baseUrl}/${id}`;

      try {
        await this.#request("delete", url);

        return true;
      } catch {
        return false;
      }
    }

    /**
     * Core HTTP request wrapper
     * @param {"get"|"post"|"put"|"delete"} method
     * @param {string} url
     * @param {any=} data
     * @param {Record<string, any>=} params
     * @returns {Promise<any>}
     */
    async #request(method, url, data = null, params = {}) {
      return await this._$http({
        method,
        url,
        data,
        params,
        ...this._options,
      });
    }
  }

  /**
   * Provider for registering REST endpoints during module configuration.
   */
  class RestProvider {
    constructor() {
      /** @private @type {ng.RestDefinition<any>[]} */
      this._definitions = [];
    }

    /**
     * Register a REST resource at config phase
     * @template T
     * @param {string} name Service name
     * @param {string} url Base URL or URI template
     * @param {{new(data:any):T}=} entityClass Optional entity constructor
     * @param {Object=} options Optional service options
     */
    rest(name, url, entityClass, options = {}) {
      this._definitions.push({ name, url, entityClass, options });
    }

    /**
     * $get factory: returns a factory function and allows access to named services
     * @returns {(baseUrl:string, entityClass?:Function, options?:object) => RestService & { get(name:string): RestService, listNames(): string[] }}
     */
    $get = [
      $injectTokens._http,
      /** @param {ng.HttpService} $http */
      ($http) => {
        const services = new Map();

        /**
         * @template T, ID
         * @type {(baseUrl: string, entityClass?: ng.EntityClass<T>, options?: object) => RestService<T, ID>}
         */
        const factory = (baseUrl, entityClass, options = {}) => {
          const svc = new RestService($http, baseUrl, entityClass, options);

          return svc;
        };

        // create services from pre-registered definitions
        for (const def of this._definitions) {
          const svc = factory(def.url, def.entityClass, def.options);

          services.set(def.name, svc);
        }

        return factory;
      },
    ];
  }

  /**
   * Initializes core `ng` module.
   * @param {ng.Angular} angular
   * @returns {ng.NgModule} `ng` module
   */
  function registerNgModule(angular) {
    return angular
      .module(
        "ng",
        [],
        [
          $injectTokens._provide,
          /** @param {ng.ProvideService} $provide */
          ($provide) => {
            // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.
            $provide.provider({
              $$sanitizeUri: SanitizeUriProvider,
            });
            $provide.value($injectTokens._angular, angular);
            $provide.value($injectTokens._window, window);
            $provide.value($injectTokens._document, document);
            $provide
              .provider($injectTokens._compile, CompileProvider)
              .directive({
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngChannel: ngChannelDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngDelete: ngDeleteDirective,
                ngDisabled: ngDisabledAriaDirective,
                ngEl: ngElDirective,
                ngForm: ngFormDirective,
                ngGet: ngGetDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInject: ngInjectDirective,
                ngInit: ngInitDirective,
                ngMessages: ngMessagesDirective,
                ngMessage: ngMessageDirective,
                ngMessageExp: ngMessageExpDirective,
                ngMessagesInclude: ngMessagesIncludeDirective,
                ngMessageDefault: ngMessageDefaultDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPost: ngPostDirective,
                ngPut: ngPutDirective,
                ngRef: ngRefDirective,
                ngRepeat: ngRepeatDirective,
                ngSetter: ngSetterDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSse: ngSseDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                ngMinlength: minlengthDirective,
                minlength: minlengthDirective,
                ngMaxlength: maxlengthDirective,
                maxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective,
                ngViewport: ngViewportDirective,
                ngWasm: ngWasmDirective,
                ngWorker: ngWorkerDirective,
                ngScope: ngScopeDirective,
              })
              .directive({
                input: hiddenInputBrowserCacheDirective,
                ngAnimateSwap: ngAnimateSwapDirective,
                ngAnimateChildren: $$AnimateChildrenDirective,
                // aria directives
                ngChecked: ngCheckedAriaDirective,
                ngClick: ngClickAriaDirective,
                ngDblclick: ngDblclickAriaDirective,
                ngInclude: ngIncludeFillContentDirective,
                ngHide: ngHideAriaDirective,
                ngShow: ngShowAriaDirective,
                ngMessages: ngMessagesAriaDirective,
                ngModel: ngModelAriaDirective,
                ngReadonly: ngReadonlyAriaDirective,
                ngRequired: ngRequiredAriaDirective,
                ngValue: ngValueAriaDirective,
                // router directives
                ngSref: $StateRefDirective,
                ngSrefActive: $StateRefActiveDirective,
                ngSrefActiveEq: $StateRefActiveDirective,
                ngState: $StateRefDynamicDirective,
                ngView: $ViewDirective,
              })
              .directive({
                ngView: $ViewDirectiveFill,
              })
              .directive(ngAttributeAliasDirectives)
              .directive(ngEventDirectives);
            $provide.provider({
              $aria: AriaProvider,
              $anchorScroll: AnchorScrollProvider,
              $animate: AnimateProvider,
              $$animation: AnimationProvider,
              $animateCss: AnimateCssProvider,
              $$animateCssDriver: AnimateCssDriverProvider,
              $$animateJs: AnimateJsProvider,
              $$animateJsDriver: AnimateJsDriverProvider,
              $$animateCache: AnimateCacheProvider,
              $$animateQueue: AnimateQueueProvider,
              $controller: ControllerProvider,
              $cookie: CookieProvider,
              $exceptionHandler: ExceptionHandlerProvider,
              $filter: FilterProvider,
              $interpolate: InterpolateProvider,
              $http: HttpProvider,
              $httpParamSerializer: HttpParamSerializerProvider,
              $location: LocationProvider,
              $log: LogProvider,
              $parse: ParseProvider,
              $$rAFScheduler: RafSchedulerProvider,
              $rest: RestProvider,
              $rootScope: RootScopeProvider,
              $router: RouterProvider,
              $sce: SceProvider,
              $sceDelegate: SceDelegateProvider,
              $sse: SseProvider,
              $templateCache: TemplateCacheProvider,
              $templateRequest: TemplateRequestProvider,
              $urlConfig: UrlConfigProvider,
              $view: ViewService,
              $transitions: TransitionProvider,
              $state: StateProvider,
              $viewScroll: ViewScrollProvider,
              $templateFactory: TemplateFactoryProvider,
              $url: UrlService,
              $stateRegistry: StateRegistryProvider,
              $eventBus: PubSubProvider,
            });
          },
        ],
      )
      .factory("$stateParams", [
        $injectTokens._router,
        /**
         * @param {ng.RouterService} globals
         * @returns {import('./router/params/state-params.js').StateParams }
         */
        (globals) => globals.params,
      ])
      .value("$trace", trace);
  }

  const ngMinErr = minErr("ng");

  const $injectorMinErr = minErr("$injector");

  const STRICT_DI = "strict-di";

  /** @typedef {Object.<string, NgModule|null>} ModuleRegistry */

  /** @type {ModuleRegistry} */
  const moduleRegistry = {};

  class Angular {
    constructor() {
      /** @private @type {!Array<string|any>} */
      this._bootsrappedModules = [];

      /** @public @type {ng.PubSubService} */
      this.$eventBus;

      /** @public @type {ng.InjectorService} */
      this.$injector;

      /**
       * @public
       * @type {string} `version` from `package.json`
       */
      this.version = "0.15.0"; //inserted via rollup plugin

      /**
       * Gets the controller instance for a given element, if exists. Defaults to "ngControllerController"
       *
       * @type {typeof getController}
       */
      this.getController = getController;

      /**
       * Return instance of InjectorService attached to element
       * @type {typeof getInjector}
       */
      this.getInjector = getInjector;

      /**
       * Gets scope for a given element.
       *  @type {typeof getScope}
       */
      this.getScope = getScope;

      /** @type {typeof errorHandlingConfig} */
      this.errorHandlingConfig = errorHandlingConfig;

      /** @type {ng.InjectionTokens} */
      this.$t = /** @type {ng.InjectionTokens} */ ({});
      Object.values($injectTokens).forEach((i) => {
        /** @type {any} */ (this.$t)[i] = i;
      });

      window.angular = this;
      registerNgModule(this);
    }

    /**
     *
     * The `angular.module` is a global place for creating, registering and retrieving AngularTS
     * modules.
     * All modules (AngularTS core or 3rd party) that should be available to an application must be
     * registered using this mechanism.
     *
     * Passing one argument retrieves an existing {@link ng.NgModule},
     * whereas passing more than one argument creates a new {@link ng.NgModule}
     *
     *
     * # Module
     *
     * A module is a collection of services, directives, controllers, filters, workers, WebAssembly modules, and configuration information.
     * `angular.module` is used to configure the {@link auto.$injector $injector}.
     *
     * ```js
     * // Create a new module
     * let myModule = angular.module('myModule', []);
     *
     * // register a new service
     * myModule.value('appName', 'MyCoolApp');
     *
     * // configure existing services inside initialization blocks.
     * myModule.config(['$locationProvider', function($locationProvider) {
     *   // Configure existing providers
     *   $locationProvider.hashPrefix('!');
     * }]);
     * ```
     *
     * Then you can create an injector and load your modules like this:
     *
     * ```js
     * let injector = angular.injector(['ng', 'myModule'])
     * ```
     *
     * However it's more likely that you'll just use
     * `ng-app` directive or
     * {@link bootstrap} to simplify this process for you.
     *
     * @param {string} name The name of the module to create or retrieve.
     * @param {Array.<string>} [requires] If specified then new module is being created. If
     *        unspecified then the module is being retrieved for further configuration.
     * @param {ng.Injectable<any>} [configFn] Optional configuration function for the module that gets
     *        passed to {@link NgModule.config NgModule.config()}.
     * @returns {NgModule} A newly registered module.
     */
    module(name, requires, configFn) {
      assertNotHasOwnProperty(name, "module");

      if (requires && hasOwn(moduleRegistry, name)) {
        moduleRegistry[name] = null; // force ensure to recreate the module
      }

      return ensure(moduleRegistry, name, () => {
        if (!requires) {
          throw $injectorMinErr(
            "nomod",
            "Module '{0}' is not available. Possibly misspelled or not loaded",
            name,
          );
        }

        return new NgModule(name, requires, configFn);
      });
    }

    /**
     * Use this function to manually start up AngularTS application.
     *
     * AngularTS will detect if it has been loaded into the browser more than once and only allow the
     * first loaded script to be bootstrapped and will report a warning to the browser console for
     * each of the subsequent scripts. This prevents strange results in applications, where otherwise
     * multiple instances of AngularTS try to work on the DOM.
     *   *
     * <div class="alert alert-warning">
     * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},
     * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.
     * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},
     * causing animations to stop working and making the injector inaccessible from outside the app.
     * </div>
     *
     * ```html
     * <!doctype html>
     * <html>
     * <body>
     * <div ng-controller="WelcomeController">
     *   {{greeting}}
     * </div>
     *
     * <script src="angular.js"></script>
     * <script>
     *   let app = angular.module('demo', [])
     *   .controller('WelcomeController', function($scope) {
     *       $scope.greeting = 'Welcome!';
     *   });
     *   angular.bootstrap(document, ['demo']);
     * </script>
     * </body>
     * </html>
     * ```
     *
     * @param {string | Element | Document} element DOM element which is the root of AngularTS application.
     * @param {Array<String|any>} [modules] an array of modules to load into the application.
     *     Each item in the array should be the name of a predefined module or a (DI annotated)
     *     function that will be invoked by the injector as a `config` block.
     *     See: {@link angular.module modules}
     * @param {import("./interface.ts").AngularBootstrapConfig} [config]
     * @returns {ng.InjectorService} The created injector instance for this application.
     */
    bootstrap(element, modules, config) {
      config = config || {
        strictDi: false,
      };

      if (
        (element instanceof Element || element instanceof Document) &&
        getInjector(/** @type {Element} */ (element))
      ) {
        throw ngMinErr("btstrpd", "App already bootstrapped");
      }

      if (isArray(modules)) {
        this._bootsrappedModules = modules;
      }

      this._bootsrappedModules.unshift([
        "$provide",
        /**
         * @param {import('./interface.ts').Provider} $provide
         */
        ($provide) => {
          $provide.value("$rootElement", element);
        },
      ]);

      this._bootsrappedModules.unshift("ng");

      const injector = createInjector(this._bootsrappedModules, config.strictDi);

      injector.invoke([
        $injectTokens._rootScope,
        $injectTokens._rootElement,
        $injectTokens._compile,
        $injectTokens._injector,
        /**
         * @param {ng.Scope} scope
         * @param {Element} el
         * @param {ng.CompileService} compile
         * @param {ng.InjectorService} $injector
         */
        (scope, el, compile, $injector) => {
          this.$rootScope = scope;
          // ng-route deps
          this.$injector = $injector; // TODO refactor away as this as this prevents multiple apps from being used

          setCacheData(el, "$injector", $injector);

          const compileFn = compile(el);

          compileFn(scope);

          // https://github.com/angular-ui/ui-router/issues/3678
          if (!hasOwn($injector, "strictDi")) {
            try {
              $injector.invoke(() => {
                /* empty */
              });
            } catch (error) {
              /** @type {string} */
              const errorStr =
                error instanceof Error ? error.toString() : String(error);

              $injector.strictDi = !!/strict mode/.exec(errorStr);
            }
          }

          /** @type {import("./router/state/state-registry.js").StateRegistryProvider} */
          const stateRegistry = $injector.get($injectTokens._stateRegistry);

          stateRegistry
            .getAll()
            .map((x) => {
              return x.$$state().resolvables;
            })
            .reduce(unnestR, [])
            .filter(
              /** @param {import("./router/resolve/resolvable.js").Resolvable} x */ (
                x,
              ) => {
                return x.deps === "deferred";
              },
            )
            .forEach(
              /** @param {import("./router/resolve/resolvable.js").Resolvable} resolvable */
              (resolvable) =>
                (resolvable.deps = annotate(
                  resolvable.resolveFn,
                  $injector.strictDi,
                )),
            );
        },
      ]);

      return injector;
    }

    /**
     * @param {any[]} modules
     * @param {boolean} [strictDi]
     * @returns {ng.InjectorService}
     */
    injector(modules, strictDi) {
      this.$injector = createInjector(modules, strictDi);

      return this.$injector;
    }

    /**
     * @param {Element|Document} element
     */
    init(element) {
      /** @type {Element|undefined} */
      let appElement;

      let module;

      const config = {};

      // The element `element` has priority over any other element.
      ngAttrPrefixes.forEach((prefix) => {
        const name = `${prefix}app`;

        if (
          /** @type {Element} */ (element).hasAttribute &&
          /** @type {Element} */ (element).hasAttribute(name)
        ) {
          appElement = /** @type {Element} */ (element);
          module = /** @type {Element} */ (element).getAttribute(name);
        }

        let candidate;

        if (
          !appElement &&
          (candidate = element.querySelector(`[${name.replace(":", "\\:")}]`))
        ) {
          appElement = candidate;
          module = candidate.getAttribute(name);
        }
      });

      if (appElement) {
        config.strictDi =
          appElement.hasAttribute(STRICT_DI) ||
          appElement.hasAttribute(`data-${STRICT_DI}`);
        this.bootstrap(appElement, module ? [module] : [], config);
      }
    }

    /**
     * Retrieves a scope by its registered name and returns its Proxy wrapper.
     *
     * Internally, this walks down the `Scope` tree starting from `$rootScope`
     * and checks for a matching `$scopename` property. The `$scopename` property
     * may be defined statically on controllers using `as` syntax, assigned via the `ngScope` directive,
     * or defined on `$scope` injectable.
     *
     * @param {string} name
     * @returns {Proxy<ng.Scope>|undefined}
     */
    getScopeByName(name) {
      validateIsString(name, "name");
      /** @type {ng.RootScopeService} */
      const $rootScope = this.$injector.get("$rootScope");

      const scope = $rootScope.$searchByName(name);

      if (scope) {
        return scope.$proxy;
      }

      return undefined;
    }
  }

  /**
   * @param {ModuleRegistry} obj
   * @param {string} name
   * @param {Function} factory
   * @returns {NgModule}
   */
  function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
  }

  const angular = new Angular();
  document.addEventListener("DOMContentLoaded", () => angular.init(document), {
    once: true,
  });

  exports.angular = angular;

}));
